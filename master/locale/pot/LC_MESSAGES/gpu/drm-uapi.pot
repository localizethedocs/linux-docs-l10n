# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../gpu/drm-uapi.rst:5
msgid "Userland interfaces"
msgstr ""

#: ../../../gpu/drm-uapi.rst:7
msgid ""
"The DRM core exports several interfaces to applications, generally intended "
"to be used through corresponding libdrm wrapper functions. In addition, "
"drivers export device-specific interfaces for use by userspace drivers & "
"device-aware applications through ioctls and sysfs files."
msgstr ""

#: ../../../gpu/drm-uapi.rst:12
msgid ""
"External interfaces include: memory mapping, context management, DMA "
"operations, AGP management, vblank control, fence management, memory "
"management, and output management."
msgstr ""

#: ../../../gpu/drm-uapi.rst:16
msgid ""
"Cover generic ioctls and sysfs layout here. We only need high-level info, "
"since man pages should cover the rest."
msgstr ""

#: ../../../gpu/drm-uapi.rst:20
msgid "libdrm Device Lookup"
msgstr ""

#: ../../../gpu/drm-uapi:22: drivers/gpu/drm/drm_ioctl.c:47
msgid "BEWARE THE DRAGONS! MIND THE TRAPDOORS!"
msgstr ""

#: ../../../gpu/drm-uapi:22: drivers/gpu/drm/drm_ioctl.c:49
msgid ""
"In an attempt to warn anyone else who's trying to figure out what's going on "
"here, I'll try to summarize the story. First things first, let's clear up "
"the names, because the kernel internals, libdrm and the ioctls are all named "
"differently:"
msgstr ""

#: ../../../gpu/drm-uapi:22: drivers/gpu/drm/drm_ioctl.c:54
msgid ""
"GET_UNIQUE ioctl, implemented by drm_getunique is wrapped up in libdrm "
"through the drmGetBusid function."
msgstr ""

#: ../../../gpu/drm-uapi:22: drivers/gpu/drm/drm_ioctl.c:56
msgid ""
"The libdrm drmSetBusid function is backed by the SET_UNIQUE ioctl. All that "
"code is nerved in the kernel with drm_invalid_op()."
msgstr ""

#: ../../../gpu/drm-uapi:22: drivers/gpu/drm/drm_ioctl.c:58
msgid ""
"The internal set_busid kernel functions and driver callbacks are exclusively "
"use by the SET_VERSION ioctl, because only drm 1.0 (which is nerved) allowed "
"userspace to set the busid through the above ioctl."
msgstr ""

#: ../../../gpu/drm-uapi:22: drivers/gpu/drm/drm_ioctl.c:61
msgid "Other ioctls and functions involved are named consistently."
msgstr ""

#: ../../../gpu/drm-uapi:22: drivers/gpu/drm/drm_ioctl.c:63
msgid ""
"For anyone wondering what's the difference between drm 1.1 and 1.4: "
"Correctly handling pci domains in the busid on ppc. Doing this correctly was "
"only implemented in libdrm in 2010, hence can't be nerved yet. No one knows "
"what's special with drm 1.2 and 1.3."
msgstr ""

#: ../../../gpu/drm-uapi:22: drivers/gpu/drm/drm_ioctl.c:68
msgid ""
"Now the actual horror story of how device lookup in drm works. At large, "
"there's 2 different ways, either by busid, or by device driver name."
msgstr ""

#: ../../../gpu/drm-uapi:22: drivers/gpu/drm/drm_ioctl.c:71
msgid "Opening by busid is fairly simple:"
msgstr ""

#: ../../../gpu/drm-uapi:22: drivers/gpu/drm/drm_ioctl.c:73
msgid ""
"First call SET_VERSION to make sure pci domains are handled properly. As a "
"side-effect this fills out the unique name in the master structure."
msgstr ""

#: ../../../gpu/drm-uapi:22: drivers/gpu/drm/drm_ioctl.c:75
msgid ""
"Call GET_UNIQUE to read out the unique name from the master structure, which "
"matches the busid thanks to step 1. If it doesn't, proceed to try the next "
"device node."
msgstr ""

#: ../../../gpu/drm-uapi:22: drivers/gpu/drm/drm_ioctl.c:79
msgid "Opening by name is slightly different:"
msgstr ""

#: ../../../gpu/drm-uapi:22: drivers/gpu/drm/drm_ioctl.c:81
msgid ""
"Directly call VERSION to get the version and to match against the driver "
"name returned by that ioctl. Note that SET_VERSION is not called, which "
"means the unique name for the master node just opening is _not_ filled out. "
"This despite that with current drm device nodes are always bound to one "
"device, and can't be runtime assigned like with drm 1.0."
msgstr ""

#: ../../../gpu/drm-uapi:22: drivers/gpu/drm/drm_ioctl.c:86
msgid "Match driver name. If it mismatches, proceed to the next device node."
msgstr ""

#: ../../../gpu/drm-uapi:22: drivers/gpu/drm/drm_ioctl.c:87
msgid ""
"Call GET_UNIQUE, and check whether the unique name has length zero (by "
"checking that the first byte in the string is 0). If that's not the case "
"libdrm skips and proceeds to the next device node. Probably this is just "
"copypasta from drm 1.0 times where a set unique name meant that the driver "
"was in use already, but that's just conjecture."
msgstr ""

#: ../../../gpu/drm-uapi:22: drivers/gpu/drm/drm_ioctl.c:93
msgid ""
"Long story short: To keep the open by name logic working, GET_UNIQUE must "
"_not_ return a unique string when SET_VERSION hasn't been called yet, "
"otherwise libdrm breaks. Even when that unique string can't ever change, and "
"is totally irrelevant for actually opening the device because runtime "
"assignable device instances were only support in drm 1.0, which is long "
"dead. But the libdrm code in drmOpenByName somehow survived, hence this "
"can't be broken."
msgstr ""

#: ../../../gpu/drm-uapi.rst:29
msgid "Primary Nodes, DRM Master and Authentication"
msgstr ""

#: ../../../gpu/drm-uapi:31: drivers/gpu/drm/drm_auth.c:43
msgid ""
":c:type:`struct drm_master <drm_master>` is used to track groups of clients "
"with open primary device nodes. For every :c:type:`struct drm_file "
"<drm_file>` which has had at least once successfully became the device "
"master (either through the SET_MASTER IOCTL, or implicitly through opening "
"the primary device node when no one else is the current master that time) "
"there exists one :c:type:`drm_master`. This is noted in :c:type:`drm_file."
"is_master <drm_file>`. All other clients have just a pointer to the :c:type:"
"`drm_master` they are associated with."
msgstr ""

#: ../../../gpu/drm-uapi:31: drivers/gpu/drm/drm_auth.c:51
msgid ""
"In addition only one :c:type:`drm_master` can be the current master for a :c:"
"type:`drm_device`. It can be switched through the DROP_MASTER and SET_MASTER "
"IOCTL, or implicitly through closing/opening the primary device node. See "
"also drm_is_current_master()."
msgstr ""

#: ../../../gpu/drm-uapi:31: drivers/gpu/drm/drm_auth.c:56
msgid ""
"Clients can authenticate against the current master (if it matches their "
"own) using the GETMAGIC and AUTHMAGIC IOCTLs. Together with exchanging "
"masters, this allows controlled access to the device for an entire group of "
"mutually trusted clients."
msgstr ""

#: ../../../gpu/drm-uapi:34: drivers/gpu/drm/drm_auth.c:73
msgid "checks whether **priv** is the current master"
msgstr ""

#: ../../../gpu/drm-uapi:34: drivers/gpu/drm/drm_auth.c:77
#: drivers/gpu/drm/drm_auth.c:370 drivers/gpu/drm/drm_auth.c:383
#: drivers/gpu/drm/drm_auth.c:424 ../../../gpu/drm-uapi:571:
#: include/drm/drm_ioctl.h:56 include/drm/drm_ioctl.h:69
#: include/drm/drm_ioctl.h:146 ../../../gpu/drm-uapi:574:
#: drivers/gpu/drm/drm_ioctl.c:444 drivers/gpu/drm/drm_ioctl.c:464
#: drivers/gpu/drm/drm_ioctl.c:805 drivers/gpu/drm/drm_ioctl.c:919
#: ../../../gpu/drm-uapi:577: drivers/gpu/drm/drm_ioc32.c:353
#: ../../../gpu/drm-uapi:643: drivers/gpu/drm/drm_debugfs_crc.c:389
#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:45
#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:202
#: drivers/gpu/drm/drm_debugfs.c:242 drivers/gpu/drm/drm_debugfs.c:462
#: drivers/gpu/drm/drm_debugfs.c:490 ../../../gpu/drm-uapi:661:
#: drivers/gpu/drm/drm_sysfs.c:435 drivers/gpu/drm/drm_sysfs.c:457
#: drivers/gpu/drm/drm_sysfs.c:482 drivers/gpu/drm/drm_sysfs.c:557
#: drivers/gpu/drm/drm_sysfs.c:575
msgid "**Parameters**"
msgstr ""

#: ../../../gpu/drm-uapi:34: drivers/gpu/drm/drm_auth.c:79
msgid "``struct drm_file *fpriv``"
msgstr ""

#: ../../../gpu/drm-uapi:34: drivers/gpu/drm/drm_auth.c:74
#: drivers/gpu/drm/drm_auth.c:380
msgid "DRM file private"
msgstr ""

#: ../../../gpu/drm-uapi:34: drivers/gpu/drm/drm_auth.c:76
#: drivers/gpu/drm/drm_auth.c:369 drivers/gpu/drm/drm_auth.c:382
#: drivers/gpu/drm/drm_auth.c:423 ../../../gpu/drm-uapi:37:
#: include/drm/drm_auth.h:129 ../../../gpu/drm-uapi:571:
#: include/drm/drm_ioctl.h:50 include/drm/drm_ioctl.h:63
#: include/drm/drm_ioctl.h:110 include/drm/drm_ioctl.h:133
#: include/drm/drm_ioctl.h:147 ../../../gpu/drm-uapi:574:
#: drivers/gpu/drm/drm_ioctl.c:445 drivers/gpu/drm/drm_ioctl.c:465
#: drivers/gpu/drm/drm_ioctl.c:806 drivers/gpu/drm/drm_ioctl.c:919
#: ../../../gpu/drm-uapi:577: drivers/gpu/drm/drm_ioc32.c:354
#: ../../../gpu/drm-uapi:643: drivers/gpu/drm/drm_debugfs_crc.c:391
#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:45
#: include/drm/drm_debugfs.h:76 include/drm/drm_debugfs.h:95
#: include/drm/drm_debugfs.h:124 include/drm/drm_debugfs.h:141
#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:202
#: drivers/gpu/drm/drm_debugfs.c:245 drivers/gpu/drm/drm_debugfs.c:464
#: drivers/gpu/drm/drm_debugfs.c:491 ../../../gpu/drm-uapi:661:
#: drivers/gpu/drm/drm_sysfs.c:434 drivers/gpu/drm/drm_sysfs.c:457
#: drivers/gpu/drm/drm_sysfs.c:483 drivers/gpu/drm/drm_sysfs.c:556
#: drivers/gpu/drm/drm_sysfs.c:574 ../../../gpu/drm-uapi:701:
#: include/uapi/drm/drm.h:631 include/uapi/drm/drm.h:638
#: include/uapi/drm/drm.h:647 include/uapi/drm/drm.h:661
#: include/uapi/drm/drm.h:673 include/uapi/drm/drm.h:686
#: include/uapi/drm/drm.h:695 include/uapi/drm/drm.h:704
#: include/uapi/drm/drm.h:716 include/uapi/drm/drm.h:723
#: include/uapi/drm/drm.h:735 include/uapi/drm/drm.h:741
#: include/uapi/drm/drm.h:748 include/uapi/drm/drm.h:757
#: include/uapi/drm/drm.h:767 include/uapi/drm/drm.h:773
#: include/uapi/drm/drm.h:780 include/uapi/drm/drm.h:794
#: include/uapi/drm/drm.h:806 include/uapi/drm/drm.h:817
#: include/uapi/drm/drm.h:833 include/uapi/drm/drm.h:844
#: include/uapi/drm/drm.h:856 include/uapi/drm/drm.h:984
#: include/uapi/drm/drm.h:1066 include/uapi/drm/drm.h:1119
#: include/uapi/drm/drm.h:1132 include/uapi/drm/drm.h:1187
#: include/uapi/drm/drm.h:1201 include/uapi/drm/drm.h:1253
#: include/uapi/drm/drm.h:1285 include/uapi/drm/drm.h:1305
#: include/uapi/drm/drm.h:1330 include/uapi/drm/drm.h:1345
#: include/uapi/drm/drm.h:1354 include/uapi/drm/drm.h:1363
#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:241
#: include/uapi/drm/drm_mode.h:359 include/uapi/drm/drm_mode.h:518
#: include/uapi/drm/drm_mode.h:554 include/uapi/drm/drm_mode.h:618
#: include/uapi/drm/drm_mode.h:737 include/uapi/drm/drm_mode.h:867
#: include/uapi/drm/drm_mode.h:940 include/uapi/drm/drm_mode.h:956
#: include/uapi/drm/drm_mode.h:962 include/uapi/drm/drm_mode.h:970
#: include/uapi/drm/drm_mode.h:991 include/uapi/drm/drm_mode.h:1069
#: include/uapi/drm/drm_mode.h:1101 include/uapi/drm/drm_mode.h:1111
#: include/uapi/drm/drm_mode.h:1120 include/uapi/drm/drm_mode.h:1142
#: include/uapi/drm/drm_mode.h:1228 include/uapi/drm/drm_mode.h:1234
#: include/uapi/drm/drm_mode.h:1267 include/uapi/drm/drm_mode.h:1293
#: include/uapi/drm/drm_mode.h:1320 include/uapi/drm/drm_mode.h:1338
msgid "**Description**"
msgstr ""

#: ../../../gpu/drm-uapi:34: drivers/gpu/drm/drm_auth.c:75
msgid ""
"Checks whether **fpriv** is current master on its device. This decides "
"whether a client is allowed to run DRM_MASTER IOCTLs."
msgstr ""

#: ../../../gpu/drm-uapi:34: drivers/gpu/drm/drm_auth.c:78
msgid ""
"Most of the modern IOCTL which require DRM_MASTER are for kernel modesetting "
"- the current master is assumed to own the non-shareable display hardware."
msgstr ""

#: ../../../gpu/drm-uapi:34: drivers/gpu/drm/drm_auth.c:366
msgid "reference a master pointer"
msgstr ""

#: ../../../gpu/drm-uapi:34: drivers/gpu/drm/drm_auth.c:372
msgid "``struct drm_master *master``"
msgstr ""

#: ../../../gpu/drm-uapi:34: drivers/gpu/drm/drm_auth.c:367
msgid ":c:type:`struct drm_master <drm_master>`"
msgstr ""

#: ../../../gpu/drm-uapi:34: drivers/gpu/drm/drm_auth.c:368
msgid ""
"Increments the reference count of **master** and returns a pointer to "
"**master**."
msgstr ""

#: ../../../gpu/drm-uapi:34: drivers/gpu/drm/drm_auth.c:379
msgid "reference :c:type:`drm_file.master <drm_file>` of **file_priv**"
msgstr ""

#: ../../../gpu/drm-uapi:34: drivers/gpu/drm/drm_auth.c:385
#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:49
#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:444
#: drivers/gpu/drm/drm_ioctl.c:464
msgid "``struct drm_file *file_priv``"
msgstr ""

#: ../../../gpu/drm-uapi:34: drivers/gpu/drm/drm_auth.c:381
msgid ""
"Increments the reference count of **file_priv**'s :c:type:`drm_file.master "
"<drm_file>` and returns the :c:type:`drm_file.master <drm_file>`. If "
"**file_priv** has no :c:type:`drm_file.master <drm_file>`, returns NULL."
msgstr ""

#: ../../../gpu/drm-uapi:34: drivers/gpu/drm/drm_auth.c:384
msgid ""
"Master pointers returned from this function should be unreferenced using "
"drm_master_put()."
msgstr ""

#: ../../../gpu/drm-uapi:34: drivers/gpu/drm/drm_auth.c:420
msgid "unreference and clear a master pointer"
msgstr ""

#: ../../../gpu/drm-uapi:34: drivers/gpu/drm/drm_auth.c:426
msgid "``struct drm_master **master``"
msgstr ""

#: ../../../gpu/drm-uapi:34: drivers/gpu/drm/drm_auth.c:421
msgid "pointer to a pointer of :c:type:`struct drm_master <drm_master>`"
msgstr ""

#: ../../../gpu/drm-uapi:34: drivers/gpu/drm/drm_auth.c:422
msgid ""
"This decrements the :c:type:`drm_master` behind **master** and sets it to "
"NULL."
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:38
msgid "drm master structure"
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:42
#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:129
#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:58
#: include/drm/drm_debugfs.h:81 include/drm/drm_debugfs.h:103
#: include/drm/drm_debugfs.h:129 ../../../gpu/drm-uapi:701:
#: include/uapi/drm/drm.h:977 include/uapi/drm/drm.h:1328
#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:226
#: include/uapi/drm/drm_mode.h:320 include/uapi/drm/drm_mode.h:430
#: include/uapi/drm/drm_mode.h:552 include/uapi/drm/drm_mode.h:564
#: include/uapi/drm/drm_mode.h:674 include/uapi/drm/drm_mode.h:865
#: include/uapi/drm/drm_mode.h:878 include/uapi/drm/drm_mode.h:946
#: include/uapi/drm/drm_mode.h:1062 include/uapi/drm/drm_mode.h:1218
#: include/uapi/drm/drm_mode.h:1233 include/uapi/drm/drm_mode.h:1249
#: include/uapi/drm/drm_mode.h:1272 include/uapi/drm/drm_mode.h:1299
#: include/uapi/drm/drm_mode.h:1326 include/uapi/drm/drm_mode.h:1334
#: include/uapi/drm/drm_mode.h:1353
msgid "**Definition**::"
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:59
#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:138
#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:67
#: include/drm/drm_debugfs.h:88 include/drm/drm_debugfs.h:112
#: include/drm/drm_debugfs.h:137 ../../../gpu/drm-uapi:701:
#: include/uapi/drm/drm.h:987 include/uapi/drm/drm.h:1335
#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:246
#: include/uapi/drm/drm_mode.h:332 include/uapi/drm/drm_mode.h:451
#: include/uapi/drm/drm_mode.h:559 include/uapi/drm/drm_mode.h:576
#: include/uapi/drm/drm_mode.h:688 include/uapi/drm/drm_mode.h:872
#: include/uapi/drm/drm_mode.h:895 include/uapi/drm/drm_mode.h:955
#: include/uapi/drm/drm_mode.h:1074 include/uapi/drm/drm_mode.h:1226
#: include/uapi/drm/drm_mode.h:1239 include/uapi/drm/drm_mode.h:1259
#: include/uapi/drm/drm_mode.h:1280 include/uapi/drm/drm_mode.h:1307
#: include/uapi/drm/drm_mode.h:1332 include/uapi/drm/drm_mode.h:1343
#: include/uapi/drm/drm_mode.h:1360
msgid "**Members**"
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:40
msgid "``refcount``"
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:41
msgid "Refcount for this master object."
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:41
#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:131
msgid "``dev``"
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:42
msgid "Link back to the DRM device"
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:51
msgid "``unique``"
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:52
msgid ""
"Unique identifier: e.g. busid. Protected by :c:type:`drm_device.master_mutex "
"<drm_device>`."
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:56
msgid "``unique_len``"
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:57
msgid ""
"Length of unique field. Protected by :c:type:`drm_device.master_mutex "
"<drm_device>`."
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:61
msgid "``magic_map``"
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:62
msgid ""
"Map of used authentication tokens. Protected by :c:type:`drm_device."
"master_mutex <drm_device>`."
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:42
msgid "``driver_priv``"
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:43
msgid "Pointer to driver-private information."
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:68
msgid "``lessor``"
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:69
msgid ""
"Lease grantor, only set if this :c:type:`struct drm_master <drm_master>` "
"represents a lessee holding a lease of objects from **lessor**. Full owners "
"of the device have this set to NULL."
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:73
msgid ""
"The lessor does not change once it's set in drm_lease_create(), and each "
"lessee holds a reference to its lessor that it releases upon being destroyed "
"in drm_lease_destroy()."
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:77
msgid "See also the :ref:`section on display resource leasing <drm_leasing>`."
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:84
#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1261
#: include/uapi/drm/drm_mode.h:1325
msgid "``lessee_id``"
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:85
msgid ""
"ID for lessees. Owners (i.e. **lessor** is NULL) always have ID 0. Protected "
"by :c:type:`drm_device.mode_config <drm_device>`'s :c:type:`drm_mode_config."
"idr_mutex <drm_mode_config>`."
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:92
msgid "``lessee_list``"
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:93
msgid ""
"List entry of lessees of **lessor**, where they are linked to **lessees**. "
"Not used for owners. Protected by :c:type:`drm_device.mode_config "
"<drm_device>`'s :c:type:`drm_mode_config.idr_mutex <drm_mode_config>`."
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:101
msgid "``lessees``"
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:102
msgid ""
"List of drm_masters leasing from this one. Protected by :c:type:`drm_device."
"mode_config <drm_device>`'s :c:type:`drm_mode_config.idr_mutex "
"<drm_mode_config>`."
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:105
msgid ""
"This list is empty if no leases have been granted, or if all lessees have "
"been destroyed. Since lessors are referenced by all their lessees, this "
"master cannot be destroyed unless the list is empty."
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:113
msgid "``leases``"
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:114
msgid ""
"Objects leased to this drm_master. Protected by :c:type:`drm_device."
"mode_config <drm_device>`'s :c:type:`drm_mode_config.idr_mutex "
"<drm_mode_config>`."
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:117
msgid ""
"Objects are leased all together in drm_lease_create(), and are removed all "
"together when the lease is revoked."
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:124
msgid "``lessee_idr``"
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:125
msgid ""
"All lessees under this owner (only used where **lessor** is NULL). Protected "
"by :c:type:`drm_device.mode_config <drm_device>`'s :c:type:`drm_mode_config."
"idr_mutex <drm_mode_config>`."
msgstr ""

#: ../../../gpu/drm-uapi:37: include/drm/drm_auth.h:43
msgid ""
"Note that master structures are only relevant for the legacy/primary device "
"nodes, hence there can only be one per device, not one per drm_minor."
msgstr ""

#: ../../../gpu/drm-uapi.rst:44
msgid "DRM Display Resource Leasing"
msgstr ""

#: ../../../gpu/drm-uapi:46: drivers/gpu/drm/drm_lease.c:19
msgid ""
"DRM leases provide information about whether a DRM master may control a DRM "
"mode setting object. This enables the creation of multiple DRM masters that "
"manage subsets of display resources."
msgstr ""

#: ../../../gpu/drm-uapi:46: drivers/gpu/drm/drm_lease.c:23
msgid ""
"The original DRM master of a device 'owns' the available drm resources. It "
"may create additional DRM masters and 'lease' resources which it controls to "
"the new DRM master. This gives the new DRM master control over the leased "
"resources until the owner revokes the lease, or the new DRM master is "
"closed. Some helpful terminology:"
msgstr ""

#: ../../../gpu/drm-uapi:46: drivers/gpu/drm/drm_lease.c:29
msgid ""
"An 'owner' is a :c:type:`struct drm_master <drm_master>` that is not leasing "
"objects from another :c:type:`struct drm_master <drm_master>`, and hence "
"'owns' the objects. The owner can be identified as the :c:type:`struct "
"drm_master <drm_master>` for which :c:type:`drm_master.lessor <drm_master>` "
"is NULL."
msgstr ""

#: ../../../gpu/drm-uapi:46: drivers/gpu/drm/drm_lease.c:33
msgid ""
"A 'lessor' is a :c:type:`struct drm_master <drm_master>` which is leasing "
"objects to one or more other :c:type:`struct drm_master <drm_master>`. "
"Currently, lessees are not allowed to create sub-leases, hence the lessor is "
"the same as the owner."
msgstr ""

#: ../../../gpu/drm-uapi:46: drivers/gpu/drm/drm_lease.c:37
msgid ""
"A 'lessee' is a :c:type:`struct drm_master <drm_master>` which is leasing "
"objects from some other :c:type:`struct drm_master <drm_master>`. Each "
"lessee only leases resources from a single lessor recorded in :c:type:"
"`drm_master.lessor <drm_master>`, and holds the set of objects that it is "
"leasing in :c:type:`drm_master.leases <drm_master>`."
msgstr ""

#: ../../../gpu/drm-uapi:46: drivers/gpu/drm/drm_lease.c:42
msgid ""
"A 'lease' is a contract between the lessor and lessee that identifies which "
"resources may be controlled by the lessee. All of the resources that are "
"leased must be owned by or leased to the lessor, and lessors are not "
"permitted to lease the same object to multiple lessees."
msgstr ""

#: ../../../gpu/drm-uapi:46: drivers/gpu/drm/drm_lease.c:47
msgid ""
"The set of objects any :c:type:`struct drm_master <drm_master>` 'controls' "
"is limited to the set of objects it leases (for lessees) or all objects (for "
"owners)."
msgstr ""

#: ../../../gpu/drm-uapi:46: drivers/gpu/drm/drm_lease.c:50
msgid ""
"Objects not controlled by a :c:type:`struct drm_master <drm_master>` cannot "
"be modified through the various state manipulating ioctls, and any state "
"reported back to user space will be edited to make them appear idle and/or "
"unusable. For instance, connectors always report 'disconnected', while "
"encoders report no possible crtcs or clones."
msgstr ""

#: ../../../gpu/drm-uapi:46: drivers/gpu/drm/drm_lease.c:56
msgid ""
"Since each lessee may lease objects from a single lessor, display resource "
"leases form a tree of :c:type:`struct drm_master <drm_master>`. As lessees "
"are currently not allowed to create sub-leases, the tree depth is limited to "
"1. All of these get activated simultaneously when the top level device owner "
"changes through the SETMASTER or DROPMASTER IOCTL, so :c:type:`drm_device."
"master <drm_device>` points to the owner at the top of the lease tree (i.e. "
"the :c:type:`struct drm_master <drm_master>` for which :c:type:`drm_master."
"lessor <drm_master>` is NULL). The full list of lessees that are leasing "
"objects from the owner can be searched via the owner's :c:type:`drm_master."
"lessee_idr <drm_master>`."
msgstr ""

#: ../../../gpu/drm-uapi.rst:50
msgid "Open-Source Userspace Requirements"
msgstr ""

#: ../../../gpu/drm-uapi.rst:52
msgid ""
"The DRM subsystem has stricter requirements than most other kernel "
"subsystems on what the userspace side for new uAPI needs to look like. This "
"section here explains what exactly those requirements are, and why they "
"exist."
msgstr ""

#: ../../../gpu/drm-uapi.rst:56
msgid ""
"The short summary is that any addition of DRM uAPI requires corresponding "
"open-sourced userspace patches, and those patches must be reviewed and ready "
"for merging into a suitable and canonical upstream project."
msgstr ""

#: ../../../gpu/drm-uapi.rst:60
msgid ""
"GFX devices (both display and render/GPU side) are really complex bits of "
"hardware, with userspace and kernel by necessity having to work together "
"really closely.  The interfaces, for rendering and modesetting, must be "
"extremely wide and flexible, and therefore it is almost always impossible to "
"precisely define them for every possible corner case. This in turn makes it "
"really practically infeasible to differentiate between behaviour that's "
"required by userspace, and which must not be changed to avoid regressions, "
"and behaviour which is only an accidental artifact of the current "
"implementation."
msgstr ""

#: ../../../gpu/drm-uapi.rst:69
msgid ""
"Without access to the full source code of all userspace users that means it "
"becomes impossible to change the implementation details, since userspace "
"could depend upon the accidental behaviour of the current implementation in "
"minute details. And debugging such regressions without access to source code "
"is pretty much impossible. As a consequence this means:"
msgstr ""

#: ../../../gpu/drm-uapi.rst:75
msgid ""
"The Linux kernel's \"no regression\" policy holds in practice only for open-"
"source userspace of the DRM subsystem. DRM developers are perfectly fine if "
"closed-source blob drivers in userspace use the same uAPI as the open "
"drivers, but they must do so in the exact same way as the open drivers. "
"Creative (ab)use of the interfaces will, and in the past routinely has, lead "
"to breakage."
msgstr ""

#: ../../../gpu/drm-uapi.rst:82
msgid ""
"Any new userspace interface must have an open-source implementation as "
"demonstration vehicle."
msgstr ""

#: ../../../gpu/drm-uapi.rst:85
msgid ""
"The other reason for requiring open-source userspace is uAPI review. Since "
"the kernel and userspace parts of a GFX stack must work together so closely, "
"code review can only assess whether a new interface achieves its goals by "
"looking at both sides. Making sure that the interface indeed covers the use-"
"case fully leads to a few additional requirements:"
msgstr ""

#: ../../../gpu/drm-uapi.rst:91
msgid ""
"The open-source userspace must not be a toy/test application, but the real "
"thing. Specifically it needs to handle all the usual error and corner cases. "
"These are often the places where new uAPI falls apart and hence essential to "
"assess the fitness of a proposed interface."
msgstr ""

#: ../../../gpu/drm-uapi.rst:96
msgid ""
"The userspace side must be fully reviewed and tested to the standards of "
"that userspace project. For e.g. mesa this means piglit testcases and review "
"on the mailing list. This is again to ensure that the new interface actually "
"gets the job done.  The userspace-side reviewer should also provide an Acked-"
"by on the kernel uAPI patch indicating that they believe the proposed uAPI "
"is sound and sufficiently documented and validated for userspace's "
"consumption."
msgstr ""

#: ../../../gpu/drm-uapi.rst:103
msgid ""
"The userspace patches must be against the canonical upstream, not some "
"vendor fork. This is to make sure that no one cheats on the review and "
"testing requirements by doing a quick fork."
msgstr ""

#: ../../../gpu/drm-uapi.rst:107
msgid ""
"The kernel patch can only be merged after all the above requirements are "
"met, but it **must** be merged to either drm-next or drm-misc-next "
"**before** the userspace patches land. uAPI always flows from the kernel, "
"doing things the other way round risks divergence of the uAPI definitions "
"and header files."
msgstr ""

#: ../../../gpu/drm-uapi.rst:112
msgid ""
"These are fairly steep requirements, but have grown out from years of shared "
"pain and experience with uAPI added hastily, and almost always regretted "
"about just as fast. GFX devices change really fast, requiring a paradigm "
"shift and entire new set of uAPI interfaces every few years at least. "
"Together with the Linux kernel's guarantee to keep existing userspace "
"running for 10+ years this is already rather painful for the DRM subsystem, "
"with multiple different uAPIs for the same thing co-existing. If we add a "
"few more complete mistakes into the mix every year it would be entirely "
"unmanageable."
msgstr ""

#: ../../../gpu/drm-uapi.rst:124
msgid "Render nodes"
msgstr ""

#: ../../../gpu/drm-uapi.rst:126
msgid ""
"DRM core provides multiple character-devices for user-space to use. "
"Depending on which device is opened, user-space can perform a different set "
"of operations (mainly ioctls). The primary node is always created and called "
"card<num>. Additionally, a currently unused control node, called "
"controlD<num> is also created. The primary node provides all legacy "
"operations and historically was the only interface used by userspace. With "
"KMS, the control node was introduced. However, the planned KMS control "
"interface has never been written and so the control node stays unused to "
"date."
msgstr ""

#: ../../../gpu/drm-uapi.rst:136
msgid ""
"With the increased use of offscreen renderers and GPGPU applications, "
"clients no longer require running compositors or graphics servers to make "
"use of a GPU. But the DRM API required unprivileged clients to authenticate "
"to a DRM-Master prior to getting GPU access. To avoid this step and to grant "
"clients GPU access without authenticating, render nodes were introduced. "
"Render nodes solely serve render clients, that is, no modesetting or "
"privileged ioctls can be issued on render nodes. Only non-global rendering "
"commands are allowed. If a driver supports render nodes, it must advertise "
"it via the DRIVER_RENDER DRM driver capability. If not supported, the "
"primary node must be used for render clients together with the legacy "
"drmAuth authentication procedure."
msgstr ""

#: ../../../gpu/drm-uapi.rst:148
msgid ""
"If a driver advertises render node support, DRM core will create a separate "
"render node called renderD<num>. There will be one render node per device. "
"No ioctls except PRIME-related ioctls will be allowed on this node. "
"Especially GEM_OPEN will be explicitly prohibited. For a complete list of "
"driver-independent ioctls that can be used on render nodes, see the ioctls "
"marked DRM_RENDER_ALLOW in drm_ioctl.c  Render nodes are designed to avoid "
"the buffer-leaks, which occur if clients guess the flink names or mmap "
"offsets on the legacy interface. Additionally to this basic interface, "
"drivers must mark their driver-dependent render-only ioctls as "
"DRM_RENDER_ALLOW so render clients can use them. Driver authors must be "
"careful not to allow any privileged ioctls on render nodes."
msgstr ""

#: ../../../gpu/drm-uapi.rst:161
msgid ""
"With render nodes, user-space can now control access to the render node via "
"basic file-system access-modes. A running graphics server which "
"authenticates clients on the privileged primary/legacy node is no longer "
"required. Instead, a client can open the render node and is immediately "
"granted GPU access. Communication between clients (or servers) is done via "
"PRIME. FLINK from render node to legacy node is not supported. New clients "
"must not use the insecure FLINK interface."
msgstr ""

#: ../../../gpu/drm-uapi.rst:169
msgid ""
"Besides dropping all modeset/global ioctls, render nodes also drop the DRM-"
"Master concept. There is no reason to associate render clients with a DRM-"
"Master as they are independent of any graphics server. Besides, they must "
"work without any running master, anyway. Drivers must be able to run without "
"a master object if they support render nodes. If, on the other hand, a "
"driver requires shared state between clients which is visible to user-space "
"and accessible beyond open-file boundaries, they cannot support render nodes."
msgstr ""

#: ../../../gpu/drm-uapi.rst:179
msgid "Device Hot-Unplug"
msgstr ""

#: ../../../gpu/drm-uapi.rst:182
msgid "The following is the plan. Implementation is not there yet (2020 May)."
msgstr ""

#: ../../../gpu/drm-uapi.rst:185
msgid ""
"Graphics devices (display and/or render) may be connected via USB (e.g. "
"display adapters or docking stations) or Thunderbolt (e.g. eGPU). An end "
"user is able to hot-unplug this kind of devices while they are being used, "
"and expects that the very least the machine does not crash. Any damage from "
"hot-unplugging a DRM device needs to be limited as much as possible and "
"userspace must be given the chance to handle it if it wants to. Ideally, "
"unplugging a DRM device still lets a desktop continue to run, but that is "
"going to need explicit support throughout the whole graphics stack: from "
"kernel and userspace drivers, through display servers, via window system "
"protocols, and in applications and libraries."
msgstr ""

#: ../../../gpu/drm-uapi.rst:196
msgid ""
"Other scenarios that should lead to the same are: unrecoverable GPU crash, "
"PCI device disappearing off the bus, or forced unbind of a driver from the "
"physical device."
msgstr ""

#: ../../../gpu/drm-uapi.rst:200
msgid ""
"In other words, from userspace perspective everything needs to keep on "
"working more or less, until userspace stops using the disappeared DRM device "
"and closes it completely. Userspace will learn of the device disappearance "
"from the device removed uevent, ioctls returning ENODEV (or driver-specific "
"ioctls returning driver-specific things), or open() returning ENXIO."
msgstr ""

#: ../../../gpu/drm-uapi.rst:207
msgid ""
"Only after userspace has closed all relevant DRM device and dmabuf file "
"descriptors and removed all mmaps, the DRM driver can tear down its instance "
"for the device that no longer exists. If the same physical device somehow "
"comes back in the mean time, it shall be a new DRM device."
msgstr ""

#: ../../../gpu/drm-uapi.rst:213
msgid ""
"Similar to PIDs, chardev minor numbers are not recycled immediately. A new "
"DRM device always picks the next free minor number compared to the previous "
"one allocated, and wraps around when minor numbers are exhausted."
msgstr ""

#: ../../../gpu/drm-uapi.rst:218
msgid ""
"The goal raises at least the following requirements for the kernel and "
"drivers."
msgstr ""

#: ../../../gpu/drm-uapi.rst:222
msgid "Requirements for KMS UAPI"
msgstr ""

#: ../../../gpu/drm-uapi.rst:224
msgid "KMS connectors must change their status to disconnected."
msgstr ""

#: ../../../gpu/drm-uapi.rst:226
msgid ""
"Legacy modesets and pageflips, and atomic commits, both real and TEST_ONLY, "
"and any other ioctls either fail with ENODEV or fake success."
msgstr ""

#: ../../../gpu/drm-uapi.rst:230
msgid ""
"Pending non-blocking KMS operations deliver the DRM events userspace is "
"expecting. This applies also to ioctls that faked success."
msgstr ""

#: ../../../gpu/drm-uapi.rst:233 ../../../gpu/drm-uapi.rst:263
msgid ""
"open() on a device node whose underlying device has disappeared will fail "
"with ENXIO."
msgstr ""

#: ../../../gpu/drm-uapi.rst:236
msgid ""
"Attempting to create a DRM lease on a disappeared DRM device will fail with "
"ENODEV. Existing DRM leases remain and work as listed above."
msgstr ""

#: ../../../gpu/drm-uapi.rst:241
msgid "Requirements for Render and Cross-Device UAPI"
msgstr ""

#: ../../../gpu/drm-uapi.rst:243
msgid ""
"All GPU jobs that can no longer run must have their fences force-signalled "
"to avoid inflicting hangs on userspace. The associated error code is ENODEV."
msgstr ""

#: ../../../gpu/drm-uapi.rst:247
msgid ""
"Some userspace APIs already define what should happen when the device "
"disappears (OpenGL, GL ES: `GL_KHR_robustness`_; `Vulkan`_: "
"VK_ERROR_DEVICE_LOST; etc.). DRM drivers are free to implement this "
"behaviour the way they see best, e.g. returning failures in driver-specific "
"ioctls and handling those in userspace drivers, or rely on uevents, and so "
"on."
msgstr ""

#: ../../../gpu/drm-uapi.rst:254
msgid ""
"dmabuf which point to memory that has disappeared will either fail to import "
"with ENODEV or continue to be successfully imported if it would have "
"succeeded before the disappearance. See also about memory maps below for "
"already imported dmabufs."
msgstr ""

#: ../../../gpu/drm-uapi.rst:259
msgid ""
"Attempting to import a dmabuf to a disappeared device will either fail with "
"ENODEV or succeed if it would have succeeded without the disappearance."
msgstr ""

#: ../../../gpu/drm-uapi.rst:270
msgid "Requirements for Memory Maps"
msgstr ""

#: ../../../gpu/drm-uapi.rst:272
msgid ""
"Memory maps have further requirements that apply to both existing maps and "
"maps created after the device has disappeared. If the underlying memory "
"disappears, the map is created or modified such that reads and writes will "
"still complete successfully but the result is undefined. This applies to "
"both userspace mmap()'d memory and memory pointed to by dmabuf which might "
"be mapped to other devices (cross-device dmabuf imports)."
msgstr ""

#: ../../../gpu/drm-uapi.rst:280
msgid ""
"Raising SIGBUS is not an option, because userspace cannot realistically "
"handle it. Signal handlers are global, which makes them extremely difficult "
"to use correctly from libraries like those that Mesa produces. Signal "
"handlers are not composable, you can't have different handlers for GPU1 and "
"GPU2 from different vendors, and a third handler for mmapped regular files. "
"Threads cause additional pain with signal handling as well."
msgstr ""

#: ../../../gpu/drm-uapi.rst:289
msgid "Device reset"
msgstr ""

#: ../../../gpu/drm-uapi.rst:291
msgid ""
"The GPU stack is really complex and is prone to errors, from hardware bugs, "
"faulty applications and everything in between the many layers. Some errors "
"require resetting the device in order to make the device usable again. This "
"section describes the expectations for DRM and usermode drivers when a "
"device resets and how to propagate the reset status."
msgstr ""

#: ../../../gpu/drm-uapi.rst:297
msgid ""
"Device resets can not be disabled without tainting the kernel, which can "
"lead to hanging the entire kernel through shrinkers/mmu_notifiers. Userspace "
"role in device resets is to propagate the message to the application and "
"apply any special policy for blocking guilty applications, if any. Corollary "
"is that debugging a hung GPU context require hardware support to be able to "
"preempt such a GPU context while it's stopped."
msgstr ""

#: ../../../gpu/drm-uapi.rst:305
msgid "Kernel Mode Driver"
msgstr ""

#: ../../../gpu/drm-uapi.rst:307
msgid ""
"The KMD is responsible for checking if the device needs a reset, and to "
"perform it as needed. Usually a hang is detected when a job gets stuck "
"executing."
msgstr ""

#: ../../../gpu/drm-uapi.rst:310
msgid ""
"Propagation of errors to userspace has proven to be tricky since it goes in "
"the opposite direction of the usual flow of commands. Because of this vendor "
"independent error handling was added to the &dma_fence object, this way "
"drivers can add an error code to their fences before signaling them. See "
"function dma_fence_set_error() on how to do this and for examples of error "
"codes to use."
msgstr ""

#: ../../../gpu/drm-uapi.rst:316
msgid ""
"The DRM scheduler also allows setting error codes on all pending fences when "
"hardware submissions are restarted after an reset. Error codes are also "
"forwarded from the hardware fence to the scheduler fence to bubble up errors "
"to the higher levels of the stack and eventually userspace."
msgstr ""

#: ../../../gpu/drm-uapi.rst:321
msgid ""
"Fence errors can be queried by userspace through the generic "
"SYNC_IOC_FILE_INFO IOCTL as well as through driver specific interfaces."
msgstr ""

#: ../../../gpu/drm-uapi.rst:324
msgid ""
"Additional to setting fence errors drivers should also keep track of resets "
"per context, the DRM scheduler provides the drm_sched_entity_error() "
"function as helper for this use case. After a reset, KMD should reject new "
"command submissions for affected contexts."
msgstr ""

#: ../../../gpu/drm-uapi.rst:330
msgid "User Mode Driver"
msgstr ""

#: ../../../gpu/drm-uapi.rst:332
msgid ""
"After command submission, UMD should check if the submission was accepted or "
"rejected. After a reset, KMD should reject submissions, and UMD can issue an "
"ioctl to the KMD to check the reset status, and this can be checked more "
"often if the UMD requires it. After detecting a reset, UMD will then proceed "
"to report it to the application using the appropriate API error code, as "
"explained in the section below about robustness."
msgstr ""

#: ../../../gpu/drm-uapi.rst:340
msgid "Robustness"
msgstr ""

#: ../../../gpu/drm-uapi.rst:342
msgid ""
"The only way to try to keep a graphical API context working after a reset is "
"if it complies with the robustness aspects of the graphical API that it is "
"using."
msgstr ""

#: ../../../gpu/drm-uapi.rst:345
msgid ""
"Graphical APIs provide ways to applications to deal with device resets. "
"However, there is no guarantee that the app will use such features "
"correctly, and a userspace that doesn't support robust interfaces (like a "
"non-robust OpenGL context or API without any robustness support like libva) "
"leave the robustness handling entirely to the userspace driver. There is no "
"strong community consensus on what the userspace driver should do in that "
"case, since all reasonable approaches have some clear downsides."
msgstr ""

#: ../../../gpu/drm-uapi.rst:354
msgid "OpenGL"
msgstr ""

#: ../../../gpu/drm-uapi.rst:356
msgid ""
"Apps using OpenGL should use the available robust interfaces, like the "
"extension ``GL_ARB_robustness`` (or ``GL_EXT_robustness`` for OpenGL ES). "
"This interface tells if a reset has happened, and if so, all the context "
"state is considered lost and the app proceeds by creating new ones. There's "
"no consensus on what to do to if robustness is not in use."
msgstr ""

#: ../../../gpu/drm-uapi.rst:363
msgid "Vulkan"
msgstr ""

#: ../../../gpu/drm-uapi.rst:365
msgid ""
"Apps using Vulkan should check for ``VK_ERROR_DEVICE_LOST`` for submissions. "
"This error code means, among other things, that a device reset has happened "
"and it needs to recreate the contexts to keep going."
msgstr ""

#: ../../../gpu/drm-uapi.rst:370
msgid "Reporting causes of resets"
msgstr ""

#: ../../../gpu/drm-uapi.rst:372
msgid ""
"Apart from propagating the reset through the stack so apps can recover, it's "
"really useful for driver developers to learn more about what caused the "
"reset in the first place. For this, drivers can make use of devcoredump to "
"store relevant information about the reset and send device wedged event with "
"``none`` recovery method (as explained in \"Device Wedging\" chapter) to "
"notify userspace, so this information can be collected and added to user bug "
"reports."
msgstr ""

#: ../../../gpu/drm-uapi.rst:380
msgid "Device Wedging"
msgstr ""

#: ../../../gpu/drm-uapi.rst:382
msgid ""
"Drivers can optionally make use of device wedged event (implemented as "
"drm_dev_wedged_event() in DRM subsystem), which notifies userspace of "
"'wedged' (hanged/unusable) state of the DRM device through a uevent. This is "
"useful especially in cases where the device is no longer operating as "
"expected and has become unrecoverable from driver context. Purpose of this "
"implementation is to provide drivers a generic way to recover the device "
"with the help of userspace intervention, without taking any drastic measures "
"(like resetting or re-enumerating the full bus, on which the underlying "
"physical device is sitting) in the driver."
msgstr ""

#: ../../../gpu/drm-uapi.rst:392
msgid ""
"A 'wedged' device is basically a device that is declared dead by the driver "
"after exhausting all possible attempts to recover it from driver context. "
"The uevent is the notification that is sent to userspace along with a hint "
"about what could possibly be attempted to recover the device from userspace "
"and bring it back to usable state. Different drivers may have different "
"ideas of a 'wedged' device depending on hardware implementation of the "
"underlying physical device, and hence the vendor agnostic nature of the "
"event. It is up to the drivers to decide when they see the need for device "
"recovery and how they want to recover from the available methods."
msgstr ""

#: ../../../gpu/drm-uapi.rst:403
msgid "Driver prerequisites"
msgstr ""

#: ../../../gpu/drm-uapi.rst:405
msgid ""
"The driver, before opting for recovery, needs to make sure that the 'wedged' "
"device doesn't harm the system as a whole by taking care of the "
"prerequisites. Necessary actions must include disabling DMA to system memory "
"as well as any communication channels with other devices. Further, the "
"driver must ensure that all dma_fences are signalled and any device state "
"that the core kernel might depend on is cleaned up. All existing mmaps "
"should be invalidated and page faults should be redirected to a dummy page. "
"Once the event is sent, the device must be kept in 'wedged' state until the "
"recovery is performed. New accesses to the device (IOCTLs) should be "
"rejected, preferably with an error code that resembles the type of failure "
"the device has encountered. This will signify the reason for wedging, which "
"can be reported to the application if needed."
msgstr ""

#: ../../../gpu/drm-uapi.rst:419
msgid "Recovery"
msgstr ""

#: ../../../gpu/drm-uapi.rst:421
msgid ""
"Current implementation defines three recovery methods, out of which, drivers "
"can use any one, multiple or none. Method(s) of choice will be sent in the "
"uevent environment as ``WEDGED=<method1>[,..,<methodN>]`` in order of less "
"to more side-effects. If driver is unsure about recovery or method is "
"unknown (like soft/hard system reboot, firmware flashing, physical device "
"replacement or any other procedure which can't be attempted on the fly), "
"``WEDGED=unknown`` will be sent instead."
msgstr ""

#: ../../../gpu/drm-uapi.rst:429
msgid ""
"Userspace consumers can parse this event and attempt recovery as per the "
"following expectations."
msgstr ""

#: ../../../gpu/drm-uapi.rst:433
msgid "Recovery method"
msgstr ""

#: ../../../gpu/drm-uapi.rst:433
msgid "Consumer expectations"
msgstr ""

#: ../../../gpu/drm-uapi.rst:435
msgid "none"
msgstr ""

#: ../../../gpu/drm-uapi.rst:435
msgid "optional telemetry collection"
msgstr ""

#: ../../../gpu/drm-uapi.rst:436
msgid "rebind"
msgstr ""

#: ../../../gpu/drm-uapi.rst:436
msgid "unbind + bind driver"
msgstr ""

#: ../../../gpu/drm-uapi.rst:437
msgid "bus-reset"
msgstr ""

#: ../../../gpu/drm-uapi.rst:437
msgid "unbind + bus reset/re-enumeration + bind"
msgstr ""

#: ../../../gpu/drm-uapi.rst:438
msgid "unknown"
msgstr ""

#: ../../../gpu/drm-uapi.rst:438
msgid "consumer policy"
msgstr ""

#: ../../../gpu/drm-uapi.rst:441
msgid ""
"The only exception to this is ``WEDGED=none``, which signifies that the "
"device was temporarily 'wedged' at some point but was recovered from driver "
"context using device specific methods like reset. No explicit recovery is "
"expected from the consumer in this case, but it can still take additional "
"steps like gathering telemetry information (devcoredump, syslog). This is "
"useful because the first hang is usually the most critical one which can "
"result in consequential hangs or complete wedging."
msgstr ""

#: ../../../gpu/drm-uapi.rst:450
msgid "Task information"
msgstr ""

#: ../../../gpu/drm-uapi.rst:452
msgid ""
"The information about which application (if any) was involved in the device "
"wedging is useful for userspace if they want to notify the user about what "
"happened (e.g. the compositor display a message to the user \"The <task "
"name> caused a graphical error and the system recovered\") or to implement "
"policies (e.g. the daemon may \"ban\" an task that keeps resetting the "
"device). If the task information is available, the uevent will display as "
"``PID=<pid>`` and ``TASK=<task name>``. Otherwise, ``PID`` and ``TASK`` will "
"not appear in the event string."
msgstr ""

#: ../../../gpu/drm-uapi.rst:461
msgid ""
"The reliability of this information is driver and hardware specific, and "
"should be taken with a caution regarding it's precision. To have a big "
"picture of what really happened, the devcoredump file provides much more "
"detailed information about the device state and about the event."
msgstr ""

#: ../../../gpu/drm-uapi.rst:467
msgid "Consumer prerequisites"
msgstr ""

#: ../../../gpu/drm-uapi.rst:469
msgid ""
"It is the responsibility of the consumer to make sure that the device or its "
"resources are not in use by any process before attempting recovery. With "
"IOCTLs erroring out, all device memory should be unmapped and file "
"descriptors should be closed to prevent leaks or undefined behaviour. The "
"idea here is to clear the device of all user context beforehand and set the "
"stage for a clean recovery."
msgstr ""

#: ../../../gpu/drm-uapi.rst:476
msgid "Example"
msgstr ""

#: ../../../gpu/drm-uapi.rst:478
msgid "Udev rule::"
msgstr ""

#: ../../../gpu/drm-uapi.rst:483
msgid "Recovery script::"
msgstr ""

#: ../../../gpu/drm-uapi.rst:495
msgid "Customization"
msgstr ""

#: ../../../gpu/drm-uapi.rst:497
msgid ""
"Although basic recovery is possible with a simple script, consumers can "
"define custom policies around recovery. For example, if the driver supports "
"multiple recovery methods, consumers can opt for the suitable one depending "
"on scenarios like repeat offences or vendor specific failures. Consumers can "
"also choose to have the device available for debugging or telemetry "
"collection and base their recovery decision on the findings. This is useful "
"especially when the driver is unsure about recovery or method is unknown."
msgstr ""

#: ../../../gpu/drm-uapi.rst:508
msgid "IOCTL Support on Device Nodes"
msgstr ""

#: ../../../gpu/drm-uapi:510: drivers/gpu/drm/drm_ioctl.c:732
msgid ""
"First things first, driver private IOCTLs should only be needed for drivers "
"supporting rendering. Kernel modesetting is all standardized, and extended "
"through properties. There are a few exceptions in some existing drivers, "
"which define IOCTL for use by the display DRM master, but they all predate "
"properties."
msgstr ""

#: ../../../gpu/drm-uapi:510: drivers/gpu/drm/drm_ioctl.c:738
msgid ""
"Now if you do have a render driver you always have to support it through "
"driver private properties. There's a few steps needed to wire all the things "
"up."
msgstr ""

#: ../../../gpu/drm-uapi:510: drivers/gpu/drm/drm_ioctl.c:742
msgid ""
"First you need to define the structure for your IOCTL in your driver private "
"UAPI header in ``include/uapi/drm/my_driver_drm.h``::"
msgstr ""

#: ../../../gpu/drm-uapi:510: drivers/gpu/drm/drm_ioctl.c:750
msgid ""
"Please make sure that you follow all the best practices from ``Documentation/"
"process/botching-up-ioctls.rst``. Note that drm_ioctl() automatically zero-"
"extends structures, hence make sure you can add more stuff at the end, i.e. "
"don't put a variable sized array there."
msgstr ""

#: ../../../gpu/drm-uapi:510: drivers/gpu/drm/drm_ioctl.c:755
msgid ""
"Then you need to define your IOCTL number, using one of DRM_IO(), DRM_IOR(), "
"DRM_IOW() or DRM_IOWR(). It must start with the DRM_IOCTL\\_ prefix::"
msgstr ""

#: ../../../gpu/drm-uapi:510: drivers/gpu/drm/drm_ioctl.c:761
msgid ""
"DRM driver private IOCTL must be in the range from DRM_COMMAND_BASE to "
"DRM_COMMAND_END. Finally you need an array of :c:type:`struct drm_ioctl_desc "
"<drm_ioctl_desc>` to wire up the handlers and set the access rights::"
msgstr ""

#: ../../../gpu/drm-uapi:510: drivers/gpu/drm/drm_ioctl.c:770
msgid ""
"And then assign this to the :c:type:`drm_driver.ioctls <drm_driver>` field "
"in your driver structure."
msgstr ""

#: ../../../gpu/drm-uapi:510: drivers/gpu/drm/drm_ioctl.c:773
msgid ""
"See the separate chapter on :ref:`file operations<drm_driver_fops>` for how "
"the driver-specific IOCTLs are wired up."
msgstr ""

#: ../../../gpu/drm-uapi.rst:514
msgid "Recommended IOCTL Return Values"
msgstr ""

#: ../../../gpu/drm-uapi.rst:516
msgid ""
"In theory a driver's IOCTL callback is only allowed to return very few error "
"codes. In practice it's good to abuse a few more. This section documents "
"common practice within the DRM subsystem:"
msgstr ""

#: ../../../gpu/drm-uapi.rst:520
msgid "ENOENT:"
msgstr ""

#: ../../../gpu/drm-uapi.rst:521
msgid ""
"Strictly this should only be used when a file doesn't exist e.g. when "
"calling the open() syscall. We reuse that to signal any kind of object "
"lookup failure, e.g. for unknown GEM buffer object handles, unknown KMS "
"object handles and similar cases."
msgstr ""

#: ../../../gpu/drm-uapi.rst:526
msgid "ENOSPC:"
msgstr ""

#: ../../../gpu/drm-uapi.rst:527
msgid ""
"Some drivers use this to differentiate \"out of kernel memory\" from \"out "
"of VRAM\". Sometimes also applies to other limited gpu resources used for "
"rendering (e.g. when you have a special limited compression buffer). "
"Sometimes resource allocation/reservation issues in command submission "
"IOCTLs are also signalled through EDEADLK."
msgstr ""

#: ../../../gpu/drm-uapi.rst:533
msgid "Simply running out of kernel/system memory is signalled through ENOMEM."
msgstr ""

#: ../../../gpu/drm-uapi.rst:535
msgid "EPERM/EACCES:"
msgstr ""

#: ../../../gpu/drm-uapi.rst:536
msgid ""
"Returned for an operation that is valid, but needs more privileges. E.g. "
"root-only or much more common, DRM master-only operations return this when "
"called by unpriviledged clients. There's no clear difference between EACCES "
"and EPERM."
msgstr ""

#: ../../../gpu/drm-uapi.rst:541
msgid "ENODEV:"
msgstr ""

#: ../../../gpu/drm-uapi.rst:542
msgid "The device is not present anymore or is not yet fully initialized."
msgstr ""

#: ../../../gpu/drm-uapi.rst:544
msgid "EOPNOTSUPP:"
msgstr ""

#: ../../../gpu/drm-uapi.rst:545
msgid "Feature (like PRIME, modesetting, GEM) is not supported by the driver."
msgstr ""

#: ../../../gpu/drm-uapi.rst:547
msgid "ENXIO:"
msgstr ""

#: ../../../gpu/drm-uapi.rst:548
msgid ""
"Remote failure, either a hardware transaction (like i2c), but also used when "
"the exporting driver of a shared dma-buf or fence doesn't support a feature "
"needed."
msgstr ""

#: ../../../gpu/drm-uapi.rst:552
msgid "EINTR:"
msgstr ""

#: ../../../gpu/drm-uapi.rst:553
msgid ""
"DRM drivers assume that userspace restarts all IOCTLs. Any DRM IOCTL can "
"return EINTR and in such a case should be restarted with the IOCTL "
"parameters left unchanged."
msgstr ""

#: ../../../gpu/drm-uapi.rst:557
msgid "EIO:"
msgstr ""

#: ../../../gpu/drm-uapi.rst:558
msgid ""
"The GPU died and couldn't be resurrected through a reset. Modesetting "
"hardware failures are signalled through the \"link status\" connector "
"property."
msgstr ""

#: ../../../gpu/drm-uapi.rst:562
msgid "EINVAL:"
msgstr ""

#: ../../../gpu/drm-uapi.rst:563
msgid ""
"Catch-all for anything that is an invalid argument combination which cannot "
"work."
msgstr ""

#: ../../../gpu/drm-uapi.rst:566
msgid ""
"IOCTL also use other error codes like ETIME, EFAULT, EBUSY, ENOTTY but their "
"usage is in line with the common meanings. The above list tries to just "
"document DRM specific patterns. Note that ENOTTY has the slightly "
"unintuitive meaning of \"this IOCTL does not exist\", and is used exactly as "
"such in DRM."
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:47
msgid "**Typedef**: DRM ioctl function type."
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:50
#: include/drm/drm_ioctl.h:63
msgid "**Syntax**"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:52
msgid ""
"``typedef int drm_ioctl_t (struct drm_device *dev, void *data, struct "
"drm_file *file_priv)``"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:58
#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:446
#: drivers/gpu/drm/drm_ioctl.c:466 ../../../gpu/drm-uapi:652:
#: drivers/gpu/drm/drm_debugfs.c:464 drivers/gpu/drm/drm_debugfs.c:492
#: ../../../gpu/drm-uapi:661: drivers/gpu/drm/drm_sysfs.c:437
msgid "``struct drm_device *dev``"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:46
msgid "DRM device inode"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:48
#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:443
#: drivers/gpu/drm/drm_ioctl.c:463 ../../../gpu/drm-uapi:652:
#: drivers/gpu/drm/drm_debugfs.c:463
msgid "``void *data``"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:47
msgid "private pointer of the ioctl call"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:48
#: include/drm/drm_ioctl.h:61
msgid "DRM file this ioctl was made on"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:49
msgid ""
"This is the DRM ioctl typedef. Note that drm_ioctl() has alrady copied "
"**data** into kernel-space, and will also copy it back, depending upon the "
"read/write settings in the ioctl command code."
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:60
msgid "**Typedef**: compatibility DRM ioctl function type."
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:65
msgid ""
"``typedef int drm_ioctl_compat_t (struct file *filp, unsigned int cmd, "
"unsigned long arg)``"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:71
#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:807
#: ../../../gpu/drm-uapi:577: drivers/gpu/drm/drm_ioc32.c:355
msgid "``struct file *filp``"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:59
msgid "file pointer"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:61
#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:804
#: ../../../gpu/drm-uapi:577: drivers/gpu/drm/drm_ioc32.c:352
msgid "``unsigned int cmd``"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:60
msgid "ioctl command code"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:62
#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:805
#: ../../../gpu/drm-uapi:577: drivers/gpu/drm/drm_ioc32.c:353
msgid "``unsigned long arg``"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:62
msgid ""
"Just a typedef to make declaring an array of compatibility handlers easier. "
"New drivers shouldn't screw up the structure layout for their ioctl "
"structures and hence never need this."
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:75
msgid "DRM ioctl flags"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:79
msgid "**Constants**"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:81
msgid "``DRM_AUTH``"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:82
msgid ""
"This is for ioctl which are used for rendering, and require that the file "
"descriptor is either for a render node, or if it's a legacy/primary node, "
"then it must be authenticated."
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:86
msgid "``DRM_MASTER``"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:87
msgid ""
"This must be set for any ioctl which can change the modeset or display "
"state. Userspace must call the ioctl through a primary node, while it is the "
"active master."
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:91
msgid ""
"Note that read-only modeset ioctl can also be called by unauthenticated "
"clients, or when a master is not the currently active one."
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:95
msgid "``DRM_ROOT_ONLY``"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:96
msgid ""
"Anything that could potentially wreak a master file descriptor needs to have "
"this flag set. Current that's only for the SETMASTER and DROPMASTER ioctl, "
"which e.g. logind can call to force a non-behaving master (display "
"compositor) into compliance."
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:101
msgid "This is equivalent to callers with the SYSADMIN capability."
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:103
msgid "``DRM_RENDER_ALLOW``"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:104
msgid ""
"This is used for all ioctl needed for rendering only, for drivers which "
"support render nodes. This should be all new render drivers, and hence it "
"should be always set for any ioctl with DRM_AUTH set. Note though that read-"
"only query ioctl might have this set, but have not set DRM_AUTH because they "
"do not require authentication."
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:76
msgid ""
"Various flags that can be set in :c:type:`drm_ioctl_desc.flags "
"<drm_ioctl_desc>` to control how userspace can use a given ioctl."
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:125
msgid "DRM driver ioctl entry"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:126
msgid "``cmd``"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:127
msgid "ioctl command number, without flags"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:127
#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:975
#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:235
#: include/uapi/drm/drm_mode.h:602 include/uapi/drm/drm_mode.h:716
#: include/uapi/drm/drm_mode.h:1062 include/uapi/drm/drm_mode.h:1258
msgid "``flags``"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:128
#: include/drm/drm_ioctl.h:145
msgid "a bitmask of :c:type:`enum drm_ioctl_flags <drm_ioctl_flags>`"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:128
msgid "``func``"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:129
msgid "handler for this ioctl"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:129
#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:60
#: include/drm/drm_debugfs.h:105 ../../../gpu/drm-uapi:704:
#: include/uapi/drm/drm_mode.h:237 include/uapi/drm/drm_mode.h:550
#: include/uapi/drm/drm_mode.h:607
msgid "``name``"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:130
msgid "user-readable name for debug output"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:130
msgid ""
"For convenience it's easier to create these using the DRM_IOCTL_DEF_DRV() "
"macro."
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:144
msgid "``DRM_IOCTL_DEF_DRV (ioctl, _func, _flags)``"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:142
msgid ""
"helper macro to fill out a :c:type:`struct drm_ioctl_desc <drm_ioctl_desc>`"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:148
msgid "``ioctl``"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:143
msgid "ioctl command suffix"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:145
msgid "``_func``"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:144
msgid "handler for the ioctl"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:146
msgid "``_flags``"
msgstr ""

#: ../../../gpu/drm-uapi:571: include/drm/drm_ioctl.h:146
msgid ""
"Small helper macro to create a :c:type:`struct drm_ioctl_desc "
"<drm_ioctl_desc>` entry. The ioctl command number is constructed by "
"prepending ``DRM_IOCTL\\_`` and passing that to DRM_IOCTL_NR()."
msgstr ""

#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:440
msgid "DRM no-op ioctl implementation"
msgstr ""

#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:441
#: drivers/gpu/drm/drm_ioctl.c:461
msgid "DRM device for the ioctl"
msgstr ""

#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:442
#: drivers/gpu/drm/drm_ioctl.c:462
msgid "data pointer for the ioctl"
msgstr ""

#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:443
#: drivers/gpu/drm/drm_ioctl.c:463
msgid "DRM file for the ioctl call"
msgstr ""

#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:444
msgid ""
"This no-op implementation for drm ioctls is useful for deprecated "
"functionality where we can't return a failure code because existing "
"userspace checks the result of the ioctl, but doesn't care about the action."
msgstr ""

#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:448
msgid "Always returns successfully with 0."
msgstr ""

#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:460
msgid "DRM invalid ioctl implementation"
msgstr ""

#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:464
msgid ""
"This no-op implementation for drm ioctls is useful for deprecated "
"functionality where we really don't want to allow userspace to call the "
"ioctl any more. This is the case for old ums interfaces for drivers that "
"transitioned to kms gradually and so kept the old legacy tables around. This "
"only applies to radeon and i915 kms drivers, other drivers shouldn't need to "
"use this function."
msgstr ""

#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:471
msgid "Always fails with a return value of -EINVAL."
msgstr ""

#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:801
msgid "ioctl callback implementation for DRM drivers"
msgstr ""

#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:802
#: ../../../gpu/drm-uapi:577: drivers/gpu/drm/drm_ioc32.c:350
msgid "file this ioctl is called on"
msgstr ""

#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:803
#: ../../../gpu/drm-uapi:577: drivers/gpu/drm/drm_ioc32.c:351
msgid "ioctl cmd number"
msgstr ""

#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:804
#: ../../../gpu/drm-uapi:577: drivers/gpu/drm/drm_ioc32.c:352
msgid "user argument"
msgstr ""

#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:805
msgid ""
"Looks up the ioctl function in the DRM core and the driver dispatch table, "
"stored in :c:type:`drm_driver.ioctls <drm_driver>`. It checks for necessary "
"permission by calling drm_ioctl_permit(), and dispatches to the respective "
"function."
msgstr ""

#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:809
#: drivers/gpu/drm/drm_ioctl.c:922 ../../../gpu/drm-uapi:577:
#: drivers/gpu/drm/drm_ioc32.c:358 ../../../gpu/drm-uapi:652:
#: drivers/gpu/drm/drm_debugfs.c:206
msgid "**Return**"
msgstr ""

#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:810
#: ../../../gpu/drm-uapi:577: drivers/gpu/drm/drm_ioc32.c:359
msgid "Zero on success, negative error code on failure."
msgstr ""

#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:915
msgid "Check for core ioctl and return ioctl permission flags"
msgstr ""

#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:921
msgid "``unsigned int nr``"
msgstr ""

#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:916
msgid "ioctl number"
msgstr ""

#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:918
msgid "``unsigned int *flags``"
msgstr ""

#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:917
msgid "where to return the ioctl permission flags"
msgstr ""

#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:918
msgid ""
"This ioctl is only used by the vmwgfx driver to augment the access checks "
"done by the drm core and insofar a pretty decent layering violation. This "
"shouldn't be used by any drivers."
msgstr ""

#: ../../../gpu/drm-uapi:574: drivers/gpu/drm/drm_ioctl.c:923
msgid ""
"True if the **nr** corresponds to a DRM core ioctl number, false otherwise."
msgstr ""

#: ../../../gpu/drm-uapi:577: drivers/gpu/drm/drm_ioc32.c:349
msgid "32bit IOCTL compatibility handler for DRM drivers"
msgstr ""

#: ../../../gpu/drm-uapi:577: drivers/gpu/drm/drm_ioc32.c:353
msgid ""
"Compatibility handler for 32 bit userspace running on 64 kernels. All actual "
"IOCTL handling is forwarded to drm_ioctl(), while marshalling structures as "
"appropriate. Note that this only handles DRM core IOCTLs, if the driver has "
"botched IOCTL itself, it must handle those by wrapping this function."
msgstr ""

#: ../../../gpu/drm-uapi.rst:581
msgid "Testing and validation"
msgstr ""

#: ../../../gpu/drm-uapi.rst:584
msgid "Testing Requirements for userspace API"
msgstr ""

#: ../../../gpu/drm-uapi.rst:586
msgid ""
"New cross-driver userspace interface extensions, like new IOCTL, new KMS "
"properties, new files in sysfs or anything else that constitutes an API "
"change should have driver-agnostic testcases in IGT for that feature, if "
"such a test can be reasonably made using IGT for the target hardware."
msgstr ""

#: ../../../gpu/drm-uapi.rst:592
msgid "Validating changes with IGT"
msgstr ""

#: ../../../gpu/drm-uapi.rst:594
msgid ""
"There's a collection of tests that aims to cover the whole functionality of "
"DRM drivers and that can be used to check that changes to DRM drivers or the "
"core don't regress existing functionality. This test suite is called IGT and "
"its code and instructions to build and run can be found in https://gitlab."
"freedesktop.org/drm/igt-gpu-tools/."
msgstr ""

#: ../../../gpu/drm-uapi.rst:601
msgid "Using VKMS to test DRM API"
msgstr ""

#: ../../../gpu/drm-uapi.rst:603
msgid ""
"VKMS is a software-only model of a KMS driver that is useful for testing and "
"for running compositors. VKMS aims to enable a virtual display without the "
"need for a hardware display capability. These characteristics made VKMS a "
"perfect tool for validating the DRM core behavior and also support the "
"compositor developer. VKMS makes it possible to test DRM functions in a "
"virtual machine without display, simplifying the validation of some of the "
"core changes."
msgstr ""

#: ../../../gpu/drm-uapi.rst:611
msgid ""
"To Validate changes in DRM API with VKMS, start setting the kernel: make "
"sure to enable VKMS module; compile the kernel with the VKMS enabled and "
"install it in the target machine. VKMS can be run in a Virtual Machine "
"(QEMU, virtme or similar). It's recommended the use of KVM with the minimum "
"of 1GB of RAM and four cores."
msgstr ""

#: ../../../gpu/drm-uapi.rst:617
msgid "It's possible to run the IGT-tests in a VM in two ways:"
msgstr ""

#: ../../../gpu/drm-uapi.rst:619
msgid "Use IGT inside a VM"
msgstr ""

#: ../../../gpu/drm-uapi.rst:620
msgid ""
"Use IGT from the host machine and write the results in a shared directory."
msgstr ""

#: ../../../gpu/drm-uapi.rst:622
msgid ""
"Following is an example of using a VM with a shared directory with the host "
"machine to run igt-tests. This example uses virtme::"
msgstr ""

#: ../../../gpu/drm-uapi.rst:627
msgid ""
"Run the igt-tests in the guest machine. This example runs the 'kms_flip' "
"tests::"
msgstr ""

#: ../../../gpu/drm-uapi.rst:632
msgid ""
"In this example, instead of building the igt_runner, Piglit is used (-p "
"option). It creates an HTML summary of the test results and saves them in "
"the folder \"igt-gpu-tools/results\". It executes only the igt-tests "
"matching the -t option."
msgstr ""

#: ../../../gpu/drm-uapi.rst:638
msgid "Display CRC Support"
msgstr ""

#: ../../../gpu/drm-uapi:640: drivers/gpu/drm/drm_debugfs_crc.c:44
msgid ""
"DRM device drivers can provide to userspace CRC information of each frame as "
"it reached a given hardware component (a CRC sampling \"source\")."
msgstr ""

#: ../../../gpu/drm-uapi:640: drivers/gpu/drm/drm_debugfs_crc.c:47
msgid ""
"Userspace can control generation of CRCs in a given CRTC by writing to the "
"file dri/0/crtc-N/crc/control in debugfs, with N being the :ref:`index of "
"the CRTC<crtc_index>`. Accepted values are source names (which are driver-"
"specific) and the \"auto\" keyword, which will let the driver select a "
"default source of frame CRCs for this CRTC."
msgstr ""

#: ../../../gpu/drm-uapi:640: drivers/gpu/drm/drm_debugfs_crc.c:53
msgid ""
"Once frame CRC generation is enabled, userspace can capture them by reading "
"the dri/0/crtc-N/crc/data file. Each line in that file contains the frame "
"number in the first field and then a number of unsigned integer fields "
"containing the CRC data. Fields are separated by a single space and the "
"number of CRC fields is source-specific."
msgstr ""

#: ../../../gpu/drm-uapi:640: drivers/gpu/drm/drm_debugfs_crc.c:59
msgid ""
"Note that though in some cases the CRC is computed in a specified way and on "
"the frame contents as supplied by userspace (eDP 1.3), in general the CRC "
"computation is performed in an unspecified way and on frame contents that "
"have been already processed in also an unspecified way and thus userspace "
"cannot rely on being able to generate matching CRC values for the frame "
"contents that it submits. In this general case, the maximum userspace can do "
"is to compare the reported CRCs of frames that should have the same contents."
msgstr ""

#: ../../../gpu/drm-uapi:640: drivers/gpu/drm/drm_debugfs_crc.c:67
msgid ""
"On the driver side the implementation effort is minimal, drivers only need "
"to implement :c:type:`drm_crtc_funcs.set_crc_source <drm_crtc_funcs>` and :c:"
"type:`drm_crtc_funcs.verify_crc_source <drm_crtc_funcs>`. The debugfs files "
"are automatically set up if those vfuncs are set. CRC samples need to be "
"captured in the driver by calling drm_crtc_add_crc_entry(). Depending on the "
"driver and HW requirements, :c:type:`drm_crtc_funcs.set_crc_source "
"<drm_crtc_funcs>` may result in a commit (even a full modeset)."
msgstr ""

#: ../../../gpu/drm-uapi:640: drivers/gpu/drm/drm_debugfs_crc.c:74
msgid ""
"CRC results must be reliable across non-full-modeset atomic commits, so if a "
"commit via DRM_IOCTL_MODE_ATOMIC would disable or otherwise interfere with "
"CRC generation, then the driver must mark that commit as a full modeset "
"(drm_atomic_crtc_needs_modeset() should return true). As a result, to ensure "
"consistent results, generic userspace must re-setup CRC generation after a "
"legacy SETCRTC or an atomic commit with DRM_MODE_ATOMIC_ALLOW_MODESET."
msgstr ""

#: ../../../gpu/drm-uapi:643: drivers/gpu/drm/drm_debugfs_crc.c:385
msgid "Add entry with CRC information for a frame"
msgstr ""

#: ../../../gpu/drm-uapi:643: drivers/gpu/drm/drm_debugfs_crc.c:391
msgid "``struct drm_crtc *crtc``"
msgstr ""

#: ../../../gpu/drm-uapi:643: drivers/gpu/drm/drm_debugfs_crc.c:386
msgid "CRTC to which the frame belongs"
msgstr ""

#: ../../../gpu/drm-uapi:643: drivers/gpu/drm/drm_debugfs_crc.c:388
msgid "``bool has_frame``"
msgstr ""

#: ../../../gpu/drm-uapi:643: drivers/gpu/drm/drm_debugfs_crc.c:387
msgid "whether this entry has a frame number to go with"
msgstr ""

#: ../../../gpu/drm-uapi:643: drivers/gpu/drm/drm_debugfs_crc.c:389
msgid "``uint32_t frame``"
msgstr ""

#: ../../../gpu/drm-uapi:643: drivers/gpu/drm/drm_debugfs_crc.c:388
msgid "number of the frame these CRCs are about"
msgstr ""

#: ../../../gpu/drm-uapi:643: drivers/gpu/drm/drm_debugfs_crc.c:390
msgid "``uint32_t *crcs``"
msgstr ""

#: ../../../gpu/drm-uapi:643: drivers/gpu/drm/drm_debugfs_crc.c:389
msgid "array of CRC values, with length matching #drm_crtc_crc.values_cnt"
msgstr ""

#: ../../../gpu/drm-uapi:643: drivers/gpu/drm/drm_debugfs_crc.c:390
msgid ""
"For each frame, the driver polls the source of CRCs for new data and calls "
"this function to add them to the buffer from where userspace reads."
msgstr ""

#: ../../../gpu/drm-uapi.rst:647
msgid "Debugfs Support"
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:43
msgid "``DRM_DEBUGFS_GPUVA_INFO (show, data)``"
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:41
msgid ":c:type:`drm_info_list` entry to dump a GPU VA space"
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:47
#: include/drm/drm_debugfs.h:63 include/drm/drm_debugfs.h:109
msgid "``show``"
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:42
msgid "the :c:type:`drm_info_list`'s show callback"
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:44
#: include/drm/drm_debugfs.h:72 include/drm/drm_debugfs.h:120
#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1220
msgid "``data``"
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:43
msgid "driver private data"
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:44
msgid ""
"Drivers should use this macro to define a :c:type:`drm_info_list` entry to "
"provide a debugfs file for dumping the GPU VA space regions and mappings."
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:47
msgid ""
"For each DRM GPU VA space drivers should call drm_debugfs_gpuva_info() from "
"their **show** callback."
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:54
#: include/drm/drm_debugfs.h:99
msgid "debugfs info list entry"
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:61
msgid "file name"
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:64
msgid ""
"Show callback. :c:type:`seq_file->private <seq_file>` will be set to the :c:"
"type:`struct drm_info_node <drm_info_node>` corresponding to the instance of "
"this info on a given :c:type:`struct drm_minor <drm_minor>`."
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:70
#: include/drm/drm_debugfs.h:117
msgid "``driver_features``"
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:71
msgid "Required driver features for this entry"
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:73
#: include/drm/drm_debugfs.h:121
msgid "Driver-private data, should not be device-specific."
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:55
#: include/drm/drm_debugfs.h:100
msgid "This structure represents a debugfs file to be created by the drm core."
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:77
msgid "Per-minor debugfs node structure"
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:89
msgid "``minor``"
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:90
msgid ":c:type:`struct drm_minor <drm_minor>` for this node."
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:91
msgid "``info_ent``"
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:92
msgid "template for this node."
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:78
msgid ""
"This structure represents a debugfs file, as an instantiation of a :c:type:"
"`struct drm_info_list <drm_info_list>` on a :c:type:`struct drm_minor "
"<drm_minor>`."
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:81
msgid "FIXME:"
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:83
msgid ""
"No it doesn't make a hole lot of sense that we duplicate debugfs entries for "
"both the render and the primary nodes, but that's how this has organically "
"grown. It should probably be fixed, with a compatibility link, if needed."
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:106
msgid "File name"
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:110
msgid ""
"Show callback. :c:type:`seq_file->private <seq_file>` will be set to the :c:"
"type:`struct drm_debugfs_entry <drm_debugfs_entry>` corresponding to the "
"instance of this info on a given :c:type:`struct drm_device <drm_device>`."
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:118
msgid "Required driver features for this entry."
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:125
msgid "Per-device debugfs node structure"
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:132
msgid ":c:type:`struct drm_device <drm_device>` for this node."
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:134
msgid "``file``"
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:135
msgid "Template for this node."
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:137
msgid "``list``"
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:138
msgid "Linked list of all device nodes."
msgstr ""

#: ../../../gpu/drm-uapi:649: include/drm/drm_debugfs.h:126
msgid ""
"This structure represents a debugfs file, as an instantiation of a :c:type:"
"`struct drm_debugfs_info <drm_debugfs_info>` on a :c:type:`struct drm_device "
"<drm_device>`."
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:198
msgid "dump the given DRM GPU VA space"
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:204
msgid "``struct seq_file *m``"
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:199
msgid "pointer to the :c:type:`seq_file` to write"
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:201
msgid "``struct drm_gpuvm *gpuvm``"
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:200
msgid "the :c:type:`drm_gpuvm` representing the GPU VA space"
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:201
msgid "Dumps the GPU VA mappings of a given DRM GPU VA manager."
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:203
msgid ""
"For each DRM GPU VA space drivers should call this function from their :c:"
"type:`drm_info_list`'s show callback."
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:207
msgid "0 on success, -ENODEV if the :c:type:`gpuvm` is not initialized"
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:238
msgid "Initialize a given set of debugfs files for DRM minor"
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:244
msgid "``const struct drm_info_list *files``"
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:240
#: drivers/gpu/drm/drm_debugfs.c:488
msgid "The array of files to create"
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:242
#: drivers/gpu/drm/drm_debugfs.c:490
msgid "``int count``"
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:241
#: drivers/gpu/drm/drm_debugfs.c:489
msgid "The number of files given"
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:243
msgid "``struct dentry *root``"
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:242
msgid "DRI debugfs dir entry."
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:244
msgid "``struct drm_minor *minor``"
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:243
msgid "device minor number"
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:244
msgid ""
"Create a given set of debugfs files represented by an array of :c:type:"
"`struct drm_info_list <drm_info_list>` in the given root directory. These "
"files will be removed automatically on drm_debugfs_dev_fini()."
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:458
msgid "Add a given file to the DRM device debugfs file list"
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:459
#: drivers/gpu/drm/drm_debugfs.c:487
msgid "drm device for the ioctl"
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:461
msgid "``const char *name``"
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:460
msgid "debugfs file name"
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:462
msgid "``int (*show)(struct seq_file*, void*)``"
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:461
msgid "show callback"
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:462
msgid "driver-private data, should not be device-specific"
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:463
msgid ""
"Add a given file entry to the DRM device debugfs file list to be created on "
"drm_debugfs_init."
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:486
msgid "Add an array of files to the DRM device debugfs file list"
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:489
msgid "``const struct drm_debugfs_info *files``"
msgstr ""

#: ../../../gpu/drm-uapi:652: drivers/gpu/drm/drm_debugfs.c:490
msgid ""
"Add a given set of debugfs files represented by an array of :c:type:`struct "
"drm_debugfs_info <drm_debugfs_info>` in the DRM device debugfs file list."
msgstr ""

#: ../../../gpu/drm-uapi.rst:656
msgid "Sysfs Support"
msgstr ""

#: ../../../gpu/drm-uapi:658: drivers/gpu/drm/drm_sysfs.c:40
msgid ""
"DRM provides very little additional support to drivers for sysfs "
"interactions, beyond just all the standard stuff. Drivers who want to expose "
"additional sysfs properties and property groups can attach them at either :c:"
"type:`drm_device.dev <drm_device>` or :c:type:`drm_connector.kdev "
"<drm_connector>`."
msgstr ""

#: ../../../gpu/drm-uapi:658: drivers/gpu/drm/drm_sysfs.c:45
msgid ""
"Registration is automatically handled when calling drm_dev_register(), or "
"drm_connector_register() in case of hot-plugged connectors. Unregistration "
"is also automatically handled by drm_dev_unregister() and "
"drm_connector_unregister()."
msgstr ""

#: ../../../gpu/drm-uapi:661: drivers/gpu/drm/drm_sysfs.c:431
msgid "generate a DRM uevent"
msgstr ""

#: ../../../gpu/drm-uapi:661: drivers/gpu/drm/drm_sysfs.c:432
msgid "DRM device"
msgstr ""

#: ../../../gpu/drm-uapi:661: drivers/gpu/drm/drm_sysfs.c:433
msgid ""
"Send a uevent for the DRM device specified by **dev**.  Currently we only "
"set HOTPLUG=1 in the uevent environment, but this could be expanded to deal "
"with other types of events."
msgstr ""

#: ../../../gpu/drm-uapi:661: drivers/gpu/drm/drm_sysfs.c:437
msgid ""
"Any new uapi should be using the drm_sysfs_connector_status_event() for "
"uevents on connector status change."
msgstr ""

#: ../../../gpu/drm-uapi:661: drivers/gpu/drm/drm_sysfs.c:453
msgid "generate a DRM uevent for any connector change"
msgstr ""

#: ../../../gpu/drm-uapi:661: drivers/gpu/drm/drm_sysfs.c:459
#: drivers/gpu/drm/drm_sysfs.c:484
msgid "``struct drm_connector *connector``"
msgstr ""

#: ../../../gpu/drm-uapi:661: drivers/gpu/drm/drm_sysfs.c:455
msgid "connector which has changed"
msgstr ""

#: ../../../gpu/drm-uapi:661: drivers/gpu/drm/drm_sysfs.c:456
msgid ""
"Send a uevent for the DRM connector specified by **connector**. This will "
"send a uevent with the properties HOTPLUG=1 and CONNECTOR."
msgstr ""

#: ../../../gpu/drm-uapi:661: drivers/gpu/drm/drm_sysfs.c:478
msgid "generate a DRM uevent for connector property change"
msgstr ""

#: ../../../gpu/drm-uapi:661: drivers/gpu/drm/drm_sysfs.c:480
msgid "connector on which property changed"
msgstr ""

#: ../../../gpu/drm-uapi:661: drivers/gpu/drm/drm_sysfs.c:482
msgid "``struct drm_property *property``"
msgstr ""

#: ../../../gpu/drm-uapi:661: drivers/gpu/drm/drm_sysfs.c:481
msgid "connector property which has changed."
msgstr ""

#: ../../../gpu/drm-uapi:661: drivers/gpu/drm/drm_sysfs.c:482
msgid ""
"Send a uevent for the specified DRM connector and property.  Currently we "
"set HOTPLUG=1 and connector id along with the attached property id related "
"to the change."
msgstr ""

#: ../../../gpu/drm-uapi:661: drivers/gpu/drm/drm_sysfs.c:553
msgid "register new device with the DRM sysfs class"
msgstr ""

#: ../../../gpu/drm-uapi:661: drivers/gpu/drm/drm_sysfs.c:559
#: drivers/gpu/drm/drm_sysfs.c:577
msgid "``struct device *dev``"
msgstr ""

#: ../../../gpu/drm-uapi:661: drivers/gpu/drm/drm_sysfs.c:554
msgid "device to register"
msgstr ""

#: ../../../gpu/drm-uapi:661: drivers/gpu/drm/drm_sysfs.c:555
msgid ""
"Registers a new :c:type:`struct device <device>` within the DRM sysfs class. "
"Essentially only used by ttm to have a place for its global settings. "
"Drivers should never use this."
msgstr ""

#: ../../../gpu/drm-uapi:661: drivers/gpu/drm/drm_sysfs.c:571
msgid "unregister device with the DRM sysfs class"
msgstr ""

#: ../../../gpu/drm-uapi:661: drivers/gpu/drm/drm_sysfs.c:572
msgid "device to unregister"
msgstr ""

#: ../../../gpu/drm-uapi:661: drivers/gpu/drm/drm_sysfs.c:573
msgid ""
"Unregisters a :c:type:`struct device <device>` from the DRM sysfs class. "
"Essentially only used by ttm to have a place for its global settings. "
"Drivers should never use this."
msgstr ""

#: ../../../gpu/drm-uapi.rst:666
msgid "VBlank event handling"
msgstr ""

#: ../../../gpu/drm-uapi.rst:668
msgid "The DRM core exposes two vertical blank related ioctls:"
msgstr ""

#: ../../../gpu/drm-uapi.rst:670
msgid ":c:macro:`DRM_IOCTL_WAIT_VBLANK`"
msgstr ""

#: ../../../gpu/drm-uapi.rst:671
msgid ""
"This takes a struct drm_wait_vblank structure as its argument, and it is "
"used to block or request a signal when a specified vblank event occurs."
msgstr ""

#: ../../../gpu/drm-uapi.rst:675
msgid ":c:macro:`DRM_IOCTL_MODESET_CTL`"
msgstr ""

#: ../../../gpu/drm-uapi.rst:676
msgid ""
"This was only used for user-mode-settind drivers around modesetting changes "
"to allow the kernel to update the vblank interrupt after mode setting, since "
"on many devices the vertical blank counter is reset to 0 at some point "
"during modeset. Modern drivers should not call this any more since with "
"kernel mode setting it is a no-op."
msgstr ""

#: ../../../gpu/drm-uapi.rst:683
msgid "Userspace API Structures"
msgstr ""

#: ../../../gpu/drm-uapi:685: include/uapi/drm/drm_mode.h:37
msgid ""
"DRM exposes many UAPI and structure definitions to have a consistent and "
"standardized interface with users. Userspace can refer to these structure "
"definitions and UAPI formats to communicate to drivers."
msgstr ""

#: ../../../gpu/drm-uapi.rst:691
msgid "CRTC index"
msgstr ""

#: ../../../gpu/drm-uapi.rst:693
msgid ""
"CRTC's have both an object ID and an index, and they are not the same thing. "
"The index is used in cases where a densely packed identifier for a CRTC is "
"needed, for instance a bitmask of CRTC's. The member possible_crtcs of "
"struct drm_mode_get_plane is an example."
msgstr ""

#: ../../../gpu/drm-uapi.rst:698
msgid ""
":c:macro:`DRM_IOCTL_MODE_GETRESOURCES` populates a structure with an array "
"of CRTC ID's, and the CRTC index is its position in this array."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:631
msgid "``DRM_CAP_DUMB_BUFFER``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:630
msgid ""
"If set to 1, the driver supports creating dumb buffers via the :c:type:"
"`DRM_IOCTL_MODE_CREATE_DUMB` ioctl."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:638
msgid "``DRM_CAP_VBLANK_HIGH_CRTC``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:637
msgid ""
"If set to 1, the kernel supports specifying a :ref:`CRTC index<crtc_index>` "
"in the high bits of :c:type:`drm_wait_vblank_request.type "
"<drm_wait_vblank_request>`."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:640
msgid "Starting kernel version 2.6.39, this capability is always set to 1."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:647
msgid "``DRM_CAP_DUMB_PREFERRED_DEPTH``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:646
msgid "The preferred bit depth for dumb buffers."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:648
msgid ""
"The bit depth is the number of bits used to indicate the color of a single "
"pixel excluding any padding. This is different from the number of bits per "
"pixel. For instance, XRGB8888 has a bit depth of 24 but has 32 bits per "
"pixel."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:653
#: include/uapi/drm/drm.h:665
msgid ""
"Note that this preference only applies to dumb buffers, it's irrelevant for "
"other types of buffers."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:661
msgid "``DRM_CAP_DUMB_PREFER_SHADOW``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:660
msgid ""
"If set to 1, the driver prefers userspace to render to a shadow buffer "
"instead of directly rendering to a dumb buffer. For best speed, userspace "
"should do streaming ordered memory copies into the dumb buffer and never "
"read from it."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:673
msgid "``DRM_CAP_PRIME``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:672
msgid ""
"Bitfield of supported PRIME sharing capabilities. See :c:type:"
"`DRM_PRIME_CAP_IMPORT` and :c:type:`DRM_PRIME_CAP_EXPORT`."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:675
msgid ""
"Starting from kernel version 6.6, both :c:type:`DRM_PRIME_CAP_IMPORT` and :c:"
"type:`DRM_PRIME_CAP_EXPORT` are always advertised."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:678
msgid ""
"PRIME buffers are exposed as dma-buf file descriptors. See :ref:"
"`prime_buffer_sharing`."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:686
msgid "``DRM_PRIME_CAP_IMPORT``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:685
msgid ""
"If this bit is set in :c:type:`DRM_CAP_PRIME`, the driver supports importing "
"PRIME buffers via the :c:type:`DRM_IOCTL_PRIME_FD_TO_HANDLE` ioctl."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:688
#: include/uapi/drm/drm.h:697
msgid ""
"Starting from kernel version 6.6, this bit is always set in :c:type:"
"`DRM_CAP_PRIME`."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:695
msgid "``DRM_PRIME_CAP_EXPORT``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:694
msgid ""
"If this bit is set in :c:type:`DRM_CAP_PRIME`, the driver supports exporting "
"PRIME buffers via the :c:type:`DRM_IOCTL_PRIME_HANDLE_TO_FD` ioctl."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:704
msgid "``DRM_CAP_TIMESTAMP_MONOTONIC``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:703
msgid ""
"If set to 0, the kernel will report timestamps with ``CLOCK_REALTIME`` in "
"struct drm_event_vblank. If set to 1, the kernel will report timestamps with "
"``CLOCK_MONOTONIC``. See ``clock_gettime(2)`` for the definition of these "
"clocks."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:708
msgid ""
"Starting from kernel version 2.6.39, the default value for this capability "
"is 1. Starting kernel version 4.15, this capability is always set to 1."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:716
msgid "``DRM_CAP_ASYNC_PAGE_FLIP``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:715
msgid ""
"If set to 1, the driver supports :c:type:`DRM_MODE_PAGE_FLIP_ASYNC` for "
"legacy page-flips."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:723
msgid "``DRM_CAP_CURSOR_WIDTH``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:722
msgid ""
"The ``CURSOR_WIDTH`` and ``CURSOR_HEIGHT`` capabilities return a valid width "
"x height combination for the hardware cursor. The intention is that a "
"hardware agnostic userspace can query a cursor plane size to use."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:726
msgid ""
"Note that the cross-driver contract is to merely return a valid size; "
"drivers are free to attach another meaning on top, eg. i915 returns the "
"maximum plane size."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:735
msgid "``DRM_CAP_CURSOR_HEIGHT``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:734
msgid "See :c:type:`DRM_CAP_CURSOR_WIDTH`."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:741
msgid "``DRM_CAP_ADDFB2_MODIFIERS``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:740
msgid ""
"If set to 1, the driver supports supplying modifiers in the :c:type:"
"`DRM_IOCTL_MODE_ADDFB2` ioctl."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:748
msgid "``DRM_CAP_PAGE_FLIP_TARGET``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:747
msgid ""
"If set to 1, the driver supports the :c:type:"
"`DRM_MODE_PAGE_FLIP_TARGET_ABSOLUTE` and :c:type:"
"`DRM_MODE_PAGE_FLIP_TARGET_RELATIVE` flags in :c:type:"
"`drm_mode_crtc_page_flip_target.flags <drm_mode_crtc_page_flip_target>` for "
"the :c:type:`DRM_IOCTL_MODE_PAGE_FLIP` ioctl."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:757
msgid "``DRM_CAP_CRTC_IN_VBLANK_EVENT``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:756
msgid ""
"If set to 1, the kernel supports reporting the CRTC ID in :c:type:"
"`drm_event_vblank.crtc_id <drm_event_vblank>` for the :c:type:"
"`DRM_EVENT_VBLANK` and :c:type:`DRM_EVENT_FLIP_COMPLETE` events."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:760
msgid "Starting kernel version 4.12, this capability is always set to 1."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:767
msgid "``DRM_CAP_SYNCOBJ``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:766
msgid ""
"If set to 1, the driver supports sync objects. See :ref:`drm_sync_objects`."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:773
msgid "``DRM_CAP_SYNCOBJ_TIMELINE``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:772
msgid ""
"If set to 1, the driver supports timeline operations on sync objects. See :"
"ref:`drm_sync_objects`."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:780
msgid "``DRM_CAP_ATOMIC_ASYNC_PAGE_FLIP``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:779
msgid ""
"If set to 1, the driver supports :c:type:`DRM_MODE_PAGE_FLIP_ASYNC` for "
"atomic commits."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:794
msgid "``DRM_CLIENT_CAP_STEREO_3D``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:793
msgid ""
"If set to 1, the DRM core will expose the stereo 3D capabilities of the "
"monitor by advertising the supported 3D layouts in the flags of struct "
"drm_mode_modeinfo. See ``DRM_MODE_FLAG_3D_*``."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:797
msgid ""
"This capability is always supported for all drivers starting from kernel "
"version 3.13."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:806
msgid "``DRM_CLIENT_CAP_UNIVERSAL_PLANES``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:805
msgid ""
"If set to 1, the DRM core will expose all planes (overlay, primary, and "
"cursor) to userspace."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:808
msgid ""
"This capability has been introduced in kernel version 3.15. Starting from "
"kernel version 3.17, this capability is always supported for all drivers."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:817
msgid "``DRM_CLIENT_CAP_ATOMIC``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:816
msgid ""
"If set to 1, the DRM core will expose atomic properties to userspace. This "
"implicitly enables :c:type:`DRM_CLIENT_CAP_UNIVERSAL_PLANES` and :c:type:"
"`DRM_CLIENT_CAP_ASPECT_RATIO`."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:820
msgid ""
"If the driver doesn't support atomic mode-setting, enabling this capability "
"will fail with -EOPNOTSUPP."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:823
msgid ""
"This capability has been introduced in kernel version 4.0. Starting from "
"kernel version 4.2, this capability is always supported for atomic-capable "
"drivers."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:833
msgid "``DRM_CLIENT_CAP_ASPECT_RATIO``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:832
msgid ""
"If set to 1, the DRM core will provide aspect ratio information in modes. "
"See ``DRM_MODE_FLAG_PIC_AR_*``."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:835
msgid ""
"This capability is always supported for all drivers starting from kernel "
"version 4.18."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:844
msgid "``DRM_CLIENT_CAP_WRITEBACK_CONNECTORS``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:843
msgid ""
"If set to 1, the DRM core will expose special connectors to be used for "
"writing back to memory the scene setup in the commit. The client must "
"enable :c:type:`DRM_CLIENT_CAP_ATOMIC` first."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:847
msgid ""
"This capability is always supported for atomic-capable drivers starting from "
"kernel version 4.19."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:856
msgid "``DRM_CLIENT_CAP_CURSOR_PLANE_HOTSPOT``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:855
msgid ""
"Drivers for para-virtualized hardware (e.g. vmwgfx, qxl, virtio and "
"virtualbox) have additional restrictions for cursor planes (thus making "
"cursor planes on those drivers not truly universal,) e.g. they need cursor "
"planes to act like one would expect from a mouse cursor and have correctly "
"set hotspot properties. If this client cap is not set the DRM core will hide "
"cursor plane on those virtualized drivers because not setting it implies "
"that the client is not capable of dealing with those extra restictions. "
"Clients which do set cursor hotspot and treat the cursor plane like a mouse "
"cursor should set this property. The client must enable :c:type:"
"`DRM_CLIENT_CAP_ATOMIC` first."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:867
msgid ""
"Setting this property on drivers which do not special case cursor planes (i."
"e. non-virtualized drivers) will return EOPNOTSUPP, which can be used by "
"userspace to gauge requirements of the hardware/drivers they're running on."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:872
msgid ""
"This capability is always supported for atomic-capable virtualized drivers "
"starting from kernel version 6.6."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:974
#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1063
msgid "``handle``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:975
msgid "syncobj handle."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:976
msgid ""
"Zero to wait for the point to be signalled, or :c:type:"
"`DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE` to wait for a fence to be available "
"for the point."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:978
msgid "``point``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:979
msgid "syncobj timeline point (set to zero for binary syncobjs)."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:979
#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1263
msgid "``fd``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:980
msgid "Existing eventfd to sent events to."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:980
#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:514
#: include/uapi/drm/drm_mode.h:1283 include/uapi/drm/drm_mode.h:1310
#: include/uapi/drm/drm_mode.h:1351
msgid "``pad``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:981
#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1352
msgid "Must be zero."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:981
msgid ""
"Register an eventfd to be signalled by a syncobj. The eventfd counter will "
"be incremented by one."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1066
msgid "``DRM_IOCTL_GEM_CLOSE``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1064
msgid "Close a GEM handle."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1065
msgid ""
"GEM handles are not reference-counted by the kernel. User-space is "
"responsible for managing their lifetime. For example, if user-space imports "
"the same memory object twice on the same DRM file description, the same GEM "
"handle is returned by both imports, and user-space needs to ensure :c:type:"
"`DRM_IOCTL_GEM_CLOSE` is performed once only. The same situation can happen "
"when a memory object is allocated, then exported and imported again on the "
"same DRM file description. The :c:type:`DRM_IOCTL_MODE_GETFB2` IOCTL is an "
"exception and always returns fresh new GEM handles even if an existing GEM "
"handle already refers to the same memory object before the IOCTL is "
"performed."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1119
msgid "``DRM_IOCTL_PRIME_HANDLE_TO_FD``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1117
msgid "Convert a GEM handle to a DMA-BUF FD."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1118
msgid ""
"User-space sets :c:type:`drm_prime_handle.handle <drm_prime_handle>` with "
"the GEM handle to export and :c:type:`drm_prime_handle.flags "
"<drm_prime_handle>`, and gets back a DMA-BUF file descriptor in :c:type:"
"`drm_prime_handle.fd <drm_prime_handle>`."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1122
msgid ""
"The export can fail for any driver-specific reason, e.g. because export is "
"not supported for this specific GEM handle (but might be for others)."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1125
msgid ""
"Support for exporting DMA-BUFs is advertised via :c:type:"
"`DRM_PRIME_CAP_EXPORT`."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1132
msgid "``DRM_IOCTL_PRIME_FD_TO_HANDLE``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1130
msgid "Convert a DMA-BUF FD to a GEM handle."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1131
msgid ""
"User-space sets :c:type:`drm_prime_handle.fd <drm_prime_handle>` with a DMA-"
"BUF file descriptor to import, and gets back a GEM handle in :c:type:"
"`drm_prime_handle.handle <drm_prime_handle>`. :c:type:`drm_prime_handle."
"flags <drm_prime_handle>` is unused."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1135
msgid ""
"If an existing GEM handle refers to the memory object backing the DMA-BUF, "
"that GEM handle is returned. Therefore user-space which needs to handle "
"arbitrary DMA-BUFs must have a user-space lookup data structure to manually "
"reference-count duplicated GEM handles. For more information see :c:type:"
"`DRM_IOCTL_GEM_CLOSE`."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1141
msgid ""
"The import can fail for any driver-specific reason, e.g. because import is "
"only supported for DMA-BUFs allocated on this DRM device."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1144
msgid ""
"Support for importing DMA-BUFs is advertised via :c:type:"
"`DRM_PRIME_CAP_IMPORT`."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1187
msgid "``DRM_IOCTL_MODE_RMFB``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1185
msgid "Remove a framebuffer."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1186
msgid ""
"This removes a framebuffer previously added via ADDFB/ADDFB2. The IOCTL "
"argument is a framebuffer object ID."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1189
msgid ""
"Warning: removing a framebuffer currently in-use on an enabled plane will "
"disable that plane. The CRTC the plane is linked to may also be disabled "
"(depending on driver capabilities)."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1201
msgid "``DRM_IOCTL_MODE_CREATE_DUMB``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1199
msgid "Create a new dumb buffer object."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1200
msgid ""
"KMS dumb buffers provide a very primitive way to allocate a buffer object "
"suitable for scanout and map it for software rendering. KMS dumb buffers are "
"not suitable for hardware-accelerated rendering nor video decoding. KMS dumb "
"buffers are not suitable to be displayed on any other device than the KMS "
"device where they were allocated from. Also see :ref:"
"`kms_dumb_buffer_objects`."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1207
msgid "The IOCTL argument is a struct drm_mode_create_dumb."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1209
msgid ""
"User-space is expected to create a KMS dumb buffer via this IOCTL, then add "
"it as a KMS framebuffer via :c:type:`DRM_IOCTL_MODE_ADDFB` and map it via :c:"
"type:`DRM_IOCTL_MODE_MAP_DUMB`."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1213
msgid ""
":c:type:`DRM_CAP_DUMB_BUFFER` indicates whether this IOCTL is supported. :c:"
"type:`DRM_CAP_DUMB_PREFERRED_DEPTH` and :c:type:`DRM_CAP_DUMB_PREFER_SHADOW` "
"indicate driver preferences for dumb buffers."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1253
msgid "``DRM_IOCTL_MODE_GETFB2``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1251
msgid "Get framebuffer metadata."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1252
msgid ""
"This queries metadata about a framebuffer. User-space fills :c:type:"
"`drm_mode_fb_cmd2.fb_id <drm_mode_fb_cmd2>` as the input, and the kernels "
"fills the rest of the struct as the output."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1256
msgid ""
"If the client is DRM master or has :c:type:`CAP_SYS_ADMIN`, :c:type:"
"`drm_mode_fb_cmd2.handles <drm_mode_fb_cmd2>` will be filled with GEM buffer "
"handles. Fresh new GEM handles are always returned, even if another GEM "
"handle referring to the same memory object already exists on the DRM file "
"description. The caller is responsible for removing the new handles, e.g. "
"via the :c:type:`DRM_IOCTL_GEM_CLOSE` IOCTL. The same new handle will be "
"returned for multiple planes in case they use the same memory object. Planes "
"are valid until one has a zero handle -- this can be used to compute the "
"number of planes."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1265
msgid ""
"Otherwise, :c:type:`drm_mode_fb_cmd2.handles <drm_mode_fb_cmd2>` will be "
"zeroed and planes are valid until one has a zero :c:type:`drm_mode_fb_cmd2."
"pitches <drm_mode_fb_cmd2>`."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1268
msgid ""
"If the framebuffer has a format modifier, :c:type:`DRM_MODE_FB_MODIFIERS` "
"will be set in :c:type:`drm_mode_fb_cmd2.flags <drm_mode_fb_cmd2>` and :c:"
"type:`drm_mode_fb_cmd2.modifier <drm_mode_fb_cmd2>` will contain the "
"modifier. Otherwise, user-space must ignore :c:type:`drm_mode_fb_cmd2."
"modifier <drm_mode_fb_cmd2>`."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1272
msgid ""
"To obtain DMA-BUF FDs for each plane without leaking GEM handles, user-space "
"can export each handle via :c:type:`DRM_IOCTL_PRIME_HANDLE_TO_FD`, then "
"immediately close each unique handle via :c:type:`DRM_IOCTL_GEM_CLOSE`, "
"making sure to not double-close handles which are specified multiple times "
"in the array."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1285
msgid "``DRM_IOCTL_MODE_CLOSEFB``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1283
msgid "Close a framebuffer."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1284
msgid ""
"This closes a framebuffer previously added via ADDFB/ADDFB2. The IOCTL "
"argument is a framebuffer object ID."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1287
msgid ""
"This IOCTL is similar to :c:type:`DRM_IOCTL_MODE_RMFB`, except it doesn't "
"disable planes and CRTCs. As long as the framebuffer is used by a plane, "
"it's kept alive. When the plane no longer uses the framebuffer (because the "
"framebuffer is replaced with another one, or the plane is disabled), the "
"framebuffer is cleaned up."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1293
msgid ""
"This is useful to implement flicker-free transitions between two processes."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1295
msgid ""
"Depending on the threat model, user-space may want to ensure that the "
"framebuffer doesn't expose any sensitive user information: closed "
"framebuffers attached to a plane can be read back by the next DRM master."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1305
msgid "``DRM_IOCTL_SET_CLIENT_NAME``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1303
msgid "Attach a name to a drm_file"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1304
msgid ""
"Having a name allows for easier tracking and debugging. The length of the "
"name (without null ending char) must be <= DRM_CLIENT_NAME_MAX_LEN. The call "
"will fail if the name contains whitespaces or non-printable chars."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1324
msgid "Header for DRM events"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1325
#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:236
msgid "``type``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1326
msgid "event type."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1326
#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1222
msgid "``length``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1327
msgid "total number of payload bytes (including header)."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1327
msgid ""
"This struct is a header for events written back to user-space on the DRM FD. "
"A read on the DRM FD will always only return complete events: e.g. if the "
"read buffer is 100 bytes large and there are two 64 byte events pending, "
"only one will be returned."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1332
msgid ""
"Event types 0 - 0x7fffffff are generic DRM events, 0x80000000 and up are "
"chipset specific. Generic DRM events include :c:type:`DRM_EVENT_VBLANK`, :c:"
"type:`DRM_EVENT_FLIP_COMPLETE` and :c:type:`DRM_EVENT_CRTC_SEQUENCE`."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1345
msgid "``DRM_EVENT_VBLANK``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1343
msgid "vertical blanking event"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1344
msgid ""
"This event is sent in response to :c:type:`DRM_IOCTL_WAIT_VBLANK` with the :"
"c:type:`_DRM_VBLANK_EVENT` flag set."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1347
#: include/uapi/drm/drm.h:1356
msgid "The event payload is a struct drm_event_vblank."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1354
msgid "``DRM_EVENT_FLIP_COMPLETE``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1352
msgid "page-flip completion event"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1353
msgid ""
"This event is sent in response to an atomic commit or legacy page-flip with "
"the :c:type:`DRM_MODE_PAGE_FLIP_EVENT` flag set."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1363
msgid "``DRM_EVENT_CRTC_SEQUENCE``"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1361
msgid "CRTC sequence event"
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1362
msgid ""
"This event is sent in response to :c:type:`DRM_IOCTL_CRTC_QUEUE_SEQUENCE`."
msgstr ""

#: ../../../gpu/drm-uapi:701: include/uapi/drm/drm.h:1364
msgid "The event payload is a struct drm_event_crtc_sequence."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:222
msgid "Display mode information."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:223
msgid "``clock``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:224
msgid "pixel clock in kHz"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:224
msgid "``hdisplay``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:225
msgid "horizontal display size"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:225
msgid "``hsync_start``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:226
msgid "horizontal sync start"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:226
msgid "``hsync_end``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:227
msgid "horizontal sync end"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:227
msgid "``htotal``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:228
msgid "horizontal total size"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:228
msgid "``hskew``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:229
msgid "horizontal skew"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:229
msgid "``vdisplay``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:230
msgid "vertical display size"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:230
msgid "``vsync_start``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:231
msgid "vertical sync start"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:231
msgid "``vsync_end``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:232
msgid "vertical sync end"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:232
msgid "``vtotal``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:233
msgid "vertical total size"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:233
msgid "``vscan``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:234
msgid "vertical scan"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:234
msgid "``vrefresh``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:235
msgid "approximate vertical refresh rate in Hz"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:236
msgid "bitmask of misc. flags, see DRM_MODE_FLAG_* defines"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:237
msgid "bitmask of type flags, see DRM_MODE_TYPE_* defines"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:238
msgid "string describing the mode resolution"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:238
msgid ""
"This is the user-space API display mode information structure. For the "
"kernel version see struct drm_display_mode."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:316
msgid "Get plane metadata."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:331
msgid "``plane_id``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:332
msgid ""
"Object ID of the plane whose information should be retrieved. Set by caller."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:336
msgid "``crtc_id``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:337
msgid "Object ID of the current CRTC."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:338
#: include/uapi/drm/drm_mode.h:704 include/uapi/drm/drm_mode.h:1350
msgid "``fb_id``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:339
msgid "Object ID of the current fb."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:342
msgid "``possible_crtcs``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:343
msgid ""
"Bitmask of CRTC's compatible with the plane. CRTC's are created and they "
"receive an index, which corresponds to their position in the bitmask. Bit N "
"corresponds to :ref:`CRTC index<crtc_index>` N."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:348
msgid "``gamma_size``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:349
msgid "Never used."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:351
msgid "``count_format_types``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:352
msgid "Number of formats."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:354
msgid "``format_type_ptr``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:355
msgid ""
"Pointer to ``__u32`` array of formats that are supported by the plane. These "
"formats do not require modifiers."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:317
msgid ""
"Userspace can perform a GETPLANE ioctl to retrieve information about a plane."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:320
msgid ""
"To retrieve the number of formats supported, set **count_format_types** to "
"zero and call the ioctl. **count_format_types** will be updated with the "
"value."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:323
msgid ""
"To retrieve these formats, allocate an array with the memory needed to store "
"**count_format_types** formats. Point **format_type_ptr** to this array and "
"call the ioctl again (with **count_format_types** still set to the value "
"returned in the first ioctl call)."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:426
msgid "Get connector metadata."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:459
msgid "``encoders_ptr``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:460
msgid "Pointer to ``__u32`` array of object IDs."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:461
msgid "``modes_ptr``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:462
msgid "Pointer to struct drm_mode_modeinfo array."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:463
msgid "``props_ptr``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:464
msgid "Pointer to ``__u32`` array of property IDs."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:465
msgid "``prop_values_ptr``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:466
msgid "Pointer to ``__u64`` array of property values."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:468
msgid "``count_modes``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:469
msgid "Number of modes."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:470
msgid "``count_props``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:471
msgid "Number of properties."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:472
msgid "``count_encoders``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:473
msgid "Number of encoders."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:475
msgid "``encoder_id``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:476
msgid "Object ID of the current encoder."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:477
msgid "``connector_id``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:478
msgid "Object ID of the connector."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:480
msgid "``connector_type``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:481
msgid "Type of the connector."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:483
msgid "See DRM_MODE_CONNECTOR_* defines."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:486
msgid "``connector_type_id``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:487
msgid "Type-specific connector number."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:489
msgid ""
"This is not an object ID. This is a per-type connector number. Each (type, "
"type_id) combination is unique across all connectors of a DRM device."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:493
msgid ""
"The (type, type_id) combination is not a stable identifier: the type_id can "
"change depending on the driver probe order."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:498
msgid "``connection``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:499
msgid "Status of the connector."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:501
msgid "See enum drm_connector_status."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:503
msgid "``mm_width``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:504
msgid "Width of the connected sink in millimeters."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:505
msgid "``mm_height``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:506
msgid "Height of the connected sink in millimeters."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:508
msgid "``subpixel``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:509
msgid "Subpixel order of the connected sink."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:511
msgid "See enum subpixel_order."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:515
msgid "Padding, must be zero."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:427
msgid ""
"User-space can perform a GETCONNECTOR ioctl to retrieve information about a "
"connector. User-space is expected to retrieve encoders, modes and properties "
"by performing this ioctl at least twice: the first time to retrieve the "
"number of elements, the second time to retrieve the elements themselves."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:432
msgid ""
"To retrieve the number of elements, set **count_props** and "
"**count_encoders** to zero, set **count_modes** to 1, and set **modes_ptr** "
"to a temporary struct drm_mode_modeinfo element."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:436
msgid ""
"To retrieve the elements, allocate arrays for **encoders_ptr**, "
"**modes_ptr**, **props_ptr** and **prop_values_ptr**, then set "
"**count_modes**, **count_props** and **count_encoders** to their capacity."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:440
msgid ""
"Performing the ioctl only twice may be racy: the number of elements may have "
"changed with a hotplug event in-between the two ioctls. User-space is "
"expected to retry the last ioctl until the number of elements stabilizes. "
"The kernel won't fill any array which doesn't have the expected length."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:445
msgid "**Force-probing a connector**"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:447
msgid ""
"If the **count_modes** field is set to zero and the DRM client is the "
"current DRM master, the kernel will perform a forced probe on the connector "
"to refresh the connector status, modes and EDID. A forced-probe can be slow, "
"might cause flickering and the ioctl will block."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:452
msgid ""
"User-space needs to force-probe connectors to ensure their metadata is up-to-"
"date at startup and after receiving a hot-plug event. User-space may perform "
"a forced-probe when the user explicitly requests it. User-space shouldn't "
"perform a forced-probe in other situations."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:548
msgid "Description for an enum/bitfield entry."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:549
msgid "``value``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:550
msgid "numeric value for this enum entry."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:551
msgid "symbolic name for this enum entry."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:551
msgid "See struct drm_property_enum for details."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:560
msgid "Get property metadata."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:591
msgid "``values_ptr``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:592
msgid "Pointer to a ``__u64`` array."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:593
msgid "``enum_blob_ptr``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:594
msgid "Pointer to a struct drm_mode_property_enum array."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:597
msgid "``prop_id``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:598
msgid "Object ID of the property which should be retrieved. Set by the caller."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:603
msgid ""
"``DRM_MODE_PROP_*`` bitfield. See :c:type:`drm_property.flags "
"<drm_property>` for a definition of the flags."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:608
msgid ""
"Symbolic property name. User-space should use this field to recognize "
"properties."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:612
msgid "``count_values``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:613
msgid "Number of elements in **values_ptr**."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:614
msgid "``count_enum_blobs``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:615
msgid "Number of elements in **enum_blob_ptr**."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:561
msgid ""
"User-space can perform a GETPROPERTY ioctl to retrieve information about a "
"property. The same property may be attached to multiple objects, see "
"\"Modeset Base Object Abstraction\"."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:565
msgid ""
"The meaning of the **values_ptr** field changes depending on the property "
"type. See :c:type:`drm_property.flags <drm_property>` for more details."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:568
msgid ""
"The **enum_blob_ptr** and **count_enum_blobs** fields are only meaningful "
"when the property has the type :c:type:`DRM_MODE_PROP_ENUM` or :c:type:"
"`DRM_MODE_PROP_BITMASK`. For backwards compatibility, the kernel will always "
"set **count_enum_blobs** to zero when the property has the type :c:type:"
"`DRM_MODE_PROP_BLOB`. User-space must ignore these two fields if the "
"property has a different type."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:574
msgid ""
"User-space is expected to retrieve values and enums by performing this ioctl "
"at least twice: the first time to retrieve the number of elements, the "
"second time to retrieve the elements themselves."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:578
msgid ""
"To retrieve the number of elements, set **count_values** and "
"**count_enum_blobs** to zero, then call the ioctl. **count_values** will be "
"updated with the number of elements. If the property has the type :c:type:"
"`DRM_MODE_PROP_ENUM` or :c:type:`DRM_MODE_PROP_BITMASK`, "
"**count_enum_blobs** will be updated as well."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:583
msgid ""
"To retrieve the elements themselves, allocate an array for **values_ptr** "
"and set **count_values** to its capacity. If the property has the type :c:"
"type:`DRM_MODE_PROP_ENUM` or :c:type:`DRM_MODE_PROP_BITMASK`, allocate an "
"array for **enum_blob_ptr** and set **count_enum_blobs** to its capacity. "
"Calling the ioctl again will fill the arrays."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:670
msgid "Frame-buffer metadata."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:705
msgid "Object ID of the frame-buffer."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:706
#: include/uapi/drm/drm_mode.h:862 include/uapi/drm/drm_mode.h:1060
msgid "``width``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:707
msgid "Width of the frame-buffer."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:708
#: include/uapi/drm/drm_mode.h:863 include/uapi/drm/drm_mode.h:1059
msgid "``height``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:709
msgid "Height of the frame-buffer."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:711
msgid "``pixel_format``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:712
msgid "FourCC format code, see ``DRM_FORMAT_*`` constants in ``drm_fourcc.h``."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:717
msgid ""
"Frame-buffer flags (see :c:type:`DRM_MODE_FB_INTERLACED` and :c:type:"
"`DRM_MODE_FB_MODIFIERS`)."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:722
msgid "``handles``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:723
msgid ""
"GEM buffer handle, one per plane. Set to 0 if the plane is unused. The same "
"handle can be used for multiple planes."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:726
msgid "``pitches``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:727
msgid "Pitch (aka. stride) in bytes, one per plane."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:728
msgid "``offsets``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:729
msgid "Offset into the buffer in bytes, one per plane."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:731
msgid "``modifier``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:732
msgid ""
"Format modifier, one per plane. See ``DRM_FORMAT_MOD_*`` constants in "
"``drm_fourcc.h``. All planes must use the same modifier. Ignored unless :c:"
"type:`DRM_MODE_FB_MODIFIERS` is set in **flags**."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:671
msgid "This struct holds frame-buffer metadata. There are two ways to use it:"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:673
msgid ""
"User-space can fill this struct and perform a :c:type:"
"`DRM_IOCTL_MODE_ADDFB2` ioctl to register a new frame-buffer. The new frame-"
"buffer object ID will be set by the kernel in **fb_id**."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:676
msgid ""
"User-space can set **fb_id** and perform a :c:type:`DRM_IOCTL_MODE_GETFB2` "
"ioctl to fetch metadata about an existing frame-buffer."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:679
msgid ""
"In case of planar formats, this struct allows up to 4 buffer objects with "
"offsets and pitches per plane. The pitch and offset order are dictated by "
"the format FourCC as defined by ``drm_fourcc.h``, e.g. NV12 is described as:"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:683
msgid ""
"YUV 4:2:0 image with a plane of 8-bit Y samples followed by an interleaved U/"
"V plane containing 8-bit 2x2 subsampled colour difference samples."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:687
msgid ""
"So it would consist of a Y plane at ``offsets[0]`` and a UV plane at "
"``offsets[1]``."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:690
msgid ""
"To accommodate tiled, compressed, etc formats, a modifier can be specified. "
"For more information see the \"Format Modifiers\" section. Note that even "
"though it looks like we have a modifier per-plane, we in fact do not. The "
"modifier for each plane must be identical. Thus all combinations of "
"different data layouts for multi-plane formats must be enumerated as "
"separate modifiers."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:697
msgid ""
"All of the entries in **handles**, **pitches**, **offsets** and **modifier** "
"must be zero when unused. Warning, for **offsets** and **modifier** zero "
"can't be used to figure out whether the entry is used or not since it's a "
"valid value (a zero offset is common, and a zero modifier is :c:type:"
"`DRM_FORMAT_MOD_LINEAR`)."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:861
msgid "Plane size hints"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:863
msgid "The width of the plane in pixel"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:864
msgid "The height of the plane in pixel"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:864
msgid ""
"The plane SIZE_HINTS property blob contains an array of struct "
"drm_plane_size_hint."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:874
msgid "HDR Metadata Infoframe Data."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:884
msgid "``eotf``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:885
msgid "Electro-Optical Transfer Function (EOTF) used in the stream."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:889
#: include/uapi/drm/drm_mode.h:948
msgid "``metadata_type``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:890
#: include/uapi/drm/drm_mode.h:949
msgid "Static_Metadata_Descriptor_ID."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:893
msgid "``display_primaries``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:894
msgid ""
"Color Primaries of the Data. These are coded as unsigned 16-bit values in "
"units of 0.00002, where 0x0000 represents zero and 0xC350 represents 1.0000. "
"**display_primaries.x**: X coordinate of color primary. **display_primaries."
"y**: Y coordinate of color primary."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:904
msgid "``white_point``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:905
msgid ""
"White Point of Colorspace Data. These are coded as unsigned 16-bit values in "
"units of 0.00002, where 0x0000 represents zero and 0xC350 represents 1.0000. "
"**white_point.x**: X coordinate of whitepoint of color primary. "
"**white_point.y**: Y coordinate of whitepoint of color primary."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:915
msgid "``max_display_mastering_luminance``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:916
msgid ""
"Max Mastering Display Luminance. This value is coded as an unsigned 16-bit "
"value in units of 1 cd/m2, where 0x0001 represents 1 cd/m2 and 0xFFFF "
"represents 65535 cd/m2."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:921
msgid "``min_display_mastering_luminance``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:922
msgid ""
"Min Mastering Display Luminance. This value is coded as an unsigned 16-bit "
"value in units of 0.0001 cd/m2, where 0x0001 represents 0.0001 cd/m2 and "
"0xFFFF represents 6.5535 cd/m2."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:928
msgid "``max_cll``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:929
msgid ""
"Max Content Light Level. This value is coded as an unsigned 16-bit value in "
"units of 1 cd/m2, where 0x0001 represents 1 cd/m2 and 0xFFFF represents "
"65535 cd/m2."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:934
msgid "``max_fall``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:935
msgid ""
"Max Frame Average Light Level. This value is coded as an unsigned 16-bit "
"value in units of 1 cd/m2, where 0x0001 represents 1 cd/m2 and 0xFFFF "
"represents 65535 cd/m2."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:875
msgid ""
"HDR Metadata Infoframe as per CTA 861.G spec. This is expected to match "
"exactly with the spec."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:878
msgid ""
"Userspace is expected to pass the metadata information as per the format "
"described in this structure."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:942
msgid "HDR output metadata"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1
msgid "``{unnamed_union}``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:2
msgid "anonymous"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:952
msgid "``hdmi_metadata_type1``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:953
msgid "HDR Metadata Infoframe."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:943
msgid "Metadata Information to be passed from userspace"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:962
msgid "``DRM_MODE_PAGE_FLIP_EVENT``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:961
msgid ""
"Request that the kernel sends back a vblank event (see struct "
"drm_event_vblank) with the :c:type:`DRM_EVENT_FLIP_COMPLETE` type when the "
"page-flip is done."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:970
msgid "``DRM_MODE_PAGE_FLIP_ASYNC``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:969
msgid ""
"Request that the page-flip is performed as soon as possible, ie. with no "
"delay due to waiting for vblank. This may cause tearing to be visible on the "
"screen."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:973
msgid ""
"When used with atomic uAPI, the driver will return an error if the hardware "
"doesn't support performing an asynchronous page-flip for this update. User-"
"space should handle this, e.g. by falling back to a regular page-flip."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:977
msgid ""
"Note, some hardware might need to perform one last synchronous page-flip "
"before being able to switch to asynchronous page-flips. As an exception, the "
"driver will return success even though that first page-flip is not "
"asynchronous."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:991
msgid "``DRM_MODE_PAGE_FLIP_FLAGS``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:990
msgid ""
"Bitmask of flags suitable for :c:type:`drm_mode_crtc_page_flip_target.flags "
"<drm_mode_crtc_page_flip_target>`."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1058
msgid "Create a KMS dumb buffer for scanout."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1060
msgid "buffer height in pixels"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1061
msgid "buffer width in pixels"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1061
msgid "``bpp``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1062
msgid "bits per pixel"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1063
msgid "must be zero"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1064
msgid "buffer object handle"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1064
msgid "``pitch``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1065
msgid "number of bytes between two consecutive lines"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1065
msgid "``size``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1066
msgid "size of the whole buffer in bytes"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1066
msgid ""
"User-space fills **height**, **width**, **bpp** and **flags**. If the IOCTL "
"succeeds, the kernel fills **handle**, **pitch** and **size**."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1101
msgid "``DRM_MODE_ATOMIC_TEST_ONLY``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1100
msgid ""
"Do not apply the atomic commit, instead check whether the hardware supports "
"this configuration."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1103
msgid ""
"See :c:type:`drm_mode_config_funcs.atomic_check <drm_mode_config_funcs>` for "
"more details on test-only commits."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1111
msgid "``DRM_MODE_ATOMIC_NONBLOCK``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1110
msgid ""
"Do not block while applying the atomic commit. The :c:type:"
"`DRM_IOCTL_MODE_ATOMIC` IOCTL returns immediately instead of waiting for the "
"changes to be applied in hardware. Note, the driver will still check that "
"the update can be applied before retuning."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1120
msgid "``DRM_MODE_ATOMIC_ALLOW_MODESET``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1119
msgid ""
"Allow the update to result in temporary or transient visible artifacts while "
"the update is being applied. Applying the update may also take significantly "
"more time than a page flip. All visual artifacts will disappear by the time "
"the update is completed, as signalled through the vblank event's timestamp "
"(see struct drm_event_vblank)."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1125
msgid ""
"This flag must be set when the KMS update might cause visible artifacts. "
"Without this flag such KMS update will return a EINVAL error. What kind of "
"update may cause visible artifacts depends on the driver and the hardware. "
"User-space that needs to know beforehand if an update might cause visible "
"artifacts can use :c:type:`DRM_MODE_ATOMIC_TEST_ONLY` without :c:type:"
"`DRM_MODE_ATOMIC_ALLOW_MODESET` to see if it fails."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1132
msgid ""
"To the best of the driver's knowledge, visual artifacts are guaranteed to "
"not appear when this flag is not set. Some sinks might display visual "
"artifacts outside of the driver's control."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1142
msgid "``DRM_MODE_ATOMIC_FLAGS``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1141
msgid ""
"Bitfield of flags accepted by the :c:type:`DRM_IOCTL_MODE_ATOMIC` IOCTL in :"
"c:type:`drm_mode_atomic.flags <drm_mode_atomic>`."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1214
msgid "Create New blob property"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1221
msgid "Pointer to data to copy."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1223
msgid "Length of data to copy."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1224
#: include/uapi/drm/drm_mode.h:1230
msgid "``blob_id``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1225
msgid "Return: new property ID."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1215
msgid ""
"Create a new 'blob' data property, copying length bytes from data pointer, "
"and returning new blob ID."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1229
msgid "Destroy user blob"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1231
msgid "blob_id to destroy"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1231
msgid "Destroy a user-created blob property."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1233
msgid ""
"User-space can release blobs as soon as they do not need to refer to them by "
"their blob object ID.  For instance, if you are using a MODE_ID blob in an "
"atomic commit and you will not make another commit re-using the same ID, you "
"can destroy the blob as soon as the commit has been issued, without waiting "
"for it to complete."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1245
msgid "Create lease"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1254
msgid "``object_ids``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1255
msgid "Pointer to array of object ids (__u32)"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1256
msgid "``object_count``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1257
msgid "Number of object ids"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1259
msgid "flags for new FD (O_CLOEXEC, etc)"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1262
msgid "Return: unique identifier for lessee."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1264
msgid "Return: file descriptor to new drm_master file"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1246
msgid "Lease mode resources, creating another drm_master."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1248
msgid ""
"The **object_ids** array must reference at least one CRTC, one connector and "
"one plane if :c:type:`DRM_CLIENT_CAP_UNIVERSAL_PLANES` is enabled. "
"Alternatively, the lease can be completely empty."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1268
msgid "List lessees"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1274
msgid "``count_lessees``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1275
msgid "Number of lessees."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1277
#: include/uapi/drm/drm_mode.h:1304
msgid ""
"On input, provides length of the array. On output, provides total number. No "
"more than the input number will be written back, so two calls can be used to "
"get the size and then the data."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1284
#: include/uapi/drm/drm_mode.h:1311
msgid "Padding."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1287
msgid "``lessees_ptr``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1288
msgid "Pointer to lessees."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1290
msgid "Pointer to __u64 array of lessee ids"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1269
msgid "List lesses from a drm_master."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1295
msgid "Get Lease"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1301
msgid "``count_objects``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1302
msgid "Number of leased objects."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1314
msgid "``objects_ptr``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1315
msgid "Pointer to objects."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1317
msgid "Pointer to __u32 array of object ids."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1296
msgid "Get leased objects."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1322
msgid "Revoke lease"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1326
msgid "Unique ID of lessee"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1330
msgid "Two dimensional rectangle."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1331
msgid "``x1``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1332
msgid "Horizontal starting coordinate (inclusive)."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1332
msgid "``y1``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1333
msgid "Vertical starting coordinate (inclusive)."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1333
msgid "``x2``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1334
msgid "Horizontal ending coordinate (exclusive)."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1334
msgid "``y2``"
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1335
msgid "Vertical ending coordinate (exclusive)."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1335
msgid ""
"With drm subsystem using struct drm_rect to manage rectangular area this "
"export it to user-space."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1338
msgid "Currently used by drm_mode_atomic blob property FB_DAMAGE_CLIPS."
msgstr ""

#: ../../../gpu/drm-uapi:704: include/uapi/drm/drm_mode.h:1351
msgid "Framebuffer ID."
msgstr ""

#: ../../../gpu/drm-uapi.rst:709
msgid "dma-buf interoperability"
msgstr ""

#: ../../../gpu/drm-uapi.rst:711
msgid ""
"Please see Documentation/userspace-api/dma-buf-alloc-exchange.rst for "
"information on how dma-buf is integrated and exposed within DRM."
msgstr ""

#: ../../../gpu/drm-uapi.rst:716
msgid "Trace events"
msgstr ""

#: ../../../gpu/drm-uapi.rst:718
msgid ""
"See Documentation/trace/tracepoints.rst for information about using Linux "
"Kernel Tracepoints. In the DRM subsystem, some events are considered stable "
"uAPI to avoid breaking tools (e.g.: GPUVis, umr) relying on them. Stable "
"means that fields cannot be removed, nor their formatting updated. Adding "
"new fields is possible, under the normal uAPI requirements."
msgstr ""

#: ../../../gpu/drm-uapi.rst:726
msgid "Stable uAPI events"
msgstr ""

#: ../../../gpu/drm-uapi.rst:728
msgid "From ``drivers/gpu/drm/scheduler/gpu_scheduler_trace.h``"
msgstr ""

#: ../../../gpu/drm-uapi:730:
#: drivers/gpu/drm/scheduler/gpu_scheduler_trace.h:36
msgid ""
"``drm_sched_job_queue``, ``drm_sched_job_run``, ``drm_sched_job_add_dep``, "
"``drm_sched_job_done`` and ``drm_sched_job_unschedulable`` are considered "
"stable uAPI."
msgstr ""

#: ../../../gpu/drm-uapi:730:
#: drivers/gpu/drm/scheduler/gpu_scheduler_trace.h:40
msgid "Common trace events attributes:"
msgstr ""

#: ../../../gpu/drm-uapi:730:
#: drivers/gpu/drm/scheduler/gpu_scheduler_trace.h:42
msgid "``dev``   - the dev_name() of the device running the job."
msgstr ""

#: ../../../gpu/drm-uapi:730:
#: drivers/gpu/drm/scheduler/gpu_scheduler_trace.h:44
msgid ""
"``ring``  - the hardware ring running the job. Together with ``dev`` it "
"uniquely identifies where the job is going to be executed."
msgstr ""

#: ../../../gpu/drm-uapi:730:
#: drivers/gpu/drm/scheduler/gpu_scheduler_trace.h:47
msgid ""
"``fence`` - the :c:type:`struct dma_fence <dma_fence>`.context and the :c:"
"type:`struct dma_fence <dma_fence>`.seqno of :c:type:`struct drm_sched_fence "
"<drm_sched_fence>`.finished"
msgstr ""

#: ../../../gpu/drm-uapi:730:
#: drivers/gpu/drm/scheduler/gpu_scheduler_trace.h:50
msgid ""
"All the events depends on drm_sched_job_arm() having been called already for "
"the job because they use :c:type:`struct drm_sched_job <drm_sched_job>`."
"sched or :c:type:`struct drm_sched_job <drm_sched_job>`.s_fence."
msgstr ""
