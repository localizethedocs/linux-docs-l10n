# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-06 15:47+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../gpu/i915.rst:3
msgid "drm/i915 Intel GFX Driver"
msgstr ""

#: ../../../gpu/i915.rst:5
msgid ""
"The drm/i915 driver supports all (with the exception of some very early "
"models) integrated GFX chipsets with both Intel display and rendering "
"blocks. This excludes a set of SoC platforms with an SGX rendering unit, "
"those have basic support through the gma500 drm driver."
msgstr ""

#: ../../../gpu/i915.rst:11
msgid "Core Driver Infrastructure"
msgstr ""

#: ../../../gpu/i915.rst:13
msgid ""
"This section covers core driver infrastructure used by both the display and "
"the GEM parts of the driver."
msgstr ""

#: ../../../gpu/i915.rst:17
msgid "Runtime Power Management"
msgstr ""

#: ../../../gpu/i915:19: drivers/gpu/drm/i915/intel_runtime_pm.c:37
msgid ""
"The i915 driver supports dynamic enabling and disabling of entire hardware "
"blocks at runtime. This is especially important on the display side where "
"software is supposed to control many power gates manually on recent "
"hardware, since on the GT side a lot of the power management is done by the "
"hardware. But even there some manual control at the device level is required."
msgstr ""

#: ../../../gpu/i915:19: drivers/gpu/drm/i915/intel_runtime_pm.c:43
msgid ""
"Since i915 supports a diverse set of platforms with a unified codebase and "
"hardware engineers just love to shuffle functionality around between power "
"domains there's a sizeable amount of indirection required. This file "
"provides generic functions to the driver for grabbing and releasing "
"references for abstract power domains. It then maps those to the actual "
"power wells present for a given platform."
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:181
msgid "grab a raw runtime pm reference"
msgstr ""

#: ../../../gpu/i915:100:
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:282
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:311
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:360
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:392
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:412
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:440
#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:108
#: drivers/gpu/drm/i915/display/intel_plane.c:121
#: drivers/gpu/drm/i915/display/intel_plane.c:155
#: drivers/gpu/drm/i915/display/intel_plane.c:1164
#: drivers/gpu/drm/i915/display/intel_plane.c:1254 ../../../gpu/i915:141:
#: drivers/gpu/drm/i915/display/intel_hotplug.c:94
#: drivers/gpu/drm/i915/display/intel_hotplug.c:128
#: drivers/gpu/drm/i915/display/intel_hotplug.c:448
#: drivers/gpu/drm/i915/display/intel_hotplug.c:576
#: drivers/gpu/drm/i915/display/intel_hotplug.c:709
#: drivers/gpu/drm/i915/display/intel_hotplug.c:854
#: drivers/gpu/drm/i915/display/intel_hotplug.c:889
#: drivers/gpu/drm/i915/display/intel_hotplug.c:1055
#: drivers/gpu/drm/i915/display/intel_hotplug.c:1099
#: drivers/gpu/drm/i915/display/intel_hotplug.c:1123 ../../../gpu/i915:150:
#: drivers/gpu/drm/i915/display/intel_audio.c:733
#: drivers/gpu/drm/i915/display/intel_audio.c:793
#: drivers/gpu/drm/i915/display/intel_audio.c:896
#: drivers/gpu/drm/i915/display/intel_audio.c:1322
#: drivers/gpu/drm/i915/display/intel_audio.c:1383
#: drivers/gpu/drm/i915/display/intel_audio.c:1399
#: drivers/gpu/drm/i915/display/intel_audio.c:1417 ../../../gpu/i915:162:
#: drivers/gpu/drm/i915/display/intel_lpe_audio.c:257
#: drivers/gpu/drm/i915/display/intel_lpe_audio.c:277
#: drivers/gpu/drm/i915/display/intel_lpe_audio.c:298
#: drivers/gpu/drm/i915/display/intel_lpe_audio.c:318 ../../../gpu/i915:171:
#: drivers/gpu/drm/i915/display/intel_psr.c:2214
#: drivers/gpu/drm/i915/display/intel_psr.c:2244
#: drivers/gpu/drm/i915/display/intel_psr.c:2275
#: drivers/gpu/drm/i915/display/intel_psr.c:2306
#: drivers/gpu/drm/i915/display/intel_psr.c:2346
#: drivers/gpu/drm/i915/display/intel_psr.c:2367
#: drivers/gpu/drm/i915/display/intel_psr.c:3061
#: drivers/gpu/drm/i915/display/intel_psr.c:3335
#: drivers/gpu/drm/i915/display/intel_psr.c:3437
#: drivers/gpu/drm/i915/display/intel_psr.c:3494
#: drivers/gpu/drm/i915/display/intel_psr.c:3688
#: drivers/gpu/drm/i915/display/intel_psr.c:3715
#: drivers/gpu/drm/i915/display/intel_psr.c:3740
#: drivers/gpu/drm/i915/display/intel_psr.c:3802
#: drivers/gpu/drm/i915/display/intel_psr.c:3818
#: drivers/gpu/drm/i915/display/intel_psr.c:3834
#: drivers/gpu/drm/i915/display/intel_psr.c:3887 ../../../gpu/i915:180:
#: drivers/gpu/drm/i915/display/intel_fbc.c:1904
#: drivers/gpu/drm/i915/display/intel_fbc.c:2031
#: drivers/gpu/drm/i915/display/intel_fbc.c:2112
#: drivers/gpu/drm/i915/display/intel_fbc.c:2130 ../../../gpu/i915:189:
#: drivers/gpu/drm/i915/display/intel_drrs.c:152
#: drivers/gpu/drm/i915/display/intel_drrs.c:184
#: drivers/gpu/drm/i915/display/intel_drrs.c:267
#: drivers/gpu/drm/i915/display/intel_drrs.c:283
#: drivers/gpu/drm/i915/display/intel_drrs.c:301 ../../../gpu/i915:204:
#: drivers/gpu/drm/i915/display/intel_dmc.c:811
#: drivers/gpu/drm/i915/display/intel_dmc.c:828
#: drivers/gpu/drm/i915/display/intel_dmc.c:846
#: drivers/gpu/drm/i915/display/intel_dmc.c:885
#: drivers/gpu/drm/i915/display/intel_dmc.c:1314
#: drivers/gpu/drm/i915/display/intel_dmc.c:1373
#: drivers/gpu/drm/i915/display/intel_dmc.c:1407
#: drivers/gpu/drm/i915/display/intel_dmc.c:1427 ../../../gpu/i915:225:
#: drivers/gpu/drm/i915/display/intel_bios.c:3004
#: drivers/gpu/drm/i915/display/intel_bios.c:3175
#: drivers/gpu/drm/i915/display/intel_bios.c:3285
#: drivers/gpu/drm/i915/display/intel_bios.c:3323
#: drivers/gpu/drm/i915/display/intel_bios.c:3364
#: drivers/gpu/drm/i915/display/intel_bios.c:3412
#: drivers/gpu/drm/i915/display/intel_bios.c:3461 ../../../gpu/i915:22:
#: drivers/gpu/drm/i915/intel_runtime_pm.c:185
#: drivers/gpu/drm/i915/intel_runtime_pm.c:207
#: drivers/gpu/drm/i915/intel_runtime_pm.c:224
#: drivers/gpu/drm/i915/intel_runtime_pm.c:278
#: drivers/gpu/drm/i915/intel_runtime_pm.c:317
#: drivers/gpu/drm/i915/intel_runtime_pm.c:332
#: drivers/gpu/drm/i915/intel_runtime_pm.c:350
#: drivers/gpu/drm/i915/intel_runtime_pm.c:365 ../../../gpu/i915:237:
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2345
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2362
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2440
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2457
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2491
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2701
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2754
#: drivers/gpu/drm/i915/display/intel_cdclk.c:3423
#: drivers/gpu/drm/i915/display/intel_cdclk.c:3506
#: drivers/gpu/drm/i915/display/intel_cdclk.c:3588
#: drivers/gpu/drm/i915/display/intel_cdclk.c:3785 ../../../gpu/i915:246:
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:158
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:257
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:303
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:419
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:458
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:508
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:3287
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4314
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4376
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4403
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4436
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4465
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4488
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4506
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4590
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4612 ../../../gpu/i915:258:
#: drivers/gpu/drm/i915/display/intel_dsb.c:319
#: drivers/gpu/drm/i915/display/intel_dsb.c:835
#: drivers/gpu/drm/i915/display/intel_dsb.c:914
#: drivers/gpu/drm/i915/display/intel_dsb.c:978 ../../../gpu/i915:25:
#: drivers/gpu/drm/i915/intel_uncore.c:685
#: drivers/gpu/drm/i915/intel_uncore.c:713
#: drivers/gpu/drm/i915/intel_uncore.c:731
#: drivers/gpu/drm/i915/intel_uncore.c:748
#: drivers/gpu/drm/i915/intel_uncore.c:792
#: drivers/gpu/drm/i915/intel_uncore.c:826
#: drivers/gpu/drm/i915/intel_uncore.c:848
#: drivers/gpu/drm/i915/intel_uncore.c:2706
#: drivers/gpu/drm/i915/intel_uncore.c:2762
#: drivers/gpu/drm/i915/intel_uncore.c:2866 ../../../gpu/i915:270:
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:318
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:386
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:407
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:429
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:448
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:467
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:496
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:523
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:654
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:684
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:718
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:796
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:819 ../../../gpu/i915:34:
#: drivers/gpu/drm/i915/i915_irq.c:1120 ../../../gpu/i915:37:
#: drivers/gpu/drm/i915/i915_irq.c:1274 ../../../gpu/i915:404:
#: drivers/gpu/drm/i915/i915_gem_evict.c:128
#: drivers/gpu/drm/i915/i915_gem_evict.c:321
#: drivers/gpu/drm/i915/i915_gem_evict.c:444 ../../../gpu/i915:40:
#: drivers/gpu/drm/i915/i915_irq.c:1287 ../../../gpu/i915:415:
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:80
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:264
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:478
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:537
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:553
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:569
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:585 ../../../gpu/i915:424:
#: drivers/gpu/drm/i915/i915_cmd_parser.c:952
#: drivers/gpu/drm/i915/i915_cmd_parser.c:1066
#: drivers/gpu/drm/i915/i915_cmd_parser.c:1429
#: drivers/gpu/drm/i915/i915_cmd_parser.c:1585 ../../../gpu/i915:452:
#: drivers/gpu/drm/i915/i915_gem_gtt.c:75
#: drivers/gpu/drm/i915/i915_gem_gtt.c:159 ../../../gpu/i915:458:
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:289
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:412
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:453
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:491
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:506
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:570
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:769
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:806 ../../../gpu/i915:476:
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:49
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:89
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:332
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:416 ../../../gpu/i915:49:
#: drivers/gpu/drm/i915/i915_vgpu.c:60 drivers/gpu/drm/i915/i915_vgpu.c:170
#: drivers/gpu/drm/i915/i915_vgpu.c:214 ../../../gpu/i915:514:
#: drivers/gpu/drm/i915/gt/uc/intel_guc.h:408 ../../../gpu/i915:527:
#: drivers/gpu/drm/i915/gt/uc/intel_guc.c:769 ../../../gpu/i915:534:
#: drivers/gpu/drm/i915/gt/uc/intel_guc_fw.c:290 ../../../gpu/i915:556:
#: drivers/gpu/drm/i915/gt/uc/intel_huc.c:522 ../../../gpu/i915:58:
#: drivers/gpu/drm/i915/intel_gvt.c:232 drivers/gpu/drm/i915/intel_gvt.c:256
#: drivers/gpu/drm/i915/intel_gvt.c:272 ../../../gpu/i915:610:
#: drivers/gpu/drm/i915/i915_perf.c:5053 ../../../gpu/i915:612:
#: drivers/gpu/drm/i915/i915_perf.c:5207 ../../../gpu/i915:614:
#: drivers/gpu/drm/i915/i915_perf.c:4259 ../../../gpu/i915:616:
#: drivers/gpu/drm/i915/i915_perf.c:4288 ../../../gpu/i915:618:
#: drivers/gpu/drm/i915/i915_perf.c:4197 ../../../gpu/i915:620:
#: drivers/gpu/drm/i915/i915_perf.c:3726 ../../../gpu/i915:622:
#: drivers/gpu/drm/i915/i915_perf.c:4588 ../../../gpu/i915:624:
#: drivers/gpu/drm/i915/i915_perf.c:4754 ../../../gpu/i915:638:
#: drivers/gpu/drm/i915/i915_perf.c:3955 ../../../gpu/i915:640:
#: drivers/gpu/drm/i915/i915_perf.c:3772 ../../../gpu/i915:642:
#: drivers/gpu/drm/i915/i915_perf.c:3702 ../../../gpu/i915:644:
#: drivers/gpu/drm/i915/i915_perf.c:3414 ../../../gpu/i915:646:
#: drivers/gpu/drm/i915/i915_perf.c:3677 ../../../gpu/i915:648:
#: drivers/gpu/drm/i915/i915_perf.c:3562 ../../../gpu/i915:650:
#: drivers/gpu/drm/i915/i915_perf.c:3587 ../../../gpu/i915:652:
#: drivers/gpu/drm/i915/i915_perf.c:3537 ../../../gpu/i915:654:
#: drivers/gpu/drm/i915/i915_perf.c:3505 ../../../gpu/i915:663:
#: drivers/gpu/drm/i915/i915_perf.c:3218 ../../../gpu/i915:665:
#: drivers/gpu/drm/i915/i915_perf.c:1266 ../../../gpu/i915:667:
#: drivers/gpu/drm/i915/i915_perf.c:3052 ../../../gpu/i915:669:
#: drivers/gpu/drm/i915/i915_perf.c:3118 ../../../gpu/i915:671:
#: drivers/gpu/drm/i915/i915_perf.c:1225 ../../../gpu/i915:673:
#: drivers/gpu/drm/i915/i915_perf.c:1249 ../../../gpu/i915:683:
#: drivers/gpu/drm/i915/i915_perf.c:524 drivers/gpu/drm/i915/i915_perf.c:617
#: drivers/gpu/drm/i915/i915_perf.c:651 drivers/gpu/drm/i915/i915_perf.c:711
#: drivers/gpu/drm/i915/i915_perf.c:931 drivers/gpu/drm/i915/i915_perf.c:1021
#: drivers/gpu/drm/i915/i915_perf.c:1140 drivers/gpu/drm/i915/i915_perf.c:1520
#: drivers/gpu/drm/i915/i915_perf.c:1613 drivers/gpu/drm/i915/i915_perf.c:3650
#: drivers/gpu/drm/i915/i915_perf.c:5230 ../../../gpu/i915:88:
#: drivers/gpu/drm/i915/display/intel_frontbuffer.h:92
#: drivers/gpu/drm/i915/display/intel_frontbuffer.h:123 ../../../gpu/i915:91:
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:77
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:110
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:132
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:155
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:226
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:319
msgid "**Parameters**"
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:187
#: drivers/gpu/drm/i915/intel_runtime_pm.c:209
#: drivers/gpu/drm/i915/intel_runtime_pm.c:226
#: drivers/gpu/drm/i915/intel_runtime_pm.c:280
#: drivers/gpu/drm/i915/intel_runtime_pm.c:319
#: drivers/gpu/drm/i915/intel_runtime_pm.c:334
#: drivers/gpu/drm/i915/intel_runtime_pm.c:352
#: drivers/gpu/drm/i915/intel_runtime_pm.c:367
msgid "``struct intel_runtime_pm *rpm``"
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:182
#: drivers/gpu/drm/i915/intel_runtime_pm.c:204
#: drivers/gpu/drm/i915/intel_runtime_pm.c:221
#: drivers/gpu/drm/i915/intel_runtime_pm.c:275
#: drivers/gpu/drm/i915/intel_runtime_pm.c:314
#: drivers/gpu/drm/i915/intel_runtime_pm.c:329
#: drivers/gpu/drm/i915/intel_runtime_pm.c:347
#: drivers/gpu/drm/i915/intel_runtime_pm.c:362
msgid "the intel_runtime_pm structure"
msgstr ""

#: ../../../gpu/i915:100:
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:283
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:312
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:360
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:392
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:411
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:439
#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:107
#: drivers/gpu/drm/i915/display/intel_plane.c:120
#: drivers/gpu/drm/i915/display/intel_plane.c:155
#: drivers/gpu/drm/i915/display/intel_plane.c:1164
#: drivers/gpu/drm/i915/display/intel_plane.c:1254 ../../../gpu/i915:141:
#: drivers/gpu/drm/i915/display/intel_hotplug.c:93
#: drivers/gpu/drm/i915/display/intel_hotplug.c:129
#: drivers/gpu/drm/i915/display/intel_hotplug.c:447
#: drivers/gpu/drm/i915/display/intel_hotplug.c:577
#: drivers/gpu/drm/i915/display/intel_hotplug.c:708
#: drivers/gpu/drm/i915/display/intel_hotplug.c:853
#: drivers/gpu/drm/i915/display/intel_hotplug.c:888
#: drivers/gpu/drm/i915/display/intel_hotplug.c:1054
#: drivers/gpu/drm/i915/display/intel_hotplug.c:1098
#: drivers/gpu/drm/i915/display/intel_hotplug.c:1122 ../../../gpu/i915:150:
#: drivers/gpu/drm/i915/display/intel_audio.c:734
#: drivers/gpu/drm/i915/display/intel_audio.c:794
#: drivers/gpu/drm/i915/display/intel_audio.c:1321
#: drivers/gpu/drm/i915/display/intel_audio.c:1382 ../../../gpu/i915:162:
#: drivers/gpu/drm/i915/display/intel_lpe_audio.c:256
#: drivers/gpu/drm/i915/display/intel_lpe_audio.c:298
#: drivers/gpu/drm/i915/display/intel_lpe_audio.c:323 ../../../gpu/i915:171:
#: drivers/gpu/drm/i915/display/intel_psr.c:2214
#: drivers/gpu/drm/i915/display/intel_psr.c:2243
#: drivers/gpu/drm/i915/display/intel_psr.c:2274
#: drivers/gpu/drm/i915/display/intel_psr.c:2306
#: drivers/gpu/drm/i915/display/intel_psr.c:2347
#: drivers/gpu/drm/i915/display/intel_psr.c:2366
#: drivers/gpu/drm/i915/display/intel_psr.c:3060
#: drivers/gpu/drm/i915/display/intel_psr.c:3336
#: drivers/gpu/drm/i915/display/intel_psr.c:3438
#: drivers/gpu/drm/i915/display/intel_psr.c:3493
#: drivers/gpu/drm/i915/display/intel_psr.c:3687
#: drivers/gpu/drm/i915/display/intel_psr.c:3714
#: drivers/gpu/drm/i915/display/intel_psr.c:3739
#: drivers/gpu/drm/i915/display/intel_psr.c:3801
#: drivers/gpu/drm/i915/display/intel_psr.c:3817
#: drivers/gpu/drm/i915/display/intel_psr.c:3835
#: drivers/gpu/drm/i915/display/intel_psr.c:3887 ../../../gpu/i915:180:
#: drivers/gpu/drm/i915/display/intel_fbc.c:1903
#: drivers/gpu/drm/i915/display/intel_fbc.c:2030
#: drivers/gpu/drm/i915/display/intel_fbc.c:2111
#: drivers/gpu/drm/i915/display/intel_fbc.c:2129 ../../../gpu/i915:189:
#: drivers/gpu/drm/i915/display/intel_drrs.c:151
#: drivers/gpu/drm/i915/display/intel_drrs.c:183
#: drivers/gpu/drm/i915/display/intel_drrs.c:267
#: drivers/gpu/drm/i915/display/intel_drrs.c:283
#: drivers/gpu/drm/i915/display/intel_drrs.c:300 ../../../gpu/i915:204:
#: drivers/gpu/drm/i915/display/intel_dmc.c:812
#: drivers/gpu/drm/i915/display/intel_dmc.c:830
#: drivers/gpu/drm/i915/display/intel_dmc.c:845
#: drivers/gpu/drm/i915/display/intel_dmc.c:884
#: drivers/gpu/drm/i915/display/intel_dmc.c:1313
#: drivers/gpu/drm/i915/display/intel_dmc.c:1372
#: drivers/gpu/drm/i915/display/intel_dmc.c:1406
#: drivers/gpu/drm/i915/display/intel_dmc.c:1426 ../../../gpu/i915:225:
#: drivers/gpu/drm/i915/display/intel_bios.c:3005
#: drivers/gpu/drm/i915/display/intel_bios.c:3174
#: drivers/gpu/drm/i915/display/intel_bios.c:3322
#: drivers/gpu/drm/i915/display/intel_bios.c:3364
#: drivers/gpu/drm/i915/display/intel_bios.c:3412
#: drivers/gpu/drm/i915/display/intel_bios.c:3461 ../../../gpu/i915:22:
#: drivers/gpu/drm/i915/intel_runtime_pm.c:184
#: drivers/gpu/drm/i915/intel_runtime_pm.c:206
#: drivers/gpu/drm/i915/intel_runtime_pm.c:224
#: drivers/gpu/drm/i915/intel_runtime_pm.c:277
#: drivers/gpu/drm/i915/intel_runtime_pm.c:317
#: drivers/gpu/drm/i915/intel_runtime_pm.c:331
#: drivers/gpu/drm/i915/intel_runtime_pm.c:350
#: drivers/gpu/drm/i915/intel_runtime_pm.c:364 ../../../gpu/i915:237:
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2344
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2361
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2700
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2753
#: drivers/gpu/drm/i915/display/intel_cdclk.c:3422
#: drivers/gpu/drm/i915/display/intel_cdclk.c:3505
#: drivers/gpu/drm/i915/display/intel_cdclk.c:3587 ../../../gpu/i915:246:
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:256
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:302
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:420
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:459
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:507
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:3287
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4313
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4377
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4404
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4436
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4466
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4489
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4507
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4591
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4613 ../../../gpu/i915:249:
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:138
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:304 ../../../gpu/i915:258:
#: drivers/gpu/drm/i915/display/intel_dsb.c:320
#: drivers/gpu/drm/i915/display/intel_dsb.c:834
#: drivers/gpu/drm/i915/display/intel_dsb.c:916
#: drivers/gpu/drm/i915/display/intel_dsb.c:977 ../../../gpu/i915:25:
#: drivers/gpu/drm/i915/intel_uncore.c:685
#: drivers/gpu/drm/i915/intel_uncore.c:712
#: drivers/gpu/drm/i915/intel_uncore.c:730
#: drivers/gpu/drm/i915/intel_uncore.c:748
#: drivers/gpu/drm/i915/intel_uncore.c:792
#: drivers/gpu/drm/i915/intel_uncore.c:848
#: drivers/gpu/drm/i915/intel_uncore.c:2711
#: drivers/gpu/drm/i915/intel_uncore.c:2767
#: drivers/gpu/drm/i915/intel_uncore.c:2868 ../../../gpu/i915:270:
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:318
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:386
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:406
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:433
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:451
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:468
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:497
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:525
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:657
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:684
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:718
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:798
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:823 ../../../gpu/i915:34:
#: drivers/gpu/drm/i915/i915_irq.c:1119 ../../../gpu/i915:37:
#: drivers/gpu/drm/i915/i915_irq.c:1273 ../../../gpu/i915:404:
#: drivers/gpu/drm/i915/i915_gem_evict.c:134
#: drivers/gpu/drm/i915/i915_gem_evict.c:323
#: drivers/gpu/drm/i915/i915_gem_evict.c:450 ../../../gpu/i915:40:
#: drivers/gpu/drm/i915/i915_irq.c:1286 ../../../gpu/i915:415:
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:83
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:263
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:480
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:538
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:554
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:570
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:587 ../../../gpu/i915:424:
#: drivers/gpu/drm/i915/i915_cmd_parser.c:951
#: drivers/gpu/drm/i915/i915_cmd_parser.c:1065
#: drivers/gpu/drm/i915/i915_cmd_parser.c:1433
#: drivers/gpu/drm/i915/i915_cmd_parser.c:1584 ../../../gpu/i915:430:
#: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:127
#: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:221
#: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:417 ../../../gpu/i915:437:
#: drivers/gpu/drm/i915/i915_scheduler_types.h:203 ../../../gpu/i915:452:
#: drivers/gpu/drm/i915/i915_gem_gtt.c:84
#: drivers/gpu/drm/i915/i915_gem_gtt.c:171 ../../../gpu/i915:458:
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:288
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:411
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:452
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:490
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:505
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:569
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:769
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:806 ../../../gpu/i915:476:
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:51
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:91
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:333
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:417 ../../../gpu/i915:49:
#: drivers/gpu/drm/i915/i915_vgpu.c:59 drivers/gpu/drm/i915/i915_vgpu.c:169
#: drivers/gpu/drm/i915/i915_vgpu.c:213 ../../../gpu/i915:514:
#: drivers/gpu/drm/i915/gt/uc/intel_guc.h:314
#: drivers/gpu/drm/i915/gt/uc/intel_guc.h:408 ../../../gpu/i915:527:
#: drivers/gpu/drm/i915/gt/uc/intel_guc.c:769 ../../../gpu/i915:534:
#: drivers/gpu/drm/i915/gt/uc/intel_guc_fw.c:289 ../../../gpu/i915:556:
#: drivers/gpu/drm/i915/gt/uc/intel_huc.c:522 ../../../gpu/i915:58:
#: drivers/gpu/drm/i915/intel_gvt.c:231 drivers/gpu/drm/i915/intel_gvt.c:256
#: drivers/gpu/drm/i915/intel_gvt.c:272 ../../../gpu/i915:610:
#: drivers/gpu/drm/i915/i915_perf.c:5052 ../../../gpu/i915:614:
#: drivers/gpu/drm/i915/i915_perf.c:4258 ../../../gpu/i915:616:
#: drivers/gpu/drm/i915/i915_perf.c:4287 ../../../gpu/i915:618:
#: drivers/gpu/drm/i915/i915_perf.c:4198 ../../../gpu/i915:620:
#: drivers/gpu/drm/i915/i915_perf.c:3726 ../../../gpu/i915:622:
#: drivers/gpu/drm/i915/i915_perf.c:4590 ../../../gpu/i915:624:
#: drivers/gpu/drm/i915/i915_perf.c:4755 ../../../gpu/i915:638:
#: drivers/gpu/drm/i915/i915_perf.c:3957 ../../../gpu/i915:640:
#: drivers/gpu/drm/i915/i915_perf.c:3774 ../../../gpu/i915:642:
#: drivers/gpu/drm/i915/i915_perf.c:3701 ../../../gpu/i915:644:
#: drivers/gpu/drm/i915/i915_perf.c:3416 ../../../gpu/i915:646:
#: drivers/gpu/drm/i915/i915_perf.c:3678 ../../../gpu/i915:648:
#: drivers/gpu/drm/i915/i915_perf.c:3561 ../../../gpu/i915:650:
#: drivers/gpu/drm/i915/i915_perf.c:3586 ../../../gpu/i915:652:
#: drivers/gpu/drm/i915/i915_perf.c:3537 ../../../gpu/i915:654:
#: drivers/gpu/drm/i915/i915_perf.c:3506 ../../../gpu/i915:663:
#: drivers/gpu/drm/i915/i915_perf.c:3219 ../../../gpu/i915:665:
#: drivers/gpu/drm/i915/i915_perf.c:1268 ../../../gpu/i915:667:
#: drivers/gpu/drm/i915/i915_perf.c:3051 ../../../gpu/i915:669:
#: drivers/gpu/drm/i915/i915_perf.c:3117 ../../../gpu/i915:671:
#: drivers/gpu/drm/i915/i915_perf.c:1224 ../../../gpu/i915:673:
#: drivers/gpu/drm/i915/i915_perf.c:1250 ../../../gpu/i915:683:
#: drivers/gpu/drm/i915/i915_perf.c:363 drivers/gpu/drm/i915/i915_perf.c:523
#: drivers/gpu/drm/i915/i915_perf.c:620 drivers/gpu/drm/i915/i915_perf.c:654
#: drivers/gpu/drm/i915/i915_perf.c:714 drivers/gpu/drm/i915/i915_perf.c:933
#: drivers/gpu/drm/i915/i915_perf.c:1024 drivers/gpu/drm/i915/i915_perf.c:1142
#: drivers/gpu/drm/i915/i915_perf.c:1519 drivers/gpu/drm/i915/i915_perf.c:1612
#: drivers/gpu/drm/i915/i915_perf.c:5229 ../../../gpu/i915:88:
#: drivers/gpu/drm/i915/display/intel_frontbuffer.h:92
#: drivers/gpu/drm/i915/display/intel_frontbuffer.h:123 ../../../gpu/i915:91:
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:78
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:110
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:132
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:155
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:225
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:320
msgid "**Description**"
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:183
msgid ""
"This is the unlocked version of intel_display_power_is_enabled() and should "
"only be used from error capture and recovery code where deadlocks are "
"possible. This function grabs a device-level runtime pm reference (mostly "
"used for asynchronous PM management from display code) and ensures that it "
"is powered up. Raw references are not considered during wakelock assert "
"checks."
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:190
msgid ""
"Any runtime pm reference obtained by this function must have a symmetric "
"call to intel_runtime_pm_put_raw() to release the reference again."
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:122
#: ../../../gpu/i915:162: drivers/gpu/drm/i915/display/intel_lpe_audio.c:277
#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:193
#: drivers/gpu/drm/i915/intel_runtime_pm.c:211
#: drivers/gpu/drm/i915/intel_runtime_pm.c:237
#: drivers/gpu/drm/i915/intel_runtime_pm.c:285 ../../../gpu/i915:237:
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2440
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2459
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2491 ../../../gpu/i915:246:
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:158
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4381
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4413
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4614 ../../../gpu/i915:258:
#: drivers/gpu/drm/i915/display/intel_dsb.c:918 ../../../gpu/i915:25:
#: drivers/gpu/drm/i915/intel_uncore.c:2724
#: drivers/gpu/drm/i915/intel_uncore.c:2773 ../../../gpu/i915:270:
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:843 ../../../gpu/i915:415:
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:97
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:269 ../../../gpu/i915:424:
#: drivers/gpu/drm/i915/i915_cmd_parser.c:1435
#: drivers/gpu/drm/i915/i915_cmd_parser.c:1586 ../../../gpu/i915:452:
#: drivers/gpu/drm/i915/i915_gem_gtt.c:92
#: drivers/gpu/drm/i915/i915_gem_gtt.c:185 ../../../gpu/i915:458:
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:420 ../../../gpu/i915:476:
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:337
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:420 ../../../gpu/i915:49:
#: drivers/gpu/drm/i915/i915_vgpu.c:249 ../../../gpu/i915:514:
#: drivers/gpu/drm/i915/gt/uc/intel_guc.h:413 ../../../gpu/i915:527:
#: drivers/gpu/drm/i915/gt/uc/intel_guc.c:774 ../../../gpu/i915:534:
#: drivers/gpu/drm/i915/gt/uc/intel_guc_fw.c:294 ../../../gpu/i915:58:
#: drivers/gpu/drm/i915/intel_gvt.c:232 ../../../gpu/i915:618:
#: drivers/gpu/drm/i915/i915_perf.c:4212 ../../../gpu/i915:620:
#: drivers/gpu/drm/i915/i915_perf.c:3729 ../../../gpu/i915:622:
#: drivers/gpu/drm/i915/i915_perf.c:4592 ../../../gpu/i915:624:
#: drivers/gpu/drm/i915/i915_perf.c:4757 ../../../gpu/i915:640:
#: drivers/gpu/drm/i915/i915_perf.c:3789 ../../../gpu/i915:644:
#: drivers/gpu/drm/i915/i915_perf.c:3424 ../../../gpu/i915:646:
#: drivers/gpu/drm/i915/i915_perf.c:3679 ../../../gpu/i915:652:
#: drivers/gpu/drm/i915/i915_perf.c:3543 ../../../gpu/i915:654:
#: drivers/gpu/drm/i915/i915_perf.c:3509 ../../../gpu/i915:663:
#: drivers/gpu/drm/i915/i915_perf.c:3228 ../../../gpu/i915:665:
#: drivers/gpu/drm/i915/i915_perf.c:1270 ../../../gpu/i915:671:
#: drivers/gpu/drm/i915/i915_perf.c:1232 ../../../gpu/i915:683:
#: drivers/gpu/drm/i915/i915_perf.c:540 drivers/gpu/drm/i915/i915_perf.c:624
#: drivers/gpu/drm/i915/i915_perf.c:660 drivers/gpu/drm/i915/i915_perf.c:725
#: drivers/gpu/drm/i915/i915_perf.c:943 drivers/gpu/drm/i915/i915_perf.c:1035
#: drivers/gpu/drm/i915/i915_perf.c:1148 drivers/gpu/drm/i915/i915_perf.c:1522
#: drivers/gpu/drm/i915/i915_perf.c:3651
msgid "**Return**"
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:194
msgid ""
"the wakeref cookie to pass to intel_runtime_pm_put_raw(), evaluates as True "
"if the wakeref was acquired, or False otherwise."
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:203
#: drivers/gpu/drm/i915/intel_runtime_pm.c:274
msgid "grab a runtime pm reference"
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:205
msgid ""
"This function grabs a device-level runtime pm reference (mostly used for GEM "
"code to ensure the GTT or GT is on) and ensures that it is powered up."
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:208
#: drivers/gpu/drm/i915/intel_runtime_pm.c:234
#: drivers/gpu/drm/i915/intel_runtime_pm.c:282
msgid ""
"Any runtime pm reference obtained by this function must have a symmetric "
"call to intel_runtime_pm_put() to release the reference again."
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:212
#: drivers/gpu/drm/i915/intel_runtime_pm.c:286
msgid "the wakeref cookie to pass to intel_runtime_pm_put()"
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:220
msgid "grab a runtime pm reference if device is active"
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:223
msgid "``bool ignore_usecount``"
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:222
msgid "get a ref even if dev->power.usage_count is 0"
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:223
msgid ""
"This function grabs a device-level runtime pm reference if the device is "
"already active and ensures that it is powered up. It is illegal to try and "
"access the HW should intel_runtime_pm_get_if_active() report failure."
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:227
msgid ""
"If **ignore_usecount** is true, a reference will be acquired even if there "
"is no user requiring the device to be powered up (dev->power.usage_count == "
"0). If the function returns false in this case then it's guaranteed that the "
"device's runtime suspend hook has been called already or that it will be "
"called (and hence it's also guaranteed that the device's runtime resume hook "
"will be called eventually)."
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:238
msgid ""
"the wakeref cookie to pass to intel_runtime_pm_put(), evaluates as True if "
"the wakeref was acquired, or False otherwise."
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:276
msgid "This function grabs a device-level runtime pm reference."
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:278
msgid ""
"It will _not_ resume the device but instead only get an extra wakeref. "
"Therefore it is only valid to call this functions from contexts where the "
"device is known to be active and with another wakeref previously hold."
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:313
msgid "release a raw runtime pm reference"
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:316
#: drivers/gpu/drm/i915/intel_runtime_pm.c:349
msgid "``intel_wakeref_t wref``"
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:315
#: drivers/gpu/drm/i915/intel_runtime_pm.c:348
msgid "wakeref acquired for the reference that is being released"
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:316
msgid ""
"This function drops the device-level runtime pm reference obtained by "
"intel_runtime_pm_get_raw() and might power down the corresponding hardware "
"block right away if this is the last reference."
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:328
msgid "release an unchecked runtime pm reference"
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:330
#: drivers/gpu/drm/i915/intel_runtime_pm.c:349
msgid ""
"This function drops the device-level runtime pm reference obtained by "
"intel_runtime_pm_get() and might power down the corresponding hardware block "
"right away if this is the last reference."
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:334
msgid ""
"This function exists only for historical reasons and should be avoided in "
"new code, as the correctness of its use cannot be checked. Always use "
"intel_runtime_pm_put() instead."
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:346
msgid "release a runtime pm reference"
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:361
msgid "enable runtime pm"
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:363
msgid ""
"This function enables runtime pm at the end of the driver load sequence."
msgstr ""

#: ../../../gpu/i915:22: drivers/gpu/drm/i915/intel_runtime_pm.c:365
msgid ""
"Note that this function does currently not enable runtime pm for the "
"subordinate display power domains. That is done by "
"intel_power_domains_enable()."
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:681
#: drivers/gpu/drm/i915/intel_uncore.c:744
msgid "grab forcewake domain references"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:687
#: drivers/gpu/drm/i915/intel_uncore.c:715
#: drivers/gpu/drm/i915/intel_uncore.c:733
#: drivers/gpu/drm/i915/intel_uncore.c:750
#: drivers/gpu/drm/i915/intel_uncore.c:794
#: drivers/gpu/drm/i915/intel_uncore.c:828
#: drivers/gpu/drm/i915/intel_uncore.c:850
#: drivers/gpu/drm/i915/intel_uncore.c:2708
#: drivers/gpu/drm/i915/intel_uncore.c:2764
#: drivers/gpu/drm/i915/intel_uncore.c:2868
msgid "``struct intel_uncore *uncore``"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:682
#: drivers/gpu/drm/i915/intel_uncore.c:710
#: drivers/gpu/drm/i915/intel_uncore.c:728
#: drivers/gpu/drm/i915/intel_uncore.c:745
#: drivers/gpu/drm/i915/intel_uncore.c:789
#: drivers/gpu/drm/i915/intel_uncore.c:823
#: drivers/gpu/drm/i915/intel_uncore.c:845
msgid "the intel_uncore structure"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:684
#: drivers/gpu/drm/i915/intel_uncore.c:747
#: drivers/gpu/drm/i915/intel_uncore.c:791
#: drivers/gpu/drm/i915/intel_uncore.c:825
#: drivers/gpu/drm/i915/intel_uncore.c:847
msgid "``enum forcewake_domains fw_domains``"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:683
#: drivers/gpu/drm/i915/intel_uncore.c:746
msgid "forcewake domains to get reference on"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:684
msgid ""
"This function can be used get GT's forcewake domain references. Normal "
"register access will handle the forcewake domains automatically. However if "
"some sequence requires the GT to not power down a particular forcewake "
"domains this function should be called at the beginning of the sequence. And "
"subsequently the reference should be dropped by symmetric call to "
"intel_unforce_forcewake_put(). Usually caller wants all the domains to be "
"kept awake so the **fw_domains** would be then FORCEWAKE_ALL."
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:709
msgid "claim forcewake on behalf of userspace"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:711
msgid ""
"This function is a wrapper around intel_uncore_forcewake_get() to acquire "
"the GT powerwell and in the process disable our debugging for the duration "
"of userspace's bypass."
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:727
msgid "release forcewake on behalf of userspace"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:729
msgid ""
"This function complements intel_uncore_forcewake_user_get() and releases the "
"GT powerwell taken on behalf of the userspace bypass."
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:747
msgid ""
"See intel_uncore_forcewake_get(). This variant places the onus on the caller "
"to explicitly handle the dev_priv->uncore.lock spinlock."
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:788
msgid "release a forcewake domain reference"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:790
#: drivers/gpu/drm/i915/intel_uncore.c:846
msgid "forcewake domains to put references"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:791
msgid ""
"This function drops the device-level forcewakes for specified domains "
"obtained by intel_uncore_forcewake_get()."
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:822
msgid "flush the delayed release"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:824
msgid "forcewake domains to flush"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:844
msgid "release forcewake domain references"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:847
msgid ""
"See intel_uncore_forcewake_put(). This variant places the onus on the caller "
"to explicitly handle the dev_priv->uncore.lock spinlock."
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2702
#: drivers/gpu/drm/i915/intel_uncore.c:2758
msgid "wait until register matches expected state"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2703
#: drivers/gpu/drm/i915/intel_uncore.c:2759
msgid "the struct intel_uncore"
msgstr ""

#: ../../../gpu/i915:258: drivers/gpu/drm/i915/display/intel_dsb.c:318
#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2705
#: drivers/gpu/drm/i915/intel_uncore.c:2761
#: drivers/gpu/drm/i915/intel_uncore.c:2866
msgid "``i915_reg_t reg``"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2704
#: drivers/gpu/drm/i915/intel_uncore.c:2760 ../../../gpu/i915:270:
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:817
msgid "the register to read"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2706
#: drivers/gpu/drm/i915/intel_uncore.c:2762 ../../../gpu/i915:270:
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:819
msgid "``u32 mask``"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2705
#: drivers/gpu/drm/i915/intel_uncore.c:2761 ../../../gpu/i915:270:
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:818
msgid "mask to apply to register value"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2707
#: drivers/gpu/drm/i915/intel_uncore.c:2763 ../../../gpu/i915:270:
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:448
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:467
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:496
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:820
msgid "``u32 value``"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2706
#: drivers/gpu/drm/i915/intel_uncore.c:2762
msgid "expected value"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2708
#: drivers/gpu/drm/i915/intel_uncore.c:2764 ../../../gpu/i915:270:
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:821
msgid "``unsigned int fast_timeout_us``"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2707
#: drivers/gpu/drm/i915/intel_uncore.c:2763 ../../../gpu/i915:270:
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:820
msgid "fast timeout in microsecond for atomic/tight wait"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2709
#: drivers/gpu/drm/i915/intel_uncore.c:2765 ../../../gpu/i915:270:
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:822
msgid "``unsigned int slow_timeout_ms``"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2708
#: drivers/gpu/drm/i915/intel_uncore.c:2764 ../../../gpu/i915:270:
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:821
msgid "slow timeout in millisecond"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2710
#: drivers/gpu/drm/i915/intel_uncore.c:2766
msgid "``u32 *out_value``"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2709
#: drivers/gpu/drm/i915/intel_uncore.c:2765
msgid "optional placeholder to hold registry value"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2710
#: drivers/gpu/drm/i915/intel_uncore.c:2766 ../../../gpu/i915:270:
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:822
msgid ""
"This routine waits until the target register **reg** contains the expected "
"**value** after applying the **mask**, i.e. it waits until ::"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2715
#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:827
msgid ""
"Otherwise, the wait will timeout after **slow_timeout_ms** milliseconds. For "
"atomic context **slow_timeout_ms** must be zero and **fast_timeout_us** must "
"be not larger than 20,0000 microseconds."
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2719
msgid ""
"Note that this routine assumes the caller holds forcewake asserted, it is "
"not suitable for very long waits. See intel_wait_for_register() if you wish "
"to wait without holding forcewake for the duration (i.e. you expect the wait "
"to be slow)."
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2725
#: drivers/gpu/drm/i915/intel_uncore.c:2774 ../../../gpu/i915:270:
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:842
msgid "0 if the register matches the desired condition, or -ETIMEDOUT."
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2771
msgid "Otherwise, the wait will timeout after **timeout_ms** milliseconds."
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2862
msgid "which forcewake domains are needed to access a register"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2864
msgid "pointer to struct intel_uncore"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2865
msgid "register in question"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2867
msgid "``unsigned int op``"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2866
msgid "operation bitmask of FW_REG_READ and/or FW_REG_WRITE"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2867
msgid ""
"Returns a set of forcewake domains required to be taken with for example "
"intel_uncore_forcewake_get for the specified register to be accessible in "
"the specified mode (read, write or read/write) with raw mmio accessors."
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2871
msgid "**NOTE**"
msgstr ""

#: ../../../gpu/i915:25: drivers/gpu/drm/i915/intel_uncore.c:2872
msgid ""
"On Gen6 and Gen7 write forcewake domain (FORCEWAKE_RENDER) requires the "
"callers to do FIFO management on their own or risk losing writes."
msgstr ""

#: ../../../gpu/i915.rst:29
msgid "Interrupt Handling"
msgstr ""

#: ../../../gpu/i915:31: drivers/gpu/drm/i915/i915_irq.c:56
msgid ""
"These functions provide the basic support for enabling and disabling the "
"interrupt handling support. There's a lot more functionality in i915_irq.c "
"and related files, but that will be described in separate chapters."
msgstr ""

#: ../../../gpu/i915:34: drivers/gpu/drm/i915/i915_irq.c:1116
msgid "initializes irq support"
msgstr ""

#: ../../../gpu/i915:34: drivers/gpu/drm/i915/i915_irq.c:1122
#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:1587
#: ../../../gpu/i915:49: drivers/gpu/drm/i915/i915_vgpu.c:62
#: ../../../gpu/i915:58: drivers/gpu/drm/i915/intel_gvt.c:234
#: drivers/gpu/drm/i915/intel_gvt.c:258 drivers/gpu/drm/i915/intel_gvt.c:274
msgid "``struct drm_i915_private *dev_priv``"
msgstr ""

#: ../../../gpu/i915:34: drivers/gpu/drm/i915/i915_irq.c:1117
#: ../../../gpu/i915:37: drivers/gpu/drm/i915/i915_irq.c:1271
#: ../../../gpu/i915:40: drivers/gpu/drm/i915/i915_irq.c:1284
#: ../../../gpu/i915:610: drivers/gpu/drm/i915/i915_perf.c:5050
#: ../../../gpu/i915:612: drivers/gpu/drm/i915/i915_perf.c:5204
#: ../../../gpu/i915:614: drivers/gpu/drm/i915/i915_perf.c:4256
#: ../../../gpu/i915:616: drivers/gpu/drm/i915/i915_perf.c:4285
msgid "i915 device instance"
msgstr ""

#: ../../../gpu/i915:34: drivers/gpu/drm/i915/i915_irq.c:1118
msgid ""
"This function initializes all the irq support including work items, timers "
"and all the vtables. It does not setup the interrupt itself though."
msgstr ""

#: ../../../gpu/i915:37: drivers/gpu/drm/i915/i915_irq.c:1270
msgid "Suspend interrupts"
msgstr ""

#: ../../../gpu/i915:37: drivers/gpu/drm/i915/i915_irq.c:1276
#: ../../../gpu/i915:40: drivers/gpu/drm/i915/i915_irq.c:1289
#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:79
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:266 ../../../gpu/i915:476:
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:51
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:91 ../../../gpu/i915:610:
#: drivers/gpu/drm/i915/i915_perf.c:5055 ../../../gpu/i915:612:
#: drivers/gpu/drm/i915/i915_perf.c:5209 ../../../gpu/i915:614:
#: drivers/gpu/drm/i915/i915_perf.c:4261 ../../../gpu/i915:616:
#: drivers/gpu/drm/i915/i915_perf.c:4290 ../../../gpu/i915:683:
#: drivers/gpu/drm/i915/i915_perf.c:5232
msgid "``struct drm_i915_private *i915``"
msgstr ""

#: ../../../gpu/i915:37: drivers/gpu/drm/i915/i915_irq.c:1272
msgid "This function is used to disable interrupts at runtime."
msgstr ""

#: ../../../gpu/i915:40: drivers/gpu/drm/i915/i915_irq.c:1283
msgid "Resume interrupts"
msgstr ""

#: ../../../gpu/i915:40: drivers/gpu/drm/i915/i915_irq.c:1285
msgid "This function is used to enable interrupts at runtime."
msgstr ""

#: ../../../gpu/i915.rst:44
msgid "Intel GVT-g Guest Support(vGPU)"
msgstr ""

#: ../../../gpu/i915:46: drivers/gpu/drm/i915/i915_vgpu.c:29
msgid ""
"Intel GVT-g is a graphics virtualization technology which shares the GPU "
"among multiple virtual machines on a time-sharing basis. Each virtual "
"machine is presented a virtual GPU (vGPU), which has equivalent features as "
"the underlying physical GPU (pGPU), so i915 driver can run seamlessly in a "
"virtual machine. This file provides vGPU specific optimizations when running "
"in a virtual machine, to reduce the complexity of vGPU emulation and to "
"improve the overall performance."
msgstr ""

#: ../../../gpu/i915:46: drivers/gpu/drm/i915/i915_vgpu.c:37
msgid ""
"A primary function introduced here is so-called \"address space ballooning\" "
"technique. Intel GVT-g partitions global graphics memory among multiple VMs, "
"so each VM can directly access a portion of the memory without hypervisor's "
"intervention, e.g. filling textures or queuing commands. However with the "
"partitioning an unmodified i915 driver would assume a smaller graphics "
"memory starting from address ZERO, then requires vGPU emulation module to "
"translate the graphics address between 'guest view' and 'host view', for all "
"registers and command opcodes which contain a graphics memory address. To "
"reduce the complexity, Intel GVT-g introduces \"address space ballooning\", "
"by telling the exact partitioning knowledge to each guest i915 driver, which "
"then reserves and prevents non-allocated portions from allocation. Thus vGPU "
"emulation module only needs to scan and validate graphics addresses without "
"complexity of address translation."
msgstr ""

#: ../../../gpu/i915:49: drivers/gpu/drm/i915/i915_vgpu.c:56
msgid "detect virtual GPU"
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:1582
#: ../../../gpu/i915:49: drivers/gpu/drm/i915/i915_vgpu.c:57
msgid "i915 device private"
msgstr ""

#: ../../../gpu/i915:49: drivers/gpu/drm/i915/i915_vgpu.c:58
msgid ""
"This function is called at the initialization stage, to detect whether "
"running on a vGPU."
msgstr ""

#: ../../../gpu/i915:49: drivers/gpu/drm/i915/i915_vgpu.c:166
msgid "deballoon reserved graphics address trunks"
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:455
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:508
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:572 ../../../gpu/i915:49:
#: drivers/gpu/drm/i915/i915_vgpu.c:172 drivers/gpu/drm/i915/i915_vgpu.c:216
msgid "``struct i915_ggtt *ggtt``"
msgstr ""

#: ../../../gpu/i915:49: drivers/gpu/drm/i915/i915_vgpu.c:167
msgid "the global GGTT from which we reserved earlier"
msgstr ""

#: ../../../gpu/i915:49: drivers/gpu/drm/i915/i915_vgpu.c:168
msgid ""
"This function is called to deallocate the ballooned-out graphic memory, when "
"driver is unloaded or when ballooning fails."
msgstr ""

#: ../../../gpu/i915:49: drivers/gpu/drm/i915/i915_vgpu.c:210
msgid "balloon out reserved graphics address trunks"
msgstr ""

#: ../../../gpu/i915:49: drivers/gpu/drm/i915/i915_vgpu.c:211
msgid "the global GGTT from which to reserve"
msgstr ""

#: ../../../gpu/i915:49: drivers/gpu/drm/i915/i915_vgpu.c:212
msgid ""
"This function is called at the initialization stage, to balloon out the "
"graphic address space allocated to other vGPUs, by marking these spaces as "
"reserved. The ballooning related knowledge(starting address and size of the "
"mappable/unmappable graphic memory) is described in the vgt_if structure in "
"a reserved mmio range."
msgstr ""

#: ../../../gpu/i915:49: drivers/gpu/drm/i915/i915_vgpu.c:218
msgid ""
"To give an example, the drawing below depicts one typical scenario after "
"ballooning. Here the vGPU1 has 2 pieces of graphic address spaces ballooned "
"out each for the mappable and the non-mappable part. From the vGPU1 point of "
"view, the total size is the same as the physical one, with the start address "
"of its graphic space being zero. Yet there are some portions ballooned "
"out( the shadow part, which are marked as reserved by drm allocator). From "
"the host point of view, the graphic address space is partitioned by multiple "
"vGPUs in different VMs. ::"
msgstr ""

#: ../../../gpu/i915:49: drivers/gpu/drm/i915/i915_vgpu.c:250
msgid "zero on success, non-zero if configuration invalid or ballooning failed"
msgstr ""

#: ../../../gpu/i915.rst:53
msgid "Intel GVT-g Host Support(vGPU device model)"
msgstr ""

#: ../../../gpu/i915:55: drivers/gpu/drm/i915/intel_gvt.c:34
msgid ""
"Intel GVT-g is a graphics virtualization technology which shares the GPU "
"among multiple virtual machines on a time-sharing basis. Each virtual "
"machine is presented a virtual GPU (vGPU), which has equivalent features as "
"the underlying physical GPU (pGPU), so i915 driver can run seamlessly in a "
"virtual machine."
msgstr ""

#: ../../../gpu/i915:55: drivers/gpu/drm/i915/intel_gvt.c:40
msgid ""
"To virtualize GPU resources GVT-g driver depends on hypervisor technology e."
"g KVM/VFIO/mdev, Xen, etc. to provide resource access trapping capability "
"and be virtualized within GVT-g device module. More architectural design doc "
"is available on https://github.com/intel/gvt-linux/wiki."
msgstr ""

#: ../../../gpu/i915:58: drivers/gpu/drm/i915/intel_gvt.c:228
msgid "initialize GVT components"
msgstr ""

#: ../../../gpu/i915:58: drivers/gpu/drm/i915/intel_gvt.c:229
msgid "drm i915 private data"
msgstr ""

#: ../../../gpu/i915:58: drivers/gpu/drm/i915/intel_gvt.c:230
msgid ""
"This function is called at the initialization stage to create a GVT device."
msgstr ""

#: ../../../gpu/i915:58: drivers/gpu/drm/i915/intel_gvt.c:233
msgid "Zero on success, negative error code if failed."
msgstr ""

#: ../../../gpu/i915:58: drivers/gpu/drm/i915/intel_gvt.c:252
msgid "cleanup GVT components when i915 driver is unbinding"
msgstr ""

#: ../../../gpu/i915:58: drivers/gpu/drm/i915/intel_gvt.c:254
#: drivers/gpu/drm/i915/intel_gvt.c:270
msgid "drm i915 private *"
msgstr ""

#: ../../../gpu/i915:58: drivers/gpu/drm/i915/intel_gvt.c:255
msgid ""
"This function is called at the i915 driver unloading stage, to shutdown GVT "
"components and release the related resources."
msgstr ""

#: ../../../gpu/i915:58: drivers/gpu/drm/i915/intel_gvt.c:268
msgid "GVT resume routine wrapper"
msgstr ""

#: ../../../gpu/i915:58: drivers/gpu/drm/i915/intel_gvt.c:271
msgid ""
"This function is called at the i915 driver resume stage to restore required "
"HW status for GVT so that vGPU can continue running after resumed."
msgstr ""

#: ../../../gpu/i915.rst:62
msgid "Workarounds"
msgstr ""

#: ../../../gpu/i915:64: drivers/gpu/drm/i915/gt/intel_workarounds.c:23
msgid ""
"Hardware workarounds are register programming documented to be executed in "
"the driver that fall outside of the normal programming sequences for a "
"platform. There are some basic categories of workarounds, depending on how/"
"when they are applied:"
msgstr ""

#: ../../../gpu/i915:64: drivers/gpu/drm/i915/gt/intel_workarounds.c:28
msgid ""
"Context workarounds: workarounds that touch registers that are saved/"
"restored to/from the HW context image. The list is emitted (via Load "
"Register Immediate commands) once when initializing the device and saved in "
"the default context. That default context is then used on every context "
"creation to have a \"primed golden context\", i.e. a context image that "
"already contains the changes needed to all the registers."
msgstr ""

#: ../../../gpu/i915:64: drivers/gpu/drm/i915/gt/intel_workarounds.c:35
msgid ""
"Context workarounds should be implemented in the \\*_ctx_workarounds_init() "
"variants respective to the targeted platforms."
msgstr ""

#: ../../../gpu/i915:64: drivers/gpu/drm/i915/gt/intel_workarounds.c:38
msgid ""
"Engine workarounds: the list of these WAs is applied whenever the specific "
"engine is reset. It's also possible that a set of engine classes share a "
"common power domain and they are reset together. This happens on some "
"platforms with render and compute engines. In this case (at least) one of "
"them need to keeep the workaround programming: the approach taken in the "
"driver is to tie those workarounds to the first compute/render engine that "
"is registered.  When executing with GuC submission, engine resets are "
"outside of kernel driver control, hence the list of registers involved in "
"written once, on engine initialization, and then passed to GuC, that saves/"
"restores their values before/after the reset takes place. See ``drivers/gpu/"
"drm/i915/gt/uc/intel_guc_ads.c`` for reference."
msgstr ""

#: ../../../gpu/i915:64: drivers/gpu/drm/i915/gt/intel_workarounds.c:50
msgid ""
"Workarounds for registers specific to RCS and CCS should be implemented in "
"rcs_engine_wa_init() and ccs_engine_wa_init(), respectively; those for "
"registers belonging to BCS, VCS or VECS should be implemented in "
"xcs_engine_wa_init(). Workarounds for registers not belonging to a specific "
"engine's MMIO range but that are part of of the common RCS/CCS reset domain "
"should be implemented in general_render_compute_wa_init(). The settings "
"about the CCS load balancing should be added in ccs_engine_wa_mode()."
msgstr ""

#: ../../../gpu/i915:64: drivers/gpu/drm/i915/gt/intel_workarounds.c:58
msgid ""
"GT workarounds: the list of these WAs is applied whenever these registers "
"revert to their default values: on GPU reset, suspend/resume [1]_, etc."
msgstr ""

#: ../../../gpu/i915:64: drivers/gpu/drm/i915/gt/intel_workarounds.c:61
msgid ""
"GT workarounds should be implemented in the \\*_gt_workarounds_init() "
"variants respective to the targeted platforms."
msgstr ""

#: ../../../gpu/i915:64: drivers/gpu/drm/i915/gt/intel_workarounds.c:64
msgid ""
"Register whitelist: some workarounds need to be implemented in userspace, "
"but need to touch privileged registers. The whitelist in the kernel "
"instructs the hardware to allow the access to happen. From the kernel side, "
"this is just a special case of a MMIO workaround (as we write the list of "
"these to/be-whitelisted registers to some special HW registers)."
msgstr ""

#: ../../../gpu/i915:64: drivers/gpu/drm/i915/gt/intel_workarounds.c:70
msgid ""
"Register whitelisting should be done in the \\*_whitelist_build() variants "
"respective to the targeted platforms."
msgstr ""

#: ../../../gpu/i915:64: drivers/gpu/drm/i915/gt/intel_workarounds.c:73
msgid ""
"Workaround batchbuffers: buffers that get executed automatically by the "
"hardware on every HW context restore. These buffers are created and "
"programmed in the default context so the hardware always go through those "
"programming sequences when switching contexts. The support for workaround "
"batchbuffers is enabled these hardware mechanisms:"
msgstr ""

#: ../../../gpu/i915:64: drivers/gpu/drm/i915/gt/intel_workarounds.c:79
msgid ""
"INDIRECT_CTX: A batchbuffer and an offset are provided in the default "
"context, pointing the hardware to jump to that location when that offset is "
"reached in the context restore. Workaround batchbuffer in the driver "
"currently uses this mechanism for all platforms."
msgstr ""

#: ../../../gpu/i915:64: drivers/gpu/drm/i915/gt/intel_workarounds.c:84
msgid ""
"BB_PER_CTX_PTR: A batchbuffer is provided in the default context, pointing "
"the hardware to a buffer to continue executing after the engine registers "
"are restored in a context restore sequence. This is currently not used in "
"the driver."
msgstr ""

#: ../../../gpu/i915:64: drivers/gpu/drm/i915/gt/intel_workarounds.c:89
msgid ""
"Other:  There are WAs that, due to their nature, cannot be applied from a "
"central place. Those are peppered around the rest of the code, as needed. "
"Workarounds related to the display IP are the main example."
msgstr ""

#: ../../../gpu/i915:64: drivers/gpu/drm/i915/gt/intel_workarounds.c:93
msgid ""
"Technically, some registers are powercontext saved & restored, so they "
"survive a suspend/resume. In practice, writing them again is not too costly "
"and simplifies things, so it's the approach taken in the driver."
msgstr ""

#: ../../../gpu/i915.rst:68
msgid "Display Hardware Handling"
msgstr ""

#: ../../../gpu/i915.rst:70
msgid ""
"This section covers everything related to the display hardware including the "
"mode setting infrastructure, plane, sprite and cursor handling and display, "
"output probing and related topics."
msgstr ""

#: ../../../gpu/i915.rst:75
msgid "Mode Setting Infrastructure"
msgstr ""

#: ../../../gpu/i915.rst:77
msgid ""
"The i915 driver is thus far the only DRM driver which doesn't use the common "
"DRM helper code to implement mode setting sequences. Thus it has its own "
"tailor-made infrastructure for executing a display configuration change."
msgstr ""

#: ../../../gpu/i915.rst:83
msgid "Frontbuffer Tracking"
msgstr ""

#: ../../../gpu/i915:85: drivers/gpu/drm/i915/display/intel_frontbuffer.c:28
msgid ""
"Many features require us to track changes to the currently active "
"frontbuffer, especially rendering targeted at the frontbuffer."
msgstr ""

#: ../../../gpu/i915:85: drivers/gpu/drm/i915/display/intel_frontbuffer.c:31
msgid ""
"To be able to do so we track frontbuffers using a bitmask for all possible "
"frontbuffer slots through intel_frontbuffer_track(). The functions in this "
"file are then called when the contents of the frontbuffer are invalidated, "
"when frontbuffer rendering has stopped again to flush out all the changes "
"and when the frontbuffer is exchanged with a flip. Subsystems interested in "
"frontbuffer changes (e.g. PSR, FBC, DRRS) should directly put their "
"callbacks into the relevant places and filter for the frontbuffer slots that "
"they are interested int."
msgstr ""

#: ../../../gpu/i915:85: drivers/gpu/drm/i915/display/intel_frontbuffer.c:40
msgid ""
"On a high level there are two types of powersaving features. The first one "
"work like a special cache (FBC and PSR) and are interested when they should "
"stop caching and when to restart caching. This is done by placing callbacks "
"into the invalidate and the flush functions: At invalidate the caching must "
"be stopped and at flush time it can be restarted. And maybe they need to "
"know when the frontbuffer changes (e.g. when the hw doesn't initiate an "
"invalidate and flush on its own) which can be achieved with placing "
"callbacks into the flip functions."
msgstr ""

#: ../../../gpu/i915:85: drivers/gpu/drm/i915/display/intel_frontbuffer.c:49
msgid ""
"The other type of display power saving feature only cares about busyness (e."
"g. DRRS). In that case all three (invalidate, flush and flip) indicate "
"busyness. There is no direct way to detect idleness. Instead an idle timer "
"work delayed work should be started from the flush and flip functions and "
"cancelled as soon as busyness is detected."
msgstr ""

#: ../../../gpu/i915:88: drivers/gpu/drm/i915/display/intel_frontbuffer.h:88
msgid "invalidate frontbuffer object"
msgstr ""

#: ../../../gpu/i915:88: drivers/gpu/drm/i915/display/intel_frontbuffer.h:94
#: drivers/gpu/drm/i915/display/intel_frontbuffer.h:125 ../../../gpu/i915:91:
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:228
msgid "``struct intel_frontbuffer *front``"
msgstr ""

#: ../../../gpu/i915:88: drivers/gpu/drm/i915/display/intel_frontbuffer.h:89
msgid "GEM object to invalidate"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3335
#: drivers/gpu/drm/i915/display/intel_psr.c:3437 ../../../gpu/i915:88:
#: drivers/gpu/drm/i915/display/intel_frontbuffer.h:91
#: drivers/gpu/drm/i915/display/intel_frontbuffer.h:122 ../../../gpu/i915:91:
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:77
msgid "``enum fb_op_origin origin``"
msgstr ""

#: ../../../gpu/i915:88: drivers/gpu/drm/i915/display/intel_frontbuffer.h:90
msgid "which operation caused the invalidation"
msgstr ""

#: ../../../gpu/i915:88: drivers/gpu/drm/i915/display/intel_frontbuffer.h:91
msgid ""
"This function gets called every time rendering on the given object starts "
"and frontbuffer caching (fbc, low refresh rate for DRRS, panel self refresh) "
"must be invalidated. For ORIGIN_CS any subsequent invalidation will be "
"delayed until the rendering completes or a flip on this frontbuffer plane is "
"scheduled."
msgstr ""

#: ../../../gpu/i915:88: drivers/gpu/drm/i915/display/intel_frontbuffer.h:119
msgid "flush frontbuffer object"
msgstr ""

#: ../../../gpu/i915:88: drivers/gpu/drm/i915/display/intel_frontbuffer.h:120
#: ../../../gpu/i915:91: drivers/gpu/drm/i915/display/intel_frontbuffer.c:223
msgid "GEM object to flush"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3436
#: ../../../gpu/i915:88: drivers/gpu/drm/i915/display/intel_frontbuffer.h:121
#: ../../../gpu/i915:91: drivers/gpu/drm/i915/display/intel_frontbuffer.c:76
msgid "which operation caused the flush"
msgstr ""

#: ../../../gpu/i915:88: drivers/gpu/drm/i915/display/intel_frontbuffer.h:122
msgid ""
"This function gets called every time rendering on the given object has "
"completed and frontbuffer caching can be started again."
msgstr ""

#: ../../../gpu/i915:91: drivers/gpu/drm/i915/display/intel_frontbuffer.c:73
msgid "flush frontbuffer"
msgstr ""

#: ../../../gpu/i915:100:
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:284
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:313
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:362
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:394
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:414
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:442
#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:130
#: drivers/gpu/drm/i915/display/intel_hotplug.c:578
#: drivers/gpu/drm/i915/display/intel_hotplug.c:711
#: drivers/gpu/drm/i915/display/intel_hotplug.c:856
#: drivers/gpu/drm/i915/display/intel_hotplug.c:891 ../../../gpu/i915:150:
#: drivers/gpu/drm/i915/display/intel_audio.c:898
#: drivers/gpu/drm/i915/display/intel_audio.c:1324
#: drivers/gpu/drm/i915/display/intel_audio.c:1385
#: drivers/gpu/drm/i915/display/intel_audio.c:1401
#: drivers/gpu/drm/i915/display/intel_audio.c:1419 ../../../gpu/i915:162:
#: drivers/gpu/drm/i915/display/intel_lpe_audio.c:259
#: drivers/gpu/drm/i915/display/intel_lpe_audio.c:279
#: drivers/gpu/drm/i915/display/intel_lpe_audio.c:300
#: drivers/gpu/drm/i915/display/intel_lpe_audio.c:320 ../../../gpu/i915:171:
#: drivers/gpu/drm/i915/display/intel_psr.c:3337
#: drivers/gpu/drm/i915/display/intel_psr.c:3439
#: drivers/gpu/drm/i915/display/intel_psr.c:3804
#: drivers/gpu/drm/i915/display/intel_psr.c:3820
#: drivers/gpu/drm/i915/display/intel_psr.c:3889 ../../../gpu/i915:180:
#: drivers/gpu/drm/i915/display/intel_fbc.c:2033
#: drivers/gpu/drm/i915/display/intel_fbc.c:2114
#: drivers/gpu/drm/i915/display/intel_fbc.c:2132 ../../../gpu/i915:189:
#: drivers/gpu/drm/i915/display/intel_drrs.c:269
#: drivers/gpu/drm/i915/display/intel_drrs.c:285 ../../../gpu/i915:204:
#: drivers/gpu/drm/i915/display/intel_dmc.c:813
#: drivers/gpu/drm/i915/display/intel_dmc.c:830
#: drivers/gpu/drm/i915/display/intel_dmc.c:848
#: drivers/gpu/drm/i915/display/intel_dmc.c:887
#: drivers/gpu/drm/i915/display/intel_dmc.c:1316
#: drivers/gpu/drm/i915/display/intel_dmc.c:1375
#: drivers/gpu/drm/i915/display/intel_dmc.c:1409
#: drivers/gpu/drm/i915/display/intel_dmc.c:1429 ../../../gpu/i915:225:
#: drivers/gpu/drm/i915/display/intel_bios.c:3006
#: drivers/gpu/drm/i915/display/intel_bios.c:3177
#: drivers/gpu/drm/i915/display/intel_bios.c:3287
#: drivers/gpu/drm/i915/display/intel_bios.c:3325
#: drivers/gpu/drm/i915/display/intel_bios.c:3366
#: drivers/gpu/drm/i915/display/intel_bios.c:3414
#: drivers/gpu/drm/i915/display/intel_bios.c:3463 ../../../gpu/i915:237:
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2347
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2364
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2459
#: drivers/gpu/drm/i915/display/intel_cdclk.c:3425
#: drivers/gpu/drm/i915/display/intel_cdclk.c:3508
#: drivers/gpu/drm/i915/display/intel_cdclk.c:3590
#: drivers/gpu/drm/i915/display/intel_cdclk.c:3787 ../../../gpu/i915:246:
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:160
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4316
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4490
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4508
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4592
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4614 ../../../gpu/i915:91:
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:79
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:112
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:134
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:157
msgid "``struct intel_display *display``"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:125
#: drivers/gpu/drm/i915/display/intel_hotplug.c:573 ../../../gpu/i915:150:
#: drivers/gpu/drm/i915/display/intel_audio.c:893
#: drivers/gpu/drm/i915/display/intel_audio.c:1319
#: drivers/gpu/drm/i915/display/intel_audio.c:1380
#: drivers/gpu/drm/i915/display/intel_audio.c:1397
#: drivers/gpu/drm/i915/display/intel_audio.c:1414 ../../../gpu/i915:162:
#: drivers/gpu/drm/i915/display/intel_lpe_audio.c:254
#: drivers/gpu/drm/i915/display/intel_lpe_audio.c:275
#: drivers/gpu/drm/i915/display/intel_lpe_audio.c:296
#: drivers/gpu/drm/i915/display/intel_lpe_audio.c:316 ../../../gpu/i915:171:
#: drivers/gpu/drm/i915/display/intel_psr.c:3332
#: drivers/gpu/drm/i915/display/intel_psr.c:3434 ../../../gpu/i915:189:
#: drivers/gpu/drm/i915/display/intel_drrs.c:264
#: drivers/gpu/drm/i915/display/intel_drrs.c:280 ../../../gpu/i915:225:
#: drivers/gpu/drm/i915/display/intel_bios.c:3001 ../../../gpu/i915:91:
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:74
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:107
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:129
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:152
msgid "display device"
msgstr ""

#: ../../../gpu/i915:189: drivers/gpu/drm/i915/display/intel_drrs.c:266
#: drivers/gpu/drm/i915/display/intel_drrs.c:282 ../../../gpu/i915:91:
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:76
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:319
msgid "``unsigned int frontbuffer_bits``"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3333
#: drivers/gpu/drm/i915/display/intel_psr.c:3435 ../../../gpu/i915:189:
#: drivers/gpu/drm/i915/display/intel_drrs.c:265
#: drivers/gpu/drm/i915/display/intel_drrs.c:281 ../../../gpu/i915:91:
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:75
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:108
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:130
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:153
msgid "frontbuffer plane tracking bits"
msgstr ""

#: ../../../gpu/i915:91: drivers/gpu/drm/i915/display/intel_frontbuffer.c:77
msgid ""
"This function gets called every time rendering on the given planes has "
"completed and frontbuffer caching can be started again. Flushes will get "
"delayed if they're blocked by some outstanding asynchronous rendering."
msgstr ""

#: ../../../gpu/i915:91: drivers/gpu/drm/i915/display/intel_frontbuffer.c:81
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:114
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:134
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:158
msgid "Can be called without any locks held."
msgstr ""

#: ../../../gpu/i915:91: drivers/gpu/drm/i915/display/intel_frontbuffer.c:106
msgid "prepare asynchronous frontbuffer flip"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3334
#: drivers/gpu/drm/i915/display/intel_psr.c:3436 ../../../gpu/i915:91:
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:109
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:131
#: drivers/gpu/drm/i915/display/intel_frontbuffer.c:154
msgid "``unsigned frontbuffer_bits``"
msgstr ""

#: ../../../gpu/i915:91: drivers/gpu/drm/i915/display/intel_frontbuffer.c:109
msgid ""
"This function gets called after scheduling a flip on **obj**. The actual "
"frontbuffer flushing will be delayed until completion is signalled with "
"intel_frontbuffer_flip_complete. If an invalidate happens in between this "
"flush will be cancelled."
msgstr ""

#: ../../../gpu/i915:91: drivers/gpu/drm/i915/display/intel_frontbuffer.c:128
msgid "complete asynchronous frontbuffer flip"
msgstr ""

#: ../../../gpu/i915:91: drivers/gpu/drm/i915/display/intel_frontbuffer.c:131
msgid ""
"This function gets called after the flip has been latched and will complete "
"on the next vblank. It will execute the flush if it hasn't been cancelled "
"yet."
msgstr ""

#: ../../../gpu/i915:91: drivers/gpu/drm/i915/display/intel_frontbuffer.c:151
msgid "synchronous frontbuffer flip"
msgstr ""

#: ../../../gpu/i915:91: drivers/gpu/drm/i915/display/intel_frontbuffer.c:154
msgid ""
"This function gets called after scheduling a flip on **obj**. This is for "
"synchronous plane updates which will happen on the next vblank and which "
"will not get delayed by pending gpu rendering."
msgstr ""

#: ../../../gpu/i915:91: drivers/gpu/drm/i915/display/intel_frontbuffer.c:222
msgid "queue flushing frontbuffer object"
msgstr ""

#: ../../../gpu/i915:91: drivers/gpu/drm/i915/display/intel_frontbuffer.c:224
msgid ""
"This function is targeted for our dirty callback for queueing flush when dma "
"fence is signals"
msgstr ""

#: ../../../gpu/i915:91: drivers/gpu/drm/i915/display/intel_frontbuffer.c:315
msgid "update frontbuffer tracking"
msgstr ""

#: ../../../gpu/i915:91: drivers/gpu/drm/i915/display/intel_frontbuffer.c:321
msgid "``struct intel_frontbuffer *old``"
msgstr ""

#: ../../../gpu/i915:91: drivers/gpu/drm/i915/display/intel_frontbuffer.c:316
msgid "current buffer for the frontbuffer slots"
msgstr ""

#: ../../../gpu/i915:91: drivers/gpu/drm/i915/display/intel_frontbuffer.c:318
msgid "``struct intel_frontbuffer *new``"
msgstr ""

#: ../../../gpu/i915:91: drivers/gpu/drm/i915/display/intel_frontbuffer.c:317
msgid "new buffer for the frontbuffer slots"
msgstr ""

#: ../../../gpu/i915:91: drivers/gpu/drm/i915/display/intel_frontbuffer.c:318
msgid "bitmask of frontbuffer slots"
msgstr ""

#: ../../../gpu/i915:91: drivers/gpu/drm/i915/display/intel_frontbuffer.c:319
msgid ""
"This updates the frontbuffer tracking bits **frontbuffer_bits** by clearing "
"them from **old** and setting them in **new**. Both **old** and **new** can "
"be NULL."
msgstr ""

#: ../../../gpu/i915.rst:95
msgid "Display FIFO Underrun Reporting"
msgstr ""

#: ../../../gpu/i915:97: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:41
msgid ""
"The i915 driver checks for display fifo underruns using the interrupt "
"signals provided by the hardware. This is enabled by default and fairly "
"useful to debug display issues, especially watermark settings."
msgstr ""

#: ../../../gpu/i915:97: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:45
msgid ""
"If an underrun is detected this is logged into dmesg. To avoid flooding logs "
"and occupying the cpu underrun interrupts are disabled after the first "
"occurrence until the next modeset on a given pipe."
msgstr ""

#: ../../../gpu/i915:97: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:49
msgid ""
"Note that underrun detection on gmch platforms is a bit more ugly since "
"there is no interrupt (despite that the signalling bit is in the PIPESTAT "
"pipe interrupt register). Also on some other platforms underrun interrupts "
"are shared, which means that if we detect an underrun we need to disable "
"underrun reporting on all pipes."
msgstr ""

#: ../../../gpu/i915:97: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:55
msgid "The code also supports underrun detection on the PCH transcoder."
msgstr ""

#: ../../../gpu/i915:100:
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:278
msgid "set cpu fifo underrun reporting state"
msgstr ""

#: ../../../gpu/i915:100:
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:279
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:308
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:357
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:389
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:409
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:437
#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:706
#: drivers/gpu/drm/i915/display/intel_hotplug.c:851
#: drivers/gpu/drm/i915/display/intel_hotplug.c:886 ../../../gpu/i915:225:
#: drivers/gpu/drm/i915/display/intel_bios.c:3172
#: drivers/gpu/drm/i915/display/intel_bios.c:3282
#: drivers/gpu/drm/i915/display/intel_bios.c:3320
#: drivers/gpu/drm/i915/display/intel_bios.c:3361
#: drivers/gpu/drm/i915/display/intel_bios.c:3409
#: drivers/gpu/drm/i915/display/intel_bios.c:3458
msgid "display device instance"
msgstr ""

#: ../../../gpu/i915:100:
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:281
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:359
#: ../../../gpu/i915:204: drivers/gpu/drm/i915/display/intel_dmc.c:810
#: drivers/gpu/drm/i915/display/intel_dmc.c:828
msgid "``enum pipe pipe``"
msgstr ""

#: ../../../gpu/i915:100:
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:280
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:358
msgid "(CPU) pipe to set state for"
msgstr ""

#: ../../../gpu/i915:100:
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:282
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:311
#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3834
#: drivers/gpu/drm/i915/display/intel_psr.c:3886 ../../../gpu/i915:204:
#: drivers/gpu/drm/i915/display/intel_dmc.c:829
msgid "``bool enable``"
msgstr ""

#: ../../../gpu/i915:100:
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:281
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:310
msgid "whether underruns should be reported or not"
msgstr ""

#: ../../../gpu/i915:100:
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:282
msgid ""
"This function sets the fifo underrun state for **pipe**. It is used in the "
"modeset code to avoid false positives since on many platforms underruns are "
"expected when disabling or enabling the pipe."
msgstr ""

#: ../../../gpu/i915:100:
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:286
msgid ""
"Notice that on some platforms disabling underrun reports for one pipe "
"disables for all due to shared interrupts. Actual reporting is still per-"
"pipe though."
msgstr ""

#: ../../../gpu/i915:100:
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:290
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:317
msgid "Returns the previous state of underrun reporting."
msgstr ""

#: ../../../gpu/i915:100:
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:307
msgid "set PCH fifo underrun reporting state"
msgstr ""

#: ../../../gpu/i915:100:
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:310
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:391
msgid "``enum pipe pch_transcoder``"
msgstr ""

#: ../../../gpu/i915:100:
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:309
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:390
msgid "the PCH transcoder (same as pipe on IVB and older)"
msgstr ""

#: ../../../gpu/i915:100:
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:311
msgid ""
"This function makes us disable or enable PCH fifo underruns for a specific "
"PCH transcoder. Notice that on some PCHs (e.g. CPT/PPT), disabling FIFO "
"underrun reporting for one transcoder may also disable all the other PCH "
"error interruts for the other transcoders, due to the fact that there's just "
"one interrupt mask/enable bit for all the transcoders."
msgstr ""

#: ../../../gpu/i915:100:
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:356
msgid "handle CPU fifo underrun interrupt"
msgstr ""

#: ../../../gpu/i915:100:
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:359
msgid ""
"This handles a CPU fifo underrun interrupt, generating an underrun warning "
"into dmesg if underrun reporting is enabled and then disables the underrun "
"interrupt to avoid an irq storm."
msgstr ""

#: ../../../gpu/i915:100:
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:388
msgid "handle PCH fifo underrun interrupt"
msgstr ""

#: ../../../gpu/i915:100:
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:391
msgid ""
"This handles a PCH fifo underrun interrupt, generating an underrun warning "
"into dmesg if underrun reporting is enabled and then disables the underrun "
"interrupt to avoid an irq storm."
msgstr ""

#: ../../../gpu/i915:100:
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:408
msgid "check for CPU fifo underruns immediately"
msgstr ""

#: ../../../gpu/i915:100:
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:410
msgid ""
"Check for CPU fifo underruns immediately. Useful on IVB/HSW where the shared "
"error interrupt may have been disabled, and so CPU fifo underruns won't "
"necessarily raise an interrupt, and on GMCH platforms where underruns never "
"raise an interrupt."
msgstr ""

#: ../../../gpu/i915:100:
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:436
msgid "check for PCH fifo underruns immediately"
msgstr ""

#: ../../../gpu/i915:100:
#: drivers/gpu/drm/i915/display/intel_fifo_underrun.c:438
msgid ""
"Check for PCH fifo underruns immediately. Useful on CPT/PPT where the shared "
"error interrupt may have been disabled, and so PCH fifo underruns won't "
"necessarily raise an interrupt."
msgstr ""

#: ../../../gpu/i915.rst:104
msgid "Plane Configuration"
msgstr ""

#: ../../../gpu/i915.rst:106
msgid ""
"This section covers plane configuration and composition with the primary "
"plane, sprites, cursors and overlays. This includes the infrastructure to do "
"atomic vsync'ed updates of all this state and also tightly coupled topics "
"like watermark setup and computation, framebuffer compression and panel self "
"refresh."
msgstr ""

#: ../../../gpu/i915.rst:113
msgid "Atomic Plane Helpers"
msgstr ""

#: ../../../gpu/i915:115: drivers/gpu/drm/i915/display/intel_plane.c:25
msgid ""
"The functions here are used by the atomic plane helper functions to "
"implement legacy plane updates (i.e., drm_plane->update_plane() and "
"drm_plane->disable_plane()).  This allows plane updates to use the atomic "
"state infrastructure and perform plane updates as separate prepare/check/"
"commit/cleanup steps."
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:104
msgid "destroy a plane"
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:110
#: drivers/gpu/drm/i915/display/intel_plane.c:123
#: drivers/gpu/drm/i915/display/intel_plane.c:157
#: drivers/gpu/drm/i915/display/intel_plane.c:1256
msgid "``struct drm_plane *plane``"
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:105
msgid "plane to destroy"
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:106
msgid ""
"Common destruction function for all types of planes (primary, cursor, "
"sprite)."
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:117
msgid "duplicate plane state"
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:118
#: drivers/gpu/drm/i915/display/intel_plane.c:152
msgid "drm plane"
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:119
msgid ""
"Allocates and returns a copy of the plane state (both common and Intel-"
"specific) for the specified plane."
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:123
msgid "The newly allocated plane state, or NULL on failure."
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:151
msgid "destroy plane state"
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:154
msgid "``struct drm_plane_state *state``"
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:153
msgid "state object to destroy"
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:154
msgid ""
"Destroys the plane state (both common and Intel-specific) for the specified "
"plane."
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:1160
msgid "Prepare fb for usage on plane"
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:1166
msgid "``struct drm_plane *_plane``"
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:1161
msgid "drm plane to prepare for"
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:1163
msgid "``struct drm_plane_state *_new_plane_state``"
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:1162
msgid "the plane state being prepared"
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:1163
msgid ""
"Prepares a framebuffer for usage on a display plane.  Generally this "
"involves pinning the underlying object and updating the frontbuffer tracking "
"bits.  Some older platforms need special physical address handling for "
"cursor planes."
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:1168
msgid "Returns 0 on success, negative error code on failure."
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:1250
msgid "Cleans up an fb after plane use"
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:1251
msgid "drm plane to clean up for"
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:1253
msgid "``struct drm_plane_state *_old_plane_state``"
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:1252
msgid "the state from the previous modeset"
msgstr ""

#: ../../../gpu/i915:118: drivers/gpu/drm/i915/display/intel_plane.c:1253
msgid "Cleans up a framebuffer that has just been removed from a plane."
msgstr ""

#: ../../../gpu/i915.rst:122
msgid "Asynchronous Page Flip"
msgstr ""

#: ../../../gpu/i915:124: drivers/gpu/drm/i915/display/intel_display.c:5911
msgid ""
"Asynchronous page flip is the implementation for the "
"DRM_MODE_PAGE_FLIP_ASYNC flag. Currently async flip is only supported via "
"the drmModePageFlip IOCTL. Correspondingly, support is currently added for "
"primary plane only."
msgstr ""

#: ../../../gpu/i915:124: drivers/gpu/drm/i915/display/intel_display.c:5915
msgid ""
"Async flip can only change the plane surface address, so anything else "
"changing is rejected from the intel_async_flip_check_hw() function. Once "
"this check is cleared, flip done interrupt is enabled using the "
"intel_crtc_enable_flip_done() function."
msgstr ""

#: ../../../gpu/i915:124: drivers/gpu/drm/i915/display/intel_display.c:5920
msgid ""
"As soon as the surface address register is written, flip done interrupt is "
"generated and the requested events are sent to the userspace in the "
"interrupt handler itself. The timestamp and sequence sent during the flip "
"done event correspond to the last vblank and have no relation to the actual "
"time when the flip done event was sent."
msgstr ""

#: ../../../gpu/i915.rst:128
msgid "Output Probing"
msgstr ""

#: ../../../gpu/i915.rst:130
msgid ""
"This section covers output probing and related infrastructure like the "
"hotplug interrupt storm detection and mitigation code. Note that the i915 "
"driver still uses most of the common DRM helper code for output probing, so "
"those sections fully apply."
msgstr ""

#: ../../../gpu/i915.rst:136
msgid "Hotplug"
msgstr ""

#: ../../../gpu/i915:138: drivers/gpu/drm/i915/display/intel_hotplug.c:43
msgid ""
"Simply put, hotplug occurs when a display is connected to or disconnected "
"from the system. However, there may be adapters and docking stations and "
"Display Port short pulses and MST devices involved, complicating matters."
msgstr ""

#: ../../../gpu/i915:138: drivers/gpu/drm/i915/display/intel_hotplug.c:47
msgid "Hotplug in i915 is handled in many different levels of abstraction."
msgstr ""

#: ../../../gpu/i915:138: drivers/gpu/drm/i915/display/intel_hotplug.c:49
msgid ""
"The platform dependent interrupt handling code in i915_irq.c enables, "
"disables, and does preliminary handling of the interrupts. The interrupt "
"handlers gather the hotplug detect (HPD) information from relevant registers "
"into a platform independent mask of hotplug pins that have fired."
msgstr ""

#: ../../../gpu/i915:138: drivers/gpu/drm/i915/display/intel_hotplug.c:54
msgid ""
"The platform independent interrupt handler intel_hpd_irq_handler() in "
"intel_hotplug.c does hotplug irq storm detection and mitigation, and passes "
"further processing to appropriate bottom halves (Display Port specific and "
"regular hotplug)."
msgstr ""

#: ../../../gpu/i915:138: drivers/gpu/drm/i915/display/intel_hotplug.c:59
msgid ""
"The Display Port work function i915_digport_work_func() calls into "
"intel_dp_hpd_pulse() via hooks, which handles DP short pulses and DP MST "
"long pulses, with failures and non-MST long pulses triggering regular "
"hotplug processing on the connector."
msgstr ""

#: ../../../gpu/i915:138: drivers/gpu/drm/i915/display/intel_hotplug.c:64
msgid ""
"The regular hotplug work function i915_hotplug_work_func() calls connector "
"detect hooks, and, if connector status changes, triggers sending of hotplug "
"uevent to userspace via drm_kms_helper_hotplug_event()."
msgstr ""

#: ../../../gpu/i915:138: drivers/gpu/drm/i915/display/intel_hotplug.c:68
msgid ""
"Finally, the userspace is responsible for triggering a modeset upon "
"receiving the hotplug uevent, disabling or enabling the crtc as needed."
msgstr ""

#: ../../../gpu/i915:138: drivers/gpu/drm/i915/display/intel_hotplug.c:71
msgid ""
"The hotplug interrupt storm detection and mitigation code keeps track of the "
"number of interrupts per hotplug pin per a period of time, and if the number "
"of interrupts exceeds a certain threshold, the interrupt is disabled for a "
"while before being re-enabled. The intention is to mitigate issues raising "
"from broken hardware triggering massive amounts of interrupts and grinding "
"the system to a halt."
msgstr ""

#: ../../../gpu/i915:138: drivers/gpu/drm/i915/display/intel_hotplug.c:78
msgid ""
"Current implementation expects that hotplug interrupt storm will not be seen "
"when display port sink is connected, hence on platforms whose DP callback is "
"handled by i915_digport_work_func reenabling of hpd is not performed (it was "
"never expected to be disabled in the first place ;) ) this is specific to DP "
"sinks handled by this routine and any other display such as HDMI or DVI "
"enabled on the same port will have proper logic since it will use "
"i915_hotplug_work_func where this logic is handled."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:90
msgid "return default pin associated with certain port."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:96
#: ../../../gpu/i915:162: drivers/gpu/drm/i915/display/intel_lpe_audio.c:319
#: ../../../gpu/i915:225: drivers/gpu/drm/i915/display/intel_bios.c:3411
msgid "``enum port port``"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:91
msgid "the hpd port to get associated pin"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:92
msgid "It is only valid and used by digital port encoder."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:94
msgid "Return pin that is associatade with **port**."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:124
msgid "gather stats and detect HPD IRQ storm on a pin"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:127
msgid "``enum hpd_pin pin``"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:126
msgid "the pin to gather stats on"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:128
msgid "``bool long_hpd``"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:127
msgid "whether the HPD IRQ was long or short"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:128
msgid ""
"Gather stats about HPD IRQs from the specified **pin**, and detect IRQ "
"storms. Only the pin specific stats and state are changed, the caller is "
"responsible for further action."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:132
msgid ""
"The number of IRQs that are allowed within **HPD_STORM_DETECT_PERIOD** is "
"stored in **display->hotplug.hpd_storm_threshold** which defaults to "
"**HPD_STORM_DEFAULT_THRESHOLD**. Long IRQs count as +10 to this threshold, "
"and short IRQs count as +1. If this threshold is exceeded, it's considered "
"an IRQ storm and the IRQ state is set to **HPD_MARK_DISABLED**."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:138
msgid ""
"By default, most systems will only count long IRQs towards :c:type:`display-"
">hotplug <display>`.hpd_storm_threshold. However, some older systems also "
"suffer from short IRQ storms and must also track these. Because short IRQ "
"storms are naturally caused by sideband interactions with DP MST devices, "
"short IRQ detection is only enabled for systems without DP MST support. "
"Systems which are new enough to support DP MST are far less likely to suffer "
"from IRQ storms at all, so this is fine."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:146
msgid ""
"The HPD threshold can be controlled through i915_hpd_storm_ctl in debugfs, "
"and should only be adjusted for automated hotplug testing."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:149
msgid "Return true if an IRQ storm was detected on **pin**."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:444
msgid "trigger an hpd irq event for a port"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:450
msgid "``struct intel_digital_port *dig_port``"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:445
msgid "digital port"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:446
msgid ""
"Trigger an HPD interrupt event for the given port, emulating a short pulse "
"generated by the sink, and schedule the dig port work to handle it."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:572
msgid "main hotplug irq handler"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:575
msgid "``u32 pin_mask``"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:574
msgid "a mask of hpd pins that have triggered the irq"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:576
msgid "``u32 long_mask``"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:575
msgid "a mask of hpd pins that may be long hpd pulses"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:576
msgid ""
"This is the main hotplug irq handler for all platforms. The platform "
"specific irq handlers call the platform specific hotplug irq handlers, which "
"read and decode the appropriate registers into bitmasks about hpd pins that "
"have triggered (**pin_mask**), and which of those pins may be long pulses "
"(**long_mask**). The **long_mask** is ignored if the port corresponding to "
"the pin is not a digital port."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:583
msgid ""
"Here, we do hotplug irq storm detection and mitigation, and pass further "
"processing to appropriate bottom halves."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:705
msgid "initializes and enables hpd support"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:707
msgid ""
"This function enables the hotplug support. It requires that interrupts have "
"already been enabled with intel_irq_init_hw(). From this point on hotplug "
"and poll request can run concurrently to other code, so locking rules must "
"be obeyed."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:712
msgid ""
"This is a separate step from interrupt enabling to simplify the locking "
"rules in the driver load and resume code."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:715
msgid "Also see: intel_hpd_poll_enable() and intel_hpd_poll_disable()."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:850
msgid "enable polling for connectors with hpd"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:852
msgid ""
"This function enables polling for all connectors which support HPD. Under "
"certain conditions HPD may not be functional. On most Intel GPUs, this "
"happens when we enter runtime suspend. On Valleyview and Cherryview systems, "
"this also happens when we shut off all of the powerwells."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:858
#: drivers/gpu/drm/i915/display/intel_hotplug.c:893
msgid ""
"Since this function can get called in contexts where we're already holding "
"dev->mode_config.mutex, we do the actual hotplug enabling in a separate "
"worker."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:862
msgid "Also see: intel_hpd_init() and intel_hpd_poll_disable()."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:885
msgid "disable polling for connectors with hpd"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:887
msgid ""
"This function disables polling for all connectors which support HPD. Under "
"certain conditions HPD may not be functional. On most Intel GPUs, this "
"happens when we enter runtime suspend. On Valleyview and Cherryview systems, "
"this also happens when we shut off all of the powerwells."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:897
msgid ""
"Also used during driver init to initialize connector->polled appropriately "
"for all connectors."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:900
msgid "Also see: intel_hpd_init() and intel_hpd_poll_enable()."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:1051
msgid "Block handling of HPD IRQs on an HPD pin"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:1057
#: drivers/gpu/drm/i915/display/intel_hotplug.c:1101
#: drivers/gpu/drm/i915/display/intel_hotplug.c:1125 ../../../gpu/i915:150:
#: drivers/gpu/drm/i915/display/intel_audio.c:735
#: drivers/gpu/drm/i915/display/intel_audio.c:795 ../../../gpu/i915:246:
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4376
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4403
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4465
msgid "``struct intel_encoder *encoder``"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:1052
msgid "Encoder to block the HPD handling for"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:1053
msgid "Blocks the handling of HPD IRQs on the HPD pin of **encoder**."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:1055
msgid "On return:"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:1057
msgid ""
"It's guaranteed that the blocked encoders' HPD pulse handler (via "
"intel_digital_port::hpd_pulse()) is not running."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:1059
msgid ""
"The hotplug event handling (via intel_encoder::hotplug()) of an HPD IRQ "
"pending at the time this function is called may be still running."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:1062
msgid ""
"Detection on the encoder's connector (via drm_connector_helper_funcs::"
"detect_ctx(), drm_connector_funcs::detect()) remains allowed, for instance "
"as part of userspace connector probing, or DRM core's connector polling."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:1067
msgid ""
"The call must be followed by calling intel_hpd_unblock(), or "
"intel_hpd_clear_and_unblock()."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:1070
msgid ""
"Note that the handling of HPD IRQs for another encoder using the same HPD "
"pin as that of **encoder** will be also blocked."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:1095
msgid "Unblock handling of HPD IRQs on an HPD pin"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:1096
#: drivers/gpu/drm/i915/display/intel_hotplug.c:1120
msgid "Encoder to unblock the HPD handling for"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:1097
msgid ""
"Unblock the handling of HPD IRQs on the HPD pin of **encoder**, which was "
"previously blocked by intel_hpd_block(). Any HPD IRQ raised on the HPD pin "
"while it was blocked will be handled for **encoder** and for any other "
"encoder sharing the same HPD pin."
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:1119
msgid "Unblock handling of new HPD IRQs on an HPD pin"
msgstr ""

#: ../../../gpu/i915:141: drivers/gpu/drm/i915/display/intel_hotplug.c:1121
msgid ""
"Unblock the handling of HPD IRQs on the HPD pin of **encoder**, which was "
"previously blocked by intel_hpd_block(). Any HPD IRQ raised on the HPD pin "
"while it was blocked will be cleared, handling only new IRQs."
msgstr ""

#: ../../../gpu/i915.rst:145
msgid "High Definition Audio"
msgstr ""

#: ../../../gpu/i915:147: drivers/gpu/drm/i915/display/intel_audio.c:43
msgid ""
"The graphics and audio drivers together support High Definition Audio over "
"HDMI and Display Port. The audio programming sequences are divided into "
"audio codec and controller enable and disable sequences. The graphics driver "
"handles the audio codec sequences, while the audio driver handles the audio "
"controller sequences."
msgstr ""

#: ../../../gpu/i915:147: drivers/gpu/drm/i915/display/intel_audio.c:49
msgid ""
"The disable sequences must be performed before disabling the transcoder or "
"port. The enable sequences may only be performed after enabling the "
"transcoder and port, and after completed link training. Therefore the audio "
"enable/disable sequences are part of the modeset sequence."
msgstr ""

#: ../../../gpu/i915:147: drivers/gpu/drm/i915/display/intel_audio.c:54
msgid ""
"The codec and controller sequences could be done either parallel or serial, "
"but generally the ELDV/PD change in the codec sequence indicates to the "
"audio driver that the controller sequence should start. Indeed, most of the "
"co-operation between the graphics and audio drivers is handled via audio "
"related registers. (The notable exception is the power management, not "
"covered here.)"
msgstr ""

#: ../../../gpu/i915:147: drivers/gpu/drm/i915/display/intel_audio.c:61
msgid ""
"The struct :c:type:`i915_audio_component` is used to interact between the "
"graphics and audio drivers. The struct :c:type:`i915_audio_component_ops` "
"**ops** in it is defined in graphics driver and called in audio driver. The "
"struct :c:type:`i915_audio_component_audio_ops` **audio_ops** is called from "
"i915 driver."
msgstr ""

#: ../../../gpu/i915:150: drivers/gpu/drm/i915/display/intel_audio.c:729
msgid "Enable the audio codec for HD audio"
msgstr ""

#: ../../../gpu/i915:150: drivers/gpu/drm/i915/display/intel_audio.c:730
msgid "encoder on which to enable audio"
msgstr ""

#: ../../../gpu/i915:150: drivers/gpu/drm/i915/display/intel_audio.c:732
#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2308
#: drivers/gpu/drm/i915/display/intel_psr.c:2369
#: drivers/gpu/drm/i915/display/intel_psr.c:3717
#: drivers/gpu/drm/i915/display/intel_psr.c:3742 ../../../gpu/i915:189:
#: drivers/gpu/drm/i915/display/intel_drrs.c:154 ../../../gpu/i915:246:
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:259
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:305
msgid "``const struct intel_crtc_state *crtc_state``"
msgstr ""

#: ../../../gpu/i915:150: drivers/gpu/drm/i915/display/intel_audio.c:731
msgid "pointer to the current crtc state."
msgstr ""

#: ../../../gpu/i915:150: drivers/gpu/drm/i915/display/intel_audio.c:733
msgid "``const struct drm_connector_state *conn_state``"
msgstr ""

#: ../../../gpu/i915:150: drivers/gpu/drm/i915/display/intel_audio.c:732
msgid "pointer to the current connector state."
msgstr ""

#: ../../../gpu/i915:150: drivers/gpu/drm/i915/display/intel_audio.c:733
msgid ""
"The enable sequences may only be performed after enabling the transcoder and "
"port, and after completed link training."
msgstr ""

#: ../../../gpu/i915:150: drivers/gpu/drm/i915/display/intel_audio.c:789
msgid "Disable the audio codec for HD audio"
msgstr ""

#: ../../../gpu/i915:150: drivers/gpu/drm/i915/display/intel_audio.c:790
msgid "encoder on which to disable audio"
msgstr ""

#: ../../../gpu/i915:150: drivers/gpu/drm/i915/display/intel_audio.c:792
#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2213
#: ../../../gpu/i915:189: drivers/gpu/drm/i915/display/intel_drrs.c:186
msgid "``const struct intel_crtc_state *old_crtc_state``"
msgstr ""

#: ../../../gpu/i915:150: drivers/gpu/drm/i915/display/intel_audio.c:791
msgid "pointer to the old crtc state."
msgstr ""

#: ../../../gpu/i915:150: drivers/gpu/drm/i915/display/intel_audio.c:793
msgid "``const struct drm_connector_state *old_conn_state``"
msgstr ""

#: ../../../gpu/i915:150: drivers/gpu/drm/i915/display/intel_audio.c:792
msgid "pointer to the old connector state."
msgstr ""

#: ../../../gpu/i915:150: drivers/gpu/drm/i915/display/intel_audio.c:793
msgid ""
"The disable sequences must be performed before disabling the transcoder or "
"port."
msgstr ""

#: ../../../gpu/i915:150: drivers/gpu/drm/i915/display/intel_audio.c:892
msgid "Set up chip specific audio hooks"
msgstr ""

#: ../../../gpu/i915:150: drivers/gpu/drm/i915/display/intel_audio.c:1318
msgid "initialize and register the audio component"
msgstr ""

#: ../../../gpu/i915:150: drivers/gpu/drm/i915/display/intel_audio.c:1320
msgid ""
"This will register with the component framework a child component which will "
"bind dynamically to the snd_hda_intel driver's corresponding master "
"component when the latter is registered. During binding the child "
"initializes an instance of struct i915_audio_component which it receives "
"from the master. The master can then start to use the interface defined by "
"this struct. Each side can break the binding at any point by deregistering "
"its own component after which each side's component unbind callback is "
"called."
msgstr ""

#: ../../../gpu/i915:150: drivers/gpu/drm/i915/display/intel_audio.c:1329
msgid ""
"We ignore any error during registration and continue with reduced "
"functionality (i.e. without HDMI audio)."
msgstr ""

#: ../../../gpu/i915:150: drivers/gpu/drm/i915/display/intel_audio.c:1379
msgid "deregister the audio component"
msgstr ""

#: ../../../gpu/i915:150: drivers/gpu/drm/i915/display/intel_audio.c:1381
msgid ""
"Deregisters the audio component, breaking any existing binding to the "
"corresponding snd_hda_intel driver's master component."
msgstr ""

#: ../../../gpu/i915:150: drivers/gpu/drm/i915/display/intel_audio.c:1395
msgid ""
"Initialize the audio driver either using component framework or using lpe "
"audio bridge"
msgstr ""

#: ../../../gpu/i915:150: drivers/gpu/drm/i915/display/intel_audio.c:1413
msgid "deinitialize the audio driver"
msgstr ""

#: ../../../gpu/i915:153: include/drm/intel/i915_component.h:43
msgid "Used for direct communication between i915 and hda drivers"
msgstr ""

#: ../../../gpu/i915:153: include/drm/intel/i915_component.h:47
#: ../../../gpu/i915:228: drivers/gpu/drm/i915/display/intel_vbt_defs.h:91
#: drivers/gpu/drm/i915/display/intel_vbt_defs.h:113 ../../../gpu/i915:249:
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:287
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:310
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:351 ../../../gpu/i915:430:
#: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:37
#: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:62
#: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:90
#: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:132
#: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:226 ../../../gpu/i915:437:
#: drivers/gpu/drm/i915/i915_scheduler_types.h:99 ../../../gpu/i915:488:
#: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:24 ../../../gpu/i915:514:
#: drivers/gpu/drm/i915/gt/uc/intel_guc.h:32 ../../../gpu/i915:633:
#: drivers/gpu/drm/i915/i915_perf_types.h:169 ../../../gpu/i915:635:
#: drivers/gpu/drm/i915/i915_perf_types.h:105 ../../../gpu/i915:660:
#: drivers/gpu/drm/i915/i915_perf_types.h:350 ../../../gpu/i915:683:
#: drivers/gpu/drm/i915/i915_perf.c:347
msgid "**Definition**::"
msgstr ""

#: ../../../gpu/i915:153: include/drm/intel/i915_component.h:54
#: ../../../gpu/i915:228: drivers/gpu/drm/i915/display/intel_vbt_defs.h:104
#: drivers/gpu/drm/i915/display/intel_vbt_defs.h:122 ../../../gpu/i915:249:
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:294
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:321
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:362 ../../../gpu/i915:430:
#: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:50
#: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:69
#: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:101
#: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:147
#: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:269 ../../../gpu/i915:437:
#: drivers/gpu/drm/i915/i915_scheduler_types.h:120 ../../../gpu/i915:488:
#: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:61 ../../../gpu/i915:514:
#: drivers/gpu/drm/i915/gt/uc/intel_guc.h:117 ../../../gpu/i915:633:
#: drivers/gpu/drm/i915/i915_perf_types.h:205 ../../../gpu/i915:635:
#: drivers/gpu/drm/i915/i915_perf_types.h:116 ../../../gpu/i915:660:
#: drivers/gpu/drm/i915/i915_perf_types.h:364 ../../../gpu/i915:683:
#: drivers/gpu/drm/i915/i915_perf.c:364
msgid "**Members**"
msgstr ""

#: ../../../gpu/i915:153: include/drm/intel/i915_component.h:47
msgid "``base``"
msgstr ""

#: ../../../gpu/i915:153: include/drm/intel/i915_component.h:48
msgid "the drm_audio_component base class"
msgstr ""

#: ../../../gpu/i915:153: include/drm/intel/i915_component.h:52
msgid "``aud_sample_rate``"
msgstr ""

#: ../../../gpu/i915:153: include/drm/intel/i915_component.h:53
msgid "the array of audio sample rate per port"
msgstr ""

#: ../../../gpu/i915.rst:157
msgid "Intel HDMI LPE Audio Support"
msgstr ""

#: ../../../gpu/i915:159: drivers/gpu/drm/i915/display/intel_lpe_audio.c:31
msgid ""
"Motivation: Atom platforms (e.g. valleyview and cherryTrail) integrates a "
"DMA-based interface as an alternative to the traditional HDaudio path. While "
"this mode is unrelated to the LPE aka SST audio engine, the documentation "
"refers to this mode as LPE so we keep this notation for the sake of "
"consistency."
msgstr ""

#: ../../../gpu/i915:159: drivers/gpu/drm/i915/display/intel_lpe_audio.c:37
msgid ""
"The interface is handled by a separate standalone driver maintained in the "
"ALSA subsystem for simplicity. To minimize the interaction between the two "
"subsystems, a bridge is setup between the hdmi-lpe-audio and i915: 1. Create "
"a platform device to share MMIO/IRQ resources 2. Make the platform device "
"child of i915 device for runtime PM. 3. Create IRQ chip to forward the LPE "
"audio irqs. the hdmi-lpe-audio driver probes the lpe audio device and "
"creates a new sound card"
msgstr ""

#: ../../../gpu/i915:159: drivers/gpu/drm/i915/display/intel_lpe_audio.c:46
msgid ""
"Threats: Due to the restriction in Linux platform device model, user need "
"manually uninstall the hdmi-lpe-audio driver before uninstalling i915 "
"module, otherwise we might run into use-after-free issues after i915 removes "
"the platform device: even though hdmi-lpe-audio driver is released, the "
"modules is still in \"installed\" status."
msgstr ""

#: ../../../gpu/i915:159: drivers/gpu/drm/i915/display/intel_lpe_audio.c:53
msgid ""
"Implementation: The MMIO/REG platform resources are created according to the "
"registers specification. When forwarding LPE audio irqs, the flow control "
"handler selection depends on the platform, for example on valleyview "
"handle_simple_irq is enough."
msgstr ""

#: ../../../gpu/i915:162: drivers/gpu/drm/i915/display/intel_lpe_audio.c:253
msgid "forwards the LPE audio irq"
msgstr ""

#: ../../../gpu/i915:162: drivers/gpu/drm/i915/display/intel_lpe_audio.c:255
msgid ""
"the LPE Audio irq is forwarded to the irq handler registered by LPE audio "
"driver."
msgstr ""

#: ../../../gpu/i915:162: drivers/gpu/drm/i915/display/intel_lpe_audio.c:273
msgid "detect and setup the bridge between HDMI LPE Audio driver and i915"
msgstr ""

#: ../../../gpu/i915:162: drivers/gpu/drm/i915/display/intel_lpe_audio.c:277
msgid ""
"0 if successful. non-zero if detection or llocation/initialization fails"
msgstr ""

#: ../../../gpu/i915:162: drivers/gpu/drm/i915/display/intel_lpe_audio.c:294
msgid "destroy the bridge between HDMI LPE audio driver and i915"
msgstr ""

#: ../../../gpu/i915:162: drivers/gpu/drm/i915/display/intel_lpe_audio.c:297
msgid "release all the resources for LPE audio <-> i915 bridge."
msgstr ""

#: ../../../gpu/i915:162: drivers/gpu/drm/i915/display/intel_lpe_audio.c:314
msgid "notify lpe audio event audio driver and i915"
msgstr ""

#: ../../../gpu/i915:162: drivers/gpu/drm/i915/display/intel_lpe_audio.c:318
msgid "``enum transcoder cpu_transcoder``"
msgstr ""

#: ../../../gpu/i915:162: drivers/gpu/drm/i915/display/intel_lpe_audio.c:317
msgid "CPU transcoder"
msgstr ""

#: ../../../gpu/i915:162: drivers/gpu/drm/i915/display/intel_lpe_audio.c:318
msgid "port"
msgstr ""

#: ../../../gpu/i915:162: drivers/gpu/drm/i915/display/intel_lpe_audio.c:320
msgid "``const void *eld``"
msgstr ""

#: ../../../gpu/i915:162: drivers/gpu/drm/i915/display/intel_lpe_audio.c:319
msgid "ELD data"
msgstr ""

#: ../../../gpu/i915:162: drivers/gpu/drm/i915/display/intel_lpe_audio.c:321
msgid "``int ls_clock``"
msgstr ""

#: ../../../gpu/i915:162: drivers/gpu/drm/i915/display/intel_lpe_audio.c:320
msgid "Link symbol clock in kHz"
msgstr ""

#: ../../../gpu/i915:162: drivers/gpu/drm/i915/display/intel_lpe_audio.c:322
msgid "``bool dp_output``"
msgstr ""

#: ../../../gpu/i915:162: drivers/gpu/drm/i915/display/intel_lpe_audio.c:321
msgid "Driving a DP output?"
msgstr ""

#: ../../../gpu/i915:162: drivers/gpu/drm/i915/display/intel_lpe_audio.c:322
msgid "Notify lpe audio driver of eld change."
msgstr ""

#: ../../../gpu/i915.rst:166
msgid "Panel Self Refresh PSR (PSR/SRD)"
msgstr ""

#: ../../../gpu/i915:168: drivers/gpu/drm/i915/display/intel_psr.c:57
msgid ""
"Since Haswell Display controller supports Panel Self-Refresh on display "
"panels witch have a remote frame buffer (RFB) implemented according to PSR "
"spec in eDP1.3. PSR feature allows the display to go to lower standby states "
"when system is idle but display is on as it eliminates display refresh "
"request to DDR memory completely as long as the frame buffer for that "
"display is unchanged."
msgstr ""

#: ../../../gpu/i915:168: drivers/gpu/drm/i915/display/intel_psr.c:64
msgid ""
"Panel Self Refresh must be supported by both Hardware (source) and Panel "
"(sink)."
msgstr ""

#: ../../../gpu/i915:168: drivers/gpu/drm/i915/display/intel_psr.c:67
msgid ""
"PSR saves power by caching the framebuffer in the panel RFB, which allows us "
"to power down the link and memory controller. For DSI panels the same idea "
"is called \"manual mode\"."
msgstr ""

#: ../../../gpu/i915:168: drivers/gpu/drm/i915/display/intel_psr.c:71
msgid ""
"The implementation uses the hardware-based PSR support which automatically "
"enters/exits self-refresh mode. The hardware takes care of sending the "
"required DP aux message and could even retrain the link (that part isn't "
"enabled yet though). The hardware also keeps track of any frontbuffer "
"changes to know when to exit self-refresh mode again. Unfortunately that "
"part doesn't work too well, hence why the i915 PSR support uses the software "
"frontbuffer tracking to make sure it doesn't miss a screen update. For this "
"integration intel_psr_invalidate() and intel_psr_flush() get called by the "
"frontbuffer tracking code. Note that because of locking issues the self-"
"refresh re-enable code is done from a work queue, which must be correctly "
"synchronized/cancelled when shutting down the pipe.\""
msgstr ""

#: ../../../gpu/i915:168: drivers/gpu/drm/i915/display/intel_psr.c:83
msgid "DC3CO (DC3 clock off)"
msgstr ""

#: ../../../gpu/i915:168: drivers/gpu/drm/i915/display/intel_psr.c:85
msgid ""
"On top of PSR2, GEN12 adds a intermediate power savings state that turns "
"clock off automatically during PSR2 idle state. The smaller overhead of "
"DC3co entry/exit vs. the overhead of PSR2 deep sleep entry/exit allows the "
"HW to enter a low-power state even when page flipping periodically (for "
"instance a 30fps video playback scenario)."
msgstr ""

#: ../../../gpu/i915:168: drivers/gpu/drm/i915/display/intel_psr.c:91
msgid ""
"Every time a flips occurs PSR2 will get out of deep sleep state(if it was), "
"so DC3CO is enabled and tgl_dc3co_disable_work is schedule to run after 6 "
"frames, if no other flip occurs and the function above is executed, DC3CO is "
"disabled and PSR2 is configured to enter deep sleep, resetting again in case "
"of another flip. Front buffer modifications do not trigger DC3CO activation "
"on purpose as it would bring a lot of complexity and most of the moderns "
"systems will only use page flips."
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2210
msgid "Disable PSR"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2216
#: drivers/gpu/drm/i915/display/intel_psr.c:2246
#: drivers/gpu/drm/i915/display/intel_psr.c:2277
#: drivers/gpu/drm/i915/display/intel_psr.c:3496
#: drivers/gpu/drm/i915/display/intel_psr.c:3690
msgid "``struct intel_dp *intel_dp``"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2211
#: drivers/gpu/drm/i915/display/intel_psr.c:2241
#: drivers/gpu/drm/i915/display/intel_psr.c:2272
#: drivers/gpu/drm/i915/display/intel_psr.c:3491
msgid "Intel DP"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2212
msgid "old CRTC state"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2213
msgid "This function needs to be called before disabling pipe."
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2240
msgid "Pause PSR"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2242
msgid "This function need to be called after enabling psr."
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2271
msgid "Resume PSR"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2273
msgid "This function need to be called after pausing psr."
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2302
msgid "Check if PSR need vblank enable/disable notification."
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2304
msgid "CRTC status"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2305
msgid ""
"We need to block DC6 entry in case of Panel Replay as enabling VBI doesn't "
"prevent it in case of Panel Replay. Panel Replay switches main link off on "
"DC entry. This means vblank interrupts are not fired and is a problem if "
"user-space is polling for vblank events. Also Wa_16025596647 needs "
"information when vblank is enabled/disabled."
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2342
msgid "Trigger \"Frame Change\" event"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2348
#: ../../../gpu/i915:258: drivers/gpu/drm/i915/display/intel_dsb.c:321
#: drivers/gpu/drm/i915/display/intel_dsb.c:837
#: drivers/gpu/drm/i915/display/intel_dsb.c:980
msgid "``struct intel_dsb *dsb``"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2343
#: ../../../gpu/i915:258: drivers/gpu/drm/i915/display/intel_dsb.c:316
#: drivers/gpu/drm/i915/display/intel_dsb.c:832
#: drivers/gpu/drm/i915/display/intel_dsb.c:975
msgid "DSB context"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2345
#: drivers/gpu/drm/i915/display/intel_psr.c:3836 ../../../gpu/i915:237:
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2703
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2756 ../../../gpu/i915:246:
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:510
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4378
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4405
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4438
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4467 ../../../gpu/i915:258:
#: drivers/gpu/drm/i915/display/intel_dsb.c:916
msgid "``struct intel_atomic_state *state``"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2344
#: ../../../gpu/i915:258: drivers/gpu/drm/i915/display/intel_dsb.c:911
msgid "the atomic state"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2346
#: drivers/gpu/drm/i915/display/intel_psr.c:3833 ../../../gpu/i915:180:
#: drivers/gpu/drm/i915/display/intel_fbc.c:1906 ../../../gpu/i915:189:
#: drivers/gpu/drm/i915/display/intel_drrs.c:303 ../../../gpu/i915:246:
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4375
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4402
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4435
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4464 ../../../gpu/i915:258:
#: drivers/gpu/drm/i915/display/intel_dsb.c:913
msgid "``struct intel_crtc *crtc``"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2345
#: ../../../gpu/i915:180: drivers/gpu/drm/i915/display/intel_fbc.c:1901
#: ../../../gpu/i915:258: drivers/gpu/drm/i915/display/intel_dsb.c:912
msgid "the CRTC"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2346
msgid "Generate PSR \"Frame Change\" event."
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2363
msgid "Minimum vblank delay needed by PSR"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2364
#: drivers/gpu/drm/i915/display/intel_psr.c:3712
#: drivers/gpu/drm/i915/display/intel_psr.c:3737 ../../../gpu/i915:189:
#: drivers/gpu/drm/i915/display/intel_drrs.c:149
msgid "the crtc state"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:2365
msgid "Return minimum vblank delay needed by PSR."
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3057
msgid "wait for PSR be ready for a pipe update"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3063
msgid "``const struct intel_crtc_state *new_crtc_state``"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3058
msgid "new CRTC state"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3059
msgid ""
"This function is expected to be called from pipe_update_start() where it is "
"not expected to race with PSR enable or disable."
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3331
msgid "Invalidate PSR"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3334
msgid "which operation caused the invalidate"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3335
msgid ""
"Since the hardware frontbuffer tracking has gaps we need to integrate with "
"the software frontbuffer tracking. This function gets called every time "
"frontbuffer rendering starts and a buffer gets dirtied. PSR must be disabled "
"if the frontbuffer mask contains a buffer relevant to PSR."
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3340
msgid ""
"Dirty frontbuffers relevant to PSR are tracked in busy_frontbuffer_bits.\""
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3433
msgid "Flush PSR"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3437
msgid ""
"Since the hardware frontbuffer tracking has gaps we need to integrate with "
"the software frontbuffer tracking. This function gets called every time "
"frontbuffer rendering has completed and flushed out to memory. PSR can be "
"enabled again if no other frontbuffer relevant to PSR is dirty."
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3442
msgid ""
"Dirty frontbuffers relevant to PSR are tracked in busy_frontbuffer_bits."
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3490
msgid "Init basic PSR work and mutex."
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3492
msgid ""
"This function is called after the initializing connector. (the initializing "
"of connector treats the handling of connector capabilities) And it "
"initializes basic PSR stuff for each DP Encoder."
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3684
msgid "return psr->link_ok"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3685
msgid "struct intel_dp"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3686
msgid ""
"We are seeing unexpected link re-trainings with some panels. This is caused "
"by panel stating bad link status after PSR is enabled. Code checking link "
"status can call this to ensure it can ignore bad link status stated by the "
"panel I.e. if panel is stating bad link and intel_psr_link_ok is stating "
"link is ok caller should rely on latter."
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3692
msgid "Return value of link_ok"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3711
msgid "grab PSR lock"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3713
msgid ""
"This is initially meant to be used by around CRTC update, when vblank "
"sensitive registers are updated and we need grab the lock before it to avoid "
"vblank evasion."
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3736
msgid "release PSR lock"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3738
msgid "Release the PSR lock that was held during pipe update."
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3798
msgid "Notify PSR about enable/disable dc5/dc6"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3799
#: drivers/gpu/drm/i915/display/intel_psr.c:3815
#: drivers/gpu/drm/i915/display/intel_psr.c:3831 ../../../gpu/i915:237:
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2698
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2751
msgid "intel atomic state"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3800
msgid ""
"This is targeted for underrun on idle PSR HW bug (Wa_16025596647) to "
"schedule psr_dc5_dc6_wa_work used for applying/removing the workaround."
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3814
msgid "Init work for underrun on idle PSR HW bug wa"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3816
msgid ""
"This is targeted for underrun on idle PSR HW bug (Wa_16025596647) to init "
"psr_dc5_dc6_wa_work used for applying the workaround."
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3830
msgid "Notify PSR about enable/disable of a pipe"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3832
msgid "intel crtc"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3833
#: drivers/gpu/drm/i915/display/intel_psr.c:3885 ../../../gpu/i915:204:
#: drivers/gpu/drm/i915/display/intel_dmc.c:828
msgid "enable/disable"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3834
msgid ""
"This is targeted for underrun on idle PSR HW bug (Wa_16025596647) to apply "
"remove the workaround when pipe is getting enabled/disabled"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3883
msgid "Notify PSR about enable/disable of vblank"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3884
msgid "intel display struct"
msgstr ""

#: ../../../gpu/i915:171: drivers/gpu/drm/i915/display/intel_psr.c:3886
msgid ""
"This is targeted for underrun on idle PSR HW bug (Wa_16025596647) to apply "
"remove the workaround when vblank is getting enabled/disabled"
msgstr ""

#: ../../../gpu/i915.rst:175
msgid "Frame Buffer Compression (FBC)"
msgstr ""

#: ../../../gpu/i915:177: drivers/gpu/drm/i915/display/intel_fbc.c:25
msgid ""
"FBC tries to save memory bandwidth (and so power consumption) by compressing "
"the amount of memory used by the display. It is total transparent to user "
"space and completely handled in the kernel."
msgstr ""

#: ../../../gpu/i915:177: drivers/gpu/drm/i915/display/intel_fbc.c:29
msgid ""
"The benefits of FBC are mostly visible with solid backgrounds and variation-"
"less patterns. It comes from keeping the memory footprint small and having "
"fewer memory pages opened and accessed for refreshing the display."
msgstr ""

#: ../../../gpu/i915:177: drivers/gpu/drm/i915/display/intel_fbc.c:33
msgid ""
"i915 is responsible to reserve stolen memory for FBC and configure its "
"offset on proper registers. The hardware takes care of all compress/"
"decompress. However there are many known cases where we have to forcibly "
"disable it to allow proper screen updates."
msgstr ""

#: ../../../gpu/i915:180: drivers/gpu/drm/i915/display/intel_fbc.c:1900
msgid "disable FBC if it's associated with crtc"
msgstr ""

#: ../../../gpu/i915:180: drivers/gpu/drm/i915/display/intel_fbc.c:1902
msgid "This function disables FBC if it's associated with the provided CRTC."
msgstr ""

#: ../../../gpu/i915:180: drivers/gpu/drm/i915/display/intel_fbc.c:2027
msgid "disable FBC when we get a FIFO underrun"
msgstr ""

#: ../../../gpu/i915:180: drivers/gpu/drm/i915/display/intel_fbc.c:2028
#: drivers/gpu/drm/i915/display/intel_fbc.c:2109
#: drivers/gpu/drm/i915/display/intel_fbc.c:2127
msgid "display"
msgstr ""

#: ../../../gpu/i915:180: drivers/gpu/drm/i915/display/intel_fbc.c:2029
msgid ""
"Without FBC, most underruns are harmless and don't really cause too many "
"problems, except for an annoying message on dmesg. With FBC, underruns can "
"become black screens or even worse, especially when paired with bad "
"watermarks. So in order for us to be on the safe side, completely disable "
"FBC in case we ever detect a FIFO underrun on any pipe. An underrun on any "
"pipe already suggests that watermarks may be bad, so try to be as safe as "
"possible."
msgstr ""

#: ../../../gpu/i915:180: drivers/gpu/drm/i915/display/intel_fbc.c:2037
msgid "This function is called from the IRQ handler."
msgstr ""

#: ../../../gpu/i915:180: drivers/gpu/drm/i915/display/intel_fbc.c:2108
msgid "Initialize FBC"
msgstr ""

#: ../../../gpu/i915:180: drivers/gpu/drm/i915/display/intel_fbc.c:2110
msgid "This function might be called during PM init process."
msgstr ""

#: ../../../gpu/i915:180: drivers/gpu/drm/i915/display/intel_fbc.c:2126
msgid "Sanitize FBC"
msgstr ""

#: ../../../gpu/i915:180: drivers/gpu/drm/i915/display/intel_fbc.c:2128
msgid ""
"Make sure FBC is initially disabled since we have no idea eg. into which "
"parts of stolen it might be scribbling into."
msgstr ""

#: ../../../gpu/i915.rst:184
msgid "Display Refresh Rate Switching (DRRS)"
msgstr ""

#: ../../../gpu/i915:186: drivers/gpu/drm/i915/display/intel_drrs.c:19
msgid ""
"Display Refresh Rate Switching (DRRS) is a power conservation feature which "
"enables swtching between low and high refresh rates, dynamically, based on "
"the usage scenario. This feature is applicable for internal panels."
msgstr ""

#: ../../../gpu/i915:186: drivers/gpu/drm/i915/display/intel_drrs.c:24
msgid ""
"Indication that the panel supports DRRS is given by the panel EDID, which "
"would list multiple refresh rates for one resolution."
msgstr ""

#: ../../../gpu/i915:186: drivers/gpu/drm/i915/display/intel_drrs.c:27
msgid ""
"DRRS is of 2 types - static and seamless. Static DRRS involves changing "
"refresh rate (RR) by doing a full modeset (may appear as a blink on screen) "
"and is used in dock-undock scenario. Seamless DRRS involves changing RR "
"without any visual effect to the user and can be used during normal system "
"usage. This is done by programming certain registers."
msgstr ""

#: ../../../gpu/i915:186: drivers/gpu/drm/i915/display/intel_drrs.c:34
msgid ""
"Support for static/seamless DRRS may be indicated in the VBT based on inputs "
"from the panel spec."
msgstr ""

#: ../../../gpu/i915:186: drivers/gpu/drm/i915/display/intel_drrs.c:37
msgid "DRRS saves power by switching to low RR based on usage scenarios."
msgstr ""

#: ../../../gpu/i915:186: drivers/gpu/drm/i915/display/intel_drrs.c:39
msgid ""
"The implementation is based on frontbuffer tracking implementation.  When "
"there is a disturbance on the screen triggered by user activity or a "
"periodic system activity, DRRS is disabled (RR is changed to high RR).  When "
"there is no movement on screen, after a timeout of 1 second, a switch to low "
"RR is made."
msgstr ""

#: ../../../gpu/i915:186: drivers/gpu/drm/i915/display/intel_drrs.c:45
msgid ""
"For integration with frontbuffer tracking code, intel_drrs_invalidate() and "
"intel_drrs_flush() are called."
msgstr ""

#: ../../../gpu/i915:186: drivers/gpu/drm/i915/display/intel_drrs.c:48
msgid ""
"DRRS can be further extended to support other internal panels and also the "
"scenario of video playback wherein RR is set based on the rate requested by "
"userspace."
msgstr ""

#: ../../../gpu/i915:189: drivers/gpu/drm/i915/display/intel_drrs.c:148
msgid "activate DRRS"
msgstr ""

#: ../../../gpu/i915:189: drivers/gpu/drm/i915/display/intel_drrs.c:150
msgid "Activates DRRS on the crtc."
msgstr ""

#: ../../../gpu/i915:189: drivers/gpu/drm/i915/display/intel_drrs.c:180
msgid "deactivate DRRS"
msgstr ""

#: ../../../gpu/i915:189: drivers/gpu/drm/i915/display/intel_drrs.c:181
msgid "the old crtc state"
msgstr ""

#: ../../../gpu/i915:189: drivers/gpu/drm/i915/display/intel_drrs.c:182
msgid "Deactivates DRRS on the crtc."
msgstr ""

#: ../../../gpu/i915:189: drivers/gpu/drm/i915/display/intel_drrs.c:263
msgid "Disable Idleness DRRS"
msgstr ""

#: ../../../gpu/i915:189: drivers/gpu/drm/i915/display/intel_drrs.c:266
msgid ""
"This function gets called everytime rendering on the given planes start. "
"Hence DRRS needs to be Upclocked, i.e. (LOW_RR -> HIGH_RR)."
msgstr ""

#: ../../../gpu/i915:189: drivers/gpu/drm/i915/display/intel_drrs.c:269
#: drivers/gpu/drm/i915/display/intel_drrs.c:287
msgid ""
"Dirty frontbuffers relevant to DRRS are tracked in busy_frontbuffer_bits."
msgstr ""

#: ../../../gpu/i915:189: drivers/gpu/drm/i915/display/intel_drrs.c:279
msgid "Restart Idleness DRRS"
msgstr ""

#: ../../../gpu/i915:189: drivers/gpu/drm/i915/display/intel_drrs.c:282
msgid ""
"This function gets called every time rendering on the given planes has "
"completed or flip on a crtc is completed. So DRRS should be upclocked "
"(LOW_RR -> HIGH_RR). And also Idleness detection should be started again, if "
"no other planes are dirty."
msgstr ""

#: ../../../gpu/i915:189: drivers/gpu/drm/i915/display/intel_drrs.c:297
msgid "Init DRRS for CRTC"
msgstr ""

#: ../../../gpu/i915:189: drivers/gpu/drm/i915/display/intel_drrs.c:298
msgid "crtc"
msgstr ""

#: ../../../gpu/i915:189: drivers/gpu/drm/i915/display/intel_drrs.c:299
msgid ""
"This function is called only once at driver load to initialize basic DRRS "
"stuff."
msgstr ""

#: ../../../gpu/i915.rst:193
msgid "DPIO"
msgstr ""

#: ../../../gpu/i915:195: drivers/gpu/drm/i915/display/intel_dpio_phy.c:40
msgid ""
"VLV, CHV and BXT have slightly peculiar display PHYs for driving DP/HDMI "
"ports. DPIO is the name given to such a display PHY. These PHYs don't follow "
"the standard programming model using direct MMIO registers, and instead "
"their registers must be accessed through IOSF sideband. VLV has one such PHY "
"for driving ports B and C, and CHV adds another PHY for driving port D. Each "
"PHY responds to specific IOSF-SB port."
msgstr ""

#: ../../../gpu/i915:195: drivers/gpu/drm/i915/display/intel_dpio_phy.c:48
msgid ""
"Each display PHY is made up of one or two channels. Each channel houses a "
"common lane part which contains the PLL and other common logic. CH0 common "
"lane also contains the IOSF-SB logic for the Common Register Interface (CRI) "
"ie. the DPIO registers. CRI clock must be running when any DPIO registers "
"are accessed."
msgstr ""

#: ../../../gpu/i915:195: drivers/gpu/drm/i915/display/intel_dpio_phy.c:54
msgid ""
"In addition to having their own registers, the PHYs are also controlled "
"through some dedicated signals from the display controller. These include "
"PLL reference clock enable, PLL enable, and CRI clock selection, for example."
msgstr ""

#: ../../../gpu/i915:195: drivers/gpu/drm/i915/display/intel_dpio_phy.c:59
msgid ""
"Eeach channel also has two splines (also called data lanes), and each spline "
"is made up of one Physical Access Coding Sub-Layer (PCS) block and two TX "
"lanes. So each channel has two PCS blocks and four TX lanes. The TX lanes "
"are used as DP lanes or TMDS data/clock pairs depending on the output type."
msgstr ""

#: ../../../gpu/i915:195: drivers/gpu/drm/i915/display/intel_dpio_phy.c:65
msgid ""
"Additionally the PHY also contains an AUX lane with AUX blocks for each "
"channel. This is used for DP AUX communication, but this fact isn't really "
"relevant for the driver since AUX is controlled from the display controller "
"side. No DPIO registers need to be accessed during AUX communication,"
msgstr ""

#: ../../../gpu/i915:195: drivers/gpu/drm/i915/display/intel_dpio_phy.c:71
msgid ""
"Generally on VLV/CHV the common lane corresponds to the pipe and the spline "
"(PCS/TX) corresponds to the port."
msgstr ""

#: ../../../gpu/i915:195: drivers/gpu/drm/i915/display/intel_dpio_phy.c:74
msgid "For dual channel PHY (VLV/CHV):"
msgstr ""

#: ../../../gpu/i915:195: drivers/gpu/drm/i915/display/intel_dpio_phy.c:76
msgid "pipe A == CMN/PLL/REF CH0"
msgstr ""

#: ../../../gpu/i915:195: drivers/gpu/drm/i915/display/intel_dpio_phy.c:78
msgid "pipe B == CMN/PLL/REF CH1"
msgstr ""

#: ../../../gpu/i915:195: drivers/gpu/drm/i915/display/intel_dpio_phy.c:80
msgid "port B == PCS/TX CH0"
msgstr ""

#: ../../../gpu/i915:195: drivers/gpu/drm/i915/display/intel_dpio_phy.c:82
msgid "port C == PCS/TX CH1"
msgstr ""

#: ../../../gpu/i915:195: drivers/gpu/drm/i915/display/intel_dpio_phy.c:84
msgid ""
"This is especially important when we cross the streams ie. drive port B with "
"pipe B, or port C with pipe A."
msgstr ""

#: ../../../gpu/i915:195: drivers/gpu/drm/i915/display/intel_dpio_phy.c:87
msgid "For single channel PHY (CHV):"
msgstr ""

#: ../../../gpu/i915:195: drivers/gpu/drm/i915/display/intel_dpio_phy.c:89
msgid "pipe C == CMN/PLL/REF CH0"
msgstr ""

#: ../../../gpu/i915:195: drivers/gpu/drm/i915/display/intel_dpio_phy.c:91
msgid "port D == PCS/TX CH0"
msgstr ""

#: ../../../gpu/i915:195: drivers/gpu/drm/i915/display/intel_dpio_phy.c:93
msgid ""
"On BXT the entire PHY channel corresponds to the port. That means the PLL is "
"also now associated with the port rather than the pipe, and so the clock "
"needs to be routed to the appropriate transcoder. Port A PLL is directly "
"connected to transcoder EDP and port B/C PLLs can be routed to any "
"transcoder A/B/C."
msgstr ""

#: ../../../gpu/i915:195: drivers/gpu/drm/i915/display/intel_dpio_phy.c:99
msgid ""
"Note: DDI0 is digital port B, DD1 is digital port C, and DDI2 is digital "
"port D (CHV) or port A (BXT). ::"
msgstr ""

#: ../../../gpu/i915.rst:199
msgid "DMC Firmware Support"
msgstr ""

#: ../../../gpu/i915:201: drivers/gpu/drm/i915/display/intel_dmc.c:46
msgid ""
"From gen9 onwards we have newly added DMC (Display microcontroller) in "
"display engine to save and restore the state of display engine when it enter "
"into low-power state and comes back to normal."
msgstr ""

#: ../../../gpu/i915:204: drivers/gpu/drm/i915/display/intel_dmc.c:807
msgid "block PKG C-state"
msgstr ""

#: ../../../gpu/i915:204: drivers/gpu/drm/i915/display/intel_dmc.c:808
#: drivers/gpu/drm/i915/display/intel_dmc.c:826
#: drivers/gpu/drm/i915/display/intel_dmc.c:843
#: drivers/gpu/drm/i915/display/intel_dmc.c:882
#: drivers/gpu/drm/i915/display/intel_dmc.c:1311
#: drivers/gpu/drm/i915/display/intel_dmc.c:1370
#: drivers/gpu/drm/i915/display/intel_dmc.c:1404
#: drivers/gpu/drm/i915/display/intel_dmc.c:1424 ../../../gpu/i915:237:
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2342
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2359
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2455
#: drivers/gpu/drm/i915/display/intel_cdclk.c:3420
#: drivers/gpu/drm/i915/display/intel_cdclk.c:3503
#: drivers/gpu/drm/i915/display/intel_cdclk.c:3585
#: drivers/gpu/drm/i915/display/intel_cdclk.c:3782
msgid "display instance"
msgstr ""

#: ../../../gpu/i915:204: drivers/gpu/drm/i915/display/intel_dmc.c:809
#: drivers/gpu/drm/i915/display/intel_dmc.c:827
msgid "pipe which register use to block"
msgstr ""

#: ../../../gpu/i915:204: drivers/gpu/drm/i915/display/intel_dmc.c:811
msgid "``bool block``"
msgstr ""

#: ../../../gpu/i915:204: drivers/gpu/drm/i915/display/intel_dmc.c:810
msgid "block/unblock"
msgstr ""

#: ../../../gpu/i915:204: drivers/gpu/drm/i915/display/intel_dmc.c:811
msgid ""
"This interface is target for Wa_16025596647 usage. I.e. to set/clear "
"PIPEDMC_BLOCK_PKGC_SW_BLOCK_PKGC_ALWAYS bit in PIPEDMC_BLOCK_PKGC_SW "
"register."
msgstr ""

#: ../../../gpu/i915:204: drivers/gpu/drm/i915/display/intel_dmc.c:824
msgid "start of PKG C-state exit"
msgstr ""

#: ../../../gpu/i915:204: drivers/gpu/drm/i915/display/intel_dmc.c:829
msgid ""
"This interface is target for Wa_16025596647 usage. I.e. start the package C "
"exit at the start of the undelayed vblank"
msgstr ""

#: ../../../gpu/i915:204: drivers/gpu/drm/i915/display/intel_dmc.c:842
msgid "write the firmware from memory to register."
msgstr ""

#: ../../../gpu/i915:204: drivers/gpu/drm/i915/display/intel_dmc.c:844
msgid ""
"DMC firmware is read from a .bin file and kept in internal memory one time. "
"Everytime display comes back from low power state this function is called to "
"copy the firmware from internal memory to registers."
msgstr ""

#: ../../../gpu/i915:204: drivers/gpu/drm/i915/display/intel_dmc.c:881
msgid "disable the firmware"
msgstr ""

#: ../../../gpu/i915:204: drivers/gpu/drm/i915/display/intel_dmc.c:883
msgid ""
"Disable all event handlers in the firmware, making sure the firmware is "
"inactive after the display is uninitialized."
msgstr ""

#: ../../../gpu/i915:204: drivers/gpu/drm/i915/display/intel_dmc.c:1310
msgid "initialize the firmware loading."
msgstr ""

#: ../../../gpu/i915:204: drivers/gpu/drm/i915/display/intel_dmc.c:1312
msgid ""
"This function is called at the time of loading the display driver to read "
"firmware from a .bin file and copied into a internal memory."
msgstr ""

#: ../../../gpu/i915:204: drivers/gpu/drm/i915/display/intel_dmc.c:1369
msgid "prepare DMC firmware before system suspend"
msgstr ""

#: ../../../gpu/i915:204: drivers/gpu/drm/i915/display/intel_dmc.c:1371
msgid ""
"Prepare the DMC firmware before entering system suspend. This includes "
"flushing pending work items and releasing any resources acquired during init."
msgstr ""

#: ../../../gpu/i915:204: drivers/gpu/drm/i915/display/intel_dmc.c:1403
msgid "init DMC firmware during system resume"
msgstr ""

#: ../../../gpu/i915:204: drivers/gpu/drm/i915/display/intel_dmc.c:1405
msgid ""
"Reinitialize the DMC firmware during system resume, reacquiring any "
"resources released in intel_dmc_suspend()."
msgstr ""

#: ../../../gpu/i915:204: drivers/gpu/drm/i915/display/intel_dmc.c:1423
msgid "unload the DMC firmware."
msgstr ""

#: ../../../gpu/i915:204: drivers/gpu/drm/i915/display/intel_dmc.c:1425
msgid ""
"Firmmware unloading includes freeing the internal memory and reset the "
"firmware loading status."
msgstr ""

#: ../../../gpu/i915.rst:208
msgid "DMC Flip Queue"
msgstr ""

#: ../../../gpu/i915:210: drivers/gpu/drm/i915/display/intel_flipq.c:24
msgid ""
"A flip queue is a ring buffer implemented by the pipe DMC firmware. The "
"driver inserts entries into the queues to be executed by the pipe DMC at a "
"specified presentation timestamp (PTS)."
msgstr ""

#: ../../../gpu/i915:210: drivers/gpu/drm/i915/display/intel_flipq.c:28
msgid "Each pipe DMC provides several queues:"
msgstr ""

#: ../../../gpu/i915:210: drivers/gpu/drm/i915/display/intel_flipq.c:30
msgid "1 general queue (two DSB buffers executed per entry)"
msgstr ""

#: ../../../gpu/i915:210: drivers/gpu/drm/i915/display/intel_flipq.c:31
msgid "3 plane queues (one DSB buffer executed per entry)"
msgstr ""

#: ../../../gpu/i915:210: drivers/gpu/drm/i915/display/intel_flipq.c:32
msgid "1 fast queue (deprecated)"
msgstr ""

#: ../../../gpu/i915.rst:214
msgid "DMC wakelock support"
msgstr ""

#: ../../../gpu/i915:216: drivers/gpu/drm/i915/display/intel_dmc_wl.c:16
msgid ""
"Wake lock is the mechanism to cause display engine to exit DC states to "
"allow programming to registers that are powered down in those states. "
"Previous projects exited DC states automatically when detecting programming. "
"Now software controls the exit by programming the wake lock. This improves "
"system performance and system interactions and better fits the flip queue "
"style of programming. Wake lock is only required when DC5, DC6, or DC6v have "
"been enabled in DC_STATE_EN and the wake lock mode of operation has been "
"enabled."
msgstr ""

#: ../../../gpu/i915:216: drivers/gpu/drm/i915/display/intel_dmc_wl.c:26
msgid ""
"The wakelock mechanism in DMC allows the display engine to exit DC states "
"explicitly before programming registers that may be powered down.  In "
"earlier hardware, this was done automatically and implicitly when the "
"display engine accessed a register.  With the wakelock implementation, the "
"driver asserts a wakelock in DMC, which forces it to exit the DC state until "
"the wakelock is deasserted."
msgstr ""

#: ../../../gpu/i915:216: drivers/gpu/drm/i915/display/intel_dmc_wl.c:34
msgid ""
"The mechanism can be enabled and disabled by writing to the DMC_WAKELOCK_CFG "
"register.  There are also 13 control registers that can be used to hold and "
"release different wakelocks.  In the current implementation, we only need "
"one wakelock, so only DMC_WAKELOCK1_CTL is used.  The other definitions are "
"here for potential future use."
msgstr ""

#: ../../../gpu/i915.rst:220
msgid "Video BIOS Table (VBT)"
msgstr ""

#: ../../../gpu/i915:222: drivers/gpu/drm/i915/display/intel_bios.c:50
msgid ""
"The Video BIOS Table, or VBT, provides platform and board specific "
"configuration information to the driver that is not discoverable or "
"available through other means. The configuration is mostly related to "
"display hardware. The VBT is available via the ACPI OpRegion or, on older "
"systems, in the PCI ROM."
msgstr ""

#: ../../../gpu/i915:222: drivers/gpu/drm/i915/display/intel_bios.c:56
msgid ""
"The VBT consists of a VBT Header (defined as :c:type:`struct vbt_header "
"<vbt_header>`), a BDB Header (:c:type:`struct bdb_header <bdb_header>`), and "
"a number of BIOS Data Blocks (BDB) that contain the actual configuration "
"information. The VBT Header, and thus the VBT, begins with \"$VBT\" "
"signature. The VBT Header contains the offset of the BDB Header. The data "
"blocks are concatenated after the BDB Header. The data blocks have a 1-byte "
"Block ID, 2-byte Block Size, and Block Size bytes of data. (Block 53, the "
"MIPI Sequence Block is an exception.)"
msgstr ""

#: ../../../gpu/i915:222: drivers/gpu/drm/i915/display/intel_bios.c:64
msgid ""
"The driver parses the VBT during load. The relevant information is stored in "
"driver private data for ease of use, and the actual VBT is not read after "
"that."
msgstr ""

#: ../../../gpu/i915:225: drivers/gpu/drm/i915/display/intel_bios.c:3000
msgid "does the given buffer contain a valid VBT"
msgstr ""

#: ../../../gpu/i915:225: drivers/gpu/drm/i915/display/intel_bios.c:3003
msgid "``const void *buf``"
msgstr ""

#: ../../../gpu/i915:225: drivers/gpu/drm/i915/display/intel_bios.c:3002
msgid "pointer to a buffer to validate"
msgstr ""

#: ../../../gpu/i915:225: drivers/gpu/drm/i915/display/intel_bios.c:3004
msgid "``size_t size``"
msgstr ""

#: ../../../gpu/i915:225: drivers/gpu/drm/i915/display/intel_bios.c:3003
msgid "size of the buffer"
msgstr ""

#: ../../../gpu/i915:225: drivers/gpu/drm/i915/display/intel_bios.c:3004
msgid "Returns true on valid VBT."
msgstr ""

#: ../../../gpu/i915:225: drivers/gpu/drm/i915/display/intel_bios.c:3171
msgid "find VBT and initialize settings from the BIOS"
msgstr ""

#: ../../../gpu/i915:225: drivers/gpu/drm/i915/display/intel_bios.c:3173
msgid ""
"Parse and initialize settings from the Video BIOS Tables (VBT). If the VBT "
"was not found in ACPI OpRegion, try to find it in PCI ROM first. Also "
"initialize some defaults if the VBT is not present at all."
msgstr ""

#: ../../../gpu/i915:225: drivers/gpu/drm/i915/display/intel_bios.c:3281
msgid "Free any resources allocated by intel_bios_init()"
msgstr ""

#: ../../../gpu/i915:225: drivers/gpu/drm/i915/display/intel_bios.c:3319
msgid "is integrated TV present in VBT"
msgstr ""

#: ../../../gpu/i915:225: drivers/gpu/drm/i915/display/intel_bios.c:3321
msgid ""
"Return true if TV is present. If no child devices were parsed from VBT, "
"assume TV is present."
msgstr ""

#: ../../../gpu/i915:225: drivers/gpu/drm/i915/display/intel_bios.c:3360
msgid "is LVDS present in VBT"
msgstr ""

#: ../../../gpu/i915:225: drivers/gpu/drm/i915/display/intel_bios.c:3363
msgid "``u8 *i2c_pin``"
msgstr ""

#: ../../../gpu/i915:225: drivers/gpu/drm/i915/display/intel_bios.c:3362
msgid "i2c pin for LVDS if present"
msgstr ""

#: ../../../gpu/i915:225: drivers/gpu/drm/i915/display/intel_bios.c:3363
msgid ""
"Return true if LVDS is present. If no child devices were parsed from VBT, "
"assume LVDS is present."
msgstr ""

#: ../../../gpu/i915:225: drivers/gpu/drm/i915/display/intel_bios.c:3408
msgid "is the specified digital port present"
msgstr ""

#: ../../../gpu/i915:225: drivers/gpu/drm/i915/display/intel_bios.c:3410
msgid "port to check"
msgstr ""

#: ../../../gpu/i915:225: drivers/gpu/drm/i915/display/intel_bios.c:3411
msgid "Return true if the device in ``port`` is present."
msgstr ""

#: ../../../gpu/i915:225: drivers/gpu/drm/i915/display/intel_bios.c:3457
msgid "is DSI present in VBT"
msgstr ""

#: ../../../gpu/i915:225: drivers/gpu/drm/i915/display/intel_bios.c:3460
msgid "``enum port *port``"
msgstr ""

#: ../../../gpu/i915:225: drivers/gpu/drm/i915/display/intel_bios.c:3459
msgid "port for DSI if present"
msgstr ""

#: ../../../gpu/i915:225: drivers/gpu/drm/i915/display/intel_bios.c:3460
msgid "Return true if DSI is present, and return the port in ``port``."
msgstr ""

#: ../../../gpu/i915:228: drivers/gpu/drm/i915/display/intel_vbt_defs.h:87
msgid "VBT Header structure"
msgstr ""

#: ../../../gpu/i915:228: drivers/gpu/drm/i915/display/intel_vbt_defs.h:88
#: drivers/gpu/drm/i915/display/intel_vbt_defs.h:110
msgid "``signature``"
msgstr ""

#: ../../../gpu/i915:228: drivers/gpu/drm/i915/display/intel_vbt_defs.h:89
msgid "VBT signature, always starts with \"$VBT\""
msgstr ""

#: ../../../gpu/i915:228: drivers/gpu/drm/i915/display/intel_vbt_defs.h:89
#: drivers/gpu/drm/i915/display/intel_vbt_defs.h:111
msgid "``version``"
msgstr ""

#: ../../../gpu/i915:228: drivers/gpu/drm/i915/display/intel_vbt_defs.h:90
msgid "Version of this structure"
msgstr ""

#: ../../../gpu/i915:228: drivers/gpu/drm/i915/display/intel_vbt_defs.h:90
#: drivers/gpu/drm/i915/display/intel_vbt_defs.h:112
msgid "``header_size``"
msgstr ""

#: ../../../gpu/i915:228: drivers/gpu/drm/i915/display/intel_vbt_defs.h:91
#: drivers/gpu/drm/i915/display/intel_vbt_defs.h:113
msgid "Size of this structure"
msgstr ""

#: ../../../gpu/i915:228: drivers/gpu/drm/i915/display/intel_vbt_defs.h:91
msgid "``vbt_size``"
msgstr ""

#: ../../../gpu/i915:228: drivers/gpu/drm/i915/display/intel_vbt_defs.h:92
msgid "Size of VBT (VBT Header, BDB Header and data blocks)"
msgstr ""

#: ../../../gpu/i915:228: drivers/gpu/drm/i915/display/intel_vbt_defs.h:92
msgid "``vbt_checksum``"
msgstr ""

#: ../../../gpu/i915:228: drivers/gpu/drm/i915/display/intel_vbt_defs.h:93
msgid "Checksum"
msgstr ""

#: ../../../gpu/i915:228: drivers/gpu/drm/i915/display/intel_vbt_defs.h:93
msgid "``reserved0``"
msgstr ""

#: ../../../gpu/i915:228: drivers/gpu/drm/i915/display/intel_vbt_defs.h:94
msgid "Reserved"
msgstr ""

#: ../../../gpu/i915:228: drivers/gpu/drm/i915/display/intel_vbt_defs.h:94
msgid "``bdb_offset``"
msgstr ""

#: ../../../gpu/i915:228: drivers/gpu/drm/i915/display/intel_vbt_defs.h:95
msgid ""
"Offset of :c:type:`struct bdb_header <bdb_header>` from beginning of VBT"
msgstr ""

#: ../../../gpu/i915:228: drivers/gpu/drm/i915/display/intel_vbt_defs.h:95
msgid "``aim_offset``"
msgstr ""

#: ../../../gpu/i915:228: drivers/gpu/drm/i915/display/intel_vbt_defs.h:96
msgid "Offsets of add-in data blocks from beginning of VBT"
msgstr ""

#: ../../../gpu/i915:228: drivers/gpu/drm/i915/display/intel_vbt_defs.h:109
msgid "BDB Header structure"
msgstr ""

#: ../../../gpu/i915:228: drivers/gpu/drm/i915/display/intel_vbt_defs.h:111
msgid "BDB signature \"BIOS_DATA_BLOCK\""
msgstr ""

#: ../../../gpu/i915:228: drivers/gpu/drm/i915/display/intel_vbt_defs.h:112
msgid "Version of the data block definitions"
msgstr ""

#: ../../../gpu/i915:228: drivers/gpu/drm/i915/display/intel_vbt_defs.h:113
msgid "``bdb_size``"
msgstr ""

#: ../../../gpu/i915:228: drivers/gpu/drm/i915/display/intel_vbt_defs.h:114
msgid "Size of BDB (BDB Header and data blocks)"
msgstr ""

#: ../../../gpu/i915.rst:232
msgid "Display clocks"
msgstr ""

#: ../../../gpu/i915:234: drivers/gpu/drm/i915/display/intel_cdclk.c:56
msgid ""
"The display engine uses several different clocks to do its work. There are "
"two main clocks involved that aren't directly related to the actual pixel "
"clock or any symbol/bit clock of the actual output port. These are the core "
"display clock (CDCLK) and RAWCLK."
msgstr ""

#: ../../../gpu/i915:234: drivers/gpu/drm/i915/display/intel_cdclk.c:61
msgid ""
"CDCLK clocks most of the display pipe logic, and thus its frequency must be "
"high enough to support the rate at which pixels are flowing through the "
"pipes. Downscaling must also be accounted as that increases the effective "
"pixel rate."
msgstr ""

#: ../../../gpu/i915:234: drivers/gpu/drm/i915/display/intel_cdclk.c:66
msgid ""
"On several platforms the CDCLK frequency can be changed dynamically to "
"minimize power consumption for a given display configuration. Typically "
"changes to the CDCLK frequency require all the display pipes to be shut down "
"while the frequency is being changed."
msgstr ""

#: ../../../gpu/i915:234: drivers/gpu/drm/i915/display/intel_cdclk.c:71
msgid ""
"On SKL+ the DMC will toggle the CDCLK off/on during DC5/6 entry/exit. DMC "
"will not change the active CDCLK frequency however, so that part will still "
"be performed by the driver directly."
msgstr ""

#: ../../../gpu/i915:234: drivers/gpu/drm/i915/display/intel_cdclk.c:75
msgid ""
"There are multiple components involved in the generation of the CDCLK "
"frequency:"
msgstr ""

#: ../../../gpu/i915:234: drivers/gpu/drm/i915/display/intel_cdclk.c:78
msgid ""
"We have the CDCLK PLL, which generates an output clock based on a reference "
"clock and a ratio parameter."
msgstr ""

#: ../../../gpu/i915:234: drivers/gpu/drm/i915/display/intel_cdclk.c:80
msgid ""
"The CD2X Divider, which divides the output of the PLL based on a divisor "
"selected from a set of pre-defined choices."
msgstr ""

#: ../../../gpu/i915:234: drivers/gpu/drm/i915/display/intel_cdclk.c:82
msgid ""
"The CD2X Squasher, which further divides the output based on a waveform "
"represented as a sequence of bits where each zero \"squashes out\" a clock "
"cycle."
msgstr ""

#: ../../../gpu/i915:234: drivers/gpu/drm/i915/display/intel_cdclk.c:85
msgid "And, finally, a fixed divider that divides the output frequency by 2."
msgstr ""

#: ../../../gpu/i915:234: drivers/gpu/drm/i915/display/intel_cdclk.c:87
msgid ""
"As such, the resulting CDCLK frequency can be calculated with the following "
"formula:"
msgstr ""

#: ../../../gpu/i915:234: drivers/gpu/drm/i915/display/intel_cdclk.c:90
msgid "cdclk = vco / cd2x_div / (sq_len / sq_div) / 2"
msgstr ""

#: ../../../gpu/i915:234: drivers/gpu/drm/i915/display/intel_cdclk.c:92
msgid ""
", where vco is the frequency generated by the PLL; cd2x_div represents the "
"CD2X Divider; sq_len and sq_div are the bit length and the number of high "
"bits for the CD2X Squasher waveform, respectively; and 2 represents the "
"fixed divider."
msgstr ""

#: ../../../gpu/i915:234: drivers/gpu/drm/i915/display/intel_cdclk.c:97
msgid ""
"Note that some older platforms do not contain the CD2X Divider and/or CD2X "
"Squasher, in which case we can ignore their respective factors in the "
"formula above."
msgstr ""

#: ../../../gpu/i915:234: drivers/gpu/drm/i915/display/intel_cdclk.c:101
msgid ""
"Several methods exist to change the CDCLK frequency, which ones are "
"supported depends on the platform:"
msgstr ""

#: ../../../gpu/i915:234: drivers/gpu/drm/i915/display/intel_cdclk.c:104
msgid ""
"Full PLL disable + re-enable with new VCO frequency. Pipes must be inactive."
msgstr ""

#: ../../../gpu/i915:234: drivers/gpu/drm/i915/display/intel_cdclk.c:105
msgid ""
"CD2X divider update. Single pipe can be active as the divider update can be "
"synchronized with the pipe's start of vblank."
msgstr ""

#: ../../../gpu/i915:234: drivers/gpu/drm/i915/display/intel_cdclk.c:107
msgid "Crawl the PLL smoothly to the new VCO frequency. Pipes can be active."
msgstr ""

#: ../../../gpu/i915:234: drivers/gpu/drm/i915/display/intel_cdclk.c:108
msgid "Squash waveform update. Pipes can be active."
msgstr ""

#: ../../../gpu/i915:234: drivers/gpu/drm/i915/display/intel_cdclk.c:109
msgid "Crawl and squash can also be done back to back. Pipes can be active."
msgstr ""

#: ../../../gpu/i915:234: drivers/gpu/drm/i915/display/intel_cdclk.c:111
msgid ""
"RAWCLK is a fixed frequency clock, often used by various auxiliary blocks "
"such as AUX CH or backlight PWM. Hence the only thing we really need to know "
"about RAWCLK is its frequency so that various dividers can be programmed "
"correctly."
msgstr ""

#: ../../../gpu/i915:237: drivers/gpu/drm/i915/display/intel_cdclk.c:2341
msgid "Initialize CDCLK hardware"
msgstr ""

#: ../../../gpu/i915:237: drivers/gpu/drm/i915/display/intel_cdclk.c:2343
msgid ""
"Initialize CDCLK. This consists mainly of initializing display->cdclk.hw and "
"sanitizing the state of the hardware if needed. This is generally done only "
"during the display core initialization sequence, after which the DMC will "
"take care of turning CDCLK off/on as needed."
msgstr ""

#: ../../../gpu/i915:237: drivers/gpu/drm/i915/display/intel_cdclk.c:2358
msgid "Uninitialize CDCLK hardware"
msgstr ""

#: ../../../gpu/i915:237: drivers/gpu/drm/i915/display/intel_cdclk.c:2360
msgid ""
"Uninitialize CDCLK. This is done only during the display core "
"uninitialization sequence."
msgstr ""

#: ../../../gpu/i915:237: drivers/gpu/drm/i915/display/intel_cdclk.c:2436
msgid "Check whether the clock changed"
msgstr ""

#: ../../../gpu/i915:237: drivers/gpu/drm/i915/display/intel_cdclk.c:2442
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2457
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2493
msgid "``const struct intel_cdclk_config *a``"
msgstr ""

#: ../../../gpu/i915:237: drivers/gpu/drm/i915/display/intel_cdclk.c:2437
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2456
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2488
msgid "first CDCLK configuration"
msgstr ""

#: ../../../gpu/i915:237: drivers/gpu/drm/i915/display/intel_cdclk.c:2439
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2458
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2490
msgid "``const struct intel_cdclk_config *b``"
msgstr ""

#: ../../../gpu/i915:237: drivers/gpu/drm/i915/display/intel_cdclk.c:2438
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2457
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2489
msgid "second CDCLK configuration"
msgstr ""

#: ../../../gpu/i915:237: drivers/gpu/drm/i915/display/intel_cdclk.c:2440
msgid ""
"True if CDCLK changed in a way that requires re-programming and False "
"otherwise."
msgstr ""

#: ../../../gpu/i915:237: drivers/gpu/drm/i915/display/intel_cdclk.c:2453
msgid ""
"Determine if changing between the two CDCLK configurations requires only a "
"cd2x divider update"
msgstr ""

#: ../../../gpu/i915:237: drivers/gpu/drm/i915/display/intel_cdclk.c:2459
msgid ""
"True if changing between the two CDCLK configurations can be done with just "
"a cd2x divider update, false if not."
msgstr ""

#: ../../../gpu/i915:237: drivers/gpu/drm/i915/display/intel_cdclk.c:2487
msgid "Determine if two CDCLK configurations are different"
msgstr ""

#: ../../../gpu/i915:237: drivers/gpu/drm/i915/display/intel_cdclk.c:2491
msgid "True if the CDCLK configurations don't match, false if they do."
msgstr ""

#: ../../../gpu/i915:237: drivers/gpu/drm/i915/display/intel_cdclk.c:2697
#: drivers/gpu/drm/i915/display/intel_cdclk.c:2750
msgid "Push the CDCLK state to the hardware"
msgstr ""

#: ../../../gpu/i915:237: drivers/gpu/drm/i915/display/intel_cdclk.c:2699
msgid ""
"Program the hardware before updating the HW plane state based on the new "
"CDCLK state, if necessary."
msgstr ""

#: ../../../gpu/i915:237: drivers/gpu/drm/i915/display/intel_cdclk.c:2752
msgid ""
"Program the hardware after updating the HW plane state based on the new "
"CDCLK state, if necessary."
msgstr ""

#: ../../../gpu/i915:237: drivers/gpu/drm/i915/display/intel_cdclk.c:3419
msgid "Determine the maximum support CDCLK frequency"
msgstr ""

#: ../../../gpu/i915:237: drivers/gpu/drm/i915/display/intel_cdclk.c:3421
msgid ""
"Determine the maximum CDCLK frequency the platform supports, and also derive "
"the maximum dot clock frequency the maximum CDCLK frequency allows."
msgstr ""

#: ../../../gpu/i915:237: drivers/gpu/drm/i915/display/intel_cdclk.c:3502
msgid "Determine the current CDCLK frequency"
msgstr ""

#: ../../../gpu/i915:237: drivers/gpu/drm/i915/display/intel_cdclk.c:3504
msgid "Determine the current CDCLK frequency."
msgstr ""

#: ../../../gpu/i915:237: drivers/gpu/drm/i915/display/intel_cdclk.c:3584
msgid "Determine the current RAWCLK frequency"
msgstr ""

#: ../../../gpu/i915:237: drivers/gpu/drm/i915/display/intel_cdclk.c:3586
msgid ""
"Determine the current RAWCLK frequency. RAWCLK is a fixed frequency clock so "
"this needs to done only once."
msgstr ""

#: ../../../gpu/i915:237: drivers/gpu/drm/i915/display/intel_cdclk.c:3781
msgid "Initialize CDCLK related modesetting hooks"
msgstr ""

#: ../../../gpu/i915.rst:241
msgid "Display PLLs"
msgstr ""

#: ../../../gpu/i915:243: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:47
msgid ""
"Display PLLs used for driving outputs vary by platform. While some have per-"
"pipe or per-encoder dedicated PLLs, others allow the use of any PLL from a "
"pool. In the latter scenario, it is possible that multiple pipes share a PLL "
"if their configurations match."
msgstr ""

#: ../../../gpu/i915:243: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:52
msgid ""
"This file provides an abstraction over display PLLs. The function "
"intel_dpll_init() initializes the PLLs for the given platform.  The users of "
"a PLL are tracked and that tracking is integrated with the atomic modset "
"interface. During an atomic operation, required PLLs can be reserved for a "
"given CRTC and encoder configuration by calling intel_dpll_reserve() and "
"previously reserved PLLs can be released with intel_dpll_release(). Changes "
"to the users are first staged in the atomic state, and then made effective "
"by calling intel_dpll_swap_state() during the atomic commit phase."
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:154
msgid "get a DPLL given its id"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:155
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4503
msgid "intel_display device instance"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:157
msgid "``enum intel_dpll_id id``"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:156
msgid "pll id"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:158
msgid "A pointer to the DPLL with **id**"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:253
msgid "enable a CRTC's DPLL"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:254
msgid "CRTC, and its state, which has a DPLL"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:255
msgid "Enable DPLL used by **crtc**."
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:299
msgid "disable a CRTC's shared DPLL"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:300
msgid "CRTC, and its state, which has a shared DPLL"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:301
msgid "Disable DPLL used by **crtc**."
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:415
msgid "Get a DPLL reference for a CRTC"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:421
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:460
msgid "``const struct intel_crtc *crtc``"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:416
msgid "CRTC on which behalf the reference is taken"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:418
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:457
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4487
msgid "``const struct intel_dpll *pll``"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:417
msgid "DPLL for which the reference is taken"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:419
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:458
msgid "``struct intel_dpll_state *dpll_state``"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:418
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:457
msgid "the DPLL atomic state in which the reference is tracked"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:419
msgid "Take a reference for **pll** tracking the use of it by **crtc**."
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:454
msgid "Drop a DPLL reference for a CRTC"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:455
msgid "CRTC on which behalf the reference is dropped"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:456
msgid "DPLL for which the reference is dropped"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:458
msgid "Drop a reference for **pll** tracking the end of use of it by **crtc**."
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:504
msgid "make atomic DPLL configuration effective"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:505
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4373
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4400
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4433
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4462
msgid "atomic state"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:506
msgid ""
"This is the dpll version of drm_atomic_helper_swap_state() since the helper "
"does not handle driver-specific global state."
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:509
msgid ""
"For consistency with atomic helpers this function does a complete swap, i.e. "
"it also puts the current state into **state**, even though there is no need "
"for that at this moment."
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:3283
msgid "select the active port DPLL for a given CRTC"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:3289
msgid "``struct intel_crtc_state *crtc_state``"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:3284
msgid "state for the CRTC to select the DPLL for"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:3286
msgid "``enum icl_port_dpll_id port_dpll_id``"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:3285
msgid "the active **port_dpll_id** to select"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:3286
msgid ""
"Select the given **port_dpll_id** instance from the DPLLs reserved for the "
"CRTC."
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4310
msgid "Initialize DPLLs"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4311
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4485
msgid "intel_display device"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4312
msgid "Initialize DPLLs for **display**."
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4372
msgid "compute DPLL state CRTC and encoder combination"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4374
msgid "CRTC to compute DPLLs for"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4375
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4402
msgid "encoder"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4376
msgid "This function computes the DPLL state for the given CRTC and encoder."
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4378
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4407
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4438
msgid ""
"The new configuration in the atomic commit **state** is made effective by "
"calling intel_dpll_swap_state()."
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4382
#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:421
#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:625
#: drivers/gpu/drm/i915/i915_perf.c:661 drivers/gpu/drm/i915/i915_perf.c:725
#: drivers/gpu/drm/i915/i915_perf.c:1035
msgid "0 on success, negative error code on failure."
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4399
msgid "reserve DPLLs for CRTC and encoder combination"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4401
msgid "CRTC to reserve DPLLs for"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4403
msgid ""
"This function reserves all required DPLLs for the given CRTC and encoder "
"combination in the current atomic commit **state** and the new **crtc** "
"atomic state."
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4410
msgid "The reserved DPLLs should be released by calling intel_dpll_release()."
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4414
msgid ""
"0 if all required DPLLs were successfully reserved, negative error code "
"otherwise."
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4432
msgid "end use of DPLLs by CRTC in atomic state"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4434
msgid "crtc from which the DPLLs are to be released"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4435
msgid ""
"This function releases all DPLLs reserved by intel_dpll_reserve() from the "
"current atomic commit **state** and the old **crtc** atomic state."
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4461
msgid "update the active DPLL for a CRTC/encoder"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4463
msgid "the CRTC for which to update the active DPLL"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4464
msgid "encoder determining the type of port DPLL"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4465
msgid ""
"Update the active DPLL for the given **crtc**/**encoder** in **crtc**'s "
"atomic state, from the port DPLLs reserved previously by "
"intel_dpll_reserve(). The DPLL selected will be based on the current mode of "
"the encoder's port."
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4484
msgid "calculate the DPLL's output frequency"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4486
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4504
msgid "DPLL for which to calculate the output frequency"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4488
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4590
msgid "``const struct intel_dpll_hw_state *dpll_hw_state``"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4487
msgid "DPLL state from which to calculate the output frequency"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4488
msgid ""
"Return the output frequency corresponding to **pll**'s passed in "
"**dpll_hw_state**."
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4502
msgid "readout the DPLL's hardware state"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4505
msgid "``struct intel_dpll *pll``"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4506
msgid "``struct intel_dpll_hw_state *dpll_hw_state``"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4505
msgid "DPLL's hardware state"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4506
msgid "Read out **pll**'s hardware state into **dpll_hw_state**."
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4586
msgid "dump hw_state"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4587
#: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4609
msgid "intel_display structure"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4589
msgid "``struct drm_printer *p``"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4588
msgid "where to print the state to"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4589
msgid "hw state to be dumped"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4590
msgid "Dumo out the relevant values in **dpll_hw_state**."
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4608
msgid "compare the two states"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4611
msgid "``const struct intel_dpll_hw_state *a``"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4610
msgid "first DPLL hw state"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4612
msgid "``const struct intel_dpll_hw_state *b``"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4611
msgid "second DPLL hw state"
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4612
msgid "Compare DPLL hw states **a** and **b**."
msgstr ""

#: ../../../gpu/i915:246: drivers/gpu/drm/i915/display/intel_dpll_mgr.c:4615
msgid "true if the states are equal, false if the differ"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:47
msgid "possible DPLL ids"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:51
#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:73
msgid "**Constants**"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:53
msgid "``DPLL_ID_PRIVATE``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:54
msgid "non-shared dpll in use"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:56
msgid "``DPLL_ID_PCH_PLL_A``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:57
msgid "DPLL A in ILK, SNB and IVB"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:59
msgid "``DPLL_ID_PCH_PLL_B``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:60
msgid "DPLL B in ILK, SNB and IVB"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:62
msgid "``DPLL_ID_WRPLL1``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:63
msgid "HSW and BDW WRPLL1"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:65
msgid "``DPLL_ID_WRPLL2``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:66
msgid "HSW and BDW WRPLL2"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:68
msgid "``DPLL_ID_SPLL``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:69
msgid "HSW and BDW SPLL"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:71
msgid "``DPLL_ID_LCPLL_810``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:72
msgid "HSW and BDW 0.81 GHz LCPLL"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:74
msgid "``DPLL_ID_LCPLL_1350``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:75
msgid "HSW and BDW 1.35 GHz LCPLL"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:77
msgid "``DPLL_ID_LCPLL_2700``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:78
msgid "HSW and BDW 2.7 GHz LCPLL"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:80
msgid "``DPLL_ID_SKL_DPLL0``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:81
msgid "SKL and later DPLL0"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:83
msgid "``DPLL_ID_SKL_DPLL1``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:84
msgid "SKL and later DPLL1"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:86
msgid "``DPLL_ID_SKL_DPLL2``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:87
msgid "SKL and later DPLL2"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:89
msgid "``DPLL_ID_SKL_DPLL3``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:90
msgid "SKL and later DPLL3"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:92
msgid "``DPLL_ID_ICL_DPLL0``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:93
msgid "ICL/TGL combo PHY DPLL0"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:95
msgid "``DPLL_ID_ICL_DPLL1``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:96
msgid "ICL/TGL combo PHY DPLL1"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:98
msgid "``DPLL_ID_EHL_DPLL4``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:99
msgid "EHL combo PHY DPLL4"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:101
msgid "``DPLL_ID_ICL_TBTPLL``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:102
msgid "ICL/TGL TBT PLL"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:104
msgid "``DPLL_ID_ICL_MGPLL1``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:105
msgid "ICL MG PLL 1 port 1 (C),"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:106
msgid "TGL TC PLL 1 port 1 (TC1)"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:108
msgid "``DPLL_ID_ICL_MGPLL2``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:109
msgid "ICL MG PLL 1 port 2 (D)"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:110
msgid "TGL TC PLL 1 port 2 (TC2)"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:112
msgid "``DPLL_ID_ICL_MGPLL3``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:113
msgid "ICL MG PLL 1 port 3 (E)"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:114
msgid "TGL TC PLL 1 port 3 (TC3)"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:116
msgid "``DPLL_ID_ICL_MGPLL4``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:117
msgid "ICL MG PLL 1 port 4 (F)"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:118
msgid "TGL TC PLL 1 port 4 (TC4)"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:120
msgid "``DPLL_ID_TGL_MGPLL5``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:121
msgid "TGL TC PLL port 5 (TC5)"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:123
msgid "``DPLL_ID_TGL_MGPLL6``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:124
msgid "TGL TC PLL port 6 (TC6)"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:126
msgid "``DPLL_ID_DG1_DPLL0``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:127
msgid "DG1 combo PHY DPLL0"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:129
msgid "``DPLL_ID_DG1_DPLL1``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:130
msgid "DG1 combo PHY DPLL1"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:132
msgid "``DPLL_ID_DG1_DPLL2``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:133
msgid "DG1 combo PHY DPLL2"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:135
msgid "``DPLL_ID_DG1_DPLL3``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:136
msgid "DG1 combo PHY DPLL3"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:48
msgid ""
"Enumeration of possible IDs for a DPLL. Real shared dpll ids must be >= 0."
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:283
msgid "hold the DPLL atomic state"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:294
msgid "``pipe_mask``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:295
msgid "mask of pipes using this DPLL, active or not"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:299
msgid "``hw_state``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:300
msgid ""
"hardware configuration for the DPLL stored in struct :c:type:"
"`intel_dpll_hw_state`."
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:284
msgid ""
"This structure holds an atomic state for the DPLL, that can represent either "
"its current state (in struct :c:type:`intel_shared_dpll`) or a desired "
"future state which would be applied by an atomic mode set (stored in a "
"struct :c:type:`intel_atomic_state`)."
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:289
msgid "See also intel_reserve_shared_dplls() and intel_release_shared_dplls()."
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:306
msgid "display PLL platform specific info"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:310
#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:405
msgid "``name``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:311
msgid "DPLL name; used for logging"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:315
msgid "``funcs``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:316
msgid "platform specific hooks"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:320
msgid "``id``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:321
msgid "unique identifier for this DPLL"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:325
msgid "``power_domain``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:326
msgid "extra power domain required by the DPLL"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:330
msgid "``always_on``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:331
msgid ""
"Inform the state checker that the DPLL is kept enabled even if not in use by "
"any CRTC."
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:338
msgid "``is_alt_port_dpll``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:339
msgid ""
"Inform the state checker that the DPLL can be used as a fallback (for TC-"
">TBT fallback)."
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:347
msgid "display PLL with tracked state and users"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:351
msgid "``state``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:352
msgid "Store the state for the pll, including its hw state and CRTCs using it."
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:359
msgid "``index``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:360
msgid "index for atomic state"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:364
msgid "``active_mask``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:365
msgid "mask of active pipes (i.e. DPMS on) using this DPLL"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:369
msgid "``on``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:370
msgid "is the PLL actually active? Disabled during modeset"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:374
msgid "``info``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:375
msgid "platform specific info"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:379
msgid "``wakeref``"
msgstr ""

#: ../../../gpu/i915:249: drivers/gpu/drm/i915/display/intel_dpll_mgr.h:380
msgid ""
"In some platforms a device-level runtime pm reference may need to be grabbed "
"to disable DC states while this DPLL is enabled"
msgstr ""

#: ../../../gpu/i915.rst:253
msgid "Display State Buffer"
msgstr ""

#: ../../../gpu/i915:255: drivers/gpu/drm/i915/display/intel_dsb.c:62
msgid ""
"A DSB (Display State Buffer) is a queue of MMIO instructions in the memory "
"which can be offloaded to DSB HW in Display Controller. DSB HW is a DMA "
"engine that can be programmed to download the DSB from memory. It allows "
"driver to batch submit display HW programming. This helps to reduce loading "
"time and CPU activity, thereby making the context switch faster. DSB Support "
"added from Gen12 Intel graphics based platform."
msgstr ""

#: ../../../gpu/i915:255: drivers/gpu/drm/i915/display/intel_dsb.c:69
msgid ""
"DSB's can access only the pipe, plane, and transcoder Data Island Packet "
"registers."
msgstr ""

#: ../../../gpu/i915:255: drivers/gpu/drm/i915/display/intel_dsb.c:72
msgid ""
"DSB HW can support only register writes (both indexed and direct MMIO "
"writes). There are no registers reads possible with DSB HW engine."
msgstr ""

#: ../../../gpu/i915:258: drivers/gpu/drm/i915/display/intel_dsb.c:315
msgid "Emit indexed register write to the DSB context"
msgstr ""

#: ../../../gpu/i915:258: drivers/gpu/drm/i915/display/intel_dsb.c:317
msgid "register address."
msgstr ""

#: ../../../gpu/i915:258: drivers/gpu/drm/i915/display/intel_dsb.c:319
msgid "``u32 val``"
msgstr ""

#: ../../../gpu/i915:258: drivers/gpu/drm/i915/display/intel_dsb.c:318
msgid "value."
msgstr ""

#: ../../../gpu/i915:258: drivers/gpu/drm/i915/display/intel_dsb.c:319
msgid ""
"This function is used for writing register-value pair in command buffer of "
"DSB."
msgstr ""

#: ../../../gpu/i915:258: drivers/gpu/drm/i915/display/intel_dsb.c:322
msgid ""
"Note that indexed writes are slower than normal MMIO writes for a small "
"number (less than 5 or so) of writes to the same register."
msgstr ""

#: ../../../gpu/i915:258: drivers/gpu/drm/i915/display/intel_dsb.c:831
msgid "Trigger workload execution of DSB."
msgstr ""

#: ../../../gpu/i915:258: drivers/gpu/drm/i915/display/intel_dsb.c:833
msgid "This function is used to do actual write to hardware using DSB."
msgstr ""

#: ../../../gpu/i915:258: drivers/gpu/drm/i915/display/intel_dsb.c:910
msgid "Allocate, pin and map the DSB command buffer."
msgstr ""

#: ../../../gpu/i915:258: drivers/gpu/drm/i915/display/intel_dsb.c:914
msgid "``enum intel_dsb_id dsb_id``"
msgstr ""

#: ../../../gpu/i915:258: drivers/gpu/drm/i915/display/intel_dsb.c:913
msgid "the DSB engine to use"
msgstr ""

#: ../../../gpu/i915:258: drivers/gpu/drm/i915/display/intel_dsb.c:915
msgid "``unsigned int max_cmds``"
msgstr ""

#: ../../../gpu/i915:258: drivers/gpu/drm/i915/display/intel_dsb.c:914
msgid "number of commands we need to fit into command buffer"
msgstr ""

#: ../../../gpu/i915:258: drivers/gpu/drm/i915/display/intel_dsb.c:915
msgid ""
"This function prepare the command buffer which is used to store dsb "
"instructions with data."
msgstr ""

#: ../../../gpu/i915:258: drivers/gpu/drm/i915/display/intel_dsb.c:919
msgid "DSB context, NULL on failure"
msgstr ""

#: ../../../gpu/i915:258: drivers/gpu/drm/i915/display/intel_dsb.c:974
msgid "To cleanup DSB context."
msgstr ""

#: ../../../gpu/i915:258: drivers/gpu/drm/i915/display/intel_dsb.c:976
msgid ""
"This function cleanup the DSB context by unpinning and releasing the VMA "
"object associated with it."
msgstr ""

#: ../../../gpu/i915.rst:262
msgid "GT Programming"
msgstr ""

#: ../../../gpu/i915.rst:265
msgid "Multicast/Replicated (MCR) Registers"
msgstr ""

#: ../../../gpu/i915:267: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:14
msgid ""
"Some GT registers are designed as \"multicast\" or \"replicated\" registers: "
"multiple instances of the same register share a single MMIO offset.  MCR "
"registers are generally used when the hardware needs to potentially track "
"independent values of a register per hardware unit (e.g., per-subslice, per-"
"L3bank, etc.).  The specific types of replication that exist vary per-"
"platform."
msgstr ""

#: ../../../gpu/i915:267: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:21
msgid ""
"MMIO accesses to MCR registers are controlled according to the settings "
"programmed in the platform's MCR_SELECTOR register(s).  MMIO writes to MCR "
"registers can be done in either a (i.e., a single write updates all "
"instances of the register to the same value) or unicast (a write updates "
"only one specific instance).  Reads of MCR registers always operate in a "
"unicast manner regardless of how the multicast/unicast bit is set in "
"MCR_SELECTOR. Selection of a specific MCR instance for unicast operations is "
"referred to as \"steering.\""
msgstr ""

#: ../../../gpu/i915:267: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:30
msgid ""
"If MCR register operations are steered toward a hardware unit that is fused "
"off or currently powered down due to power gating, the MMIO operation is "
"\"terminated\" by the hardware.  Terminated read operations will return a "
"value of zero and terminated unicast write operations will be silently "
"ignored."
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:314
msgid "Acquire MCR steering lock"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:320
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:388
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:409
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:431
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:450
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:469
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:498
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:525
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:656
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:686
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:720
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:798
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:821
msgid "``struct intel_gt *gt``"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:315
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:383
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:404
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:426
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:445
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:464
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:493
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:520
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:652
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:681
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:715
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:793
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:816
msgid "GT structure"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:317
msgid "``unsigned long *flags``"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:316
msgid "storage to save IRQ flags to"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:317
msgid ""
"Performs locking to protect the steering for the duration of an MCR "
"operation.  On MTL and beyond, a hardware lock will also be taken to "
"serialize access not only for the driver, but also for external hardware and "
"firmware agents."
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:322
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:387
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:431
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:453
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:469
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:501
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:536
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:692
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:723
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:840
msgid "**Context**"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:323
msgid ""
"Takes gt->mcr_lock.  uncore->lock should *not* be held when this function is "
"called, although it may be acquired after this function call."
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:382
msgid "Release MCR steering lock"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:385
msgid "``unsigned long flags``"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:384
msgid "IRQ flags to restore"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:385
msgid "Releases the lock acquired by intel_gt_mcr_lock()."
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:388
msgid "Releases gt->mcr_lock"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:403
msgid "Sanitize MCR steering lock"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:405
msgid ""
"This will be used to sanitize the initial status of the hardware lock during "
"driver load and resume since there won't be any concurrent access from other "
"agents at those times, but it's possible that boot firmware may have left "
"the lock in a bad state."
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:425
msgid "read a specific instance of an MCR register"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:428
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:447
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:466
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:495
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:522
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:654
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:683
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:717
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:818
msgid "``i915_mcr_reg_t reg``"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:427
msgid "the MCR register to read"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:429
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:449
msgid "``int group``"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:428
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:448
msgid "the MCR group"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:430
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:450
msgid "``int instance``"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:429
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:449
msgid "the MCR instance"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:431
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:470
msgid "Takes and releases gt->mcr_lock"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:432
msgid ""
"Returns the value read from an MCR register after steering toward a specific "
"group/instance."
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:444
msgid "write a specific instance of an MCR register"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:446
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:465
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:494
msgid "the MCR register to write"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:447
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:466
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:495
msgid "value to write"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:450
msgid ""
"Write an MCR register in unicast mode after steering toward a specific group/"
"instance."
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:454
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:841
msgid "Calls a function that takes and releases gt->mcr_lock"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:463
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:492
msgid "write a value to all instances of an MCR register"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:467
msgid "Write an MCR register in multicast mode to update all instances."
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:496
msgid ""
"Write an MCR register in multicast mode to update all instances.  This "
"function assumes the caller is already holding any necessary forcewake "
"domains; use intel_gt_mcr_multicast_write() in cases where forcewake should "
"be obtained automatically."
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:502
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:690
msgid "The caller must hold gt->mcr_lock."
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:519
msgid "Performs a multicast RMW operations"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:521
msgid "the MCR register to read and write"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:523
msgid "``u32 clear``"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:522
msgid "bits to clear during RMW"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:524
msgid "``u32 set``"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:523
msgid "bits to set during RMW"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:524
msgid ""
"Performs a read-modify-write on an MCR register in a multicast manner. This "
"operation only makes sense on MCR registers where all instances are expected "
"to have the same value.  The read will target any non-terminated instance "
"and the write will be applied to all instances."
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:529
msgid ""
"This function assumes the caller is already holding any necessary forcewake "
"domains; use intel_gt_mcr_multicast_rmw() in cases where forcewake should be "
"obtained automatically."
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:534
msgid "Returns the old (unmodified) value read."
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:534
msgid "Calls functions that take and release gt->mcr_lock"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:650
msgid ""
"find group/instance values that will steer a register to a non-terminated "
"instance"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:653
msgid "register for which the steering is required"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:655
msgid "``u8 *group``"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:654
msgid "return variable for group steering"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:656
msgid "``u8 *instance``"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:655
msgid "return variable for instance steering"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:656
msgid ""
"This function returns a group/instance pair that is guaranteed to work for "
"read steering of the given register. Note that a value will be returned even "
"if the register is not replicated and therefore does not actually require "
"steering."
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:680
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:714
msgid "reads one instance of an MCR register"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:682
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:716
msgid "register to read"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:683
msgid ""
"Reads a GT MCR register.  The read will be steered to a non-terminated "
"instance (i.e., one that isn't fused off or powered down by power gating). "
"This function assumes the caller is already holding any necessary forcewake "
"domains; use intel_gt_mcr_read_any() in cases where forcewake should be "
"obtained automatically."
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:690
#: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:721
msgid "Returns the value from a non-terminated instance of **reg**."
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:717
msgid ""
"Reads a GT MCR register.  The read will be steered to a non-terminated "
"instance (i.e., one that isn't fused off or powered down by power gating)."
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:721
msgid "Calls a function that takes and releases gt->mcr_lock."
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:792
msgid "returns the group/instance steering for a SS"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:795
msgid "``unsigned int dss``"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:794
msgid "DSS ID to obtain steering for"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:796
msgid "``unsigned int *group``"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:795
msgid "pointer to storage for steering group ID"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:797
msgid "``unsigned int *instance``"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:796
msgid "pointer to storage for steering instance ID"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:797
msgid ""
"Returns the steering IDs (via the **group** and **instance** parameters) "
"that correspond to a specific subslice/DSS ID."
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:815
msgid "wait until MCR register matches expected state"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:819
msgid "value to wait for"
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:831
msgid ""
"This function is basically an MCR-friendly version of "
"__intel_wait_for_register_fw().  Generally this function will only be used "
"on GAM registers which are a bit special --- although they're MCR registers, "
"reads (e.g., waiting for status updates) are always directed to the primary "
"instance."
msgstr ""

#: ../../../gpu/i915:270: drivers/gpu/drm/i915/gt/intel_gt_mcr.c:837
msgid ""
"Note that this routine assumes the caller holds forcewake asserted, it is "
"not suitable for very long waits."
msgstr ""

#: ../../../gpu/i915.rst:274
msgid "Memory Management and Command Submission"
msgstr ""

#: ../../../gpu/i915.rst:276
msgid ""
"This sections covers all things related to the GEM implementation in the "
"i915 driver."
msgstr ""

#: ../../../gpu/i915.rst:280
msgid "Intel GPU Basics"
msgstr ""

#: ../../../gpu/i915.rst:282
msgid "An Intel GPU has multiple engines. There are several engine types:"
msgstr ""

#: ../../../gpu/i915.rst:284
msgid ""
"Render Command Streamer (RCS). An engine for rendering 3D and performing "
"compute."
msgstr ""

#: ../../../gpu/i915.rst:286
msgid ""
"Blitting Command Streamer (BCS). An engine for performing blitting and/or "
"copying operations."
msgstr ""

#: ../../../gpu/i915.rst:288
msgid ""
"Video Command Streamer. An engine used for video encoding and decoding. Also "
"sometimes called 'BSD' in hardware documentation."
msgstr ""

#: ../../../gpu/i915.rst:290
msgid ""
"Video Enhancement Command Streamer (VECS). An engine for video enhancement. "
"Also sometimes called 'VEBOX' in hardware documentation."
msgstr ""

#: ../../../gpu/i915.rst:292
msgid ""
"Compute Command Streamer (CCS). An engine that has access to the media and "
"GPGPU pipelines, but not the 3D pipeline."
msgstr ""

#: ../../../gpu/i915.rst:294
msgid ""
"Graphics Security Controller (GSCCS). A dedicated engine for internal "
"communication with GSC controller on security related tasks like High-"
"bandwidth Digital Content Protection (HDCP), Protected Xe Path (PXP), and "
"HuC firmware authentication."
msgstr ""

#: ../../../gpu/i915.rst:299
msgid ""
"The Intel GPU family is a family of integrated GPU's using Unified Memory "
"Access. For having the GPU \"do work\", user space will feed the GPU batch "
"buffers via one of the ioctls `DRM_IOCTL_I915_GEM_EXECBUFFER2` or "
"`DRM_IOCTL_I915_GEM_EXECBUFFER2_WR`. Most such batchbuffers will instruct "
"the GPU to perform work (for example rendering) and that work needs memory "
"from which to read and memory to which to write. All memory is encapsulated "
"within GEM buffer objects (usually created with the ioctl "
"`DRM_IOCTL_I915_GEM_CREATE`). An ioctl providing a batchbuffer for the GPU "
"to create will also list all GEM buffer objects that the batchbuffer reads "
"and/or writes. For implementation details of memory management see `GEM BO "
"Management Implementation Details`_."
msgstr ""

#: ../../../gpu/i915.rst:311
msgid ""
"The i915 driver allows user space to create a context via the ioctl "
"`DRM_IOCTL_I915_GEM_CONTEXT_CREATE` which is identified by a 32-bit integer. "
"Such a context should be viewed by user-space as -loosely- analogous to the "
"idea of a CPU process of an operating system. The i915 driver guarantees "
"that commands issued to a fixed context are to be executed so that writes of "
"a previously issued command are seen by reads of following commands. Actions "
"issued between different contexts (even if from the same file descriptor) "
"are NOT given that guarantee and the only way to synchronize across contexts "
"(even from the same file descriptor) is through the use of fences. At least "
"as far back as Gen4, also have that a context carries with it a GPU HW "
"context; the HW context is essentially (most of at least) the state of a "
"GPU. In addition to the ordering guarantees, the kernel will restore GPU "
"state via HW context when commands are issued to a context, this saves user "
"space the need to restore (most of at least) the GPU state at the start of "
"each batchbuffer. The non-deprecated ioctls to submit batchbuffer work can "
"pass that ID (in the lower bits of drm_i915_gem_execbuffer2::rsvd1) to "
"identify what context to use with the command."
msgstr ""

#: ../../../gpu/i915.rst:330
msgid ""
"The GPU has its own memory management and address space. The kernel driver "
"maintains the memory translation table for the GPU. For older GPUs (i.e. "
"those before Gen8), there is a single global such translation table, a "
"global Graphics Translation Table (GTT). For newer generation GPUs each "
"context has its own translation table, called Per-Process Graphics "
"Translation Table (PPGTT). Of important note, is that although PPGTT is "
"named per-process it is actually per context. When user space submits a "
"batchbuffer, the kernel walks the list of GEM buffer objects used by the "
"batchbuffer and guarantees that not only is the memory of each such GEM "
"buffer object resident but it is also present in the (PP)GTT. If the GEM "
"buffer object is not yet placed in the (PP)GTT, then it is given an address. "
"Two consequences of this are: the kernel needs to edit the batchbuffer "
"submitted to write the correct value of the GPU address when a GEM BO is "
"assigned a GPU address and the kernel might evict a different GEM BO from "
"the (PP)GTT to make address room for another GEM BO. Consequently, the "
"ioctls submitting a batchbuffer for execution also include a list of all "
"locations within buffers that refer to GPU-addresses so that the kernel can "
"edit the buffer correctly. This process is dubbed relocation."
msgstr ""

#: ../../../gpu/i915.rst:351
msgid "Locking Guidelines"
msgstr ""

#: ../../../gpu/i915.rst:354
msgid ""
"This is a description of how the locking should be after refactoring is "
"done. Does not necessarily reflect what the locking looks like while WIP."
msgstr ""

#: ../../../gpu/i915.rst:358
msgid ""
"All locking rules and interface contracts with cross-driver interfaces (dma-"
"buf, dma_fence) need to be followed."
msgstr ""

#: ../../../gpu/i915.rst:361
msgid ""
"dma_resv will be the outermost lock (when needed) and ww_acquire_ctx is to "
"be hoisted at highest level and passed down within i915_gem_ctx in the call "
"chain"
msgstr ""

#: ../../../gpu/i915.rst:365
msgid ""
"While holding lru/memory manager (buddy, drm_mm, whatever) locks system "
"memory allocations are not allowed"
msgstr ""

#: ../../../gpu/i915.rst:368
msgid ""
"Do not nest different lru/memory manager locks within each other. Take them "
"in turn to update memory allocations, relying on the objects dma_resv "
"ww_mutex to serialize against other operations."
msgstr ""

#: ../../../gpu/i915.rst:372
msgid ""
"The suggestion for lru/memory managers locks is that they are small enough "
"to be spinlocks."
msgstr ""

#: ../../../gpu/i915.rst:375
msgid ""
"All features need to come with exhaustive kernel selftests and/or IGT tests "
"when appropriate"
msgstr ""

#: ../../../gpu/i915.rst:378
msgid ""
"All LMEM uAPI paths need to be fully restartable (_interruptible() for all "
"locks/waits/sleeps)"
msgstr ""

#: ../../../gpu/i915.rst:381
msgid ""
"Error handling validation through signal injection. Still the best strategy "
"we have for validating GEM uAPI corner cases. Must be excessively used in "
"the IGT, and we need to check that we really have full path coverage of all "
"error cases."
msgstr ""

#: ../../../gpu/i915.rst:387
msgid "-EDEADLK handling with ww_mutex"
msgstr ""

#: ../../../gpu/i915.rst:390
msgid "GEM BO Management Implementation Details"
msgstr ""

#: ../../../gpu/i915:392: drivers/gpu/drm/i915/i915_vma_types.h:126
msgid ""
"A VMA represents a GEM BO that is bound into an address space. Therefore, a "
"VMA's presence cannot be guaranteed before binding, or after unbinding the "
"object into/from the address space."
msgstr ""

#: ../../../gpu/i915:392: drivers/gpu/drm/i915/i915_vma_types.h:130
msgid ""
"To make things as simple as possible (ie. no refcounting), a VMA's lifetime "
"will always be <= an objects lifetime. So object refcounting should cover us."
msgstr ""

#: ../../../gpu/i915.rst:396
msgid "Buffer Object Eviction"
msgstr ""

#: ../../../gpu/i915.rst:398
msgid ""
"This section documents the interface functions for evicting buffer objects "
"to make space available in the virtual gpu address spaces. Note that this is "
"mostly orthogonal to shrinking buffer objects caches, which has the goal to "
"make main memory (shared with the gpu through the unified memory "
"architecture) available."
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:124
#: drivers/gpu/drm/i915/i915_gem_evict.c:317
msgid "Evict vmas to make room for binding a new one"
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:130
#: drivers/gpu/drm/i915/i915_gem_evict.c:323
#: drivers/gpu/drm/i915/i915_gem_evict.c:446 ../../../gpu/i915:452:
#: drivers/gpu/drm/i915/i915_gem_gtt.c:77
#: drivers/gpu/drm/i915/i915_gem_gtt.c:161
msgid "``struct i915_address_space *vm``"
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:125
#: drivers/gpu/drm/i915/i915_gem_evict.c:318
msgid "address space to evict from"
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:127
#: drivers/gpu/drm/i915/i915_gem_evict.c:320
#: drivers/gpu/drm/i915/i915_gem_evict.c:443 ../../../gpu/i915:415:
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:82 ../../../gpu/i915:452:
#: drivers/gpu/drm/i915/i915_gem_gtt.c:74
#: drivers/gpu/drm/i915/i915_gem_gtt.c:158
msgid "``struct i915_gem_ww_ctx *ww``"
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:126
#: drivers/gpu/drm/i915/i915_gem_evict.c:319 ../../../gpu/i915:452:
#: drivers/gpu/drm/i915/i915_gem_gtt.c:73
#: drivers/gpu/drm/i915/i915_gem_gtt.c:157
msgid "An optional struct i915_gem_ww_ctx."
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:128
msgid "``u64 min_size``"
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:127
msgid "size of the desired free space"
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:129
#: ../../../gpu/i915:452: drivers/gpu/drm/i915/i915_gem_gtt.c:162
msgid "``u64 alignment``"
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:128
msgid "alignment constraint of the desired free space"
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:130
#: ../../../gpu/i915:452: drivers/gpu/drm/i915/i915_gem_gtt.c:81
#: drivers/gpu/drm/i915/i915_gem_gtt.c:165
msgid "``unsigned long color``"
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:129
msgid "color for the desired space"
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:131
#: ../../../gpu/i915:452: drivers/gpu/drm/i915/i915_gem_gtt.c:166
msgid "``u64 start``"
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:130
msgid "start (inclusive) of the range from which to evict objects"
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:132
#: ../../../gpu/i915:452: drivers/gpu/drm/i915/i915_gem_gtt.c:168
msgid "``u64 end``"
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:131
msgid "end (exclusive) of the range from which to evict objects"
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:133
msgid "``unsigned flags``"
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:132
#: drivers/gpu/drm/i915/i915_gem_evict.c:321
msgid "additional flags to control the eviction algorithm"
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:133
msgid ""
"This function will try to evict vmas until a free space satisfying the "
"requirements is found. Callers must check first whether any such hole exists "
"already before calling this function."
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:137
msgid "This function is used by the object/vma binding code."
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:139
msgid ""
"Since this function is only used to free up virtual address space it only "
"ignores pinned vmas, and not object where the backing storage itself is "
"pinned. Hence obj->pages_pin_count does not protect against eviction."
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:143
#: drivers/gpu/drm/i915/i915_gem_evict.c:324
#: drivers/gpu/drm/i915/i915_gem_evict.c:454
msgid ""
"To clarify: This is for freeing up virtual address space, not for freeing "
"memory in e.g. the shrinker."
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:321
msgid "``struct drm_mm_node *target``"
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:320
msgid "range (and color) to evict for"
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:322
#: ../../../gpu/i915:452: drivers/gpu/drm/i915/i915_gem_gtt.c:83
#: drivers/gpu/drm/i915/i915_gem_gtt.c:170
msgid "``unsigned int flags``"
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:322
msgid "This function will try to evict vmas that overlap the target node."
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:440
msgid "Evict all idle vmas from a vm"
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:441
msgid "Address space to cleanse"
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:442
msgid ""
"An optional struct i915_gem_ww_ctx. If not NULL, i915_gem_evict_vm will be "
"able to evict vma's locked by the ww as well."
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:445
msgid "``struct drm_i915_gem_object **busy_bo``"
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:444
msgid ""
"Optional pointer to struct drm_i915_gem_object. If not NULL, then in the "
"event i915_gem_evict_vm() is unable to trylock an object for eviction, then "
"**busy_bo** will point to it. -EBUSY is also returned. The caller must drop "
"the vm->mutex, before trying again to acquire the contended lock. The caller "
"also owns a reference to the object."
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:449
msgid "This function evicts all vmas from a vm."
msgstr ""

#: ../../../gpu/i915:404: drivers/gpu/drm/i915/i915_gem_evict.c:451
msgid ""
"This is used by the execbuf code as a last-ditch effort to defragment the "
"address space."
msgstr ""

#: ../../../gpu/i915.rst:408
msgid "Buffer Object Memory Shrinking"
msgstr ""

#: ../../../gpu/i915.rst:410
msgid ""
"This section documents the interface function for shrinking memory usage of "
"buffer object caches. Shrinking is used to make main memory available. Note "
"that this is mostly orthogonal to evicting buffer objects, which has the "
"goal to make space in gpu virtual address spaces."
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:76
msgid "Shrink buffer object caches"
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:77
msgid "i915 gem ww acquire ctx, or NULL"
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:78
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:261 ../../../gpu/i915:476:
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:46
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:86
msgid "i915 device"
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:80
msgid "``unsigned long target``"
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:79
msgid "amount of memory to make available, in pages"
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:81
msgid "``unsigned long *nr_scanned``"
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:80
msgid "optional output for number of pages scanned (incremental)"
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:82
msgid "``unsigned int shrink``"
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:81
msgid "control flags for selecting cache types"
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:82
msgid ""
"This function is the main interface to the shrinker. It will try to release "
"up to **target** pages of main memory backing storage from buffer objects. "
"Selection of the specific caches can be done with **flags**. This is e.g. "
"useful when purgeable objects should be removed from caches preferentially."
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:87
msgid ""
"Note that it's not guaranteed that released amount is actually available as "
"free system memory - the pages might still be in-used to due to other "
"reasons (like cpu mmaps) or the mm core has reused them before we could grab "
"them. Therefore code that needs to explicitly shrink buffer objects caches "
"(e.g. to avoid deadlocks in memory reclaim) must fall back to "
"i915_gem_shrink_all()."
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:93
msgid ""
"Also note that any kind of pinning (both per-vma address space pins and "
"backing storage pins at the buffer object level) result in the shrinker code "
"having to skip the object."
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:98
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:270
msgid "The number of pages of backing storage actually released."
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:260
msgid "Shrink buffer object caches completely"
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:262
msgid ""
"This is a simple wrapper around i915_gem_shrink() to aggressively shrink all "
"caches completely. It also first waits for and retires all outstanding "
"requests to also be able to release backing storage for active objects."
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:266
msgid ""
"This should only be used in code to intentionally quiescent the gpu or as a "
"last-ditch effort when memory seems to have run out."
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:474
msgid ""
"Hide the object from the shrinker. By default all object types that support "
"shrinking(see IS_SHRINKABLE), will also make the object visible to the "
"shrinker after allocating the system memory pages."
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:480
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:539
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:555
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:571
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:587 ../../../gpu/i915:458:
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:771
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:808
msgid "``struct drm_i915_gem_object *obj``"
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:478
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:536
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:552
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:568
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:585
msgid "The GEM object."
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:479
msgid ""
"This is typically used for special kernel internal objects that can't be "
"easily processed by the shrinker, like if they are perma-pinned."
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:533
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:565
msgid ""
"Move the object to the tail of the shrinkable list. Objects on this list "
"might be swapped out. Used with WILLNEED objects."
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:537
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:553
msgid ""
"DO NOT USE. This is intended to be called on very special objects that don't "
"yet have mm.pages, but are guaranteed to have potentially reclaimable pages "
"underneath."
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:549
msgid ""
"Move the object to the tail of the purgeable list. Objects on this list "
"might be swapped out. Used with DONTNEED objects."
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:569
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:586
msgid "MUST only be called on objects which have backing pages."
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:571
#: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:588
msgid ""
"MUST be balanced with previous call to i915_gem_object_make_unshrinkable()."
msgstr ""

#: ../../../gpu/i915:415: drivers/gpu/drm/i915/gem/i915_gem_shrinker.c:581
msgid ""
"Move the object to the tail of the purgeable list. Used with DONTNEED "
"objects. Unlike with shrinkable objects, the shrinker will attempt to "
"discard the backing pages, instead of trying to swap them out."
msgstr ""

#: ../../../gpu/i915.rst:419
msgid "Batchbuffer Parsing"
msgstr ""

#: ../../../gpu/i915:421: drivers/gpu/drm/i915/i915_cmd_parser.c:43
msgid ""
"Motivation: Certain OpenGL features (e.g. transform feedback, performance "
"monitoring) require userspace code to submit batches containing commands "
"such as MI_LOAD_REGISTER_IMM to access various registers. Unfortunately, "
"some generations of the hardware will noop these commands in \"unsecure\" "
"batches (which includes all userspace batches submitted via i915) even "
"though the commands may be safe and represent the intended programming model "
"of the device."
msgstr ""

#: ../../../gpu/i915:421: drivers/gpu/drm/i915/i915_cmd_parser.c:52
msgid ""
"The software command parser is similar in operation to the command parsing "
"done in hardware for unsecure batches. However, the software parser allows "
"some operations that would be noop'd by hardware, if the parser determines "
"the operation is safe, and submits the batch as \"secure\" to prevent "
"hardware parsing."
msgstr ""

#: ../../../gpu/i915:421: drivers/gpu/drm/i915/i915_cmd_parser.c:58
msgid ""
"Threats: At a high level, the hardware (and software) checks attempt to "
"prevent granting userspace undue privileges. There are three categories of "
"privilege."
msgstr ""

#: ../../../gpu/i915:421: drivers/gpu/drm/i915/i915_cmd_parser.c:62
msgid ""
"First, commands which are explicitly defined as privileged or which should "
"only be used by the kernel driver. The parser rejects such commands"
msgstr ""

#: ../../../gpu/i915:421: drivers/gpu/drm/i915/i915_cmd_parser.c:65
msgid ""
"Second, commands which access registers. To support correct/enhanced "
"userspace functionality, particularly certain OpenGL extensions, the parser "
"provides a whitelist of registers which userspace may safely access"
msgstr ""

#: ../../../gpu/i915:421: drivers/gpu/drm/i915/i915_cmd_parser.c:69
msgid ""
"Third, commands which access privileged memory (i.e. GGTT, HWS page, etc). "
"The parser always rejects such commands."
msgstr ""

#: ../../../gpu/i915:421: drivers/gpu/drm/i915/i915_cmd_parser.c:72
msgid ""
"The majority of the problematic commands fall in the MI_* range, with only a "
"few specific commands on each engine (e.g. PIPE_CONTROL and MI_FLUSH_DW)."
msgstr ""

#: ../../../gpu/i915:421: drivers/gpu/drm/i915/i915_cmd_parser.c:75
msgid ""
"Implementation: Each engine maintains tables of commands and registers which "
"the parser uses in scanning batch buffers submitted to that engine."
msgstr ""

#: ../../../gpu/i915:421: drivers/gpu/drm/i915/i915_cmd_parser.c:79
msgid ""
"Since the set of commands that the parser must check for is significantly "
"smaller than the number of commands supported, the parser tables contain "
"only those commands required by the parser. This generally works because "
"command opcode ranges have standard command length encodings. So for "
"commands that the parser does not need to check, it can easily skip them. "
"This is implemented via a per-engine length decoding vfunc."
msgstr ""

#: ../../../gpu/i915:421: drivers/gpu/drm/i915/i915_cmd_parser.c:86
msgid ""
"Unfortunately, there are a number of commands that do not follow the "
"standard length encoding for their opcode range, primarily amongst the MI_* "
"commands. To handle this, the parser provides a way to define explicit "
"\"skip\" entries in the per-engine command tables."
msgstr ""

#: ../../../gpu/i915:421: drivers/gpu/drm/i915/i915_cmd_parser.c:91
msgid ""
"Other command table entries map fairly directly to high level categories "
"mentioned above: rejected, register whitelist. The parser implements a "
"number of checks, including the privileged memory checks, via a general "
"bitmasking mechanism."
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:948
msgid "set cmd parser related fields for an engine"
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:954
#: drivers/gpu/drm/i915/i915_cmd_parser.c:1068
#: drivers/gpu/drm/i915/i915_cmd_parser.c:1431
msgid "``struct intel_engine_cs *engine``"
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:949
msgid "the engine to initialize"
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:950
msgid ""
"Optionally initializes fields related to batch buffer command parsing in the "
"struct intel_engine_cs based on whether the platform requires software "
"command parsing."
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:1062
msgid "clean up cmd parser related fields"
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:1063
msgid "the engine to clean up"
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:1064
msgid ""
"Releases any resources related to command parsing that may have been "
"initialized for the specified engine."
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:1425
msgid "parse a batch buffer for privilege violations"
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:1426
msgid "the engine on which the batch is to execute"
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:1428
msgid "``struct i915_vma *batch``"
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:1427
msgid "the batch buffer in question"
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:1429
msgid "``unsigned long batch_offset``"
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:1428
msgid "byte offset in the batch at which execution starts"
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:1430
msgid "``unsigned long batch_length``"
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:1429
msgid "length of the commands in batch_obj"
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:1431
msgid "``struct i915_vma *shadow``"
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:1430
msgid "validated copy of the batch buffer in question"
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:1432
msgid "``bool trampoline``"
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:1431
msgid "true if we need to trampoline into privileged execution"
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:1432
msgid ""
"Parses the specified batch buffer looking for privilege violations as "
"described in the overview."
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:1436
msgid ""
"non-zero if the parser finds violations or otherwise fails; -EACCES if the "
"batch appears legal but should use hardware parsing"
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:1581
msgid "get the cmd parser version number"
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:1583
msgid ""
"The cmd parser maintains a simple increasing integer version number suitable "
"for passing to userspace clients to determine what operations are permitted."
msgstr ""

#: ../../../gpu/i915:424: drivers/gpu/drm/i915/i915_cmd_parser.c:1587
msgid "the current version number of the cmd parser"
msgstr ""

#: ../../../gpu/i915.rst:428
msgid "User Batchbuffer Execution"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:33
msgid "A set of engines"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:1
msgid "``{unnamed_union}``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:2
msgid "anonymous"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:37
#: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:295
msgid "``link``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:38
msgid "Link in i915_gem_context::stale::engines"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:40
#: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:328
msgid "``rcu``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:41
msgid "RCU to use when freeing"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:44
msgid "``fence``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:45
msgid "Fence used for delayed destruction of engines"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:47
#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:203
msgid "``ctx``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:48
msgid "i915_gem_context backpointer"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:50
msgid "``num_engines``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:51
msgid "Number of engines in this set"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:53
#: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:64
#: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:235
msgid "``engines``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:54
msgid "Array of engines"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:58
msgid "Iterator for an i915_gem_engines set"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:61
msgid "``idx``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:62
msgid "Index into i915_gem_engines::engines"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:65
msgid "Engine set being iterated"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:69
msgid "Describes the type of an i915_gem_proto_engine"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:75
msgid "``I915_GEM_ENGINE_TYPE_INVALID``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:76
msgid "An invalid engine"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:78
msgid "``I915_GEM_ENGINE_TYPE_PHYSICAL``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:79
msgid "A single physical engine"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:81
msgid "``I915_GEM_ENGINE_TYPE_BALANCED``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:82
msgid "A load-balanced engine set"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:84
msgid "``I915_GEM_ENGINE_TYPE_PARALLEL``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:85
msgid "A parallel engine set"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:86
msgid "prototype engine"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:108
msgid "``type``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:109
msgid "Type of this engine"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:111
#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:179
#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:353
msgid "``engine``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:112
msgid "Engine, for physical"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:114
msgid "``num_siblings``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:115
msgid "Number of balanced or parallel siblings"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:117
msgid "``width``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:118
msgid "Width of each sibling"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:120
msgid "``siblings``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:121
msgid "Balanced siblings or num_siblings * width for parallel"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:123
#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:355
msgid "``sseu``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:124
msgid "Client-set SSEU parameters"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:87
msgid ""
"This struct describes an engine that a context may contain.  Engines have "
"four types:"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:90
msgid ""
"I915_GEM_ENGINE_TYPE_INVALID: Invalid engines can be created but they show "
"up as a NULL in i915_gem_engines::engines[i] and any attempt to use them by "
"the user results in -EINVAL.  They are also useful during proto-context "
"construction because the client may create invalid engines and then set them "
"up later as virtual engines."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:96
msgid ""
"I915_GEM_ENGINE_TYPE_PHYSICAL: A single physical engine, described by "
"i915_gem_proto_engine::engine."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:99
msgid ""
"I915_GEM_ENGINE_TYPE_BALANCED: A load-balanced engine set, described "
"i915_gem_proto_engine::num_siblings and i915_gem_proto_engine::siblings."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:102
msgid ""
"I915_GEM_ENGINE_TYPE_PARALLEL: A parallel submission engine set, described "
"i915_gem_proto_engine::width, i915_gem_proto_engine::num_siblings, and "
"i915_gem_proto_engine::siblings."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:128
msgid "prototype context"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:190
msgid "``fpriv``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:191
msgid "Client which creates the context"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:193
#: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:275
msgid "``vm``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:194
msgid "See :c:type:`i915_gem_context.vm <i915_gem_context>`"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:196
#: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:333
msgid "``user_flags``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:197
msgid "See :c:type:`i915_gem_context.user_flags <i915_gem_context>`"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:199
#: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:374
msgid "``sched``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:200
msgid "See :c:type:`i915_gem_context.sched <i915_gem_context>`"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:202
msgid "``num_user_engines``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:203
msgid "Number of user-specified engines or -1"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:205
msgid "``user_engines``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:206
msgid "User-specified engines"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:208
msgid "``legacy_rcs_sseu``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:209
msgid "Client-set SSEU parameters for the legacy RCS"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:211
msgid "``single_timeline``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:212
msgid "See See :c:type:`i915_gem_context.syncobj <i915_gem_context>`"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:214
#: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:350
msgid "``uses_protected_content``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:215
msgid ""
"See :c:type:`i915_gem_context.uses_protected_content <i915_gem_context>`"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:217
#: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:360
msgid "``pxp_wakeref``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:218
msgid "See :c:type:`i915_gem_context.pxp_wakeref <i915_gem_context>`"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:129
msgid ""
"The struct i915_gem_proto_context represents the creation parameters for a "
"struct i915_gem_context.  This is used to gather parameters provided either "
"through creation flags or via SET_CONTEXT_PARAM so that, when we create the "
"final i915_gem_context, those parameters can be immutable."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:134
msgid ""
"The context uAPI allows for two methods of setting context parameters: "
"SET_CONTEXT_PARAM and CONTEXT_CREATE_EXT_SETPARAM.  The former is allowed to "
"be called at any time while the later happens as part of "
"GEM_CONTEXT_CREATE.  When these were initially added, Currently, everything "
"settable via one is settable via the other.  While some params are fairly "
"simple and setting them on a live context is harmless such the context "
"priority, others are far trickier such as the VM or the set of engines.  To "
"avoid some truly nasty race conditions, we don't allow setting the VM or the "
"set of engines on live contexts."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:144
msgid ""
"The way we dealt with this without breaking older userspace that sets the VM "
"or engine set via SET_CONTEXT_PARAM is to delay the creation of the actual "
"context until after the client is done configuring it with "
"SET_CONTEXT_PARAM.  From the perspective of the client, it has the same u32 "
"context ID the whole time.  From the perspective of i915, however, it's an "
"i915_gem_proto_context right up until the point where we attempt to do "
"something which the proto-context can't handle at which point the real "
"context gets created."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:153
msgid ""
"This is accomplished via a little xarray dance.  When GEM_CONTEXT_CREATE is "
"called, we create a proto-context, reserve a slot in context_xa but leave it "
"NULL, the proto-context in the corresponding slot in proto_context_xa.  "
"Then, whenever we go to look up a context, we first check context_xa.  If "
"it's there, we return the i915_gem_context and we're done.  If it's not, we "
"look in proto_context_xa and, if we find it there, we create the actual "
"context and kill the proto-context."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:161
msgid ""
"At the time we made this change (April, 2021), we did a fairly complete "
"audit of existing userspace to ensure this wouldn't break anything:"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:164
msgid "Mesa/i965 didn't use the engines or VM APIs at all"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:166
msgid ""
"Mesa/ANV used the engines API but via CONTEXT_CREATE_EXT_SETPARAM and didn't "
"use the VM API."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:169
msgid "Mesa/iris didn't use the engines or VM APIs at all"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:171
msgid ""
"The open-source compute-runtime didn't yet use the engines API but did use "
"the VM API via SET_CONTEXT_PARAM.  However, CONTEXT_SETPARAM was always the "
"second ioctl on that context, immediately following GEM_CONTEXT_CREATE."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:176
msgid ""
"The media driver sets engines and bonding/balancing via SET_CONTEXT_PARAM.  "
"However, CONTEXT_SETPARAM to set the VM was always the second ioctl on that "
"context, immediately following GEM_CONTEXT_CREATE and setting engines "
"immediately followed that."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:181
msgid ""
"In order for this dance to work properly, any modification to an "
"i915_gem_proto_context that is exposed to the client via "
"drm_i915_file_private::proto_context_xa must be guarded by "
"drm_i915_file_private::proto_context_lock.  The exception is when a proto-"
"context has not yet been exposed such as when handling "
"CONTEXT_CREATE_SET_PARAM during GEM_CONTEXT_CREATE."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:222
msgid "client state"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:228
msgid "``i915``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:229
msgid "i915 device backpointer"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:231
msgid "``file_priv``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:232
msgid "owning file descriptor"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:236
msgid "User defined engines for this context"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:238
msgid ""
"Various uAPI offer the ability to lookup up an index from this array to "
"select an engine operate on."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:241
msgid ""
"Multiple logically distinct instances of the same engine may be defined in "
"the array, as well as composite virtual engines."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:245
msgid ""
"Execbuf uses the I915_EXEC_RING_MASK as an index into this array to select "
"which HW context + engine to execute on. For the default array, the "
"user_ring_map[] is used to translate the legacy uABI onto the appropriate "
"index (e.g. both I915_EXEC_DEFAULT and I915_EXEC_RENDER select the same "
"context, and I915_EXEC_BSD is weird). For a user defined array, execbuf uses "
"I915_EXEC_RING_MASK as a plain index."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:253
msgid ""
"User defined by I915_CONTEXT_PARAM_ENGINE (when the CONTEXT_USER_ENGINES "
"flag is set)."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:257
msgid "``engines_mutex``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:258
msgid "guards writes to engines"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:261
msgid "``syncobj``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:262
msgid "Shared timeline syncobj"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:264
msgid ""
"When the SHARED_TIMELINE flag is set on context creation, we emulate a "
"single timeline across all engines using this syncobj. For every execbuffer2 "
"call, this syncobj is used as both an in- and out-fence.  Unlike the real "
"intel_timeline, this doesn't provide perfect atomic in-order guarantees if "
"the client races with itself by calling execbuffer2 twice concurrently.  "
"However, if userspace races with itself, that's not likely to yield well- "
"defined results anyway so we choose to not care."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:276
msgid "unique address space (GTT)"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:278
msgid ""
"In full-ppgtt mode, each context has its own address space ensuring complete "
"separation of one client from all others."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:281
msgid ""
"In other modes, this is a NULL pointer with the expectation that the caller "
"uses the shared global GTT."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:286
msgid "``pid``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:287
msgid "process id of creator"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:289
msgid ""
"Note that who created the context may not be the principle user, as the "
"context may be shared across a local socket. However, that should only "
"affect the default context, all contexts created explicitly by the client "
"are expected to be isolated."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:296
msgid "place with :c:type:`drm_i915_private.context_list <drm_i915_private>`"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:298
msgid "``client``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:299
msgid "struct i915_drm_client"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:301
msgid "``client_link``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:302
msgid "for linking onto :c:type:`i915_drm_client.ctx_list <i915_drm_client>`"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:305
#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:107
msgid "``ref``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:306
msgid "reference count"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:308
msgid ""
"A reference to a context is held by both the client who created it and on "
"each request submitted to the hardware using the request (to ensure the "
"hardware has access to the state until it has finished all pending writes). "
"See i915_gem_context_get() and i915_gem_context_put() for access."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:316
msgid "``release_work``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:317
msgid ""
"Work item for deferred cleanup, since i915_gem_context_put() tends to be "
"called from hardirq context."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:320
msgid ""
"FIXME: The only real reason for this is :c:type:`i915_gem_engines.fence "
"<i915_gem_engines>`, all other callers are from process context and need at "
"most some mild shuffling to pull the i915_gem_context_put() call out of a "
"spinlock."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:329
msgid "rcu_head for deferred freeing."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:334
msgid "small set of booleans controlled by the user"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:343
msgid "``flags``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:344
msgid "small set of booleans"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:351
msgid "context uses PXP-encrypted objects."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:353
msgid ""
"This flag can only be set at ctx creation time and it's immutable for the "
"lifetime of the context. See I915_CONTEXT_PARAM_PROTECTED_CONTENT in uapi/"
"drm/i915_drm.h for more info on setting restrictions and expected behaviour "
"of marked contexts."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:361
msgid "wakeref to keep the device awake when PXP is in use"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:363
msgid ""
"PXP sessions are invalidated when the device is suspended, which in turns "
"invalidates all contexts and objects using it. To keep the flow simple, we "
"keep the device awake when contexts using PXP objects are in use. It is "
"expected that the userspace application only uses PXP when the display is "
"on, so taking a wakeref here shouldn't worsen our power metrics."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:371
msgid "``mutex``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:372
msgid "guards everything that isn't engines or handles_vma"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:375
msgid "scheduler parameters"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:377
msgid "``guilty_count``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:378
msgid "How many times this context has caused a GPU hang."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:380
msgid "``active_count``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:381
msgid ""
"How many times this context was active during a GPU hang, but did not cause "
"it."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:386
msgid "``hang_timestamp``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:387
msgid "The last time(s) this context caused a GPU hang"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:391
msgid "``remap_slice``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:392
msgid "Bitmask of cache lines that need remapping"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:395
msgid "``handles_vma``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:396
msgid ""
"rbtree to look up our context specific obj/vma for the user handle. (user "
"handles are per fd, but the binding is per vm, which may be one per context "
"or shared with the global GTT)"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:401
msgid "``lut_mutex``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:402
msgid "Locks handles_vma"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:406
msgid "arbitrary name, used for user debug"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:408
msgid ""
"A name is constructed for the context from the creator's process name, pid "
"and user handle in order to uniquely identify the context in messages."
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:413
msgid "``stale``"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:414
msgid "tracks stale engines to be destroyed"
msgstr ""

#: ../../../gpu/i915:430: drivers/gpu/drm/i915/gem/i915_gem_context_types.h:223
msgid ""
"The struct i915_gem_context represents the combined view of the driver and "
"logical hardware state for a particular client."
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:87
msgid ""
"Userspace submits commands to be executed on the GPU as an instruction "
"stream within a GEM object we call a batchbuffer. This instructions may "
"refer to other GEM objects containing auxiliary state such as kernels, "
"samplers, render targets and even secondary batchbuffers. Userspace does not "
"know where in the GPU memory these objects reside and so before the "
"batchbuffer is passed to the GPU for execution, those addresses in the "
"batchbuffer and auxiliary objects are updated. This is known as relocation, "
"or patching. To try and avoid having to relocate each object on the next "
"execution, userspace is told the location of those objects in this pass, but "
"this remains just a hint as the kernel may choose a new location for any "
"object in the future."
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:99
msgid ""
"At the level of talking to the hardware, submitting a batchbuffer for the "
"GPU to execute is to add content to a buffer from which the HW command "
"streamer is reading."
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:103
msgid ""
"Add a command to load the HW context. For Logical Ring Contexts, i.e. "
"Execlists, this command is not placed on the same buffer as the remaining "
"items."
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:107
msgid "Add a command to invalidate caches to the buffer."
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:109
msgid ""
"Add a batchbuffer start command to the buffer; the start command is "
"essentially a token together with the GPU address of the batchbuffer to be "
"executed."
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:113
msgid "Add a pipeline flush to the buffer."
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:115
msgid ""
"Add a memory write command to the buffer to record when the GPU is done "
"executing the batchbuffer. The memory write writes the global sequence "
"number of the request, ``i915_request::global_seqno``; the i915 driver uses "
"the current value in the register to determine if the GPU has completed the "
"batchbuffer."
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:121
msgid ""
"Add a user interrupt command to the buffer. This command instructs the GPU "
"to issue an interrupt when the command, pipeline flush and memory write are "
"completed."
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:125
msgid ""
"Inform the hardware of the additional commands added to the buffer (by "
"updating the tail pointer)."
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:128
msgid "Processing an execbuf ioctl is conceptually split up into a few phases."
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:130
msgid "Validation - Ensure all the pointers, handles and flags are valid."
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:131
msgid "Reservation - Assign GPU address space for every object"
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:132
msgid "Relocation - Update any addresses to point to the final locations"
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:133
msgid "Serialisation - Order the request with respect to its dependencies"
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:134
msgid "Construction - Construct a request to execute the batchbuffer"
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:135
msgid "Submission (at some point in the future execution)"
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:137
msgid ""
"Reserving resources for the execbuf is the most complicated phase. We "
"neither want to have to migrate the object in the address space, nor do we "
"want to have to update any relocations pointing to this object. Ideally, we "
"want to leave the object where it is and for all the existing relocations to "
"match. If the object is given a new address, or if userspace thinks the "
"object is elsewhere, we have to parse all the relocation entries and update "
"the addresses. Userspace can set the I915_EXEC_NORELOC flag to hint that all "
"the target addresses in all of its objects match the value in the relocation "
"entries and that they all match the presumed offsets given by the list of "
"execbuffer objects. Using this knowledge, we know that if we haven't moved "
"any buffers, all the relocation entries are valid and we can skip the "
"update. (If userspace is wrong, the likely outcome is an impromptu GPU "
"hang.) The requirement for using I915_EXEC_NO_RELOC are:"
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:151
msgid ""
"The addresses written in the objects must match the corresponding reloc."
"presumed_offset which in turn must match the corresponding execobject.offset."
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:155
msgid ""
"Any render targets written to in the batch must be flagged with "
"EXEC_OBJECT_WRITE."
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:158
msgid ""
"To avoid stalling, execobject.offset should match the current address of "
"that object within the active context."
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:161
msgid ""
"The reservation is done is multiple phases. First we try and keep any object "
"already bound in its current location - so as long as meets the constraints "
"imposed by the new execbuffer. Any object left unbound after the first pass "
"is then fitted into any available idle space. If an object does not fit, all "
"objects are removed from the reservation and the process rerun after sorting "
"the objects into a priority order (more difficult to fit objects are tried "
"first). Failing that, the entire VM is cleared and we try to fit the execbuf "
"once last time before concluding that it simply will not fit."
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:171
msgid ""
"A small complication to all of this is that we allow userspace not only to "
"specify an alignment and a size for the object in the address space, but we "
"also allow userspace to specify the exact offset. This objects are simpler "
"to place (the location is known a priori) all we have to do is make sure the "
"space is available."
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:177
msgid ""
"Once all the objects are in place, patching up the buried pointers to point "
"to the final locations is a fairly simple job of walking over the relocation "
"entry arrays, looking up the right address and rewriting the value into the "
"object. Simple! ... The relocation entries are stored in user memory and so "
"to access them we have to copy them into a local buffer. That copy has to "
"avoid taking any pagefaults as they may lead back to a GEM object requiring "
"the vm->mutex (i.e. recursive deadlock). So once again we split the "
"relocation into multiple passes. First we try to do everything within an "
"atomic context (avoid the pagefaults) which requires that we never wait. If "
"we detect that we may wait, or if we need to fault, then we have to fallback "
"to a slower path. The slowpath has to drop the mutex. (Can you hear alarm "
"bells yet?) Dropping the mutex means that we lose all the state we have "
"built up so far for the execbuf and we must reset any global data. However, "
"we do leave the objects pinned in their final locations - which is a "
"potential issue for concurrent execbufs. Once we have left the mutex, we can "
"allocate and copy all the relocation entries into a large array at our "
"leisure, reacquire the mutex, reclaim all the objects and other state and "
"then proceed to update any incorrect addresses with the objects."
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:196
msgid ""
"As we process the relocation entries, we maintain a record of whether the "
"object is being written to. Using NORELOC, we expect userspace to provide "
"this information instead. We also check whether we can skip the relocation "
"by comparing the expected value inside the relocation entry with the "
"target's final address. If they differ, we have to map the current object "
"and rewrite the 4 or 8 byte pointer within."
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:203
msgid ""
"Serialising an execbuf is quite simple according to the rules of the GEM "
"ABI. Execution within each context is ordered by the order of submission. "
"Writes to any GEM object are in order of submission and are exclusive. Reads "
"from a GEM object are unordered with respect to other reads, but ordered by "
"writes. A write submitted after a read cannot occur before the read, and "
"similarly any read submitted after a write cannot occur before the write. "
"Writes are ordered between engines such that only one write occurs at any "
"time (completing any reads beforehand) - using semaphores where available "
"and CPU serialisation otherwise. Other GEM access obey the same rules, any "
"write (either via mmaps using set-domain, or via pwrite) must flush all GPU "
"reads before starting, and any read (either using set-domain or pread) must "
"flush all GPU writes before starting. (Note we only employ a barrier before, "
"we currently rely on userspace not concurrently starting a new execution "
"whilst reading or writing to an object. This may be an advantage or not "
"depending on how much you trust userspace not to shoot themselves in the "
"foot.) Serialisation may just result in the request being inserted into a "
"DAG awaiting its turn, but most simple is to wait on the CPU until all "
"dependencies are resolved."
msgstr ""

#: ../../../gpu/i915:432: drivers/gpu/drm/i915/gem/i915_gem_execbuffer.c:222
msgid ""
"After all of that, is just a matter of closing the request and handing it to "
"the hardware (well, leaving it in a queue to be executed). However, we also "
"offer the ability for batchbuffers to be run with elevated privileges so "
"that they access otherwise hidden registers. (Used to adjust L3 cache etc.) "
"Before any batch is given extra privileges we first must check that it "
"contains no nefarious instructions, we check that each instruction is from "
"our whitelist and all registers are also from an allowed list. We first copy "
"the user's batchbuffer to a shadow (so that the user doesn't have access to "
"it, either by the CPU or GPU as we scan it) and then parse each instruction. "
"If everything is ok, we set a flag telling the hardware to run the "
"batchbuffer in trusted mode, otherwise the ioctl is rejected."
msgstr ""

#: ../../../gpu/i915.rst:436
msgid "Scheduling"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:95
msgid "scheduler engine"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:108
msgid "reference count of schedule engine object"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:112
#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:184
msgid "``lock``"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:113
msgid ""
"protects requests in priority lists, requests, hold and tasklet while running"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:118
msgid "``requests``"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:119
msgid "list of requests inflight on this schedule engine"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:123
msgid "``hold``"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:124
msgid "list of ready requests, but on hold"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:128
msgid "``tasklet``"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:129
msgid "softirq tasklet for submission"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:133
msgid "``default_priolist``"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:134
msgid "priority list for I915_PRIORITY_NORMAL"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:138
msgid "``queue_priority_hint``"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:139
msgid "Highest pending priority."
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:141
msgid ""
"When we add requests into the queue, or adjust the priority of executing "
"requests, we compute the maximum priority of those pending requests. We can "
"then use this value to determine if we need to preempt the executing "
"requests to service the queue. However, since the we may have recorded the "
"priority of an inflight request we wanted to preempt but since completed, at "
"the time of dequeuing the priority hint may no longer may match the highest "
"available request priority."
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:152
msgid "``queue``"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:153
msgid "queue of requests, in priority lists"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:157
msgid "``no_priolist``"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:158
msgid "priority lists disabled"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:162
msgid "``private_data``"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:163
msgid "private data of the submission backend"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:167
#: ../../../gpu/i915:635: drivers/gpu/drm/i915/i915_perf_types.h:157
msgid "``destroy``"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:168
msgid "destroy schedule engine / cleanup in backend"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:172
msgid "``disabled``"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:173
msgid "check if backend has disabled submission"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:177
msgid "``kick_backend``"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:178
msgid "kick backend after a request's priority has changed"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:183
msgid "``bump_inflight_request_prio``"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:184
msgid "update priority of an inflight request"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:189
msgid "``retire_inflight_request_prio``"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:190
msgid "indicate request is retired to priority tracking"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:195
msgid "``schedule``"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:196
msgid "adjust priority of request"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:198
msgid ""
"Call when the priority on a request has changed and it and its dependencies "
"may need rescheduling. Note the request itself may not be ready to run!"
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:96
msgid ""
"A schedule engine represents a submission queue with different priority "
"bands. It contains all the common state (relative to the backend) to queue, "
"track, and submit a request."
msgstr ""

#: ../../../gpu/i915:437: drivers/gpu/drm/i915/i915_scheduler_types.h:100
msgid ""
"This object at the moment is quite i915 specific but will transition into a "
"container for the drm_gpu_scheduler plus a few other variables once the i915 "
"is integrated with the DRM scheduler."
msgstr ""

#: ../../../gpu/i915.rst:441
msgid "Logical Rings, Logical Ring Contexts and Execlists"
msgstr ""

#: ../../../gpu/i915:443:
#: drivers/gpu/drm/i915/gt/intel_execlists_submission.c:7
msgid ""
"Motivation: GEN8 brings an expansion of the HW contexts: \"Logical Ring "
"Contexts\". These expanded contexts enable a number of new abilities, "
"especially \"Execlists\" (also implemented in this file)."
msgstr ""

#: ../../../gpu/i915:443:
#: drivers/gpu/drm/i915/gt/intel_execlists_submission.c:12
msgid ""
"One of the main differences with the legacy HW contexts is that logical ring "
"contexts incorporate many more things to the context's state, like PDPs or "
"ringbuffer control registers:"
msgstr ""

#: ../../../gpu/i915:443:
#: drivers/gpu/drm/i915/gt/intel_execlists_submission.c:16
msgid ""
"The reason why PDPs are included in the context is straightforward: as "
"PPGTTs (per-process GTTs) are actually per-context, having the PDPs "
"contained there mean you don't need to do a ppgtt->switch_mm yourself, "
"instead, the GPU will do it for you on the context switch."
msgstr ""

#: ../../../gpu/i915:443:
#: drivers/gpu/drm/i915/gt/intel_execlists_submission.c:21
msgid ""
"But, what about the ringbuffer control registers (head, tail, etc..)? "
"shouldn't we just need a set of those per engine command streamer? This is "
"where the name \"Logical Rings\" starts to make sense: by virtualizing the "
"rings, the engine cs shifts to a new \"ring buffer\" with every context "
"switch. When you want to submit a workload to the GPU you: A) choose your "
"context, B) find its appropriate virtualized ring, C) write commands to it "
"and then, finally, D) tell the GPU to switch to that context."
msgstr ""

#: ../../../gpu/i915:443:
#: drivers/gpu/drm/i915/gt/intel_execlists_submission.c:29
msgid ""
"Instead of the legacy MI_SET_CONTEXT, the way you tell the GPU to switch to "
"a contexts is via a context execution list, ergo \"Execlists\"."
msgstr ""

#: ../../../gpu/i915:443:
#: drivers/gpu/drm/i915/gt/intel_execlists_submission.c:32
msgid "LRC implementation: Regarding the creation of contexts, we have:"
msgstr ""

#: ../../../gpu/i915:443:
#: drivers/gpu/drm/i915/gt/intel_execlists_submission.c:35
msgid "One global default context."
msgstr ""

#: ../../../gpu/i915:443:
#: drivers/gpu/drm/i915/gt/intel_execlists_submission.c:36
msgid "One local default context for each opened fd."
msgstr ""

#: ../../../gpu/i915:443:
#: drivers/gpu/drm/i915/gt/intel_execlists_submission.c:37
msgid "One local extra context for each context create ioctl call."
msgstr ""

#: ../../../gpu/i915:443:
#: drivers/gpu/drm/i915/gt/intel_execlists_submission.c:39
msgid ""
"Now that ringbuffers belong per-context (and not per-engine, like before) "
"and that contexts are uniquely tied to a given engine (and not reusable, "
"like before) we need:"
msgstr ""

#: ../../../gpu/i915:443:
#: drivers/gpu/drm/i915/gt/intel_execlists_submission.c:43
msgid "One ringbuffer per-engine inside each context."
msgstr ""

#: ../../../gpu/i915:443:
#: drivers/gpu/drm/i915/gt/intel_execlists_submission.c:44
msgid "One backing object per-engine inside each context."
msgstr ""

#: ../../../gpu/i915:443:
#: drivers/gpu/drm/i915/gt/intel_execlists_submission.c:46
msgid ""
"The global default context starts its life with these new objects fully "
"allocated and populated. The local default context for each opened fd is "
"more complex, because we don't know at creation time which engine is going "
"to use them. To handle this, we have implemented a deferred creation of LR "
"contexts:"
msgstr ""

#: ../../../gpu/i915:443:
#: drivers/gpu/drm/i915/gt/intel_execlists_submission.c:52
msgid ""
"The local context starts its life as a hollow or blank holder, that only "
"gets populated for a given engine once we receive an execbuffer. If later on "
"we receive another execbuffer ioctl for the same context but a different "
"engine, we allocate/populate a new ringbuffer and context backing object and "
"so on."
msgstr ""

#: ../../../gpu/i915:443:
#: drivers/gpu/drm/i915/gt/intel_execlists_submission.c:58
msgid ""
"Finally, regarding local contexts created using the ioctl call: as they are "
"only allowed with the render ring, we can allocate & populate them right "
"away (no need to defer anything, at least for now)."
msgstr ""

#: ../../../gpu/i915:443:
#: drivers/gpu/drm/i915/gt/intel_execlists_submission.c:62
msgid ""
"Execlists implementation: Execlists are the new method by which, on gen8+ "
"hardware, workloads are submitted for execution (as opposed to the legacy, "
"ringbuffer-based, method). This method works as follows:"
msgstr ""

#: ../../../gpu/i915:443:
#: drivers/gpu/drm/i915/gt/intel_execlists_submission.c:67
msgid ""
"When a request is committed, its commands (the BB start and any leading or "
"trailing commands, like the seqno breadcrumbs) are placed in the ringbuffer "
"for the appropriate context. The tail pointer in the hardware context is not "
"updated at this time, but instead, kept by the driver in the ringbuffer "
"structure. A structure representing this request is added to a request queue "
"for the appropriate engine: this structure contains a copy of the context's "
"tail after the request was written to the ring buffer and a pointer to the "
"context itself."
msgstr ""

#: ../../../gpu/i915:443:
#: drivers/gpu/drm/i915/gt/intel_execlists_submission.c:76
msgid ""
"If the engine's request queue was empty before the request was added, the "
"queue is processed immediately. Otherwise the queue will be processed during "
"a context switch interrupt. In any case, elements on the queue will get sent "
"(in pairs) to the GPU's ExecLists Submit Port (ELSP, for short) with a "
"globally unique 20-bits submission ID."
msgstr ""

#: ../../../gpu/i915:443:
#: drivers/gpu/drm/i915/gt/intel_execlists_submission.c:82
msgid ""
"When execution of a request completes, the GPU updates the context status "
"buffer with a context complete event and generates a context switch "
"interrupt. During the interrupt handling, the driver examines the events in "
"the buffer: for each context complete event, if the announced ID matches "
"that on the head of the request queue, then that request is retired and "
"removed from the queue."
msgstr ""

#: ../../../gpu/i915:443:
#: drivers/gpu/drm/i915/gt/intel_execlists_submission.c:88
msgid ""
"After processing, if any requests were retired and the queue is not empty "
"then a new execution list can be submitted. The two requests at the front of "
"the queue are next to be submitted but since a context may not occur twice "
"in an execution list, if subsequent requests have the same ID as the first "
"then the two requests must be combined. This is done simply by discarding "
"requests at the head of the queue until either only one requests is left (in "
"which case we use a NULL second context) or the first two requests have "
"unique IDs."
msgstr ""

#: ../../../gpu/i915:443:
#: drivers/gpu/drm/i915/gt/intel_execlists_submission.c:96
msgid ""
"By always executing the first two requests in the queue the driver ensures "
"that the GPU is kept as busy as possible. In the case where a single context "
"completes but a second context is still executing, the request for this "
"second context will be at the head of the queue when we remove the first "
"one. This request will then be resubmitted along with a new request for a "
"different context, which will cause the hardware to continue executing the "
"second request and queue the new request (the GPU detects the condition of a "
"context getting preempted with the same context and optimizes the context "
"switch flow by not doing preemption, but just sampling the new tail pointer)."
msgstr ""

#: ../../../gpu/i915.rst:447
msgid "Global GTT views"
msgstr ""

#: ../../../gpu/i915:449: drivers/gpu/drm/i915/i915_vma_types.h:38
msgid "Background and previous state"
msgstr ""

#: ../../../gpu/i915:449: drivers/gpu/drm/i915/i915_vma_types.h:40
msgid ""
"Historically objects could exists (be bound) in global GTT space only as "
"singular instances with a view representing all of the object's backing "
"pages in a linear fashion. This view will be called a normal view."
msgstr ""

#: ../../../gpu/i915:449: drivers/gpu/drm/i915/i915_vma_types.h:44
msgid ""
"To support multiple views of the same object, where the number of mapped "
"pages is not equal to the backing store, or where the layout of the pages is "
"not linear, concept of a GGTT view was added."
msgstr ""

#: ../../../gpu/i915:449: drivers/gpu/drm/i915/i915_vma_types.h:48
msgid ""
"One example of an alternative view is a stereo display driven by a single "
"image. In this case we would have a framebuffer looking like this (2x2 "
"pages):"
msgstr ""

#: ../../../gpu/i915:449: drivers/gpu/drm/i915/i915_vma_types.h:52
msgid "12 34"
msgstr ""

#: ../../../gpu/i915:449: drivers/gpu/drm/i915/i915_vma_types.h:55
msgid ""
"Above would represent a normal GGTT view as normally mapped for GPU or CPU "
"rendering. In contrast, fed to the display engine would be an alternative "
"view which could look something like this:"
msgstr ""

#: ../../../gpu/i915:449: drivers/gpu/drm/i915/i915_vma_types.h:59
msgid "1212 3434"
msgstr ""

#: ../../../gpu/i915:449: drivers/gpu/drm/i915/i915_vma_types.h:62
msgid ""
"In this example both the size and layout of pages in the alternative view is "
"different from the normal view."
msgstr ""

#: ../../../gpu/i915:449: drivers/gpu/drm/i915/i915_vma_types.h:65
msgid "Implementation and usage"
msgstr ""

#: ../../../gpu/i915:449: drivers/gpu/drm/i915/i915_vma_types.h:67
msgid ""
"GGTT views are implemented using VMAs and are distinguished via enum "
"i915_gtt_view_type and struct i915_gtt_view."
msgstr ""

#: ../../../gpu/i915:449: drivers/gpu/drm/i915/i915_vma_types.h:70
msgid ""
"A new flavour of core GEM functions which work with GGTT bound objects were "
"added with the _ggtt_ infix, and sometimes with _view postfix to avoid "
"renaming  in large amounts of code. They take the struct i915_gtt_view "
"parameter encapsulating all metadata required to implement a view."
msgstr ""

#: ../../../gpu/i915:449: drivers/gpu/drm/i915/i915_vma_types.h:75
msgid ""
"As a helper for callers which are only interested in the normal view, "
"globally const i915_gtt_view_normal singleton instance exists. All old core "
"GEM API functions, the ones not taking the view parameter, are operating on, "
"or with the normal GGTT view."
msgstr ""

#: ../../../gpu/i915:449: drivers/gpu/drm/i915/i915_vma_types.h:80
msgid "Code wanting to add or use a new GGTT view needs to:"
msgstr ""

#: ../../../gpu/i915:449: drivers/gpu/drm/i915/i915_vma_types.h:82
msgid "Add a new enum with a suitable name."
msgstr ""

#: ../../../gpu/i915:449: drivers/gpu/drm/i915/i915_vma_types.h:83
msgid "Extend the metadata in the i915_gtt_view structure if required."
msgstr ""

#: ../../../gpu/i915:449: drivers/gpu/drm/i915/i915_vma_types.h:84
msgid "Add support to i915_get_vma_pages()."
msgstr ""

#: ../../../gpu/i915:449: drivers/gpu/drm/i915/i915_vma_types.h:86
msgid ""
"New views are required to build a scatter-gather table from within the "
"i915_get_vma_pages function. This table is stored in the vma.gtt_view and "
"exists for the lifetime of an VMA."
msgstr ""

#: ../../../gpu/i915:449: drivers/gpu/drm/i915/i915_vma_types.h:90
msgid ""
"Core API is designed to have copy semantics which means that passed in "
"struct i915_gtt_view does not need to be persistent (left around after "
"calling the core API functions)."
msgstr ""

#: ../../../gpu/i915:452: drivers/gpu/drm/i915/i915_gem_gtt.c:71
msgid "reserve a node in an address_space (GTT)"
msgstr ""

#: ../../../gpu/i915:452: drivers/gpu/drm/i915/i915_gem_gtt.c:72
#: drivers/gpu/drm/i915/i915_gem_gtt.c:156
msgid "the :c:type:`struct i915_address_space <i915_address_space>`"
msgstr ""

#: ../../../gpu/i915:452: drivers/gpu/drm/i915/i915_gem_gtt.c:75
#: drivers/gpu/drm/i915/i915_gem_gtt.c:159
msgid "``struct drm_mm_node *node``"
msgstr ""

#: ../../../gpu/i915:452: drivers/gpu/drm/i915/i915_gem_gtt.c:74
#: drivers/gpu/drm/i915/i915_gem_gtt.c:158
msgid ""
"the :c:type:`struct drm_mm_node <drm_mm_node>` (typically i915_vma.node)"
msgstr ""

#: ../../../gpu/i915:452: drivers/gpu/drm/i915/i915_gem_gtt.c:76
#: drivers/gpu/drm/i915/i915_gem_gtt.c:160
msgid "``u64 size``"
msgstr ""

#: ../../../gpu/i915:452: drivers/gpu/drm/i915/i915_gem_gtt.c:75
#: drivers/gpu/drm/i915/i915_gem_gtt.c:159
msgid ""
"how much space to allocate inside the GTT, must be #I915_GTT_PAGE_SIZE "
"aligned"
msgstr ""

#: ../../../gpu/i915:452: drivers/gpu/drm/i915/i915_gem_gtt.c:78
msgid "``u64 offset``"
msgstr ""

#: ../../../gpu/i915:452: drivers/gpu/drm/i915/i915_gem_gtt.c:77
msgid ""
"where to insert inside the GTT, must be #I915_GTT_MIN_ALIGNMENT aligned, and "
"the node (**offset** + **size**) must fit within the address space"
msgstr ""

#: ../../../gpu/i915:452: drivers/gpu/drm/i915/i915_gem_gtt.c:80
msgid ""
"color to apply to node, if this node is not from a VMA, color must be "
"#I915_COLOR_UNEVICTABLE"
msgstr ""

#: ../../../gpu/i915:452: drivers/gpu/drm/i915/i915_gem_gtt.c:82
#: drivers/gpu/drm/i915/i915_gem_gtt.c:169
msgid "control search and eviction behaviour"
msgstr ""

#: ../../../gpu/i915:452: drivers/gpu/drm/i915/i915_gem_gtt.c:83
msgid ""
"i915_gem_gtt_reserve() tries to insert the **node** at the exact **offset** "
"inside the address space (using **size** and **color**). If the **node** "
"does not fit, it tries to evict any overlapping nodes from the GTT, "
"including any neighbouring nodes if the colors do not match (to ensure guard "
"pages between differing domains). See i915_gem_evict_for_node() for the gory "
"details on the eviction algorithm. #PIN_NONBLOCK may used to prevent waiting "
"on evicting active overlapping objects, and any overlapping node that is "
"pinned or marked as unevictable will also result in failure."
msgstr ""

#: ../../../gpu/i915:452: drivers/gpu/drm/i915/i915_gem_gtt.c:93
#: drivers/gpu/drm/i915/i915_gem_gtt.c:186
msgid ""
"0 on success, -ENOSPC if no suitable hole is found, -EINTR if asked to wait "
"for eviction and interrupted."
msgstr ""

#: ../../../gpu/i915:452: drivers/gpu/drm/i915/i915_gem_gtt.c:155
msgid "insert a node into an address_space (GTT)"
msgstr ""

#: ../../../gpu/i915:452: drivers/gpu/drm/i915/i915_gem_gtt.c:161
msgid ""
"required alignment of starting offset, may be 0 but if specified, this must "
"be a power-of-two and at least #I915_GTT_MIN_ALIGNMENT"
msgstr ""

#: ../../../gpu/i915:452: drivers/gpu/drm/i915/i915_gem_gtt.c:164
msgid "color to apply to node"
msgstr ""

#: ../../../gpu/i915:452: drivers/gpu/drm/i915/i915_gem_gtt.c:165
msgid ""
"start of any range restriction inside GTT (0 for all), must be "
"#I915_GTT_PAGE_SIZE aligned"
msgstr ""

#: ../../../gpu/i915:452: drivers/gpu/drm/i915/i915_gem_gtt.c:167
msgid ""
"end of any range restriction inside GTT (U64_MAX for all), must be "
"#I915_GTT_PAGE_SIZE aligned if not U64_MAX"
msgstr ""

#: ../../../gpu/i915:452: drivers/gpu/drm/i915/i915_gem_gtt.c:170
msgid ""
"i915_gem_gtt_insert() first searches for an available hole into which is can "
"insert the node. The hole address is aligned to **alignment** and its "
"**size** must then fit entirely within the [**start**, **end**] bounds. The "
"nodes on either side of the hole must match **color**, or else a guard page "
"will be inserted between the two nodes (or the node evicted). If no suitable "
"hole is found, first a victim is randomly selected and tested for eviction, "
"otherwise then the LRU list of objects within the GTT is scanned to find the "
"first set of replacement nodes to create the hole. Those old overlapping "
"nodes are evicted from the GTT (and so must be rebound before any future "
"use). Any node that is currently pinned cannot be evicted (see "
"i915_vma_pin()). Similar if the node's VMA is currently active and "
"#PIN_NONBLOCK is specified, that node is also skipped when searching for an "
"eviction candidate. See i915_gem_evict_something() for the gory details on "
"the eviction algorithm."
msgstr ""

#: ../../../gpu/i915.rst:456
msgid "GTT Fences and Swizzling"
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:285
msgid "force-remove fence for a VMA"
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:291
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:414 ../../../gpu/i915:514:
#: drivers/gpu/drm/i915/gt/uc/intel_guc.h:407
msgid "``struct i915_vma *vma``"
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:286
msgid "vma to map linearly (not through a fence reg)"
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:287
msgid ""
"This function force-removes any fence from the given object, which is useful "
"if the kernel wants to do untiled GTT access."
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:408
msgid "set up fencing for a vma"
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:409
msgid "vma to map through a fence reg"
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:410
msgid ""
"When mapping objects through the GTT, userspace wants to be able to write to "
"them without having to worry about swizzling if the object is tiled. This "
"function walks the fence regs looking for a free one for **obj**, stealing "
"one if it can't find any."
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:415
msgid ""
"It then sets up the reg based on the object's properties: address, pitch and "
"tiling format."
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:418
msgid "For an untiled surface, this removes any existing fence."
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:449
msgid "Reserve a fence for vGPU"
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:450
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:503
msgid "Global GTT"
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:451
msgid ""
"This function walks the fence regs looking for a free one and remove it from "
"the fence_list. It is used to reserve fence for vGPU to use."
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:487
msgid "Reclaim a reserved fence"
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:493
msgid "``struct i915_fence_reg *fence``"
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:488
msgid "the fence reg"
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:489
msgid ""
"This function add a reserved fence register from vGPU to the fence_list."
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:502
msgid "restore fence state"
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:504
msgid ""
"Restore the hw fence state to match the software tracking again, to be "
"called after a gpu reset and on resume. Note that on runtime suspend we only "
"cancel the fences, to be reacquired by the user later."
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:566
msgid "detect bit 6 swizzling pattern"
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:567
msgid "Global GGTT"
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:568
msgid ""
"Detects bit 6 swizzling of address lookup between IGD access and CPU access "
"through main memory."
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:765
msgid "fixup bit 17 swizzling"
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:766
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:803
msgid "i915 GEM buffer object"
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:768
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:805
msgid "``struct sg_table *pages``"
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:767
#: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:804
msgid "the scattergather list of physical pages"
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:768
msgid ""
"This function fixes up the swizzling in case any page frame number for this "
"object has changed in bit 17 since that state has been saved with "
"i915_gem_object_save_bit_17_swizzle()."
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:772
msgid ""
"This is called when pinning backing storage again, since the kernel is free "
"to move unpinned backing storage around (either by directly moving pages or "
"by swapping them out and back in again)."
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:802
msgid "save bit 17 swizzling"
msgstr ""

#: ../../../gpu/i915:458: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:805
msgid ""
"This function saves the bit 17 of each page frame number so that swizzling "
"can be fixed up later on with i915_gem_object_do_bit_17_swizzle(). This must "
"be called before the backing storage can be unpinned."
msgstr ""

#: ../../../gpu/i915.rst:462
msgid "Global GTT Fence Handling"
msgstr ""

#: ../../../gpu/i915:464: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:18
msgid ""
"Important to avoid confusions: \"fences\" in the i915 driver are not "
"execution fences used to track command completion but hardware detiler "
"objects which wrap a given range of the global GTT. Each platform has only a "
"fairly limited set of these objects."
msgstr ""

#: ../../../gpu/i915:464: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:23
msgid ""
"Fences are used to detile GTT memory mappings. They're also connected to the "
"hardware frontbuffer render tracking and hence interact with frontbuffer "
"compression. Furthermore on older platforms fences are required for tiled "
"objects used by the display engine. They can also be used by the render "
"engine - they're required for blitter commands and are optional for render "
"commands. But on gen4+ both display (with the exception of fbc) and "
"rendering have their own tiling state bits and don't need fences."
msgstr ""

#: ../../../gpu/i915:464: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:31
msgid ""
"Also note that fences only support X and Y tiling and hence can't be used "
"for the fancier new tiling formats like W, Ys and Yf."
msgstr ""

#: ../../../gpu/i915:464: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:34
msgid ""
"Finally note that because fences are such a restricted resource they're "
"dynamically associated with objects. Furthermore fence state is committed to "
"the hardware lazily to avoid unnecessary stalls on gen2/3. Therefore code "
"must explicitly call i915_gem_object_get_fence() to synchronize fencing "
"status for cpu access. Also note that some code wants an unfenced view, for "
"those cases the fence can be removed forcefully with "
"i915_gem_object_put_fence()."
msgstr ""

#: ../../../gpu/i915:464: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:41
msgid ""
"Internally these functions will synchronize with userspace access by "
"removing CPU ptes into GTT mmaps (not the GTT ptes themselves) as needed."
msgstr ""

#: ../../../gpu/i915.rst:468
msgid "Hardware Tiling and Swizzling Details"
msgstr ""

#: ../../../gpu/i915:470: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:518
msgid ""
"The idea behind tiling is to increase cache hit rates by rearranging pixel "
"data so that a group of pixel accesses are in the same cacheline. "
"Performance improvement from doing this on the back/depth buffer are on the "
"order of 30%."
msgstr ""

#: ../../../gpu/i915:470: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:523
msgid ""
"Intel architectures make this somewhat more complicated, though, by "
"adjustments made to addressing of data when the memory is in interleaved "
"mode (matched pairs of DIMMS) to improve memory bandwidth. For interleaved "
"memory, the CPU sends every sequential 64 bytes to an alternate memory "
"channel so it can get the bandwidth from both."
msgstr ""

#: ../../../gpu/i915:470: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:529
msgid ""
"The GPU also rearranges its accesses for increased bandwidth to interleaved "
"memory, and it matches what the CPU does for non-tiled.  However, when tiled "
"it does it a little differently, since one walks addresses not just in the X "
"direction but also Y.  So, along with alternating channels when bit 6 of the "
"address flips, it also alternates when other bits flip --  Bits 9 (every 512 "
"bytes, an X tile scanline) and 10 (every two X tile scanlines) are common to "
"both the 915 and 965-class hardware."
msgstr ""

#: ../../../gpu/i915:470: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:537
msgid ""
"The CPU also sometimes XORs in higher bits as well, to improve bandwidth "
"doing strided access like we do so frequently in graphics.  This is called "
"\"Channel XOR Randomization\" in the MCH documentation.  The result is that "
"the CPU is XORing in either bit 11 or bit 17 to bit 6 of its address decode."
msgstr ""

#: ../../../gpu/i915:470: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:543
msgid ""
"All of this bit 6 XORing has an effect on our memory management, as we need "
"to make sure that the 3d driver can correctly address object contents."
msgstr ""

#: ../../../gpu/i915:470: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:547
msgid ""
"If we don't have interleaved memory, all tiling is safe and no swizzling is "
"required."
msgstr ""

#: ../../../gpu/i915:470: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:550
msgid ""
"When bit 17 is XORed in, we simply refuse to tile at all.  Bit 17 is not "
"just a page offset, so as we page an object out and back in, individual "
"pages in it will have different bit 17 addresses, resulting in each 64 bytes "
"being swapped with its neighbor!"
msgstr ""

#: ../../../gpu/i915:470: drivers/gpu/drm/i915/gt/intel_ggtt_fencing.c:555
msgid ""
"Otherwise, if interleaved, we have to tell the 3d driver what the address "
"swizzling it needs to do is, since it's writing with the CPU to the pages "
"(bit 6 and potentially bit 11 XORed in), and the GPU is reading from the "
"pages (bit 6, 9, and 10 XORed in), resulting in a cumulative bit swizzling "
"required by the CPU of XORing in bit 6, 9, 10, and potentially 11, in order "
"to match what the GPU expects."
msgstr ""

#: ../../../gpu/i915.rst:474
msgid "Object Tiling IOCTLs"
msgstr ""

#: ../../../gpu/i915:476: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:45
msgid "required global GTT size for a fence"
msgstr ""

#: ../../../gpu/i915:476: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:48
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:88 ../../../gpu/i915:527:
#: drivers/gpu/drm/i915/gt/uc/intel_guc.c:768
msgid "``u32 size``"
msgstr ""

#: ../../../gpu/i915:476: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:47
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:87
msgid "object size"
msgstr ""

#: ../../../gpu/i915:476: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:49
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:89
msgid "``unsigned int tiling``"
msgstr ""

#: ../../../gpu/i915:476: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:48
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:88
msgid "tiling mode"
msgstr ""

#: ../../../gpu/i915:476: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:50
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:90
msgid "``unsigned int stride``"
msgstr ""

#: ../../../gpu/i915:476: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:49
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:89
msgid "tiling stride"
msgstr ""

#: ../../../gpu/i915:476: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:50
msgid ""
"Return the required global GTT size for a fence (view of a tiled object), "
"taking into account potential fence register mapping."
msgstr ""

#: ../../../gpu/i915:476: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:85
msgid "required global GTT alignment for a fence"
msgstr ""

#: ../../../gpu/i915:476: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:90
msgid ""
"Return the required global GTT alignment for a fence (a view of a tiled "
"object), taking into account potential fence register mapping."
msgstr ""

#: ../../../gpu/i915:476: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:328
msgid "IOCTL handler to set tiling mode"
msgstr ""

#: ../../../gpu/i915:476: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:334
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:418 ../../../gpu/i915:618:
#: drivers/gpu/drm/i915/i915_perf.c:4199 ../../../gpu/i915:622:
#: drivers/gpu/drm/i915/i915_perf.c:4590 ../../../gpu/i915:624:
#: drivers/gpu/drm/i915/i915_perf.c:4756
msgid "``struct drm_device *dev``"
msgstr ""

#: ../../../gpu/i915:476: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:329
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:413
msgid "DRM device"
msgstr ""

#: ../../../gpu/i915:476: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:331
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:415 ../../../gpu/i915:618:
#: drivers/gpu/drm/i915/i915_perf.c:4196 ../../../gpu/i915:622:
#: drivers/gpu/drm/i915/i915_perf.c:4587 ../../../gpu/i915:624:
#: drivers/gpu/drm/i915/i915_perf.c:4753
msgid "``void *data``"
msgstr ""

#: ../../../gpu/i915:476: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:330
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:414
msgid "data pointer for the ioctl"
msgstr ""

#: ../../../gpu/i915:476: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:332
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:416 ../../../gpu/i915:618:
#: drivers/gpu/drm/i915/i915_perf.c:4197 ../../../gpu/i915:622:
#: drivers/gpu/drm/i915/i915_perf.c:4589 ../../../gpu/i915:624:
#: drivers/gpu/drm/i915/i915_perf.c:4754 ../../../gpu/i915:640:
#: drivers/gpu/drm/i915/i915_perf.c:3773
msgid "``struct drm_file *file``"
msgstr ""

#: ../../../gpu/i915:476: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:331
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:415
msgid "DRM file for the ioctl call"
msgstr ""

#: ../../../gpu/i915:476: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:332
msgid ""
"Sets the tiling mode of an object, returning the required swizzling of bit 6 "
"of addresses in the object."
msgstr ""

#: ../../../gpu/i915:476: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:335
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:418
msgid "Called by the user via ioctl."
msgstr ""

#: ../../../gpu/i915:476: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:338
#: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:421
msgid "Zero on success, negative errno on failure."
msgstr ""

#: ../../../gpu/i915:476: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:412
msgid "IOCTL handler to get tiling mode"
msgstr ""

#: ../../../gpu/i915:476: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:416
msgid ""
"Returns the current tiling mode and required bit 6 swizzling for the object."
msgstr ""

#: ../../../gpu/i915:479: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:18
msgid ""
"i915_gem_set_tiling_ioctl() and i915_gem_get_tiling_ioctl() is the userspace "
"interface to declare fence register requirements."
msgstr ""

#: ../../../gpu/i915:479: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:21
msgid ""
"In principle GEM doesn't care at all about the internal data layout of an "
"object, and hence it also doesn't care about tiling or swizzling. There's "
"two exceptions:"
msgstr ""

#: ../../../gpu/i915:479: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:25
msgid ""
"For X and Y tiling the hardware provides detilers for CPU access, so called "
"fences. Since there's only a limited amount of them the kernel must manage "
"these, and therefore userspace must tell the kernel the object tiling if it "
"wants to use fences for detiling."
msgstr ""

#: ../../../gpu/i915:479: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:29
msgid ""
"On gen3 and gen4 platforms have a swizzling pattern for tiled objects which "
"depends upon the physical page frame number. When swapping such objects the "
"page frame number might change and the kernel must be able to fix this up "
"and hence now the tiling. Note that on a subset of platforms with asymmetric "
"memory channel population the swizzling pattern changes in an unknown way, "
"and for those the kernel simply forbids swapping completely."
msgstr ""

#: ../../../gpu/i915:479: drivers/gpu/drm/i915/gem/i915_gem_tiling.c:36
msgid ""
"Since neither of this applies for new tiling layouts on modern platforms "
"like W, Ys and Yf tiling GEM only allows object tiling to be set to X or Y "
"tiled. Anything else can be handled in userspace entirely without the "
"kernel's involvement."
msgstr ""

#: ../../../gpu/i915.rst:483
msgid "Protected Objects"
msgstr ""

#: ../../../gpu/i915:485: drivers/gpu/drm/i915/pxp/intel_pxp.c:23
msgid ""
"PXP (Protected Xe Path) is a feature available in Gen12 and newer platforms. "
"It allows execution and flip to display of protected (i.e. encrypted) "
"objects. The SW support is enabled via the CONFIG_DRM_I915_PXP kconfig."
msgstr ""

#: ../../../gpu/i915:485: drivers/gpu/drm/i915/pxp/intel_pxp.c:27
msgid ""
"Objects can opt-in to PXP encryption at creation time via the "
"I915_GEM_CREATE_EXT_PROTECTED_CONTENT create_ext flag. For objects to be "
"correctly protected they must be used in conjunction with a context created "
"with the I915_CONTEXT_PARAM_PROTECTED_CONTENT flag. See the documentation of "
"those two uapi flags for details and restrictions."
msgstr ""

#: ../../../gpu/i915:485: drivers/gpu/drm/i915/pxp/intel_pxp.c:33
msgid ""
"Protected objects are tied to a pxp session; currently we only support one "
"session, which i915 manages and whose index is available in the uapi "
"(I915_PROTECTED_CONTENT_DEFAULT_SESSION) for use in instructions targeting "
"protected objects. The session is invalidated by the HW when certain events "
"occur (e.g. suspend/resume). When this happens, all the objects that were "
"used with the session are marked as invalid and all contexts marked as using "
"protected content are banned. Any further attempt at using them in an "
"execbuf call is rejected, while flips are converted to black frames."
msgstr ""

#: ../../../gpu/i915:485: drivers/gpu/drm/i915/pxp/intel_pxp.c:43
msgid ""
"Some of the PXP setup operations are performed by the Management Engine, "
"which is handled by the mei driver; communication between i915 and mei is "
"performed via the mei_pxp component module."
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:20
msgid "pxp state"
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:24
msgid "``ctrl_gt``"
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:25
msgid ""
"pointer to the tile that owns the controls for PXP subsystem assets that the "
"VDBOX, the KCR engine (and GSC CS depending on the platform)"
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:30
msgid "``platform_cfg_is_bad``"
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:31
msgid ""
"used to track if any prior arb session creation resulted in a failure that "
"was caused by a platform configuration issue, meaning that failure will not "
"get resolved without a change to the platform (not kernel) such as BIOS "
"configuration, firwmware update, etc. This bool gets reflected when "
"GET_PARAM:I915_PARAM_PXP_STATUS is called."
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:39
msgid "``kcr_base``"
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:40
msgid ""
"base mmio offset for the KCR engine which is different on legacy platforms "
"vs newer platforms where the KCR is inside the media-tile."
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:45
msgid "``gsccs_res``"
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:46
msgid "resources for request submission for platforms that have a GSC engine."
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:59
msgid "``pxp_component``"
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:60
msgid ""
"i915_pxp_component struct of the bound mei_pxp module. Only set and cleared "
"inside component bind/unbind functions, which are protected by :c:type:"
"`tee_mutex`."
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:66
msgid "``dev_link``"
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:67
msgid "Enforce module relationship for power management ordering."
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:70
msgid "``pxp_component_added``"
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:71
msgid ""
"track if the pxp component has been added. Set and cleared in tee init and "
"fini functions respectively."
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:75
msgid "``ce``"
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:76
msgid "kernel-owned context used for PXP operations"
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:78
msgid "``arb_mutex``"
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:79
msgid "protects arb session start"
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:81
msgid "``arb_is_valid``"
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:82
msgid ""
"tracks arb session status. After a teardown, the arb session can still be in "
"play on the HW even if the keys are gone, so we can't rely on the HW state "
"of the session to know if it's valid and need to track the status in SW."
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:89
msgid "``key_instance``"
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:90
msgid ""
"tracks which key instance we're on, so we can use it to determine if an "
"object was created using the current key or a previous one."
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:95
msgid "``tee_mutex``"
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:96
msgid "protects the tee channel binding and messaging."
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:98
msgid "``stream_cmd``"
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:99
msgid "LMEM obj used to send stream PXP commands to the GSC"
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:105
msgid "``hw_state_invalidated``"
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:106
msgid ""
"if the HW perceives an attack on the integrity of the encryption it will "
"invalidate the keys and expect SW to re-initialize the session. We keep "
"track of this state to make sure we only re-start the arb session when "
"required."
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:112
msgid "``irq_enabled``"
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:113
msgid "tracks the status of the kcr irqs"
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:115
msgid "``termination``"
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:116
msgid ""
"tracks the status of a pending termination. Only re-initialized under gt-"
">irq_lock and completed in :c:type:`session_work`."
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:120
msgid "``session_work``"
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:121
msgid "worker that manages session events."
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:122
msgid "``session_events``"
msgstr ""

#: ../../../gpu/i915:488: drivers/gpu/drm/i915/pxp/intel_pxp_types.h:123
msgid "pending session events, protected with gt->irq_lock."
msgstr ""

#: ../../../gpu/i915.rst:491
msgid "Microcontrollers"
msgstr ""

#: ../../../gpu/i915.rst:493
msgid ""
"Starting from gen9, three microcontrollers are available on the HW: the "
"graphics microcontroller (GuC), the HEVC/H.265 microcontroller (HuC) and the "
"display microcontroller (DMC). The driver is responsible for loading the "
"firmwares on the microcontrollers; the GuC and HuC firmwares are transferred "
"to WOPCM using the DMA engine, while the DMC firmware is written through "
"MMIO."
msgstr ""

#: ../../../gpu/i915.rst:500
msgid "WOPCM"
msgstr ""

#: ../../../gpu/i915.rst:503
msgid "WOPCM Layout"
msgstr ""

#: ../../../gpu/i915:505: drivers/gpu/drm/i915/gt/intel_wopcm.c:10
msgid ""
"The layout of the WOPCM will be fixed after writing to GuC WOPCM size and "
"offset registers whose values are calculated and determined by HuC/GuC "
"firmware size and set of hardware requirements/restrictions as shown below:"
msgstr ""

#: ../../../gpu/i915:505: drivers/gpu/drm/i915/gt/intel_wopcm.c:36
msgid ""
"GuC accessible WOPCM starts at GuC WOPCM base and ends at GuC WOPCM top. The "
"top part of the WOPCM is reserved for hardware contexts (e.g. RC6 context)."
msgstr ""

#: ../../../gpu/i915.rst:509
msgid "GuC"
msgstr ""

#: ../../../gpu/i915:511: drivers/gpu/drm/i915/gt/uc/intel_guc.c:24
msgid ""
"The GuC is a microcontroller inside the GT HW, introduced in gen9. The GuC "
"is designed to offload some of the functionality usually performed by the "
"host driver; currently the main operations it can take care of are:"
msgstr ""

#: ../../../gpu/i915:511: drivers/gpu/drm/i915/gt/uc/intel_guc.c:28
msgid "Authentication of the HuC, which is required to fully enable HuC usage."
msgstr ""

#: ../../../gpu/i915:511: drivers/gpu/drm/i915/gt/uc/intel_guc.c:29
msgid "Low latency graphics context scheduling (a.k.a. GuC submission)."
msgstr ""

#: ../../../gpu/i915:511: drivers/gpu/drm/i915/gt/uc/intel_guc.c:30
msgid "GT Power management."
msgstr ""

#: ../../../gpu/i915:511: drivers/gpu/drm/i915/gt/uc/intel_guc.c:32
msgid ""
"The enable_guc module parameter can be used to select which of those "
"operations to enable within GuC. Note that not all the operations are "
"supported on all gen9+ platforms."
msgstr ""

#: ../../../gpu/i915:511: drivers/gpu/drm/i915/gt/uc/intel_guc.c:36
msgid ""
"Enabling the GuC is not mandatory and therefore the firmware is only loaded "
"if at least one of the operations is selected. However, not loading the GuC "
"might result in the loss of some features that do require the GuC (currently "
"just the HuC, but more are expected to land in the future)."
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:28
msgid "Top level structure of GuC."
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:34
msgid "``fw``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:35
msgid "the GuC firmware"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:36
msgid "``log``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:37
msgid "sub-structure containing GuC log related data and objects"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:38
msgid "``ct``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:39
msgid "the command transport communication channel"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:40
msgid "``slpc``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:41
msgid "sub-structure containing SLPC related data and objects"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:42
msgid "``capture``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:43
msgid "the error-state-capture module's data and objects"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:45
msgid "``dbgfs_node``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:46
msgid "debugfs node"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:48
msgid "``sched_engine``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:49
msgid "Global engine used to submit requests to GuC"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:51
msgid "``stalled_request``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:52
msgid ""
"if GuC can't process a request for any reason, we save it until GuC restarts "
"processing. No other request can be submitted until the stalled request is "
"processed."
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:57
msgid "``submission_stall_reason``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:58
msgid "reason why submission is stalled"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:67
msgid "``irq_lock``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:68
msgid "protects GuC irq state"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:70
msgid "``msg_enabled_mask``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:71
msgid ""
"mask of events that are processed when receiving an INTEL_GUC_ACTION_DEFAULT "
"G2H message."
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:76
msgid "``outstanding_submission_g2h``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:77
msgid ""
"number of outstanding GuC to Host responses related to GuC submission, used "
"to determine if the GT is idle"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:82
msgid "``tlb_lookup``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:83
msgid "xarray to store all pending TLB invalidation requests"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:86
msgid "``serial_slot``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:87
msgid ""
"id to the initial waiter created in tlb_lookup, which is used only when "
"failed to allocate new waiter."
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:91
msgid "``next_seqno``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:92
msgid "the next id (sequence number) to allocate."
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:94
msgid "``interrupts``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:95
msgid "pointers to GuC interrupt-managing functions."
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:103
msgid "``submission_state``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:104
msgid "sub-structure for submission state protected by single lock"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:108
msgid "``submission_state.lock``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:109
msgid ""
"protects everything in submission_state, ce->guc_id.id, and ce->guc_id.ref "
"when transitioning in and out of zero"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:114
msgid "``submission_state.guc_ids``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:115
msgid "used to allocate new guc_ids, single-lrc"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:119
msgid "``submission_state.num_guc_ids``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:120
msgid ""
"Number of guc_ids, selftest feature to be able to reduce this number while "
"testing."
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:124
msgid "``submission_state.guc_ids_bitmap``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:125
msgid "used to allocate new guc_ids, multi-lrc"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:129
msgid "``submission_state.guc_id_list``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:130
msgid "list of intel_context with valid guc_ids but no refs"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:134
msgid "``submission_state.guc_ids_in_use``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:135
msgid "Number single-lrc guc_ids in use"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:139
msgid "``submission_state.destroyed_contexts``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:140
msgid "list of contexts waiting to be destroyed (deregistered with the GuC)"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:144
msgid "``submission_state.destroyed_worker``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:145
msgid ""
"worker to deregister contexts, need as we need to take a GT PM reference and "
"can't from destroy function as it might be in an atomic context (no sleeping)"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:151
msgid "``submission_state.reset_fail_worker``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:152
msgid "worker to trigger a GT reset after an engine reset fails"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:156
msgid "``submission_state.reset_fail_mask``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:157
msgid "mask of engines that failed to reset"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:161
msgid "``submission_state.sched_disable_delay_ms``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:162
msgid "schedule disable delay, in ms, for contexts"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:166
msgid "``submission_state.sched_disable_gucid_threshold``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:167
msgid ""
"threshold of min remaining available guc_ids before we start bypassing the "
"schedule disable delay"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:174
msgid "``submission_supported``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:175
msgid "tracks whether we support GuC submission on the current platform"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:178
msgid "``submission_selected``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:179
msgid "tracks whether the user enabled GuC submission"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:180
msgid "``submission_initialized``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:181
msgid "tracks whether GuC submission has been initialised"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:182
msgid "``submission_version``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:183
msgid "Submission API version of the currently loaded firmware"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:186
msgid "``rc_supported``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:187
msgid "tracks whether we support GuC rc on the current platform"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:189
msgid "``rc_selected``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:190
msgid "tracks whether the user enabled GuC rc"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:192
msgid "``ads_vma``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:193
msgid "object allocated to hold the GuC ADS"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:194
msgid "``ads_map``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:195
msgid "contents of the GuC ADS"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:196
msgid "``ads_regset_size``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:197
msgid "size of the save/restore regsets in the ADS"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:199
msgid "``ads_regset_count``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:200
msgid "number of save/restore registers in the ADS for each engine"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:203
msgid "``ads_regset``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:204
msgid "save/restore regsets in the ADS"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:205
msgid "``ads_golden_ctxt_size``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:206
msgid "size of the golden contexts in the ADS"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:207
msgid "``ads_waklv_size``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:208
msgid "size of workaround KLVs"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:209
msgid "``ads_capture_size``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:210
msgid "size of register lists in the ADS used for error capture"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:212
msgid "``lrc_desc_pool_v69``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:213
msgid "object allocated to hold the GuC LRC descriptor pool"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:214
msgid "``lrc_desc_pool_vaddr_v69``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:215
msgid "contents of the GuC LRC descriptor pool"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:218
msgid "``context_lookup``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:219
msgid ""
"used to resolve intel_context from guc_id, if a context is present in this "
"structure it is registered with the GuC"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:223
msgid "``params``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:224
msgid "Control params for fw initialization"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:226
msgid "``send_regs``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:227
msgid "GuC's FW specific registers used for sending MMIO H2G"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:233
msgid "``notify_reg``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:234
msgid "register used to send interrupts to the GuC FW"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:237
msgid "``mmio_msg``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:238
msgid ""
"notification bitmask that the GuC writes in one of its registers when the CT "
"channel is disabled, to be processed when the channel is back up."
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:243
msgid "``send_mutex``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:244
msgid "used to serialize the intel_guc_send actions"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:247
msgid "``timestamp``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:248
msgid ""
"GT timestamp object that stores a copy of the timestamp and adjusts it for "
"overflow using a worker."
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:252
msgid "``timestamp.lock``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:253
msgid "Lock protecting the below fields and the engine stats."
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:258
msgid "``timestamp.gt_stamp``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:259
msgid "64-bit extended value of the GT timestamp."
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:264
msgid "``timestamp.ping_delay``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:265
msgid "Period for polling the GT timestamp for overflow."
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:270
msgid "``timestamp.work``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:271
msgid ""
"Periodic work to adjust GT timestamp, engine and context usage for overflows."
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:276
msgid "``timestamp.shift``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:277
msgid "Right shift value for the gpm timestamp"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:281
msgid "``timestamp.last_stat_jiffies``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:282
msgid ""
"jiffies at last actual stats collection time. We use this timestamp to "
"ensure we don't oversample the stats because runtime power management events "
"can trigger stats collection at much higher rates than required."
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:291
msgid "``dead_guc_worker``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:292
msgid ""
"Asynchronous worker thread for forcing a GuC reset. Specifically used when "
"the G2H handler wants to issue a reset. Resets require flushing the G2H "
"queue. So, the G2H processing itself must not trigger a reset directly. "
"Instead, go via this worker."
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:298
msgid "``last_dead_guc_jiffies``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:299
msgid ""
"timestamp of previous 'dead guc' occurrence used to prevent a fundamentally "
"broken system from continuously reloading the GuC."
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:306
msgid "``number_guc_id_stolen``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:307
msgid "The number of guc_ids that have been stolen"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:310
msgid "``fast_response_selftest``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:311
msgid "Backdoor to CT handler for fast response selftest"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:29
msgid ""
"It handles firmware loading and manages client pool. intel_guc owns an "
"i915_sched_engine for submission."
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:404
msgid "Get and validate the GGTT offset of **vma**"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:410
#: ../../../gpu/i915:527: drivers/gpu/drm/i915/gt/uc/intel_guc.c:771
#: ../../../gpu/i915:534: drivers/gpu/drm/i915/gt/uc/intel_guc_fw.c:292
msgid "``struct intel_guc *guc``"
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:405
msgid "intel_guc structure."
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:406
msgid "i915 graphics virtual memory area."
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:407
msgid ""
"GuC does not allow any gfx GGTT address that falls into range [0, ggtt."
"pin_bias), which is reserved for Boot ROM, SRAM and WOPCM. Currently, in "
"order to exclude [0, ggtt.pin_bias) address space from GGTT, all gfx objects "
"used by GuC are allocated with intel_guc_allocate_vma() and pinned with "
"PIN_OFFSET_BIAS along with the value of ggtt.pin_bias."
msgstr ""

#: ../../../gpu/i915:514: drivers/gpu/drm/i915/gt/uc/intel_guc.h:414
msgid "GGTT offset of the **vma**."
msgstr ""

#: ../../../gpu/i915.rst:517
msgid "GuC Firmware Layout"
msgstr ""

#: ../../../gpu/i915:519: drivers/gpu/drm/i915/gt/uc/intel_uc_fw_abi.h:13
msgid "The GuC/HuC firmware layout looks like this::"
msgstr ""

#: ../../../gpu/i915:519: drivers/gpu/drm/i915/gt/uc/intel_uc_fw_abi.h:26
msgid ""
"The firmware may or may not have modulus key and exponent data. The header, "
"uCode and RSA signature are must-have components that will be used by "
"driver. Length of each components, which is all in dwords, can be found in "
"header. In the case that modulus and exponent are not present in fw, a.k.a "
"truncated image, the length value still appears in header."
msgstr ""

#: ../../../gpu/i915:519: drivers/gpu/drm/i915/gt/uc/intel_uc_fw_abi.h:32
msgid ""
"Driver will do some basic fw size validation based on the following rules:"
msgstr ""

#: ../../../gpu/i915:519: drivers/gpu/drm/i915/gt/uc/intel_uc_fw_abi.h:34
msgid "Header, uCode and RSA are must-have components."
msgstr ""

#: ../../../gpu/i915:519: drivers/gpu/drm/i915/gt/uc/intel_uc_fw_abi.h:35
msgid ""
"All firmware components, if they present, are in the sequence illustrated in "
"the layout table above."
msgstr ""

#: ../../../gpu/i915:519: drivers/gpu/drm/i915/gt/uc/intel_uc_fw_abi.h:37
msgid "Length info of each component can be found in header, in dwords."
msgstr ""

#: ../../../gpu/i915:519: drivers/gpu/drm/i915/gt/uc/intel_uc_fw_abi.h:38
msgid ""
"Modulus and exponent key are not required by driver. They may not appear in "
"fw. So driver will load a truncated firmware in this case."
msgstr ""

#: ../../../gpu/i915:519: drivers/gpu/drm/i915/gt/uc/intel_uc_fw_abi.h:41
msgid ""
"Starting from DG2, the HuC is loaded by the GSC instead of i915. The GSC "
"firmware performs all the required integrity checks, we just need to check "
"the version. Note that the header for GSC-managed blobs is different from "
"the CSS used for dma-loaded firmwares."
msgstr ""

#: ../../../gpu/i915.rst:523
msgid "GuC Memory Management"
msgstr ""

#: ../../../gpu/i915:525: drivers/gpu/drm/i915/gt/uc/intel_guc.c:731
msgid ""
"GuC can't allocate any memory for its own usage, so all the allocations must "
"be handled by the host driver. GuC accesses the memory via the GGTT, with "
"the exception of the top and bottom parts of the 4GB address space, which "
"are instead re-mapped by the GuC HW to memory location of the FW itself "
"(WOPCM) or other parts of the HW. The driver must take care not to place "
"objects that the GuC is going to access in these reserved ranges. The layout "
"of the GuC address space is shown below:"
msgstr ""

#: ../../../gpu/i915:525: drivers/gpu/drm/i915/gt/uc/intel_guc.c:757
msgid ""
"The lower part of GuC Address Space [0, ggtt_pin_bias) is mapped to GuC "
"WOPCM while upper part of GuC Address Space [ggtt_pin_bias, GUC_GGTT_TOP) is "
"mapped to DRAM. The value of the GuC ggtt_pin_bias is the GuC WOPCM size."
msgstr ""

#: ../../../gpu/i915:527: drivers/gpu/drm/i915/gt/uc/intel_guc.c:765
msgid "Allocate a GGTT VMA for GuC usage"
msgstr ""

#: ../../../gpu/i915:527: drivers/gpu/drm/i915/gt/uc/intel_guc.c:766
msgid "the guc"
msgstr ""

#: ../../../gpu/i915:527: drivers/gpu/drm/i915/gt/uc/intel_guc.c:767
msgid "size of area to allocate (both virtual space and memory)"
msgstr ""

#: ../../../gpu/i915:527: drivers/gpu/drm/i915/gt/uc/intel_guc.c:768
msgid ""
"This is a wrapper to create an object for use with the GuC. In order to use "
"it inside the GuC, an object needs to be pinned lifetime, so we allocate "
"both some backing storage and a range inside the Global GTT. We must pin it "
"in the GGTT somewhere other than than [0, GUC ggtt_pin_bias) because that "
"range is reserved inside GuC."
msgstr ""

#: ../../../gpu/i915:527: drivers/gpu/drm/i915/gt/uc/intel_guc.c:775
msgid "A i915_vma if successful, otherwise an ERR_PTR."
msgstr ""

#: ../../../gpu/i915.rst:532
msgid "GuC-specific firmware loader"
msgstr ""

#: ../../../gpu/i915:534: drivers/gpu/drm/i915/gt/uc/intel_guc_fw.c:286
msgid "load GuC uCode to device"
msgstr ""

#: ../../../gpu/i915:534: drivers/gpu/drm/i915/gt/uc/intel_guc_fw.c:287
msgid "intel_guc structure"
msgstr ""

#: ../../../gpu/i915:534: drivers/gpu/drm/i915/gt/uc/intel_guc_fw.c:288
msgid ""
"Called from intel_uc_init_hw() during driver load, resume from sleep and "
"after a GPU reset."
msgstr ""

#: ../../../gpu/i915:534: drivers/gpu/drm/i915/gt/uc/intel_guc_fw.c:291
msgid ""
"The firmware image should have already been fetched into memory, so only "
"check that fetch succeeded, and then transfer the image to the h/w."
msgstr ""

#: ../../../gpu/i915:534: drivers/gpu/drm/i915/gt/uc/intel_guc_fw.c:295
msgid "non-zero code on error"
msgstr ""

#: ../../../gpu/i915.rst:538
msgid "GuC-based command submission"
msgstr ""

#: ../../../gpu/i915:540: drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c:39
msgid ""
"The Scratch registers: There are 16 MMIO-based registers start from 0xC180. "
"The kernel driver writes a value to the action register (SOFT_SCRATCH_0) "
"along with any data. It then triggers an interrupt on the GuC via another "
"register write (0xC4C8). Firmware writes a success/fail code back to the "
"action register after processes the request. The kernel driver polls waiting "
"for this update and then proceeds."
msgstr ""

#: ../../../gpu/i915:540: drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c:47
msgid ""
"Command Transport buffers (CTBs): Covered in detail in other sections but "
"CTBs (Host to GuC - H2G, GuC to Host - G2H) are a message interface between "
"the i915 and GuC."
msgstr ""

#: ../../../gpu/i915:540: drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c:51
msgid ""
"Context registration: Before a context can be submitted it must be "
"registered with the GuC via a H2G. A unique guc_id is associated with each "
"context. The context is either registered at request creation time (normal "
"operation) or at submission time (abnormal operation, e.g. after a reset)."
msgstr ""

#: ../../../gpu/i915:540: drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c:57
msgid ""
"Context submission: The i915 updates the LRC tail value in memory. The i915 "
"must enable the scheduling of the context within the GuC for the GuC to "
"actually consider it. Therefore, the first time a disabled context is "
"submitted we use a schedule enable H2G, while follow up submissions are done "
"via the context submit H2G, which informs the GuC that a previously enabled "
"context has new work available."
msgstr ""

#: ../../../gpu/i915:540: drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c:65
msgid ""
"Context unpin: To unpin a context a H2G is used to disable scheduling. When "
"the corresponding G2H returns indicating the scheduling disable operation "
"has completed it is safe to unpin the context. While a disable is in flight "
"it isn't safe to resubmit the context so a fence is used to stall all future "
"requests of that context until the G2H is returned. Because this interaction "
"with the GuC takes a non-zero amount of time we delay the disabling of "
"scheduling after the pin count goes to zero by a configurable period of time "
"(see SCHED_DISABLE_DELAY_MS). The thought is this gives the user a window of "
"time to resubmit something on the context before doing this costly "
"operation. This delay is only done if the context isn't closed and the "
"guc_id usage is less than a threshold (see "
"NUM_SCHED_DISABLE_GUC_IDS_THRESHOLD)."
msgstr ""

#: ../../../gpu/i915:540: drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c:78
msgid ""
"Context deregistration: Before a context can be destroyed or if we steal its "
"guc_id we must deregister the context with the GuC via H2G. If stealing the "
"guc_id it isn't safe to submit anything to this guc_id until the deregister "
"completes so a fence is used to stall all requests associated with this "
"guc_id until the corresponding G2H returns indicating the guc_id has been "
"deregistered."
msgstr ""

#: ../../../gpu/i915:540: drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c:85
msgid ""
"submission_state.guc_ids: Unique number associated with private GuC context "
"data passed in during context registration / submission / deregistration. "
"64k available. Simple ida is used for allocation."
msgstr ""

#: ../../../gpu/i915:540: drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c:90
msgid ""
"Stealing guc_ids: If no guc_ids are available they can be stolen from "
"another context at request creation time if that context is unpinned. If a "
"guc_id can't be found we punt this problem to the user as we believe this is "
"near impossible to hit during normal use cases."
msgstr ""

#: ../../../gpu/i915:540: drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c:96
msgid ""
"Locking: In the GuC submission code we have 3 basic spin locks which protect "
"everything. Details about each below."
msgstr ""

#: ../../../gpu/i915:540: drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c:100
msgid ""
"sched_engine->lock This is the submission lock for all contexts that share "
"an i915 schedule engine (sched_engine), thus only one of the contexts which "
"share a sched_engine can be submitting at a time. Currently only one "
"sched_engine is used for all of GuC submission but that could change in the "
"future."
msgstr ""

#: ../../../gpu/i915:540: drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c:106
msgid ""
"guc->submission_state.lock Global lock for GuC submission state. Protects "
"guc_ids and destroyed contexts list."
msgstr ""

#: ../../../gpu/i915:540: drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c:110
msgid ""
"ce->guc_state.lock Protects everything under ce->guc_state. Ensures that a "
"context is in the correct state before issuing a H2G. e.g. We don't issue a "
"schedule disable on a disabled context (bad idea), we don't issue a schedule "
"enable when a schedule disable is in flight, etc... Also protects list of "
"inflight requests on the context and the priority management state. Lock is "
"individual to each context."
msgstr ""

#: ../../../gpu/i915:540: drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c:118
msgid ""
"Lock ordering rules: sched_engine->lock -> ce->guc_state.lock guc-"
">submission_state.lock -> ce->guc_state.lock"
msgstr ""

#: ../../../gpu/i915:540: drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c:122
msgid ""
"Reset races: When a full GT reset is triggered it is assumed that some G2H "
"responses to H2Gs can be lost as the GuC is also reset. Losing these G2H can "
"prove to be fatal as we do certain operations upon receiving a G2H (e.g. "
"destroy contexts, release guc_ids, etc...). When this occurs we can scrub "
"the context state and cleanup appropriately, however this is quite racey. To "
"avoid races, the reset code must disable submission before scrubbing for the "
"missing G2H, while the submission code must check for submission being "
"disabled and skip sending H2Gs and updating context states when it is. Both "
"sides must also make sure to hold the relevant locks."
msgstr ""

#: ../../../gpu/i915.rst:544
msgid "GuC ABI"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:3
msgid "**HXG Message**"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:10
msgid ""
"All messages exchanged with GuC are defined using 32 bit dwords. First dword "
"is treated as a message header. Remaining dwords are optional."
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:14
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:69
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:106
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:129
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:162
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:184
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:206
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:229 ../../../gpu/i915:547:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_mmio_abi.h:37
#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:22
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:63
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:95
#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:15
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:38
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:67
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:84 ../../../gpu/i915:550:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:13
msgid "Bits"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:14
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:69
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:106
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:129
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:162
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:184
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:206
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:229 ../../../gpu/i915:547:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_mmio_abi.h:37
#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:22
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:63
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:95
#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:15
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:38
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:67
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:84 ../../../gpu/i915:550:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:13
msgid "Description"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:17
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:71
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:108
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:131
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:164
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:186
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:208
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:231 ../../../gpu/i915:547:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_mmio_abi.h:39
#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:24
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:65
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:97
#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:17
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:40
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:69
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:86 ../../../gpu/i915:550:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:15
msgid "0"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:17
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:71
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:108
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:131
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:164
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:186
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:208
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:231 ../../../gpu/i915:549:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:17
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:40
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:69
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:86
msgid "31"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:17
msgid "**ORIGIN** - originator of the message"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:18
msgid "_`GUC_HXG_ORIGIN_HOST` = 0"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:19
msgid "_`GUC_HXG_ORIGIN_GUC` = 1"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:22
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:73
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:110
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:133
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:166
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:188
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:210
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:233 ../../../gpu/i915:549:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:19
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:42
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:71
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:88
msgid "30:28"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:22
msgid "**TYPE** - message type"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:23
msgid "_`GUC_HXG_TYPE_REQUEST` = 0"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:24
msgid "_`GUC_HXG_TYPE_EVENT` = 1"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:25
msgid "_`GUC_HXG_TYPE_FAST_REQUEST` = 2"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:26
msgid "_`GUC_HXG_TYPE_NO_RESPONSE_BUSY` = 3"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:27
msgid "_`GUC_HXG_TYPE_NO_RESPONSE_RETRY` = 5"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:28
msgid "_`GUC_HXG_TYPE_RESPONSE_FAILURE` = 6"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:29
msgid "_`GUC_HXG_TYPE_RESPONSE_SUCCESS` = 7"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:31
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:168
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:190
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:235 ../../../gpu/i915:549:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:44
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:90
msgid "27:0"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:31
msgid "**AUX** - auxiliary data (depends on TYPE)"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:33
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:79
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:139
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:237 ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:28
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:74
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:105
#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:25
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:77 ../../../gpu/i915:550:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:21
msgid "1"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:33
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:37
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:79
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:83
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:139
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:143
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:237
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:241 ../../../gpu/i915:547:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_mmio_abi.h:39
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_mmio_abi.h:43
#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:24
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:28
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:32
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:42
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:74
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:78
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:105
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:109
#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:32
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:34
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:77 ../../../gpu/i915:550:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:21
#: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:25
msgid "31:0"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:35
msgid "**PAYLOAD** - optional payload (depends on TYPE)"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:35
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:81
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:116
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:141
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:239 ../../../gpu/i915:547:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_mmio_abi.h:41
#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:40
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:76
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:107
#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:23
msgid "..."
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:37
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:83
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:143
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:241 ../../../gpu/i915:547:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_mmio_abi.h:43
#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:78
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:109
#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:25
msgid "n"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:43
msgid "**HXG Request**"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:59
msgid ""
"The `HXG Request`_ message should be used to initiate synchronous activity "
"for which confirmation or return data is expected."
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:62
msgid ""
"The recipient of this message shall use `HXG Response`_, `HXG Failure`_ or "
"`HXG Retry`_ message as a definite reply, and may use `HXG Busy`_ message as "
"a intermediate reply."
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:66
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:126
msgid ""
"Format of **DATA0** and all **DATAn** fields depends on the **ACTION** code."
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:71
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:131
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:164
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:186
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:208
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:231
msgid "ORIGIN"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:73
#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:19
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:71
msgid "TYPE = GUC_HXG_TYPE_REQUEST_"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:75
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:112
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:135
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:212 ../../../gpu/i915:549:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:21
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:73
msgid "27:16"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:75
msgid "**DATA0** - request data (depends on ACTION)"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:77
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:114
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:137
#: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:214 ../../../gpu/i915:549:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:23
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:27
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:75 ../../../gpu/i915:550:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:19
msgid "15:0"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:77
msgid "**ACTION** - requested action code"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:81
msgid "**DATAn** - optional data (depends on ACTION)"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:89
msgid "**HXG Fast Request**"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:95
msgid ""
"The `HXG Request`_ message should be used to initiate asynchronous activity "
"for which confirmation or return data is not expected."
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:98
msgid "If confirmation is required then `HXG Request`_ shall be used instead."
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:100
msgid ""
"The recipient of this message may only use `HXG Failure`_ message if it was "
"unable to accept this request (like invalid data)."
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:103
msgid ""
"Format of `HXG Fast Request`_ message is same as `HXG Request`_ except "
"**TYPE**."
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:108
msgid "ORIGIN - see `HXG Message`_"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:110
msgid "TYPE = `GUC_HXG_TYPE_FAST_REQUEST`_"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:112
msgid "DATA0 - see `HXG Request`_"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:114
msgid "ACTION - see `HXG Request`_"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:116
msgid "DATAn - see `HXG Request`_"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:122
msgid "**HXG Event**"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:123
msgid ""
"The `HXG Event`_ message should be used to initiate asynchronous activity "
"that does not involves immediate confirmation nor data."
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:133
msgid "TYPE = GUC_HXG_TYPE_EVENT_"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:135
msgid "**DATA0** - event data (depends on ACTION)"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:137
msgid "**ACTION** - event action code"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:141
msgid "**DATAn** - optional event  data (depends on ACTION)"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:149
msgid "**HXG Busy**"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:155
msgid ""
"The `HXG Busy`_ message may be used to acknowledge reception of the `HXG "
"Request`_ message if the recipient expects that it processing will be longer "
"than default timeout."
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:159
msgid "The **COUNTER** field may be used as a progress indicator."
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:166
msgid "TYPE = GUC_HXG_TYPE_NO_RESPONSE_BUSY_"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:168
msgid "**COUNTER** - progress indicator"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:174
msgid "**HXG Retry**"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:178
msgid ""
"The `HXG Retry`_ message should be used by recipient to indicate that the "
"`HXG Request`_ message was dropped and it should be resent again."
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:181
msgid "The **REASON** field may be used to provide additional information."
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:188
msgid "TYPE = GUC_HXG_TYPE_NO_RESPONSE_RETRY_"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:190
msgid "**REASON** - reason for retry"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:191
msgid "_`GUC_HXG_RETRY_REASON_UNSPECIFIED` = 0"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:197
msgid "**HXG Failure**"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:202
msgid ""
"The `HXG Failure`_ message shall be used as a reply to the `HXG Request`_ "
"message that could not be processed due to an error."
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:210
msgid "TYPE = GUC_HXG_TYPE_RESPONSE_FAILURE_"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:212
msgid "**HINT** - additional error hint"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:214
msgid "**ERROR** - error/result code"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:220
msgid "**HXG Response**"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:225
msgid ""
"The `HXG Response`_ message shall be used as a reply to the `HXG Request`_ "
"message that was successfully processed without an error."
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:233
#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:42
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:88
msgid "TYPE = GUC_HXG_TYPE_RESPONSE_SUCCESS_"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:235
msgid "**DATA0** - data (depends on ACTION from `HXG Request`_)"
msgstr ""

#: ../../../gpu/i915:546: drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:239
msgid "**DATAn** - data (depends on ACTION from `HXG Request`_)"
msgstr ""

#: ../../../gpu/i915:547:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_mmio_abi.h:3
msgid "**GuC MMIO based communication**"
msgstr ""

#: ../../../gpu/i915:547:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_mmio_abi.h:10
msgid ""
"The MMIO based communication between Host and GuC relies on special hardware "
"registers which format could be defined by the software (so called scratch "
"registers)."
msgstr ""

#: ../../../gpu/i915:547:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_mmio_abi.h:14
msgid ""
"Each MMIO based message, both Host to GuC (H2G) and GuC to Host (G2H) "
"messages, which maximum length depends on number of available scratch "
"registers, is directly written into those scratch registers."
msgstr ""

#: ../../../gpu/i915:547:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_mmio_abi.h:18
msgid ""
"For Gen9+, there are 16 software scratch registers 0xC180-0xC1B8, but no H2G "
"command takes more than 4 parameters and the GuC firmware itself uses an 4-"
"element array to store the H2G message."
msgstr ""

#: ../../../gpu/i915:547:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_mmio_abi.h:22
msgid ""
"For Gen11+, there are additional 4 registers 0x190240-0x19024C, which are, "
"regardless on lower count, preferred over legacy ones."
msgstr ""

#: ../../../gpu/i915:547:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_mmio_abi.h:25
msgid ""
"The MMIO based communication is mainly used during driver initialization "
"phase to setup the `CTB based communication`_ that will be used afterwards."
msgstr ""

#: ../../../gpu/i915:547:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_mmio_abi.h:31
msgid "**MMIO HXG Message**"
msgstr ""

#: ../../../gpu/i915:547:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_mmio_abi.h:34
msgid "Format of the MMIO messages follows definitions of `HXG Message`_."
msgstr ""

#: ../../../gpu/i915:547:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_mmio_abi.h:41
#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:107
msgid "[Embedded `HXG Message`_]"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:3
msgid "**CT Buffer**"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:15
msgid "Circular buffer used to send `CTB Message`_"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:20
msgid "**CTB Descriptor**"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:24
msgid ""
"**HEAD** - offset (in dwords) to the last dword that was read from the `CT "
"Buffer`_. It can only be updated by the receiver."
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:28
msgid ""
"**TAIL** - offset (in dwords) to the last dword that was written to the `CT "
"Buffer`_. It can only be updated by the sender."
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:32
#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:32
msgid "2"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:32
msgid "**STATUS** - status of the CTB"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:34
msgid "_`GUC_CTB_STATUS_NO_ERROR` = 0 (normal operation)"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:35
msgid "_`GUC_CTB_STATUS_OVERFLOW` = 1 (head/tail too large)"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:36
msgid "_`GUC_CTB_STATUS_UNDERFLOW` = 2 (truncated message)"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:37
msgid "_`GUC_CTB_STATUS_MISMATCH` = 4 (head/tail modified)"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:38
msgid "_`GUC_CTB_STATUS_UNUSED` = 8 (CTB is not in use)"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:40
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:42
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:101
msgid "RESERVED = MBZ"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:42
msgid "15"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:48
msgid "**CTB Message**"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:65
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:97
#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:25
#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:15
msgid "31:16"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:65
msgid "**FENCE** - message identifier"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:67
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:99
msgid "15:12"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:67
msgid "**FORMAT** - format of the CTB message"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:68
msgid "_`GUC_CTB_FORMAT_HXG` = 0 - see `CTB HXG Message`_"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:70
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:101
msgid "11:8"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:70
msgid "**RESERVED**"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:72
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:103
msgid "7:0"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:72
msgid "**NUM_DWORDS** - length of the CTB message (w/o header)"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:74
msgid "optional (depends on FORMAT)"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:84
msgid "**CTB HXG Message**"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:97
msgid "FENCE"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:99
msgid "FORMAT = GUC_CTB_FORMAT_HXG_"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:103
msgid "NUM_DWORDS = length (in dwords) of the embedded HXG message"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:115
msgid "**CTB based communication**"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:119
msgid ""
"The CTB (command transport buffer) communication between Host and GuC is "
"based on u32 data stream written to the shared buffer. One buffer can be "
"used to transmit data only in one direction (one-directional channel)."
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:123
msgid ""
"Current status of the each buffer is stored in the buffer descriptor. Buffer "
"descriptor holds tail and head fields that represents active data stream. "
"The tail field is updated by the data producer (sender), and head field is "
"updated by the data consumer (receiver)::"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:140
msgid ""
"Each message in data stream starts with the single u32 treated as a header, "
"followed by optional set of u32 data that makes message specific payload::"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:161
msgid "The message header consists of:"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:163
msgid "**len**, indicates length of the message payload (in u32)"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:164
msgid "**code**, indicates message code"
msgstr ""

#: ../../../gpu/i915:548:
#: drivers/gpu/drm/i915/gt/uc/abi/guc_communication_ctb_abi.h:165
msgid "**flags**, holds various bits to control message handling"
msgstr ""

#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:3
msgid "**HOST2GUC_SELF_CFG**"
msgstr ""

#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:10
msgid ""
"This message is used by Host KMD to setup of the `GuC Self Config KLVs`_."
msgstr ""

#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:12
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:64
msgid "This message must be sent as `MMIO HXG Message`_."
msgstr ""

#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:17
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:69
msgid "ORIGIN = GUC_HXG_ORIGIN_HOST_"
msgstr ""

#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:21
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:73
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:90
msgid "DATA0 = MBZ"
msgstr ""

#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:23
msgid "ACTION = _`GUC_ACTION_HOST2GUC_SELF_CFG` = 0x0508"
msgstr ""

#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:25
msgid "**KLV_KEY** - KLV key, see `GuC Self Config KLVs`_"
msgstr ""

#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:27
msgid "**KLV_LEN** - KLV length"
msgstr ""

#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:29
msgid "32 bit KLV = 1"
msgstr ""

#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:30
msgid "64 bit KLV = 2"
msgstr ""

#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:32
msgid "**VALUE32** - Bits 31-0 of the KLV value"
msgstr ""

#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:34
msgid "3"
msgstr ""

#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:34
msgid "**VALUE64** - Bits 63-32 of the KLV value (**KLV_LEN** = 2)"
msgstr ""

#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:40
#: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:86
msgid "ORIGIN = GUC_HXG_ORIGIN_GUC_"
msgstr ""

#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:44
msgid "DATA0 = **NUM** - 1 if KLV was parsed, 0 if not recognized"
msgstr ""

#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:50
msgid "**HOST2GUC_CONTROL_CTB**"
msgstr ""

#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:62
msgid ""
"This H2G action allows Vf Host to enable or disable H2G and G2H `CT Buffer`_."
msgstr ""

#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:75
msgid "ACTION = _`GUC_ACTION_HOST2GUC_CONTROL_CTB` = 0x4509"
msgstr ""

#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:77
msgid "**CONTROL** - control `CTB based communication`_"
msgstr ""

#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:79
msgid "_`GUC_CTB_CONTROL_DISABLE` = 0"
msgstr ""

#: ../../../gpu/i915:549: drivers/gpu/drm/i915/gt/uc/abi/guc_actions_abi.h:80
msgid "_`GUC_CTB_CONTROL_ENABLE` = 1"
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:3
msgid "**GuC KLV**"
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:15
msgid "**KEY** - KLV key identifier"
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:16
msgid "`GuC Self Config KLVs`_"
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:19
msgid "**LEN** - length of VALUE (in 32bit dwords)"
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:21
msgid "**VALUE** - actual value of the KLV (format depends on KEY)"
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:31
msgid "**GuC Self Config KLVs**"
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:37
msgid "`GuC KLV`_ keys available for use with HOST2GUC_SELF_CFG_."
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:39
msgid "_`GUC_KLV_SELF_CFG_H2G_CTB_ADDR`"
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:-1
msgid "0x0902"
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:40
msgid ""
"Refers to 64 bit Global Gfx address of H2G `CT Buffer`_. Should be above "
"WOPCM address but below APIC base address for native mode."
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:43
msgid "_`GUC_KLV_SELF_CFG_H2G_CTB_DESCRIPTOR_ADDR`"
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:-1
msgid "0x0903"
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:44
msgid ""
"Refers to 64 bit Global Gfx address of H2G `CTB Descriptor`_. Should be "
"above WOPCM address but below APIC base address for native mode."
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:47
msgid "_`GUC_KLV_SELF_CFG_H2G_CTB_SIZE`"
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:-1
msgid "0x0904"
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:48
msgid ""
"Refers to size of H2G `CT Buffer`_ in bytes. Should be a multiple of 4K."
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:51
msgid "_`GUC_KLV_SELF_CFG_G2H_CTB_ADDR`"
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:-1
msgid "0x0905"
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:52
msgid ""
"Refers to 64 bit Global Gfx address of G2H `CT Buffer`_. Should be above "
"WOPCM address but below APIC base address for native mode."
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:55
msgid "_`GUC_KLV_SELF_CFG_G2H_CTB_DESCRIPTOR_ADDR`"
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:-1
msgid "0x0906"
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:56
msgid ""
"Refers to 64 bit Global Gfx address of G2H `CTB Descriptor`_. Should be "
"above WOPCM address but below APIC base address for native mode."
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:59
msgid "_`GUC_KLV_SELF_CFG_G2H_CTB_SIZE`"
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:-1
msgid "0x0907"
msgstr ""

#: ../../../gpu/i915:550: drivers/gpu/drm/i915/gt/uc/abi/guc_klvs_abi.h:60
msgid ""
"Refers to size of G2H `CT Buffer`_ in bytes. Should be a multiple of 4K."
msgstr ""

#: ../../../gpu/i915.rst:553
msgid "HuC"
msgstr ""

#: ../../../gpu/i915:554: drivers/gpu/drm/i915/gt/uc/intel_huc.c:21
msgid ""
"The HuC is a dedicated microcontroller for usage in media HEVC (High "
"Efficiency Video Coding) operations. Userspace can directly use the firmware "
"capabilities by adding HuC specific commands to batch buffers."
msgstr ""

#: ../../../gpu/i915:554: drivers/gpu/drm/i915/gt/uc/intel_huc.c:25
msgid ""
"The kernel driver is only responsible for loading the HuC firmware and "
"triggering its security authentication. This is done differently depending "
"on the platform:"
msgstr ""

#: ../../../gpu/i915:554: drivers/gpu/drm/i915/gt/uc/intel_huc.c:29
msgid ""
"older platforms (from Gen9 to most Gen12s): the load is performed via DMA "
"and the authentication via GuC"
msgstr ""

#: ../../../gpu/i915:554: drivers/gpu/drm/i915/gt/uc/intel_huc.c:31
msgid "DG2: load and authentication are both performed via GSC."
msgstr ""

#: ../../../gpu/i915:554: drivers/gpu/drm/i915/gt/uc/intel_huc.c:32
msgid ""
"MTL and newer platforms: the load is performed via DMA (same as with not-DG2 "
"older platforms), while the authentication is done in 2-steps, a first auth "
"for clear-media workloads via GuC and a second one for all workloads via GSC."
msgstr ""

#: ../../../gpu/i915:554: drivers/gpu/drm/i915/gt/uc/intel_huc.c:37
msgid ""
"On platforms where the GuC does the authentication, to correctly do so the "
"HuC binary must be loaded before the GuC one. Loading the HuC is optional; "
"however, not using the HuC might negatively impact power usage and/or "
"performance of media workloads, depending on the use-cases. HuC must be "
"reloaded on events that cause the WOPCM to lose its contents (S3/S4, FLR); "
"on older platforms the HuC must also be reloaded on GuC/GT reset, while on "
"newer ones it will survive that."
msgstr ""

#: ../../../gpu/i915:554: drivers/gpu/drm/i915/gt/uc/intel_huc.c:46
msgid ""
"See https://github.com/intel/media-driver for the latest details on HuC "
"functionality."
msgstr ""

#: ../../../gpu/i915:556: drivers/gpu/drm/i915/gt/uc/intel_huc.c:518
msgid "Authenticate HuC uCode"
msgstr ""

#: ../../../gpu/i915:556: drivers/gpu/drm/i915/gt/uc/intel_huc.c:524
msgid "``struct intel_huc *huc``"
msgstr ""

#: ../../../gpu/i915:556: drivers/gpu/drm/i915/gt/uc/intel_huc.c:519
msgid "intel_huc structure"
msgstr ""

#: ../../../gpu/i915:556: drivers/gpu/drm/i915/gt/uc/intel_huc.c:521
msgid "``enum intel_huc_authentication_type type``"
msgstr ""

#: ../../../gpu/i915:556: drivers/gpu/drm/i915/gt/uc/intel_huc.c:520
msgid "authentication type (via GuC or via GSC)"
msgstr ""

#: ../../../gpu/i915:556: drivers/gpu/drm/i915/gt/uc/intel_huc.c:521
msgid "Called after HuC and GuC firmware loading during intel_uc_init_hw()."
msgstr ""

#: ../../../gpu/i915:556: drivers/gpu/drm/i915/gt/uc/intel_huc.c:523
msgid ""
"This function invokes the GuC action to authenticate the HuC firmware, "
"passing the offset of the RSA signature to intel_guc_auth_huc(). It then "
"waits for up to 50ms for firmware verification ACK."
msgstr ""

#: ../../../gpu/i915.rst:560
msgid "HuC Memory Management"
msgstr ""

#: ../../../gpu/i915:562: drivers/gpu/drm/i915/gt/uc/intel_huc.c:53
msgid ""
"Similarly to the GuC, the HuC can't do any memory allocations on its own, "
"with the difference being that the allocations for HuC usage are handled by "
"the userspace driver instead of the kernel one. The HuC accesses the memory "
"via the PPGTT belonging to the context loaded on the VCS executing the HuC-"
"specific commands."
msgstr ""

#: ../../../gpu/i915.rst:566
msgid "HuC Firmware Layout"
msgstr ""

#: ../../../gpu/i915.rst:567
msgid ""
"The HuC FW layout is the same as the GuC one, see `GuC Firmware Layout`_"
msgstr ""

#: ../../../gpu/i915.rst:570
msgid "DMC"
msgstr ""

#: ../../../gpu/i915.rst:571
msgid "See `DMC Firmware Support`_"
msgstr ""

#: ../../../gpu/i915.rst:574
msgid "Tracing"
msgstr ""

#: ../../../gpu/i915.rst:576
msgid ""
"This sections covers all things related to the tracepoints implemented in "
"the i915 driver."
msgstr ""

#: ../../../gpu/i915.rst:580
msgid "i915_ppgtt_create and i915_ppgtt_release"
msgstr ""

#: ../../../gpu/i915:582: drivers/gpu/drm/i915/i915_trace.h:646
msgid ""
"With full ppgtt enabled each process using drm will allocate at least one "
"translation table. With these traces it is possible to keep track of the "
"allocation and of the lifetime of the tables; this can be used during "
"testing/debug to verify that we are not leaking ppgtts. These traces "
"identify the ppgtt through the vm pointer, which is also printed by the "
"i915_vma_bind and i915_vma_unbind tracepoints."
msgstr ""

#: ../../../gpu/i915.rst:586
msgid "i915_context_create and i915_context_free"
msgstr ""

#: ../../../gpu/i915:588: drivers/gpu/drm/i915/i915_trace.h:683
msgid ""
"These tracepoints are used to track creation and deletion of contexts. If "
"full ppgtt is enabled, they also print the address of the vm assigned to the "
"context."
msgstr ""

#: ../../../gpu/i915.rst:592
msgid "Perf"
msgstr ""

#: ../../../gpu/i915.rst:595
msgid "Overview"
msgstr ""

#: ../../../gpu/i915:596: drivers/gpu/drm/i915/i915_perf.c:29
msgid ""
"Gen graphics supports a large number of performance counters that can help "
"driver and application developers understand and optimize their use of the "
"GPU."
msgstr ""

#: ../../../gpu/i915:596: drivers/gpu/drm/i915/i915_perf.c:33
msgid ""
"This i915 perf interface enables userspace to configure and open a file "
"descriptor representing a stream of GPU metrics which can then be read() as "
"a stream of sample records."
msgstr ""

#: ../../../gpu/i915:596: drivers/gpu/drm/i915/i915_perf.c:37
msgid ""
"The interface is particularly suited to exposing buffered metrics that are "
"captured by DMA from the GPU, unsynchronized with and unrelated to the CPU."
msgstr ""

#: ../../../gpu/i915:596: drivers/gpu/drm/i915/i915_perf.c:40
msgid ""
"Streams representing a single context are accessible to applications with a "
"corresponding drm file descriptor, such that OpenGL can use the interface "
"without special privileges. Access to system-wide metrics requires root "
"privileges by default, unless changed via the dev.i915.perf_event_paranoid "
"sysctl option."
msgstr ""

#: ../../../gpu/i915.rst:600
msgid "Comparison with Core Perf"
msgstr ""

#: ../../../gpu/i915:601: drivers/gpu/drm/i915/i915_perf.c:51
msgid ""
"The interface was initially inspired by the core Perf infrastructure but "
"some notable differences are:"
msgstr ""

#: ../../../gpu/i915:601: drivers/gpu/drm/i915/i915_perf.c:54
msgid ""
"i915 perf file descriptors represent a \"stream\" instead of an \"event\"; "
"where a perf event primarily corresponds to a single 64bit value, while a "
"stream might sample sets of tightly-coupled counters, depending on the "
"configuration.  For example the Gen OA unit isn't designed to support "
"orthogonal configurations of individual counters; it's configured for a set "
"of related counters. Samples for an i915 perf stream capturing OA metrics "
"will include a set of counter values packed in a compact HW specific format. "
"The OA unit supports a number of different packing formats which can be "
"selected by the user opening the stream. Perf has support for grouping "
"events, but each event in the group is configured, validated and "
"authenticated individually with separate system calls."
msgstr ""

#: ../../../gpu/i915:601: drivers/gpu/drm/i915/i915_perf.c:66
msgid ""
"i915 perf stream configurations are provided as an array of u64 (key,value) "
"pairs, instead of a fixed struct with multiple miscellaneous config members, "
"interleaved with event-type specific members."
msgstr ""

#: ../../../gpu/i915:601: drivers/gpu/drm/i915/i915_perf.c:70
msgid ""
"i915 perf doesn't support exposing metrics via an mmap'd circular buffer. "
"The supported metrics are being written to memory by the GPU unsynchronized "
"with the CPU, using HW specific packing formats for counter sets. Sometimes "
"the constraints on HW configuration require reports to be filtered before it "
"would be acceptable to expose them to unprivileged applications - to hide "
"the metrics of other processes/contexts. For these use cases a read() based "
"interface is a good fit, and provides an opportunity to filter data as it "
"gets copied from the GPU mapped buffers to userspace buffers."
msgstr ""

#: ../../../gpu/i915:601: drivers/gpu/drm/i915/i915_perf.c:83
msgid ""
"The first prototype of this driver was based on the core perf "
"infrastructure, and while we did make that mostly work, with some changes to "
"perf, we found we were breaking or working around too many assumptions baked "
"into perf's currently cpu centric design."
msgstr ""

#: ../../../gpu/i915:601: drivers/gpu/drm/i915/i915_perf.c:88
msgid ""
"In the end we didn't see a clear benefit to making perf's implementation and "
"interface more complex by changing design assumptions while we knew we still "
"wouldn't be able to use any existing perf based userspace tools."
msgstr ""

#: ../../../gpu/i915:601: drivers/gpu/drm/i915/i915_perf.c:92
msgid ""
"Also considering the Gen specific nature of the Observability hardware and "
"how userspace will sometimes need to combine i915 perf OA metrics with side-"
"band OA data captured via MI_REPORT_PERF_COUNT commands; we're expecting the "
"interface to be used by a platform specific userspace such as OpenGL or "
"tools. This is to say; we aren't inherently missing out on having a standard "
"vendor/architecture agnostic interface by not using perf."
msgstr ""

#: ../../../gpu/i915:601: drivers/gpu/drm/i915/i915_perf.c:100
msgid ""
"For posterity, in case we might re-visit trying to adapt core perf to be "
"better suited to exposing i915 metrics these were the main pain points we "
"hit:"
msgstr ""

#: ../../../gpu/i915:601: drivers/gpu/drm/i915/i915_perf.c:104
msgid "The perf based OA PMU driver broke some significant design assumptions:"
msgstr ""

#: ../../../gpu/i915:601: drivers/gpu/drm/i915/i915_perf.c:106
msgid ""
"Existing perf pmus are used for profiling work on a cpu and we were "
"introducing the idea of _IS_DEVICE pmus with different security "
"implications, the need to fake cpu-related data (such as user/kernel "
"registers) to fit with perf's current design, and adding _DEVICE records as "
"a way to forward device-specific status records."
msgstr ""

#: ../../../gpu/i915:601: drivers/gpu/drm/i915/i915_perf.c:112
msgid ""
"The OA unit writes reports of counters into a circular buffer, without "
"involvement from the CPU, making our PMU driver the first of a kind."
msgstr ""

#: ../../../gpu/i915:601: drivers/gpu/drm/i915/i915_perf.c:115
msgid ""
"Given the way we were periodically forward data from the GPU-mapped, OA "
"buffer to perf's buffer, those bursts of sample writes looked to perf like "
"we were sampling too fast and so we had to subvert its throttling checks."
msgstr ""

#: ../../../gpu/i915:601: drivers/gpu/drm/i915/i915_perf.c:119
msgid ""
"Perf supports groups of counters and allows those to be read via "
"transactions internally but transactions currently seem designed to be "
"explicitly initiated from the cpu (say in response to a userspace read()) "
"and while we could pull a report out of the OA buffer we can't trigger a "
"report from the cpu on demand."
msgstr ""

#: ../../../gpu/i915:601: drivers/gpu/drm/i915/i915_perf.c:125
msgid ""
"Related to being report based; the OA counters are configured in HW as a set "
"while perf generally expects counter configurations to be orthogonal. "
"Although counters can be associated with a group leader as they are opened, "
"there's no clear precedent for being able to provide group-wide "
"configuration attributes (for example we want to let userspace choose the OA "
"unit report format used to capture all counters in a set, or specify a GPU "
"context to filter metrics on). We avoided using perf's grouping feature and "
"forwarded OA reports to userspace via perf's 'raw' sample field. This suited "
"our userspace well considering how coupled the counters are when dealing "
"with normalizing. It would be inconvenient to split counters up into "
"separate events, only to require userspace to recombine them. For Mesa it's "
"also convenient to be forwarded raw, periodic reports for combining with the "
"side-band raw reports it captures using MI_REPORT_PERF_COUNT commands."
msgstr ""

#: ../../../gpu/i915:601: drivers/gpu/drm/i915/i915_perf.c:140
msgid ""
"As a side note on perf's grouping feature; there was also some concern that "
"using PERF_FORMAT_GROUP as a way to pack together counter values would quite "
"drastically inflate our sample sizes, which would likely lower the effective "
"sampling resolutions we could use when the available memory bandwidth is "
"limited."
msgstr ""

#: ../../../gpu/i915:601: drivers/gpu/drm/i915/i915_perf.c:146
msgid ""
"With the OA unit's report formats, counters are packed together as 32 or "
"40bit values, with the largest report size being 256 bytes."
msgstr ""

#: ../../../gpu/i915:601: drivers/gpu/drm/i915/i915_perf.c:149
msgid ""
"PERF_FORMAT_GROUP values are 64bit, but there doesn't appear to be a "
"documented ordering to the values, implying PERF_FORMAT_ID must also be used "
"to add a 64bit ID before each value; giving 16 bytes per counter."
msgstr ""

#: ../../../gpu/i915:601: drivers/gpu/drm/i915/i915_perf.c:153
msgid ""
"Related to counter orthogonality; we can't time share the OA unit, while "
"event scheduling is a central design idea within perf for allowing userspace "
"to open + enable more events than can be configured in HW at any one time.  "
"The OA unit is not designed to allow re-configuration while in use. We can't "
"reconfigure the OA unit without losing internal OA unit state which we can't "
"access explicitly to save and restore. Reconfiguring the OA unit is also "
"relatively slow, involving ~100 register writes. From userspace Mesa also "
"depends on a stable OA configuration when emitting MI_REPORT_PERF_COUNT "
"commands and importantly the OA unit can't be disabled while there are "
"outstanding MI_RPC commands lest we hang the command streamer."
msgstr ""

#: ../../../gpu/i915:601: drivers/gpu/drm/i915/i915_perf.c:165
msgid ""
"The contents of sample records aren't extensible by device drivers (i.e. the "
"sample_type bits). As an example; Sourab Gupta had been looking to attach "
"GPU timestamps to our OA samples. We were shoehorning OA reports into sample "
"records by using the 'raw' field, but it's tricky to pack more than one "
"thing into this field because events/core.c currently only lets a pmu give a "
"single raw data pointer plus len which will be copied into the ring buffer. "
"To include more than the OA report we'd have to copy the report into an "
"intermediate larger buffer. I'd been considering allowing a vector of "
"data+len values to be specified for copying the raw data, but it felt like a "
"kludge to being using the raw field for this purpose."
msgstr ""

#: ../../../gpu/i915:601: drivers/gpu/drm/i915/i915_perf.c:176
msgid ""
"It felt like our perf based PMU was making some technical compromises just "
"for the sake of using perf:"
msgstr ""

#: ../../../gpu/i915:601: drivers/gpu/drm/i915/i915_perf.c:179
msgid ""
"perf_event_open() requires events to either relate to a pid or a specific "
"cpu core, while our device pmu related to neither.  Events opened with a pid "
"will be automatically enabled/disabled according to the scheduling of that "
"process - so not appropriate for us. When an event is related to a cpu id, "
"perf ensures pmu methods will be invoked via an inter process interrupt on "
"that core. To avoid invasive changes our userspace opened OA perf events for "
"a specific cpu. This was workable but it meant the majority of the OA driver "
"ran in atomic context, including all OA report forwarding, which wasn't "
"really necessary in our case and seems to make our locking requirements "
"somewhat complex as we handled the interaction with the rest of the i915 "
"driver."
msgstr ""

#: ../../../gpu/i915.rst:605
msgid "i915 Driver Entry Points"
msgstr ""

#: ../../../gpu/i915.rst:607
msgid ""
"This section covers the entrypoints exported outside of i915_perf.c to "
"integrate with drm/i915 and to handle the `DRM_I915_PERF_OPEN` ioctl."
msgstr ""

#: ../../../gpu/i915:610: drivers/gpu/drm/i915/i915_perf.c:5049
msgid "initialize i915-perf state on module bind"
msgstr ""

#: ../../../gpu/i915:610: drivers/gpu/drm/i915/i915_perf.c:5051
msgid "Initializes i915-perf state without exposing anything to userspace."
msgstr ""

#: ../../../gpu/i915:610: drivers/gpu/drm/i915/i915_perf.c:5053
#: ../../../gpu/i915:640: drivers/gpu/drm/i915/i915_perf.c:3779
#: ../../../gpu/i915:642: drivers/gpu/drm/i915/i915_perf.c:3703
#: ../../../gpu/i915:650: drivers/gpu/drm/i915/i915_perf.c:3592
#: ../../../gpu/i915:652: drivers/gpu/drm/i915/i915_perf.c:3540
#: ../../../gpu/i915:671: drivers/gpu/drm/i915/i915_perf.c:1227
#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:535
#: drivers/gpu/drm/i915/i915_perf.c:719 drivers/gpu/drm/i915/i915_perf.c:1029
msgid "**Note**"
msgstr ""

#: ../../../gpu/i915:610: drivers/gpu/drm/i915/i915_perf.c:5054
msgid ""
"i915-perf initialization is split into an 'init' and 'register' phase with "
"the i915_perf_register() exposing state to userspace."
msgstr ""

#: ../../../gpu/i915:612: drivers/gpu/drm/i915/i915_perf.c:5203
msgid "Counter part to i915_perf_init()"
msgstr ""

#: ../../../gpu/i915:614: drivers/gpu/drm/i915/i915_perf.c:4255
msgid "exposes i915-perf to userspace"
msgstr ""

#: ../../../gpu/i915:614: drivers/gpu/drm/i915/i915_perf.c:4257
msgid ""
"In particular OA metric sets are advertised under a sysfs metrics/ directory "
"allowing userspace to enumerate valid IDs that can be used to open an i915-"
"perf stream."
msgstr ""

#: ../../../gpu/i915:616: drivers/gpu/drm/i915/i915_perf.c:4284
msgid "hide i915-perf from userspace"
msgstr ""

#: ../../../gpu/i915:616: drivers/gpu/drm/i915/i915_perf.c:4286
msgid ""
"i915-perf state cleanup is split up into an 'unregister' and 'deinit' phase "
"where the interface is first hidden from userspace by i915_perf_unregister() "
"before cleaning up remaining state in i915_perf_fini()."
msgstr ""

#: ../../../gpu/i915:618: drivers/gpu/drm/i915/i915_perf.c:4193
#: ../../../gpu/i915:640: drivers/gpu/drm/i915/i915_perf.c:3768
msgid "DRM ioctl() for userspace to open a stream FD"
msgstr ""

#: ../../../gpu/i915:618: drivers/gpu/drm/i915/i915_perf.c:4194
#: ../../../gpu/i915:622: drivers/gpu/drm/i915/i915_perf.c:4585
#: ../../../gpu/i915:624: drivers/gpu/drm/i915/i915_perf.c:4751
msgid "drm device"
msgstr ""

#: ../../../gpu/i915:618: drivers/gpu/drm/i915/i915_perf.c:4195
msgid "ioctl data copied from userspace (unvalidated)"
msgstr ""

#: ../../../gpu/i915:618: drivers/gpu/drm/i915/i915_perf.c:4196
#: ../../../gpu/i915:622: drivers/gpu/drm/i915/i915_perf.c:4588
#: ../../../gpu/i915:624: drivers/gpu/drm/i915/i915_perf.c:4753
#: ../../../gpu/i915:640: drivers/gpu/drm/i915/i915_perf.c:3772
msgid "drm file"
msgstr ""

#: ../../../gpu/i915:618: drivers/gpu/drm/i915/i915_perf.c:4197
msgid ""
"Validates the stream open parameters given by userspace including flags and "
"an array of u64 key, value pair properties."
msgstr ""

#: ../../../gpu/i915:618: drivers/gpu/drm/i915/i915_perf.c:4200
msgid ""
"Very little is assumed up front about the nature of the stream being opened "
"(for instance we don't assume it's for periodic OA unit metrics). An i915-"
"perf stream is expected to be a suitable interface for other forms of "
"buffered data written by the GPU besides periodic OA metrics."
msgstr ""

#: ../../../gpu/i915:618: drivers/gpu/drm/i915/i915_perf.c:4205
msgid ""
"Note we copy the properties from userspace outside of the i915 perf mutex to "
"avoid an awkward lockdep with mmap_lock."
msgstr ""

#: ../../../gpu/i915:618: drivers/gpu/drm/i915/i915_perf.c:4208
msgid ""
"Most of the implementation details are handled by "
"i915_perf_open_ioctl_locked() after taking the :c:type:`gt->perf <gt>`.lock "
"mutex for serializing with any non-file-operation driver hooks."
msgstr ""

#: ../../../gpu/i915:618: drivers/gpu/drm/i915/i915_perf.c:4213
msgid ""
"A newly opened i915 Perf stream file descriptor or negative error code on "
"failure."
msgstr ""

#: ../../../gpu/i915:620: drivers/gpu/drm/i915/i915_perf.c:3722
msgid "handles userspace close() of a stream file"
msgstr ""

#: ../../../gpu/i915:620: drivers/gpu/drm/i915/i915_perf.c:3728
msgid "``struct inode *inode``"
msgstr ""

#: ../../../gpu/i915:620: drivers/gpu/drm/i915/i915_perf.c:3723
msgid "anonymous inode associated with file"
msgstr ""

#: ../../../gpu/i915:620: drivers/gpu/drm/i915/i915_perf.c:3725
#: ../../../gpu/i915:644: drivers/gpu/drm/i915/i915_perf.c:3416
#: ../../../gpu/i915:646: drivers/gpu/drm/i915/i915_perf.c:3679
#: ../../../gpu/i915:652: drivers/gpu/drm/i915/i915_perf.c:3539
#: ../../../gpu/i915:654: drivers/gpu/drm/i915/i915_perf.c:3504
#: ../../../gpu/i915:673: drivers/gpu/drm/i915/i915_perf.c:1248
msgid "``struct file *file``"
msgstr ""

#: ../../../gpu/i915:620: drivers/gpu/drm/i915/i915_perf.c:3724
#: ../../../gpu/i915:644: drivers/gpu/drm/i915/i915_perf.c:3411
#: ../../../gpu/i915:646: drivers/gpu/drm/i915/i915_perf.c:3674
#: ../../../gpu/i915:652: drivers/gpu/drm/i915/i915_perf.c:3534
#: ../../../gpu/i915:654: drivers/gpu/drm/i915/i915_perf.c:3503
#: ../../../gpu/i915:673: drivers/gpu/drm/i915/i915_perf.c:1247
msgid "An i915 perf stream file"
msgstr ""

#: ../../../gpu/i915:620: drivers/gpu/drm/i915/i915_perf.c:3725
msgid "Cleans up any resources associated with an open i915 perf stream file."
msgstr ""

#: ../../../gpu/i915:620: drivers/gpu/drm/i915/i915_perf.c:3727
msgid "NB: close() can't really fail from the userspace point of view."
msgstr ""

#: ../../../gpu/i915:620: drivers/gpu/drm/i915/i915_perf.c:3730
#: ../../../gpu/i915:640: drivers/gpu/drm/i915/i915_perf.c:3789
#: ../../../gpu/i915:663: drivers/gpu/drm/i915/i915_perf.c:3229
msgid "zero on success or a negative error code."
msgstr ""

#: ../../../gpu/i915:622: drivers/gpu/drm/i915/i915_perf.c:4584
msgid "DRM ioctl() for userspace to add a new OA config"
msgstr ""

#: ../../../gpu/i915:622: drivers/gpu/drm/i915/i915_perf.c:4586
msgid ""
"ioctl data (pointer to struct drm_i915_perf_oa_config) copied from userspace "
"(unvalidated)"
msgstr ""

#: ../../../gpu/i915:622: drivers/gpu/drm/i915/i915_perf.c:4589
msgid ""
"Validates the submitted OA register to be saved into a new OA config that "
"can then be used for programming the OA unit and its NOA network."
msgstr ""

#: ../../../gpu/i915:622: drivers/gpu/drm/i915/i915_perf.c:4593
msgid ""
"A new allocated config number to be used with the perf open ioctl or a "
"negative error code on failure."
msgstr ""

#: ../../../gpu/i915:624: drivers/gpu/drm/i915/i915_perf.c:4750
msgid "DRM ioctl() for userspace to remove an OA config"
msgstr ""

#: ../../../gpu/i915:624: drivers/gpu/drm/i915/i915_perf.c:4752
msgid "ioctl data (pointer to u64 integer) copied from userspace"
msgstr ""

#: ../../../gpu/i915:624: drivers/gpu/drm/i915/i915_perf.c:4754
msgid ""
"Configs can be removed while being used, the will stop appearing in sysfs "
"and their content will be freed when the stream using the config is closed."
msgstr ""

#: ../../../gpu/i915:624: drivers/gpu/drm/i915/i915_perf.c:4758
msgid "0 on success or a negative error code on failure."
msgstr ""

#: ../../../gpu/i915.rst:628
msgid "i915 Perf Stream"
msgstr ""

#: ../../../gpu/i915.rst:630
msgid ""
"This section covers the stream-semantics-agnostic structures and functions "
"for representing an i915 perf stream FD and associated file operations."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:165
msgid "state for a single open stream FD"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:169
msgid "``perf``"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:170
msgid "i915_perf backpointer"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:174
msgid "``uncore``"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:175
msgid "mmio access path"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:180
msgid "Engine associated with this performance stream."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:185
msgid "Lock associated with operations on stream"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:189
#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:344
msgid "``sample_flags``"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:190
msgid ""
"Flags representing the `DRM_I915_PERF_PROP_SAMPLE_*` properties given when "
"opening a stream, representing the contents of a single sample as read() by "
"userspace."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:196
msgid "``sample_size``"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:197
msgid ""
"Considering the configured contents of a sample combined with the required "
"header size, this is the total size of a single sample record."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:204
msgid ""
"``NULL`` if measuring system-wide across all contexts or a specific context "
"that is being monitored."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:209
msgid "``enabled``"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:210
msgid ""
"Whether the stream is currently enabled, considering whether the stream was "
"opened in a disabled state and based on `I915_PERF_IOCTL_ENABLE` and "
"`I915_PERF_IOCTL_DISABLE` calls."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:216
#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:346
msgid "``hold_preemption``"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:217
msgid ""
"Whether preemption is put on hold for command submissions done on the "
"**ctx**. This is useful for some drivers that cannot easily post process the "
"OA buffer context to subtract delta of performance counters not associated "
"with **ctx**."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:224
msgid "``ops``"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:225
msgid ""
"The callbacks providing the implementation of this specific type of "
"configured stream."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:230
msgid "``oa_config``"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:231
msgid "The OA configuration used by the stream."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:235
msgid "``oa_config_bos``"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:236
msgid ""
"A list of struct i915_oa_config_bo allocated lazily each time **oa_config** "
"changes."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:241
msgid "``pinned_ctx``"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:242
msgid "The OA context specific information."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:246
msgid "``specific_ctx_id``"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:247
msgid "The id of the specific context."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:251
msgid "``specific_ctx_id_mask``"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:252
msgid "The mask used to masking specific_ctx_id bits."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:256
msgid "``poll_check_timer``"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:257
msgid ""
"High resolution timer that will periodically check for data in the circular "
"OA buffer for notifying userspace (e.g. during a read() or poll())."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:263
msgid "``poll_wq``"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:264
msgid ""
"The wait queue that hrtimer callback wakes when it sees data ready to read "
"in the circular OA buffer."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:269
msgid "``pollin``"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:270
msgid "Whether there is data available to read."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:274
msgid "``periodic``"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:275
msgid "Whether periodic sampling is currently enabled."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:279
msgid "``period_exponent``"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:280
msgid "The OA unit sampling frequency is derived from this."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:284
msgid "``oa_buffer``"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:285
msgid "State of the OA buffer."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:293
msgid "``oa_buffer.ptr_lock``"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:294
msgid "Locks reads and writes to all head/tail state"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:297
msgid ""
"Consider: the head and tail pointer state needs to be read consistently from "
"a hrtimer callback (atomic context) and read() fop (user context) with tail "
"pointer updates happening in atomic context and head updates in user context "
"and the (unlikely) possibility of read() errors needing to reset all head/"
"tail state."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:304
msgid ""
"Note: Contention/performance aren't currently a significant concern here "
"considering the relatively low frequency of hrtimer callbacks (5ms period) "
"and that reads typically only happen in response to a hrtimer event and "
"likely complete before the next callback."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:310
msgid ""
"Note: This lock is not held *while* reading and copying data to userspace so "
"the value of head observed in htrimer callbacks won't represent any partial "
"consumption of data."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:316
msgid "``oa_buffer.head``"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:317
msgid ""
"Although we can always read back the head pointer register, we prefer to "
"avoid trusting the HW state, just to avoid any risk that some hardware "
"condition could * somehow bump the head pointer unpredictably and cause us "
"to forward the wrong OA buffer data to userspace."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:326
msgid "``oa_buffer.tail``"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:327
msgid "The last verified tail that can be read by userspace."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:333
msgid "``noa_wait``"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:334
msgid ""
"A batch buffer doing a wait on the GPU for the NOA logic to be reprogrammed."
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:339
#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:358
msgid "``poll_oa_period``"
msgstr ""

#: ../../../gpu/i915:633: drivers/gpu/drm/i915/i915_perf_types.h:340
msgid ""
"The period in nanoseconds at which the OA buffer should be checked for "
"available data."
msgstr ""

#: ../../../gpu/i915:635: drivers/gpu/drm/i915/i915_perf_types.h:101
msgid "the OPs to support a specific stream type"
msgstr ""

#: ../../../gpu/i915:635: drivers/gpu/drm/i915/i915_perf_types.h:105
msgid "``enable``"
msgstr ""

#: ../../../gpu/i915:635: drivers/gpu/drm/i915/i915_perf_types.h:106
msgid ""
"Enables the collection of HW samples, either in response to "
"`I915_PERF_IOCTL_ENABLE` or implicitly called when stream is opened without "
"`I915_PERF_FLAG_DISABLED`."
msgstr ""

#: ../../../gpu/i915:635: drivers/gpu/drm/i915/i915_perf_types.h:112
msgid "``disable``"
msgstr ""

#: ../../../gpu/i915:635: drivers/gpu/drm/i915/i915_perf_types.h:113
msgid ""
"Disables the collection of HW samples, either in response to "
"`I915_PERF_IOCTL_DISABLE` or implicitly called before destroying the stream."
msgstr ""

#: ../../../gpu/i915:635: drivers/gpu/drm/i915/i915_perf_types.h:119
msgid "``poll_wait``"
msgstr ""

#: ../../../gpu/i915:635: drivers/gpu/drm/i915/i915_perf_types.h:120
msgid ""
"Call poll_wait, passing a wait queue that will be woken once there is "
"something ready to read() for the stream"
msgstr ""

#: ../../../gpu/i915:635: drivers/gpu/drm/i915/i915_perf_types.h:127
msgid "``wait_unlocked``"
msgstr ""

#: ../../../gpu/i915:635: drivers/gpu/drm/i915/i915_perf_types.h:128
msgid ""
"For handling a blocking read, wait until there is something to ready to "
"read() for the stream. E.g. wait on the same wait queue that would be passed "
"to poll_wait()."
msgstr ""

#: ../../../gpu/i915:635: drivers/gpu/drm/i915/i915_perf_types.h:134
#: ../../../gpu/i915:660: drivers/gpu/drm/i915/i915_perf_types.h:393
msgid "``read``"
msgstr ""

#: ../../../gpu/i915:635: drivers/gpu/drm/i915/i915_perf_types.h:135
msgid ""
"Copy buffered metrics as records to userspace **buf**: the userspace, "
"destination buffer **count**: the number of bytes to copy, requested by "
"userspace **offset**: zero at the start of the read, updated as the read "
"proceeds, it represents how many bytes have been copied so far and the "
"buffer offset for copying the next record."
msgstr ""

#: ../../../gpu/i915:635: drivers/gpu/drm/i915/i915_perf_types.h:142
msgid ""
"Copy as many buffered i915 perf samples and records for this stream to "
"userspace as will fit in the given buffer."
msgstr ""

#: ../../../gpu/i915:635: drivers/gpu/drm/i915/i915_perf_types.h:145
msgid ""
"Only write complete records; returning -``ENOSPC`` if there isn't room for a "
"complete record."
msgstr ""

#: ../../../gpu/i915:635: drivers/gpu/drm/i915/i915_perf_types.h:148
msgid ""
"Return any error condition that results in a short read such as -``ENOSPC`` "
"or -``EFAULT``, even though these may be squashed before returning to "
"userspace."
msgstr ""

#: ../../../gpu/i915:635: drivers/gpu/drm/i915/i915_perf_types.h:158
msgid "Cleanup any stream specific resources."
msgstr ""

#: ../../../gpu/i915:635: drivers/gpu/drm/i915/i915_perf_types.h:160
msgid "The stream will always be disabled before this is called."
msgstr ""

#: ../../../gpu/i915:638: drivers/gpu/drm/i915/i915_perf.c:3951
msgid "validate + copy userspace stream open properties"
msgstr ""

#: ../../../gpu/i915:638: drivers/gpu/drm/i915/i915_perf.c:3957
#: ../../../gpu/i915:640: drivers/gpu/drm/i915/i915_perf.c:3774
msgid "``struct i915_perf *perf``"
msgstr ""

#: ../../../gpu/i915:638: drivers/gpu/drm/i915/i915_perf.c:3952
#: ../../../gpu/i915:640: drivers/gpu/drm/i915/i915_perf.c:3769
msgid "i915 perf instance"
msgstr ""

#: ../../../gpu/i915:638: drivers/gpu/drm/i915/i915_perf.c:3954
msgid "``u64 __user *uprops``"
msgstr ""

#: ../../../gpu/i915:638: drivers/gpu/drm/i915/i915_perf.c:3953
msgid "The array of u64 key value pairs given by userspace"
msgstr ""

#: ../../../gpu/i915:638: drivers/gpu/drm/i915/i915_perf.c:3955
msgid "``u32 n_props``"
msgstr ""

#: ../../../gpu/i915:638: drivers/gpu/drm/i915/i915_perf.c:3954
msgid "The number of key value pairs expected in **uprops**"
msgstr ""

#: ../../../gpu/i915:638: drivers/gpu/drm/i915/i915_perf.c:3956
#: ../../../gpu/i915:640: drivers/gpu/drm/i915/i915_perf.c:3772
#: ../../../gpu/i915:663: drivers/gpu/drm/i915/i915_perf.c:3218
msgid "``struct perf_open_properties *props``"
msgstr ""

#: ../../../gpu/i915:638: drivers/gpu/drm/i915/i915_perf.c:3955
msgid "The stream configuration built up while validating properties"
msgstr ""

#: ../../../gpu/i915:638: drivers/gpu/drm/i915/i915_perf.c:3956
msgid ""
"Note this function only validates properties in isolation it doesn't "
"validate that the combination of properties makes sense or that all "
"properties necessary for a particular kind of stream have been set."
msgstr ""

#: ../../../gpu/i915:638: drivers/gpu/drm/i915/i915_perf.c:3960
msgid ""
"Note that there currently aren't any ordering requirements for properties so "
"we shouldn't validate or assume anything about ordering here. This doesn't "
"rule out defining new properties with ordering requirements in the future."
msgstr ""

#: ../../../gpu/i915:640: drivers/gpu/drm/i915/i915_perf.c:3771
#: ../../../gpu/i915:663: drivers/gpu/drm/i915/i915_perf.c:3217
msgid "``struct drm_i915_perf_open_param *param``"
msgstr ""

#: ../../../gpu/i915:640: drivers/gpu/drm/i915/i915_perf.c:3770
msgid "The open parameters passed to 'DRM_I915_PERF_OPEN`"
msgstr ""

#: ../../../gpu/i915:640: drivers/gpu/drm/i915/i915_perf.c:3771
msgid "individually validated u64 property value pairs"
msgstr ""

#: ../../../gpu/i915:640: drivers/gpu/drm/i915/i915_perf.c:3773
msgid "See i915_perf_ioctl_open() for interface details."
msgstr ""

#: ../../../gpu/i915:640: drivers/gpu/drm/i915/i915_perf.c:3775
msgid ""
"Implements further stream config validation and stream initialization on "
"behalf of i915_perf_open_ioctl() with the :c:type:`gt->perf <gt>`.lock mutex "
"taken to serialize with any non-file-operation driver hooks."
msgstr ""

#: ../../../gpu/i915:640: drivers/gpu/drm/i915/i915_perf.c:3780
msgid ""
"at this point the **props** have only been validated in isolation and it's "
"still necessary to validate that the combination of properties makes sense."
msgstr ""

#: ../../../gpu/i915:640: drivers/gpu/drm/i915/i915_perf.c:3784
msgid ""
"In the case where userspace is interested in OA unit metrics then further "
"config validation and stream initialization details will be handled by "
"i915_oa_stream_init(). The code here should only validate config state that "
"will be relevant to all stream types / backends."
msgstr ""

#: ../../../gpu/i915:642: drivers/gpu/drm/i915/i915_perf.c:3698
msgid "destroy an i915 perf stream"
msgstr ""

#: ../../../gpu/i915:642: drivers/gpu/drm/i915/i915_perf.c:3704
#: ../../../gpu/i915:648: drivers/gpu/drm/i915/i915_perf.c:3564
#: ../../../gpu/i915:650: drivers/gpu/drm/i915/i915_perf.c:3589
#: ../../../gpu/i915:654: drivers/gpu/drm/i915/i915_perf.c:3507
#: ../../../gpu/i915:663: drivers/gpu/drm/i915/i915_perf.c:3220
#: ../../../gpu/i915:665: drivers/gpu/drm/i915/i915_perf.c:1268
#: ../../../gpu/i915:667: drivers/gpu/drm/i915/i915_perf.c:3054
#: ../../../gpu/i915:669: drivers/gpu/drm/i915/i915_perf.c:3120
#: ../../../gpu/i915:671: drivers/gpu/drm/i915/i915_perf.c:1227
#: ../../../gpu/i915:673: drivers/gpu/drm/i915/i915_perf.c:1251
#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:526
#: drivers/gpu/drm/i915/i915_perf.c:619 drivers/gpu/drm/i915/i915_perf.c:653
#: drivers/gpu/drm/i915/i915_perf.c:713 drivers/gpu/drm/i915/i915_perf.c:933
#: drivers/gpu/drm/i915/i915_perf.c:1023 drivers/gpu/drm/i915/i915_perf.c:1142
#: drivers/gpu/drm/i915/i915_perf.c:1522 drivers/gpu/drm/i915/i915_perf.c:1615
#: drivers/gpu/drm/i915/i915_perf.c:3652
msgid "``struct i915_perf_stream *stream``"
msgstr ""

#: ../../../gpu/i915:642: drivers/gpu/drm/i915/i915_perf.c:3699
#: ../../../gpu/i915:654: drivers/gpu/drm/i915/i915_perf.c:3502
#: ../../../gpu/i915:663: drivers/gpu/drm/i915/i915_perf.c:3215
#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:3647
msgid "An i915 perf stream"
msgstr ""

#: ../../../gpu/i915:642: drivers/gpu/drm/i915/i915_perf.c:3700
msgid ""
"Frees all resources associated with the given i915 perf **stream**, "
"disabling any associated data capture in the process."
msgstr ""

#: ../../../gpu/i915:642: drivers/gpu/drm/i915/i915_perf.c:3704
msgid ""
"The :c:type:`gt->perf <gt>`.lock mutex has been taken to serialize with any "
"non-file-operation driver hooks."
msgstr ""

#: ../../../gpu/i915:644: drivers/gpu/drm/i915/i915_perf.c:3410
msgid "handles read() FOP for i915 perf stream FDs"
msgstr ""

#: ../../../gpu/i915:644: drivers/gpu/drm/i915/i915_perf.c:3413
#: ../../../gpu/i915:665: drivers/gpu/drm/i915/i915_perf.c:1265
#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:616
#: drivers/gpu/drm/i915/i915_perf.c:650 drivers/gpu/drm/i915/i915_perf.c:711
#: drivers/gpu/drm/i915/i915_perf.c:930 drivers/gpu/drm/i915/i915_perf.c:1021
#: drivers/gpu/drm/i915/i915_perf.c:1139
msgid "``char __user *buf``"
msgstr ""

#: ../../../gpu/i915:644: drivers/gpu/drm/i915/i915_perf.c:3412
#: ../../../gpu/i915:665: drivers/gpu/drm/i915/i915_perf.c:1264
#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:615
#: drivers/gpu/drm/i915/i915_perf.c:649 drivers/gpu/drm/i915/i915_perf.c:710
#: drivers/gpu/drm/i915/i915_perf.c:929 drivers/gpu/drm/i915/i915_perf.c:1020
#: drivers/gpu/drm/i915/i915_perf.c:1138
msgid "destination buffer given by userspace"
msgstr ""

#: ../../../gpu/i915:644: drivers/gpu/drm/i915/i915_perf.c:3414
#: ../../../gpu/i915:665: drivers/gpu/drm/i915/i915_perf.c:1266
#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:617
#: drivers/gpu/drm/i915/i915_perf.c:651 drivers/gpu/drm/i915/i915_perf.c:712
#: drivers/gpu/drm/i915/i915_perf.c:931 drivers/gpu/drm/i915/i915_perf.c:1022
#: drivers/gpu/drm/i915/i915_perf.c:1140
msgid "``size_t count``"
msgstr ""

#: ../../../gpu/i915:644: drivers/gpu/drm/i915/i915_perf.c:3413
#: ../../../gpu/i915:665: drivers/gpu/drm/i915/i915_perf.c:1265
#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:616
#: drivers/gpu/drm/i915/i915_perf.c:650 drivers/gpu/drm/i915/i915_perf.c:711
#: drivers/gpu/drm/i915/i915_perf.c:930 drivers/gpu/drm/i915/i915_perf.c:1021
#: drivers/gpu/drm/i915/i915_perf.c:1139
msgid "the number of bytes userspace wants to read"
msgstr ""

#: ../../../gpu/i915:644: drivers/gpu/drm/i915/i915_perf.c:3415
msgid "``loff_t *ppos``"
msgstr ""

#: ../../../gpu/i915:644: drivers/gpu/drm/i915/i915_perf.c:3414
msgid "(inout) file seek position (unused)"
msgstr ""

#: ../../../gpu/i915:644: drivers/gpu/drm/i915/i915_perf.c:3415
msgid ""
"The entry point for handling a read() on a stream file descriptor from "
"userspace. Most of the work is left to the i915_perf_read_locked() and :c:"
"type:`i915_perf_stream_ops->read <i915_perf_stream_ops>` but to save having "
"stream implementations (of which we might have multiple later) we handle "
"blocking read here."
msgstr ""

#: ../../../gpu/i915:644: drivers/gpu/drm/i915/i915_perf.c:3420
msgid ""
"We can also consistently treat trying to read from a disabled stream as an "
"IO error so implementations can assume the stream is enabled while reading."
msgstr ""

#: ../../../gpu/i915:644: drivers/gpu/drm/i915/i915_perf.c:3425
msgid "The number of bytes copied or a negative error code on failure."
msgstr ""

#: ../../../gpu/i915:646: drivers/gpu/drm/i915/i915_perf.c:3673
#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:3646
msgid "support ioctl() usage with i915 perf stream FDs"
msgstr ""

#: ../../../gpu/i915:646: drivers/gpu/drm/i915/i915_perf.c:3676
#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:3649
msgid "``unsigned int cmd``"
msgstr ""

#: ../../../gpu/i915:646: drivers/gpu/drm/i915/i915_perf.c:3675
#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:3648
msgid "the ioctl request"
msgstr ""

#: ../../../gpu/i915:646: drivers/gpu/drm/i915/i915_perf.c:3677
#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:3650
msgid "``unsigned long arg``"
msgstr ""

#: ../../../gpu/i915:646: drivers/gpu/drm/i915/i915_perf.c:3676
#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:3649
msgid "the ioctl data"
msgstr ""

#: ../../../gpu/i915:646: drivers/gpu/drm/i915/i915_perf.c:3677
msgid "Implementation deferred to i915_perf_ioctl_locked()."
msgstr ""

#: ../../../gpu/i915:646: drivers/gpu/drm/i915/i915_perf.c:3680
#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:3651
msgid ""
"zero on success or a negative error code. Returns -EINVAL for an unknown "
"ioctl request."
msgstr ""

#: ../../../gpu/i915:648: drivers/gpu/drm/i915/i915_perf.c:3558
msgid "handle `I915_PERF_IOCTL_ENABLE` ioctl"
msgstr ""

#: ../../../gpu/i915:648: drivers/gpu/drm/i915/i915_perf.c:3559
msgid "A disabled i915 perf stream"
msgstr ""

#: ../../../gpu/i915:648: drivers/gpu/drm/i915/i915_perf.c:3560
msgid "[Re]enables the associated capture of data for this stream."
msgstr ""

#: ../../../gpu/i915:648: drivers/gpu/drm/i915/i915_perf.c:3562
msgid ""
"If a stream was previously enabled then there's currently no intention to "
"provide userspace any guarantee about the preservation of previously "
"buffered data."
msgstr ""

#: ../../../gpu/i915:650: drivers/gpu/drm/i915/i915_perf.c:3583
msgid "handle `I915_PERF_IOCTL_DISABLE` ioctl"
msgstr ""

#: ../../../gpu/i915:650: drivers/gpu/drm/i915/i915_perf.c:3584
msgid "An enabled i915 perf stream"
msgstr ""

#: ../../../gpu/i915:650: drivers/gpu/drm/i915/i915_perf.c:3585
msgid "Disables the associated capture of data for this stream."
msgstr ""

#: ../../../gpu/i915:650: drivers/gpu/drm/i915/i915_perf.c:3587
msgid ""
"The intention is that disabling an re-enabling a stream will ideally be "
"cheaper than destroying and re-opening a stream with the same configuration, "
"though there are no formal guarantees about what state or buffered data must "
"be retained between disabling and re-enabling a stream."
msgstr ""

#: ../../../gpu/i915:650: drivers/gpu/drm/i915/i915_perf.c:3593
msgid ""
"while a stream is disabled it's considered an error for userspace to attempt "
"to read from the stream (-EIO)."
msgstr ""

#: ../../../gpu/i915:652: drivers/gpu/drm/i915/i915_perf.c:3533
msgid "call poll_wait() with a suitable wait queue for stream"
msgstr ""

#: ../../../gpu/i915:652: drivers/gpu/drm/i915/i915_perf.c:3536
#: ../../../gpu/i915:654: drivers/gpu/drm/i915/i915_perf.c:3505
#: ../../../gpu/i915:673: drivers/gpu/drm/i915/i915_perf.c:1249
msgid "``poll_table *wait``"
msgstr ""

#: ../../../gpu/i915:652: drivers/gpu/drm/i915/i915_perf.c:3535
#: ../../../gpu/i915:654: drivers/gpu/drm/i915/i915_perf.c:3504
#: ../../../gpu/i915:673: drivers/gpu/drm/i915/i915_perf.c:1248
msgid "poll() state table"
msgstr ""

#: ../../../gpu/i915:652: drivers/gpu/drm/i915/i915_perf.c:3536
msgid ""
"For handling userspace polling on an i915 perf stream, this ensures "
"poll_wait() gets called with a wait queue that will be woken for new stream "
"data."
msgstr ""

#: ../../../gpu/i915:652: drivers/gpu/drm/i915/i915_perf.c:3541
msgid "Implementation deferred to i915_perf_poll_locked()"
msgstr ""

#: ../../../gpu/i915:652: drivers/gpu/drm/i915/i915_perf.c:3543
#: ../../../gpu/i915:654: drivers/gpu/drm/i915/i915_perf.c:3510
msgid "any poll events that are ready without sleeping"
msgstr ""

#: ../../../gpu/i915:654: drivers/gpu/drm/i915/i915_perf.c:3501
msgid "poll_wait() with a suitable wait queue for stream"
msgstr ""

#: ../../../gpu/i915:654: drivers/gpu/drm/i915/i915_perf.c:3505
msgid ""
"For handling userspace polling on an i915 perf stream, this calls through "
"to :c:type:`i915_perf_stream_ops->poll_wait <i915_perf_stream_ops>` to call "
"poll_wait() with a wait queue that will be woken for new stream data."
msgstr ""

#: ../../../gpu/i915.rst:658
msgid "i915 Perf Observation Architecture Stream"
msgstr ""

#: ../../../gpu/i915:660: drivers/gpu/drm/i915/i915_perf_types.h:346
msgid "Gen specific implementation of an OA unit stream"
msgstr ""

#: ../../../gpu/i915:660: drivers/gpu/drm/i915/i915_perf_types.h:350
msgid "``is_valid_b_counter_reg``"
msgstr ""

#: ../../../gpu/i915:660: drivers/gpu/drm/i915/i915_perf_types.h:351
msgid ""
"Validates register's address for programming boolean counters for a "
"particular platform."
msgstr ""

#: ../../../gpu/i915:660: drivers/gpu/drm/i915/i915_perf_types.h:356
msgid "``is_valid_mux_reg``"
msgstr ""

#: ../../../gpu/i915:660: drivers/gpu/drm/i915/i915_perf_types.h:357
msgid ""
"Validates register's address for programming mux for a particular platform."
msgstr ""

#: ../../../gpu/i915:660: drivers/gpu/drm/i915/i915_perf_types.h:362
msgid "``is_valid_flex_reg``"
msgstr ""

#: ../../../gpu/i915:660: drivers/gpu/drm/i915/i915_perf_types.h:363
msgid ""
"Validates register's address for programming flex EU filtering for a "
"particular platform."
msgstr ""

#: ../../../gpu/i915:660: drivers/gpu/drm/i915/i915_perf_types.h:368
msgid "``enable_metric_set``"
msgstr ""

#: ../../../gpu/i915:660: drivers/gpu/drm/i915/i915_perf_types.h:369
msgid ""
"Selects and applies any MUX configuration to set up the Boolean and Custom "
"(B/C) counters that are part of the counter reports being sampled. May apply "
"system constraints such as disabling EU clock gating as required."
msgstr ""

#: ../../../gpu/i915:660: drivers/gpu/drm/i915/i915_perf_types.h:377
msgid "``disable_metric_set``"
msgstr ""

#: ../../../gpu/i915:660: drivers/gpu/drm/i915/i915_perf_types.h:378
msgid "Remove system constraints associated with using the OA unit."
msgstr ""

#: ../../../gpu/i915:660: drivers/gpu/drm/i915/i915_perf_types.h:383
msgid "``oa_enable``"
msgstr ""

#: ../../../gpu/i915:660: drivers/gpu/drm/i915/i915_perf_types.h:384
msgid "Enable periodic sampling"
msgstr ""

#: ../../../gpu/i915:660: drivers/gpu/drm/i915/i915_perf_types.h:388
msgid "``oa_disable``"
msgstr ""

#: ../../../gpu/i915:660: drivers/gpu/drm/i915/i915_perf_types.h:389
msgid "Disable periodic sampling"
msgstr ""

#: ../../../gpu/i915:660: drivers/gpu/drm/i915/i915_perf_types.h:394
msgid "Copy data from the circular OA buffer into a given userspace buffer."
msgstr ""

#: ../../../gpu/i915:660: drivers/gpu/drm/i915/i915_perf_types.h:402
msgid "``oa_hw_tail_read``"
msgstr ""

#: ../../../gpu/i915:660: drivers/gpu/drm/i915/i915_perf_types.h:403
msgid "read the OA tail pointer register"
msgstr ""

#: ../../../gpu/i915:660: drivers/gpu/drm/i915/i915_perf_types.h:405
msgid ""
"In particular this enables us to share all the fiddly code for handling the "
"OA unit tail pointer race that affects multiple generations."
msgstr ""

#: ../../../gpu/i915:663: drivers/gpu/drm/i915/i915_perf.c:3214
msgid "validate combined props for OA stream and init"
msgstr ""

#: ../../../gpu/i915:663: drivers/gpu/drm/i915/i915_perf.c:3216
msgid "The open parameters passed to `DRM_I915_PERF_OPEN`"
msgstr ""

#: ../../../gpu/i915:663: drivers/gpu/drm/i915/i915_perf.c:3217
msgid "The property state that configures stream (individually validated)"
msgstr ""

#: ../../../gpu/i915:663: drivers/gpu/drm/i915/i915_perf.c:3218
msgid ""
"While read_properties_unlocked() validates properties in isolation it "
"doesn't ensure that the combination necessarily makes sense."
msgstr ""

#: ../../../gpu/i915:663: drivers/gpu/drm/i915/i915_perf.c:3221
msgid ""
"At this point it has been determined that userspace wants a stream of OA "
"metrics, but still we need to further validate the combined properties are "
"OK."
msgstr ""

#: ../../../gpu/i915:663: drivers/gpu/drm/i915/i915_perf.c:3225
msgid ""
"If the configuration makes sense then we can allocate memory for a circular "
"OA buffer and apply the requested metric set configuration."
msgstr ""

#: ../../../gpu/i915:665: drivers/gpu/drm/i915/i915_perf.c:1262
msgid "just calls through to :c:type:`i915_oa_ops->read <i915_oa_ops>`"
msgstr ""

#: ../../../gpu/i915:665: drivers/gpu/drm/i915/i915_perf.c:1263
#: ../../../gpu/i915:671: drivers/gpu/drm/i915/i915_perf.c:1222
#: ../../../gpu/i915:673: drivers/gpu/drm/i915/i915_perf.c:1246
#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:614
#: drivers/gpu/drm/i915/i915_perf.c:648 drivers/gpu/drm/i915/i915_perf.c:709
#: drivers/gpu/drm/i915/i915_perf.c:928 drivers/gpu/drm/i915/i915_perf.c:1019
#: drivers/gpu/drm/i915/i915_perf.c:1137 drivers/gpu/drm/i915/i915_perf.c:1517
#: drivers/gpu/drm/i915/i915_perf.c:1610
msgid "An i915-perf stream opened for OA metrics"
msgstr ""

#: ../../../gpu/i915:665: drivers/gpu/drm/i915/i915_perf.c:1267
#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:618
#: drivers/gpu/drm/i915/i915_perf.c:652 drivers/gpu/drm/i915/i915_perf.c:713
#: drivers/gpu/drm/i915/i915_perf.c:932 drivers/gpu/drm/i915/i915_perf.c:1023
#: drivers/gpu/drm/i915/i915_perf.c:1141
msgid "``size_t *offset``"
msgstr ""

#: ../../../gpu/i915:665: drivers/gpu/drm/i915/i915_perf.c:1266
#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:617
#: drivers/gpu/drm/i915/i915_perf.c:651 drivers/gpu/drm/i915/i915_perf.c:712
#: drivers/gpu/drm/i915/i915_perf.c:931 drivers/gpu/drm/i915/i915_perf.c:1022
#: drivers/gpu/drm/i915/i915_perf.c:1140
msgid "(inout): the current position for writing into **buf**"
msgstr ""

#: ../../../gpu/i915:665: drivers/gpu/drm/i915/i915_perf.c:1267
#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:936
#: drivers/gpu/drm/i915/i915_perf.c:1145
msgid ""
"Updates **offset** according to the number of bytes successfully copied into "
"the userspace buffer."
msgstr ""

#: ../../../gpu/i915:665: drivers/gpu/drm/i915/i915_perf.c:1271
#: ../../../gpu/i915:671: drivers/gpu/drm/i915/i915_perf.c:1232
#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:944
#: drivers/gpu/drm/i915/i915_perf.c:1149 drivers/gpu/drm/i915/i915_perf.c:1523
msgid "zero on success or a negative error code"
msgstr ""

#: ../../../gpu/i915:667: drivers/gpu/drm/i915/i915_perf.c:3048
msgid "handle `I915_PERF_IOCTL_ENABLE` for OA stream"
msgstr ""

#: ../../../gpu/i915:667: drivers/gpu/drm/i915/i915_perf.c:3049
#: ../../../gpu/i915:669: drivers/gpu/drm/i915/i915_perf.c:3115
msgid "An i915 perf stream opened for OA metrics"
msgstr ""

#: ../../../gpu/i915:667: drivers/gpu/drm/i915/i915_perf.c:3050
msgid ""
"[Re]enables hardware periodic sampling according to the period configured "
"when opening the stream. This also starts a hrtimer that will periodically "
"check for data in the circular OA buffer for notifying userspace (e.g. "
"during a read() or poll())."
msgstr ""

#: ../../../gpu/i915:669: drivers/gpu/drm/i915/i915_perf.c:3114
msgid "handle `I915_PERF_IOCTL_DISABLE` for OA stream"
msgstr ""

#: ../../../gpu/i915:669: drivers/gpu/drm/i915/i915_perf.c:3116
msgid ""
"Stops the OA unit from periodically writing counter reports into the "
"circular OA buffer. This also stops the hrtimer that periodically checks for "
"data in the circular OA buffer, for notifying userspace."
msgstr ""

#: ../../../gpu/i915:671: drivers/gpu/drm/i915/i915_perf.c:1221
msgid "handles blocking IO until OA data available"
msgstr ""

#: ../../../gpu/i915:671: drivers/gpu/drm/i915/i915_perf.c:1223
msgid ""
"Called when userspace tries to read() from a blocking stream FD opened for "
"OA metrics. It waits until the hrtimer callback finds a non-empty OA buffer "
"and wakes us."
msgstr ""

#: ../../../gpu/i915:671: drivers/gpu/drm/i915/i915_perf.c:1228
msgid ""
"it's acceptable to have this return with some false positives since any "
"subsequent read handling will return -EAGAIN if there isn't really data "
"ready for userspace yet."
msgstr ""

#: ../../../gpu/i915:673: drivers/gpu/drm/i915/i915_perf.c:1245
msgid "call poll_wait() for an OA stream poll()"
msgstr ""

#: ../../../gpu/i915:673: drivers/gpu/drm/i915/i915_perf.c:1249
msgid ""
"For handling userspace polling on an i915 perf stream opened for OA metrics, "
"this starts a poll_wait with the wait queue that our hrtimer callback wakes "
"when it sees data ready to read in the circular OA buffer."
msgstr ""

#: ../../../gpu/i915.rst:677
msgid "Other i915 Perf Internals"
msgstr ""

#: ../../../gpu/i915.rst:679
msgid ""
"This section simply includes all other currently documented i915 perf "
"internals, in no particular order, but may include some more minor utilities "
"or platform specific details than found in the more high-level sections."
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:343
msgid "for validated properties given to open a stream"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:345
msgid "`DRM_I915_PERF_PROP_SAMPLE_*` properties are tracked as flags"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:345
msgid "``single_context``"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:346
msgid "Whether a single or all gpu contexts should be monitored"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:347
msgid "Whether the preemption is disabled for the filtered context"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:348
msgid "``ctx_handle``"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:349
msgid "A gem ctx handle for use with **single_context**"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:349
msgid "``metrics_set``"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:350
msgid "An ID for an OA unit metric set advertised via sysfs"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:350
msgid "``oa_format``"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:351
msgid "An OA unit HW report format"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:351
msgid "``oa_periodic``"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:352
msgid "Whether to enable periodic OA unit sampling"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:352
msgid "``oa_period_exponent``"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:353
msgid "The OA unit sampling period is derived from this"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:354
msgid "The engine (typically rcs0) being monitored by the OA unit"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:354
msgid "``has_sseu``"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:355
msgid "Whether **sseu** was specified by userspace"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:356
msgid ""
"internal SSEU configuration computed either from the userspace specified "
"configuration in the opening parameters or a default value (see "
"get_default_sseu_config())"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:359
msgid ""
"The period in nanoseconds at which the CPU will check for OA data "
"availability"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:360
msgid ""
"As read_properties_unlocked() enumerates and validates the properties given "
"to open a stream of metrics the configuration is built up in the structure "
"which starts out zero initialized."
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:520
msgid "check for data and update tail ptr state"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:521
msgid "i915 stream instance"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:522
msgid ""
"This is either called via fops (for blocking reads in user ctx) or the poll "
"check hrtimer (atomic ctx) to check the OA buffer tail pointer and check if "
"there is data available for userspace to read."
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:526
msgid ""
"This function is central to providing a workaround for the OA unit tail "
"pointer having a race with respect to what data is visible to the CPU. It is "
"responsible for reading tail pointers from the hardware and giving the "
"pointers time to 'age' before they are made available for reading. (See "
"description of OA_TAIL_MARGIN_NSEC above for further details.)"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:532
msgid ""
"Besides returning true when there is data available to read() this function "
"also updates the tail in the oa_buffer object."
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:536
msgid ""
"It's safe to read OA config state here unlocked, assuming that this is only "
"called while the stream is enabled, while the global OA configuration can't "
"be modified."
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:540
msgid "``true`` if the OA buffer contains data, else ``false``"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:613
msgid "Appends a status record to a userspace read() buffer."
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:619
msgid "``enum drm_i915_perf_record_type type``"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:618
msgid "The kind of status to report to userspace"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:619
msgid ""
"Writes a status record (such as `DRM_I915_PERF_RECORD_OA_REPORT_LOST`) into "
"the userspace read() buffer."
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:622
#: drivers/gpu/drm/i915/i915_perf.c:658
msgid "The **buf** **offset** will only be updated on success."
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:647
msgid "Copies single OA report into userspace read() buffer."
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:653
msgid "``const u8 *report``"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:652
msgid "A single OA report to (optionally) include as part of the sample"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:653
msgid ""
"The contents of a sample are configured through "
"`DRM_I915_PERF_PROP_SAMPLE_*` properties when opening a stream, tracked as "
"`stream->sample_flags`. This function copies the requested components of a "
"single sample to the given read() **buf**."
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:707
#: drivers/gpu/drm/i915/i915_perf.c:1017
msgid "Copies all buffered OA reports into userspace read() buffer."
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:713
#: drivers/gpu/drm/i915/i915_perf.c:1023
msgid ""
"Notably any error condition resulting in a short read (-``ENOSPC`` or -"
"``EFAULT``) will be returned even though one or more records may have been "
"successfully copied. In this case it's up to the caller to decide if the "
"error should be squashed before returning to userspace."
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:720
#: drivers/gpu/drm/i915/i915_perf.c:1030
msgid ""
"reports are consumed from the head, and appended to the tail, so the tail "
"chases the head?... If you think that's mad and back-to-front you're not "
"alone, but this follows the Gen PRM naming convention."
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:927
#: drivers/gpu/drm/i915/i915_perf.c:1136
msgid "copy status records then buffered OA reports"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:932
msgid ""
"Checks OA unit status registers and if necessary appends corresponding "
"status records for userspace (such as for a buffer full condition) and then "
"initiate appending any buffered OA reports."
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:939
msgid ""
"NB: some data may be successfully copied to the userspace buffer even if an "
"error is returned, and this is reflected in the updated **offset**."
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:1141
msgid ""
"Checks Gen 7 specific OA unit status registers and if necessary appends "
"corresponding status records for userspace (such as for a buffer full "
"condition) and then initiate appending any buffered OA reports."
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:1516
msgid "determine and hold ctx hw id"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:1518
msgid ""
"Determine the render context hw id, and ensure it remains fixed for the "
"lifetime of the stream. This ensures that we don't have to worry about "
"updating the context ID in OACONTROL on the fly."
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:1609
msgid "counterpart to oa_get_render_ctx_id releases hold"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:1611
msgid ""
"In case anything needed doing to ensure the context HW ID would remain valid "
"for the lifetime of the stream, then that can be undone here."
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:5226
msgid "Version of the i915-perf subsystem"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:5227
msgid "The i915 device"
msgstr ""

#: ../../../gpu/i915:683: drivers/gpu/drm/i915/i915_perf.c:5228
msgid "This version number is used by userspace to detect available features."
msgstr ""

#: ../../../gpu/i915.rst:708
msgid "Style"
msgstr ""

#: ../../../gpu/i915.rst:710
msgid ""
"The drm/i915 driver codebase has some style rules in addition to (and, in "
"some cases, deviating from) the kernel coding style."
msgstr ""

#: ../../../gpu/i915.rst:714
msgid "Register macro definition style"
msgstr ""

#: ../../../gpu/i915.rst:716
msgid "The style guide for ``i915_reg.h``."
msgstr ""

#: ../../../gpu/i915:718: drivers/gpu/drm/i915/i915_reg.h:32
msgid ""
"Follow the style described here for new macros, and while changing existing "
"macros. Do **not** mass change existing definitions just to update the style."
msgstr ""

#: ../../../gpu/i915:718: drivers/gpu/drm/i915/i915_reg.h:38
msgid "Keep helper macros near the top. For example, _PIPE() and friends."
msgstr ""

#: ../../../gpu/i915:718: drivers/gpu/drm/i915/i915_reg.h:40
msgid ""
"Prefix macros that generally should not be used outside of this file with "
"underscore '_'. For example, _PIPE() and friends, single instances of "
"registers that are defined solely for the use by function-like macros."
msgstr ""

#: ../../../gpu/i915:718: drivers/gpu/drm/i915/i915_reg.h:44
msgid ""
"Avoid using the underscore prefixed macros outside of this file. There are "
"exceptions, but keep them to a minimum."
msgstr ""

#: ../../../gpu/i915:718: drivers/gpu/drm/i915/i915_reg.h:47
msgid ""
"There are two basic types of register definitions: Single registers and "
"register groups. Register groups are registers which have two or more "
"instances, for example one per pipe, port, transcoder, etc. Register groups "
"should be defined using function-like macros."
msgstr ""

#: ../../../gpu/i915:718: drivers/gpu/drm/i915/i915_reg.h:52
msgid ""
"For single registers, define the register offset first, followed by register "
"contents."
msgstr ""

#: ../../../gpu/i915:718: drivers/gpu/drm/i915/i915_reg.h:55
msgid ""
"For register groups, define the register instance offsets first, prefixed "
"with underscore, followed by a function-like macro choosing the right "
"instance based on the parameter, followed by register contents."
msgstr ""

#: ../../../gpu/i915:718: drivers/gpu/drm/i915/i915_reg.h:59
msgid ""
"Define the register contents (i.e. bit and bit field macros) from most "
"significant to least significant bit. Indent the register content macros "
"using two extra spaces between ``#define`` and the macro name."
msgstr ""

#: ../../../gpu/i915:718: drivers/gpu/drm/i915/i915_reg.h:63
msgid ""
"Define bit fields using ``REG_GENMASK(h, l)``. Define bit field contents "
"using ``REG_FIELD_PREP(mask, value)``. This will define the values already "
"shifted in place, so they can be directly OR'd together. For convenience, "
"function-like macros may be used to define bit fields, but do note that the "
"macros may be needed to read as well as write the register contents."
msgstr ""

#: ../../../gpu/i915:718: drivers/gpu/drm/i915/i915_reg.h:69
msgid ""
"Define bits using ``REG_BIT(N)``. Do **not** add ``_BIT`` suffix to the name."
msgstr ""

#: ../../../gpu/i915:718: drivers/gpu/drm/i915/i915_reg.h:71
msgid ""
"Group the register and its contents together without blank lines, separate "
"from other registers and their contents with one blank line."
msgstr ""

#: ../../../gpu/i915:718: drivers/gpu/drm/i915/i915_reg.h:74
msgid ""
"Indent macro values from macro names using TABs. Align values vertically. "
"Use braces in macro values as needed to avoid unintended precedence after "
"macro substitution. Use spaces in macro values according to kernel coding "
"style. Use lower case in hexadecimal values."
msgstr ""

#: ../../../gpu/i915:718: drivers/gpu/drm/i915/i915_reg.h:82
msgid ""
"Try to name registers according to the specs. If the register name changes "
"in the specs from platform to another, stick to the original name."
msgstr ""

#: ../../../gpu/i915:718: drivers/gpu/drm/i915/i915_reg.h:85
msgid ""
"Try to reuse existing register macro definitions. Only add new macros for "
"new register offsets, or when the register contents have changed enough to "
"warrant a full redefinition."
msgstr ""

#: ../../../gpu/i915:718: drivers/gpu/drm/i915/i915_reg.h:89
msgid ""
"When a register macro changes for a new platform, prefix the new macro using "
"the platform acronym or generation. For example, ``SKL_`` or ``GEN8_``. The "
"prefix signifies the start platform/generation using the register."
msgstr ""

#: ../../../gpu/i915:718: drivers/gpu/drm/i915/i915_reg.h:93
msgid ""
"When a bit (field) macro changes or gets added for a new platform, while "
"retaining the existing register macro, add a platform acronym or generation "
"suffix to the name. For example, ``_SKL`` or ``_GEN8``."
msgstr ""

#: ../../../gpu/i915:718: drivers/gpu/drm/i915/i915_reg.h:100
msgid ""
"(Note that the values in the example are indented using spaces instead of "
"TABs to avoid misalignment in generated documentation. Use TABs in the "
"definitions.)::"
msgstr ""

#: ../../../gpu/i915.rst:724
msgid "i915 DRM client usage stats implementation"
msgstr ""

#: ../../../gpu/i915.rst:726
msgid ""
"The drm/i915 driver implements the DRM client usage stats specification as "
"documented in :ref:`drm-client-usage-stats`."
msgstr ""

#: ../../../gpu/i915.rst:729
msgid ""
"Example of the output showing the implemented key value pairs and entirety "
"of the currently possible format options:"
msgstr ""

#: ../../../gpu/i915.rst:746
msgid ""
"Possible `drm-engine-` key names are: `render`, `copy`, `video` and `video-"
"enhance`."
msgstr ""
