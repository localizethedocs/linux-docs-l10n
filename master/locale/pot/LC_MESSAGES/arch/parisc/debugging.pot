# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/parisc/debugging.rst:3
msgid "PA-RISC Debugging"
msgstr ""

#: ../../../arch/parisc/debugging.rst:5
msgid ""
"okay, here are some hints for debugging the lower-level parts of linux/"
"parisc."
msgstr ""

#: ../../../arch/parisc/debugging.rst:10
msgid "1. Absolute addresses"
msgstr ""

#: ../../../arch/parisc/debugging.rst:12
msgid ""
"A lot of the assembly code currently runs in real mode, which means absolute "
"addresses are used instead of virtual addresses as in the rest of the "
"kernel.  To translate an absolute address to a virtual address you can "
"lookup in System.map, add __PAGE_OFFSET (0x10000000 currently)."
msgstr ""

#: ../../../arch/parisc/debugging.rst:20
msgid "2. HPMCs"
msgstr ""

#: ../../../arch/parisc/debugging.rst:22
msgid ""
"When real-mode code tries to access non-existent memory, you'll get an HPMC "
"instead of a kernel oops.  To debug an HPMC, try to find the System "
"Responder/Requestor addresses.  The System Requestor address should match "
"(one of the) processor HPAs (high addresses in the I/O range); the System "
"Responder address is the address real-mode code tried to access."
msgstr ""

#: ../../../arch/parisc/debugging.rst:29
msgid ""
"Typical values for the System Responder address are addresses larger than "
"__PAGE_OFFSET (0x10000000) which mean a virtual address didn't get "
"translated to a physical address before real-mode code tried to access it."
msgstr ""

#: ../../../arch/parisc/debugging.rst:36
msgid "3. Q bit fun"
msgstr ""

#: ../../../arch/parisc/debugging.rst:38
msgid ""
"Certain, very critical code has to clear the Q bit in the PSW.  What happens "
"when the Q bit is cleared is the CPU does not update the registers "
"interruption handlers read to find out where the machine was interrupted - "
"so if you get an interruption between the instruction that clears the Q bit "
"and the RFI that sets it again you don't know where exactly it happened.  If "
"you're lucky the IAOQ will point to the instruction that cleared the Q bit, "
"if you're not it points anywhere at all.  Usually Q bit problems will show "
"themselves in unexplainable system hangs or running off the end of physical "
"memory."
msgstr ""
