# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../input/input.rst:5
msgid "Introduction"
msgstr ""

#: ../../../input/input.rst:0
msgid "Copyright"
msgstr ""

#: ../../../input/input.rst:7
msgid "|copy| 1999-2001 Vojtech Pavlik <vojtech@ucw.cz> - Sponsored by SuSE"
msgstr ""

#: ../../../input/input.rst:10
msgid "Architecture"
msgstr ""

#: ../../../input/input.rst:12
msgid ""
"Input subsystem is a collection of drivers that is designed to support all "
"input devices under Linux. Most of the drivers reside in drivers/input, "
"although quite a few live in drivers/hid and drivers/platform."
msgstr ""

#: ../../../input/input.rst:17
msgid ""
"The core of the input subsystem is the input module, which must be loaded "
"before any other of the input modules - it serves as a way of communication "
"between two groups of modules:"
msgstr ""

#: ../../../input/input.rst:22 ../../../input/input.rst:171
msgid "Device drivers"
msgstr ""

#: ../../../input/input.rst:24
msgid ""
"These modules talk to the hardware (for example via USB), and provide events "
"(keystrokes, mouse movements) to the input module."
msgstr ""

#: ../../../input/input.rst:28 ../../../input/input.rst:79
msgid "Event handlers"
msgstr ""

#: ../../../input/input.rst:30
msgid ""
"These modules get events from input core and pass them where needed via "
"various interfaces - keystrokes to the kernel, mouse movements via a "
"simulated PS/2 interface to GPM and X, and so on."
msgstr ""

#: ../../../input/input.rst:35
msgid "Simple Usage"
msgstr ""

#: ../../../input/input.rst:37
msgid ""
"For the most usual configuration, with one USB mouse and one USB keyboard, "
"you'll have to load the following modules (or have them built in to the "
"kernel)::"
msgstr ""

#: ../../../input/input.rst:48
msgid ""
"After this, the USB keyboard will work straight away, and the USB mouse will "
"be available as a character device on major 13, minor 63::"
msgstr ""

#: ../../../input/input.rst:53
msgid ""
"This device is usually created automatically by the system. The commands to "
"create it by hand are::"
msgstr ""

#: ../../../input/input.rst:60
msgid ""
"After that you have to point GPM (the textmode mouse cut&paste tool) and "
"XFree to this device to use it - GPM should be called like::"
msgstr ""

#: ../../../input/input.rst:65
msgid "And in X::"
msgstr ""

#: ../../../input/input.rst:73
msgid "When you do all of the above, you can use your USB mouse and keyboard."
msgstr ""

#: ../../../input/input.rst:76
msgid "Detailed Description"
msgstr ""

#: ../../../input/input.rst:81
msgid ""
"Event handlers distribute the events from the devices to userspace and in-"
"kernel consumers, as needed."
msgstr ""

#: ../../../input/input.rst:85
msgid "evdev"
msgstr ""

#: ../../../input/input.rst:87
msgid ""
"``evdev`` is the generic input event interface. It passes the events "
"generated in the kernel straight to the program, with timestamps. The event "
"codes are the same on all architectures and are hardware independent."
msgstr ""

#: ../../../input/input.rst:92
msgid ""
"This is the preferred interface for userspace to consume user input, and all "
"clients are encouraged to use it."
msgstr ""

#: ../../../input/input.rst:95
msgid "See :ref:`event-interface` for notes on API."
msgstr ""

#: ../../../input/input.rst:97
msgid "The devices are in /dev/input::"
msgstr ""

#: ../../../input/input.rst:105
msgid ""
"There are two ranges of minors: 64 through 95 is the static legacy range. If "
"there are more than 32 input devices in a system, additional evdev nodes are "
"created with minors starting with 256."
msgstr ""

#: ../../../input/input.rst:110
msgid "keyboard"
msgstr ""

#: ../../../input/input.rst:112
msgid ""
"``keyboard`` is in-kernel input handler and is a part of VT code. It "
"consumes keyboard keystrokes and handles user input for VT consoles."
msgstr ""

#: ../../../input/input.rst:116
msgid "mousedev"
msgstr ""

#: ../../../input/input.rst:118
msgid ""
"``mousedev`` is a hack to make legacy programs that use mouse input work. It "
"takes events from either mice or digitizers/tablets and makes a PS/2-style "
"(a la /dev/psaux) mouse device available to the userland."
msgstr ""

#: ../../../input/input.rst:123
msgid "Mousedev devices in /dev/input (as shown above) are::"
msgstr ""

#: ../../../input/input.rst:134
msgid ""
"Each ``mouse`` device is assigned to a single mouse or digitizer, except the "
"last one - ``mice``. This single character device is shared by all mice and "
"digitizers, and even if none are connected, the device is present.  This is "
"useful for hotplugging USB mice, so that older programs that do not handle "
"hotplug can open the device even when no mice are present."
msgstr ""

#: ../../../input/input.rst:141
msgid ""
"CONFIG_INPUT_MOUSEDEV_SCREEN_[XY] in the kernel configuration are the size "
"of your screen (in pixels) in XFree86. This is needed if you want to use "
"your digitizer in X, because its movement is sent to X via a virtual PS/2 "
"mouse and thus needs to be scaled accordingly. These values won't be used if "
"you use a mouse only."
msgstr ""

#: ../../../input/input.rst:147
msgid ""
"Mousedev will generate either PS/2, ImPS/2 (Microsoft IntelliMouse) or "
"ExplorerPS/2 (IntelliMouse Explorer) protocols, depending on what the "
"program reading the data wishes. You can set GPM and X to any of these. "
"You'll need ImPS/2 if you want to make use of a wheel on a USB mouse and "
"ExplorerPS/2 if you want to use extra (up to 5) buttons."
msgstr ""

#: ../../../input/input.rst:154
msgid "joydev"
msgstr ""

#: ../../../input/input.rst:156
msgid ""
"``joydev`` implements v0.x and v1.x Linux joystick API. See :ref:`joystick-"
"api` for details."
msgstr ""

#: ../../../input/input.rst:159
msgid ""
"As soon as any joystick is connected, it can be accessed in /dev/input on::"
msgstr ""

#: ../../../input/input.rst:167
msgid ""
"And so on up to js31 in legacy range, and additional nodes with minors above "
"256 if there are more joystick devices."
msgstr ""

#: ../../../input/input.rst:173
msgid "Device drivers are the modules that generate events."
msgstr ""

#: ../../../input/input.rst:176
msgid "hid-generic"
msgstr ""

#: ../../../input/input.rst:178
msgid ""
"``hid-generic`` is one of the largest and most complex driver of the whole "
"suite. It handles all HID devices, and because there is a very wide variety "
"of them, and because the USB HID specification isn't simple, it needs to be "
"this big."
msgstr ""

#: ../../../input/input.rst:183
msgid ""
"Currently, it handles USB mice, joysticks, gamepads, steering wheels, "
"keyboards, trackballs and digitizers."
msgstr ""

#: ../../../input/input.rst:186
msgid ""
"However, USB uses HID also for monitor controls, speaker controls, UPSs, "
"LCDs and many other purposes."
msgstr ""

#: ../../../input/input.rst:189
msgid ""
"The monitor and speaker controls should be easy to add to the hid/input "
"interface, but for the UPSs and LCDs it doesn't make much sense. For this, "
"the hiddev interface was designed. See Documentation/hid/hiddev.rst for more "
"information about it."
msgstr ""

#: ../../../input/input.rst:194
msgid ""
"The usage of the usbhid module is very simple, it takes no parameters, "
"detects everything automatically and when a HID device is inserted, it "
"detects it appropriately."
msgstr ""

#: ../../../input/input.rst:198
msgid ""
"However, because the devices vary wildly, you might happen to have a device "
"that doesn't work well. In that case #define DEBUG at the beginning of hid-"
"core.c and send me the syslog traces."
msgstr ""

#: ../../../input/input.rst:203
msgid "usbmouse"
msgstr ""

#: ../../../input/input.rst:205
msgid ""
"For embedded systems, for mice with broken HID descriptors and just any "
"other use when the big usbhid wouldn't be a good choice, there is the "
"usbmouse driver. It handles USB mice only. It uses a simpler HIDBP protocol. "
"This also means the mice must support this simpler protocol. Not all do. If "
"you don't have any strong reason to use this module, use usbhid instead."
msgstr ""

#: ../../../input/input.rst:213
msgid "usbkbd"
msgstr ""

#: ../../../input/input.rst:215
msgid ""
"Much like usbmouse, this module talks to keyboards with a simplified HIDBP "
"protocol. It's smaller, but doesn't support any extra special keys. Use "
"usbhid instead if there isn't any special reason to use this."
msgstr ""

#: ../../../input/input.rst:220
msgid "psmouse"
msgstr ""

#: ../../../input/input.rst:222
msgid ""
"This is driver for all flavors of pointing devices using PS/2 protocol, "
"including Synaptics and ALPS touchpads, Intellimouse Explorer devices, "
"Logitech PS/2 mice and so on."
msgstr ""

#: ../../../input/input.rst:227
msgid "atkbd"
msgstr ""

#: ../../../input/input.rst:229
msgid "This is driver for PS/2 (AT) keyboards."
msgstr ""

#: ../../../input/input.rst:232
msgid "iforce"
msgstr ""

#: ../../../input/input.rst:234
msgid ""
"A driver for I-Force joysticks and wheels, both over USB and RS232. It "
"includes Force Feedback support now, even though Immersion Corp. considers "
"the protocol a trade secret and won't disclose a word about it."
msgstr ""

#: ../../../input/input.rst:240
msgid "Verifying if it works"
msgstr ""

#: ../../../input/input.rst:242
msgid ""
"Typing a couple keys on the keyboard should be enough to check that a "
"keyboard works and is correctly connected to the kernel keyboard driver."
msgstr ""

#: ../../../input/input.rst:246
msgid ""
"Doing a ``cat /dev/input/mouse0`` (c, 13, 32) will verify that a mouse is "
"also emulated; characters should appear if you move it."
msgstr ""

#: ../../../input/input.rst:249
msgid ""
"You can test the joystick emulation with the ``jstest`` utility, available "
"in the joystick package (see :ref:`joystick-doc`)."
msgstr ""

#: ../../../input/input.rst:252
msgid "You can test the event devices with the ``evtest`` utility."
msgstr ""

#: ../../../input/input.rst:257
msgid "Event interface"
msgstr ""

#: ../../../input/input.rst:259
msgid ""
"You can use blocking and nonblocking reads, and also select() on the /dev/"
"input/eventX devices, and you'll always get a whole number of input events "
"on a read. Their layout is::"
msgstr ""

#: ../../../input/input.rst:270
msgid ""
"``time`` is the timestamp, it returns the time at which the event happened. "
"Type is for example EV_REL for relative movement, EV_KEY for a keypress or "
"release. More types are defined in include/uapi/linux/input-event-codes.h."
msgstr ""

#: ../../../input/input.rst:274
msgid ""
"``code`` is event code, for example REL_X or KEY_BACKSPACE, again a complete "
"list is in include/uapi/linux/input-event-codes.h."
msgstr ""

#: ../../../input/input.rst:277
msgid ""
"``value`` is the value the event carries. Either a relative change for "
"EV_REL, absolute new value for EV_ABS (joysticks ...), or 0 for EV_KEY for "
"release, 1 for keypress and 2 for autorepeat."
msgstr ""

#: ../../../input/input.rst:281
msgid ""
"See :ref:`input-event-codes` for more information about various even codes."
msgstr ""
