# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../locking/seqlock.rst:3
msgid "Sequence counters and sequential locks"
msgstr ""

#: ../../../locking/seqlock.rst:6
msgid "Introduction"
msgstr ""

#: ../../../locking/seqlock.rst:8
msgid ""
"Sequence counters are a reader-writer consistency mechanism with lockless "
"readers (read-only retry loops), and no writer starvation. They are used for "
"data that's rarely written to (e.g. system time), where the reader wants a "
"consistent set of information and is willing to retry if that information "
"changes."
msgstr ""

#: ../../../locking/seqlock.rst:14
msgid ""
"A data set is consistent when the sequence count at the beginning of the "
"read side critical section is even and the same sequence count value is read "
"again at the end of the critical section. The data in the set must be copied "
"out inside the read side critical section. If the sequence count has changed "
"between the start and the end of the critical section, the reader must retry."
msgstr ""

#: ../../../locking/seqlock.rst:21
msgid ""
"Writers increment the sequence count at the start and the end of their "
"critical section. After starting the critical section the sequence count is "
"odd and indicates to the readers that an update is in progress. At the end "
"of the write side critical section the sequence count becomes even again "
"which lets readers make progress."
msgstr ""

#: ../../../locking/seqlock.rst:27
msgid ""
"A sequence counter write side critical section must never be preempted or "
"interrupted by read side sections. Otherwise the reader will spin for the "
"entire scheduler tick due to the odd sequence count value and the "
"interrupted writer. If that reader belongs to a real-time scheduling class, "
"it can spin forever and the kernel will livelock."
msgstr ""

#: ../../../locking/seqlock.rst:33
msgid ""
"This mechanism cannot be used if the protected data contains pointers, as "
"the writer can invalidate a pointer that the reader is following."
msgstr ""

#: ../../../locking/seqlock.rst:40
msgid "Sequence counters (``seqcount_t``)"
msgstr ""

#: ../../../locking/seqlock.rst:42
msgid ""
"This is the raw counting mechanism, which does not protect against multiple "
"writers.  Write side critical sections must thus be serialized by an "
"external lock."
msgstr ""

#: ../../../locking/seqlock.rst:46
msgid ""
"If the write serialization primitive is not implicitly disabling preemption, "
"preemption must be explicitly disabled before entering the write side "
"section. If the read section can be invoked from hardirq or softirq "
"contexts, interrupts or bottom halves must also be respectively disabled "
"before entering the write section."
msgstr ""

#: ../../../locking/seqlock.rst:52
msgid ""
"If it's desired to automatically handle the sequence counter requirements of "
"writer serialization and non-preemptibility, use :ref:`seqlock_t` instead."
msgstr ""

#: ../../../locking/seqlock.rst:56 ../../../locking/seqlock.rst:171
msgid "Initialization::"
msgstr ""

#: ../../../locking/seqlock.rst:70 ../../../locking/seqlock.rst:185
msgid "Write path::"
msgstr ""

#: ../../../locking/seqlock.rst:80
msgid "Read path::"
msgstr ""

#: ../../../locking/seqlock.rst:93
msgid "Sequence counters with associated locks (``seqcount_LOCKNAME_t``)"
msgstr ""

#: ../../../locking/seqlock.rst:95
msgid ""
"As discussed at :ref:`seqcount_t`, sequence count write side critical "
"sections must be serialized and non-preemptible. This variant of sequence "
"counters associate the lock used for writer serialization at initialization "
"time, which enables lockdep to validate that the write side critical "
"sections are properly serialized."
msgstr ""

#: ../../../locking/seqlock.rst:101
msgid ""
"This lock association is a NOOP if lockdep is disabled and has neither "
"storage nor runtime overhead. If lockdep is enabled, the lock pointer is "
"stored in struct seqcount and lockdep's \"lock is held\" assertions are "
"injected at the beginning of the write side critical section to validate "
"that it is properly protected."
msgstr ""

#: ../../../locking/seqlock.rst:107
msgid ""
"For lock types which do not implicitly disable preemption, preemption "
"protection is enforced in the write side function."
msgstr ""

#: ../../../locking/seqlock.rst:110
msgid "The following sequence counters with associated locks are defined:"
msgstr ""

#: ../../../locking/seqlock.rst:112
msgid "``seqcount_spinlock_t``"
msgstr ""

#: ../../../locking/seqlock.rst:113
msgid "``seqcount_raw_spinlock_t``"
msgstr ""

#: ../../../locking/seqlock.rst:114
msgid "``seqcount_rwlock_t``"
msgstr ""

#: ../../../locking/seqlock.rst:115
msgid "``seqcount_mutex_t``"
msgstr ""

#: ../../../locking/seqlock.rst:116
msgid "``seqcount_ww_mutex_t``"
msgstr ""

#: ../../../locking/seqlock.rst:118
msgid ""
"The sequence counter read and write APIs can take either a plain seqcount_t "
"or any of the seqcount_LOCKNAME_t variants above."
msgstr ""

#: ../../../locking/seqlock.rst:121
msgid "Initialization (replace \"LOCKNAME\" with one of the supported locks)::"
msgstr ""

#: ../../../locking/seqlock.rst:136
msgid ""
"Write path: same as in :ref:`seqcount_t`, while running from a context with "
"the associated write serialization lock acquired."
msgstr ""

#: ../../../locking/seqlock.rst:139
msgid "Read path: same as in :ref:`seqcount_t`."
msgstr ""

#: ../../../locking/seqlock.rst:145
msgid "Latch sequence counters (``seqcount_latch_t``)"
msgstr ""

#: ../../../locking/seqlock.rst:147
msgid ""
"Latch sequence counters are a multiversion concurrency control mechanism "
"where the embedded seqcount_t counter even/odd value is used to switch "
"between two copies of protected data. This allows the sequence counter read "
"path to safely interrupt its own write side critical section."
msgstr ""

#: ../../../locking/seqlock.rst:152
msgid ""
"Use seqcount_latch_t when the write side sections cannot be protected from "
"interruption by readers. This is typically the case when the read side can "
"be invoked from NMI handlers."
msgstr ""

#: ../../../locking/seqlock.rst:156
msgid "Check `write_seqcount_latch()` for more information."
msgstr ""

#: ../../../locking/seqlock.rst:162
msgid "Sequential locks (``seqlock_t``)"
msgstr ""

#: ../../../locking/seqlock.rst:164
msgid ""
"This contains the :ref:`seqcount_t` mechanism earlier discussed, plus an "
"embedded spinlock for writer serialization and non-preemptibility."
msgstr ""

#: ../../../locking/seqlock.rst:167
msgid ""
"If the read side section can be invoked from hardirq or softirq context, use "
"the write side function variants which disable interrupts or bottom halves "
"respectively."
msgstr ""

#: ../../../locking/seqlock.rst:193
msgid "Read path, three categories:"
msgstr ""

#: ../../../locking/seqlock.rst:195
msgid ""
"Normal Sequence readers which never block a writer but they must retry if a "
"writer is in progress by detecting change in the sequence number.  Writers "
"do not wait for a sequence reader::"
msgstr ""

#: ../../../locking/seqlock.rst:206
msgid ""
"Locking readers which will wait if a writer or another locking reader is in "
"progress. A locking reader in progress will also block a writer from "
"entering its critical section. This read lock is exclusive. Unlike rwlock_t, "
"only one locking reader can acquire it::"
msgstr ""

#: ../../../locking/seqlock.rst:217
msgid ""
"Conditional lockless reader (as in 1), or locking reader (as in 2), "
"according to a passed marker. This is used to avoid lockless readers "
"starvation (too much retry loops) in case of a sharp spike in write "
"activity. First, a lockless read is tried (even marker passed). If that "
"trial fails (odd sequence counter is returned, which is used as the next "
"iteration marker), the lockless read is transformed to a full locking read "
"and no retry loop is necessary::"
msgstr ""

#: ../../../locking/seqlock.rst:237
msgid "API documentation"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:59
msgid "``seqcount_init (s)``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:57
msgid "runtime initializer for seqcount_t"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:61
#: include/linux/seqlock.h:88 include/linux/seqlock.h:270
#: include/linux/seqlock.h:287 include/linux/seqlock.h:295
#: include/linux/seqlock.h:307 include/linux/seqlock.h:326
#: include/linux/seqlock.h:349 include/linux/seqlock.h:375
#: include/linux/seqlock.h:399 include/linux/seqlock.h:419
#: include/linux/seqlock.h:440 include/linux/seqlock.h:461
#: include/linux/seqlock.h:486 include/linux/seqlock.h:511
#: include/linux/seqlock.h:532 include/linux/seqlock.h:585
#: include/linux/seqlock.h:618 include/linux/seqlock.h:626
#: include/linux/seqlock.h:632 include/linux/seqlock.h:652
#: include/linux/seqlock.h:669 include/linux/seqlock.h:683
#: include/linux/seqlock.h:697 include/linux/seqlock.h:708
#: include/linux/seqlock.h:789 include/linux/seqlock.h:798
#: include/linux/seqlock.h:816 include/linux/seqlock.h:826
#: include/linux/seqlock.h:833 include/linux/seqlock.h:844
#: include/linux/seqlock.h:866 include/linux/seqlock.h:885
#: include/linux/seqlock.h:898 include/linux/seqlock.h:911
#: include/linux/seqlock.h:925 include/linux/seqlock.h:938
#: include/linux/seqlock.h:960 include/linux/seqlock.h:973
#: include/linux/seqlock.h:989 include/linux/seqlock.h:1010
#: include/linux/seqlock.h:1019 include/linux/seqlock.h:1033
#: include/linux/seqlock.h:1043 include/linux/seqlock.h:1057
#: include/linux/seqlock.h:1075 include/linux/seqlock.h:1089
#: include/linux/seqlock.h:1101 include/linux/seqlock.h:1140
#: include/linux/seqlock.h:1152 include/linux/seqlock.h:1166
#: include/linux/seqlock.h:1199
msgid "**Parameters**"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:63
#: include/linux/seqlock.h:272 include/linux/seqlock.h:289
#: include/linux/seqlock.h:297 include/linux/seqlock.h:309
#: include/linux/seqlock.h:328 include/linux/seqlock.h:351
#: include/linux/seqlock.h:377 include/linux/seqlock.h:401
#: include/linux/seqlock.h:421 include/linux/seqlock.h:442
#: include/linux/seqlock.h:463 include/linux/seqlock.h:488
#: include/linux/seqlock.h:513 include/linux/seqlock.h:534
#: include/linux/seqlock.h:587 include/linux/seqlock.h:628
msgid "``s``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:58
msgid "Pointer to the seqcount_t instance"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:86
msgid "``SEQCNT_ZERO (name)``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:84
msgid "static initializer for seqcount_t"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:90
msgid "``name``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:85
msgid "Name of the seqcount_t instance"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:268
msgid "``__read_seqcount_begin (s)``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:266
msgid "begin a seqcount_t read section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:267
#: include/linux/seqlock.h:284 include/linux/seqlock.h:292
#: include/linux/seqlock.h:304 include/linux/seqlock.h:324
#: include/linux/seqlock.h:347 include/linux/seqlock.h:372
#: include/linux/seqlock.h:396 include/linux/seqlock.h:416
#: include/linux/seqlock.h:437 include/linux/seqlock.h:459
#: include/linux/seqlock.h:483 include/linux/seqlock.h:508
#: include/linux/seqlock.h:529 include/linux/seqlock.h:583
msgid "Pointer to seqcount_t or any of the seqcount_LOCKNAME_t variants"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:269
#: include/linux/seqlock.h:286 include/linux/seqlock.h:294
#: include/linux/seqlock.h:310 include/linux/seqlock.h:335
#: include/linux/seqlock.h:358 include/linux/seqlock.h:382
#: include/linux/seqlock.h:402 include/linux/seqlock.h:633
#: include/linux/seqlock.h:653 include/linux/seqlock.h:669
#: include/linux/seqlock.h:683 include/linux/seqlock.h:832
#: include/linux/seqlock.h:847 include/linux/seqlock.h:1119
#: include/linux/seqlock.h:1140
msgid "**Return**"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:269
#: include/linux/seqlock.h:286 include/linux/seqlock.h:294
#: include/linux/seqlock.h:311 include/linux/seqlock.h:325
#: include/linux/seqlock.h:359
msgid "count to be passed to read_seqcount_retry()"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:285
msgid "``raw_read_seqcount_begin (s)``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:283
msgid "begin a seqcount_t read section w/o lockdep"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:293
msgid "``read_seqcount_begin (s)``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:291
msgid "begin a seqcount_t read critical section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:305
msgid "``raw_read_seqcount (s)``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:303
msgid "read the raw seqcount_t counter value"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:306
#: include/linux/seqlock.h:327 include/linux/seqlock.h:349
#: include/linux/seqlock.h:375 include/linux/seqlock.h:399
#: include/linux/seqlock.h:462 include/linux/seqlock.h:531
#: include/linux/seqlock.h:585 include/linux/seqlock.h:631
#: include/linux/seqlock.h:651 include/linux/seqlock.h:707
#: include/linux/seqlock.h:797 include/linux/seqlock.h:844
#: include/linux/seqlock.h:865 include/linux/seqlock.h:884
#: include/linux/seqlock.h:897 include/linux/seqlock.h:910
#: include/linux/seqlock.h:924 include/linux/seqlock.h:937
#: include/linux/seqlock.h:962 include/linux/seqlock.h:974
#: include/linux/seqlock.h:988 include/linux/seqlock.h:1019
#: include/linux/seqlock.h:1043 include/linux/seqlock.h:1077
#: include/linux/seqlock.h:1106 include/linux/seqlock.h:1152
#: include/linux/seqlock.h:1167 include/linux/seqlock.h:1202
msgid "**Description**"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:305
msgid ""
"raw_read_seqcount opens a read critical section of the given seqcount_t, "
"without any lockdep checking, and without checking or masking the sequence "
"counter LSB. Calling code is responsible for handling that."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:324
msgid "``raw_seqcount_try_begin (s, start)``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:322
#: include/linux/seqlock.h:345
msgid ""
"begin a seqcount_t read critical section w/o lockdep and w/o counter "
"stabilization"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:326
#: include/linux/seqlock.h:374 include/linux/seqlock.h:398
msgid "``start``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:326
msgid ""
"Similar to raw_seqcount_begin(), except it enables eliding the critical "
"section entirely if odd, instead of doing the speculation knowing it will "
"fail."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:330
msgid ""
"Useful when counter stabilization is more or less equivalent to taking the "
"lock and there is a slowpath that does that."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:333
msgid "If true, start will be set to the (even) sequence count read."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:336
msgid "true when a read critical section is started."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:347
msgid "``raw_seqcount_begin (s)``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:348
msgid ""
"raw_seqcount_begin opens a read critical section of the given seqcount_t. "
"Unlike read_seqcount_begin(), this function will not wait for the count to "
"stabilize. If a writer is active when it begins, it will fail the "
"read_seqcount_retry() at the end of the read critical section instead of "
"stabilizing at the beginning of it."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:354
msgid ""
"Use this only in special kernel hot paths where the read section is small "
"and has a high probability of success through other external means. It will "
"save a single branching instruction."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:373
msgid "``__read_seqcount_retry (s, start)``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:371
msgid "end a seqcount_t read section w/o barrier"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:373
#: include/linux/seqlock.h:397
msgid "count, from read_seqcount_begin()"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:374
msgid ""
"__read_seqcount_retry is like read_seqcount_retry, but has no smp_rmb() "
"barrier. Callers should ensure that smp_rmb() or equivalent ordering is "
"provided before actually loading any of the variables that are to be "
"protected in this critical section."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:379
msgid ""
"Use carefully, only in critical code, and comment how the barrier is "
"provided."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:383
#: include/linux/seqlock.h:403 include/linux/seqlock.h:669
#: include/linux/seqlock.h:683 include/linux/seqlock.h:848
msgid "true if a read section retry is required, else false"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:397
msgid "``read_seqcount_retry (s, start)``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:395
msgid "end a seqcount_t read critical section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:398
msgid ""
"read_seqcount_retry closes the read critical section of given seqcount_t.  "
"If the critical section was invalid, it must be ignored (and typically "
"retried)."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:417
msgid "``raw_write_seqcount_begin (s)``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:415
msgid "start a seqcount_t write section w/o lockdep"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:418
#: include/linux/seqlock.h:439 include/linux/seqlock.h:463
#: include/linux/seqlock.h:485 include/linux/seqlock.h:510
#: include/linux/seqlock.h:869 include/linux/seqlock.h:996
#: include/linux/seqlock.h:1117
msgid "**Context**"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:418
#: include/linux/seqlock.h:463
msgid "check write_seqcount_begin()"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:438
msgid "``raw_write_seqcount_end (s)``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:436
msgid "end a seqcount_t write section w/o lockdep"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:439
msgid "check write_seqcount_end()"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:459
msgid "``write_seqcount_begin_nested (s, subclass)``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:457
msgid "start a seqcount_t write section with custom lockdep nesting level"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:461
msgid "``subclass``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:460
msgid "lockdep nesting level"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:461
msgid "See Documentation/locking/lockdep-design.rst"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:484
msgid "``write_seqcount_begin (s)``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:482
msgid "start a seqcount_t write side critical section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:485
msgid ""
"sequence counter write side sections must be serialized and non-preemptible. "
"Preemption will be automatically disabled if and only if the seqcount write "
"serialization lock is associated, and preemptible.  If readers can be "
"invoked from hardirq or softirq context, interrupts or bottom halves must be "
"respectively disabled."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:509
msgid "``write_seqcount_end (s)``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:507
msgid "end a seqcount_t write side critical section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:510
msgid ""
"Preemption will be automatically re-enabled if and only if the seqcount "
"write serialization lock is associated, and preemptible."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:530
msgid "``raw_write_seqcount_barrier (s)``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:528
msgid "do a seqcount_t write barrier"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:530
msgid ""
"This can be used to provide an ordering guarantee instead of the usual "
"consistency guarantee. It is one wmb cheaper, because it can collapse the "
"two back-to-back wmb()s."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:534
msgid ""
"Note that writes surrounding the barrier should be declared atomic (e.g. via "
"WRITE_ONCE): a) to ensure the writes become visible to other threads "
"atomically, avoiding compiler optimizations; b) to document which writes are "
"meant to propagate to the reader critical section. This is necessary because "
"neither writes before nor after the barrier are enclosed in a seq-writer "
"critical section that would ensure readers are aware of ongoing writes::"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:583
msgid "``write_seqcount_invalidate (s)``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:581
msgid "invalidate in-progress seqcount_t read side operations"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:584
msgid ""
"After write_seqcount_invalidate, no seqcount_t read side operations will "
"complete successfully and see data older than this."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:616
msgid "``SEQCNT_LATCH_ZERO (seq_name)``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:614
msgid "static initializer for seqcount_latch_t"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:620
msgid "``seq_name``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:615
msgid "Name of the seqcount_latch_t instance"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:624
msgid "``seqcount_latch_init (s)``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:622
msgid "runtime initializer for seqcount_latch_t"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:623
msgid "Pointer to the seqcount_latch_t instance"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:628
#: include/linux/seqlock.h:648
msgid "pick even/odd latch data copy"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:634
#: include/linux/seqlock.h:654 include/linux/seqlock.h:671
#: include/linux/seqlock.h:685
msgid "``const seqcount_latch_t *s``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:629
#: include/linux/seqlock.h:649 include/linux/seqlock.h:666
#: include/linux/seqlock.h:680 include/linux/seqlock.h:694
#: include/linux/seqlock.h:705 include/linux/seqlock.h:786
#: include/linux/seqlock.h:795
msgid "Pointer to seqcount_latch_t"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:630
msgid ""
"See raw_write_seqcount_latch() for details and a full reader/writer usage "
"example."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:634
msgid ""
"sequence counter raw value. Use the lowest bit as an index for picking which "
"data copy to read. The full counter must then be checked with "
"raw_read_seqcount_latch_retry()."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:650
msgid ""
"See write_seqcount_latch() for details and a full reader/writer usage "
"example."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:654
msgid ""
"sequence counter raw value. Use the lowest bit as an index for picking which "
"data copy to read. The full counter must then be checked with "
"read_seqcount_latch_retry()."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:665
#: include/linux/seqlock.h:679
msgid "end a seqcount_latch_t read section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:668
#: include/linux/seqlock.h:682 include/linux/seqlock.h:843
msgid "``unsigned start``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:667
msgid "count, from raw_read_seqcount_latch()"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:681
msgid "count, from read_seqcount_latch()"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:693
msgid "redirect latch readers to even/odd copy"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:699
#: include/linux/seqlock.h:710 include/linux/seqlock.h:791
#: include/linux/seqlock.h:800
msgid "``seqcount_latch_t *s``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:704
msgid "redirect latch readers to odd copy"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:706
msgid ""
"The latch technique is a multiversion concurrency control method that allows "
"queries during non-atomic modifications. If you can guarantee queries never "
"interrupt the modification -- e.g. the concurrency is strictly between CPUs "
"-- you most likely do not need this."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:711
msgid ""
"Where the traditional RCU/lockless data structures rely on atomic "
"modifications to ensure queries observe either the old or the new state the "
"latch allows the same for non-atomic updates. The trade-off is doubling the "
"cost of storage; we have to maintain two copies of the entire data structure."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:717
msgid ""
"Very simply put: we first modify one copy and then the other. This ensures "
"there is always one copy in a stable state, ready to give us an answer."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:720
msgid "The basic form is a data structure like::"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:727
msgid ""
"Where a modification, which is assumed to be externally serialized, does the "
"following::"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:739
msgid "The query will have a form like::"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:758
msgid ""
"So during the modification, queries are first redirected to data[1]. Then we "
"modify data[0]. When that is complete, we redirect queries back to data[0] "
"and we can modify data[1]."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:762
msgid "**NOTE**"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:763
msgid ""
"The non-requirement for atomic modifications does _NOT_ include the "
"publishing of new entries in the case where data is a dynamic data structure."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:767
msgid ""
"An iteration might start in data[0] and get suspended long enough to miss an "
"entire modification sequence, once it resumes it might observe the new entry."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:771
msgid "NOTE2:"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:773
msgid ""
"When data is a dynamic data structure; one should use regular RCU patterns "
"to manage the lifetimes of the objects within."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:785
msgid "redirect latch readers to even copy"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:794
msgid "end a seqcount_latch_t write section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:796
msgid ""
"Marks the end of a seqcount_latch_t writer section, after all copies of the "
"latch-protected data have been updated."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:814
msgid "``seqlock_init (sl)``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:812
msgid "dynamic initializer for seqlock_t"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:818
#: include/linux/seqlock.h:828
msgid "``sl``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:813
msgid "Pointer to the seqlock_t instance"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:824
msgid "``DEFINE_SEQLOCK (sl)``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:822
msgid "Define a statically allocated seqlock_t"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:823
msgid "Name of the seqlock_t instance"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:829
msgid "start a seqlock_t read side critical section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:835
#: include/linux/seqlock.h:846
msgid "``const seqlock_t *sl``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:830
#: include/linux/seqlock.h:841 include/linux/seqlock.h:863
#: include/linux/seqlock.h:882 include/linux/seqlock.h:895
#: include/linux/seqlock.h:908 include/linux/seqlock.h:922
#: include/linux/seqlock.h:935 include/linux/seqlock.h:958
#: include/linux/seqlock.h:971 include/linux/seqlock.h:986
#: include/linux/seqlock.h:1007 include/linux/seqlock.h:1017
#: include/linux/seqlock.h:1031 include/linux/seqlock.h:1041
#: include/linux/seqlock.h:1055 include/linux/seqlock.h:1073
#: include/linux/seqlock.h:1087 include/linux/seqlock.h:1098
#: include/linux/seqlock.h:1137 include/linux/seqlock.h:1149
#: include/linux/seqlock.h:1164 include/linux/seqlock.h:1197
msgid "Pointer to seqlock_t"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:832
msgid "count, to be passed to read_seqretry()"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:840
msgid "end a seqlock_t read side section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:842
msgid "count, from read_seqbegin()"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:843
msgid ""
"read_seqretry closes the read side critical section of given seqlock_t. If "
"the critical section was invalid, it must be ignored (and typically retried)."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:862
msgid "start a seqlock_t write side critical section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:868
#: include/linux/seqlock.h:887 include/linux/seqlock.h:900
#: include/linux/seqlock.h:913 include/linux/seqlock.h:927
#: include/linux/seqlock.h:940 include/linux/seqlock.h:975
#: include/linux/seqlock.h:991 include/linux/seqlock.h:1012
#: include/linux/seqlock.h:1021 include/linux/seqlock.h:1035
#: include/linux/seqlock.h:1045 include/linux/seqlock.h:1059
#: include/linux/seqlock.h:1091
msgid "``seqlock_t *sl``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:864
msgid ""
"write_seqlock opens a write side critical section for the given seqlock_t.  "
"It also implicitly acquires the spinlock_t embedded inside that sequential "
"lock. All seqlock_t write side sections are thus automatically serialized "
"and non-preemptible."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:870
msgid ""
"if the seqlock_t read section, or other write side critical sections, can be "
"invoked from hardirq or softirq contexts, use the _irqsave or _bh variants "
"of this function instead."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:881
msgid "end a seqlock_t write side critical section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:883
msgid ""
"write_sequnlock closes the (serialized and non-preemptible) write side "
"critical section of given seqlock_t."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:894
msgid "start a softirqs-disabled seqlock_t write section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:896
msgid ""
"_bh variant of write_seqlock(). Use only if the read side section, or other "
"write side sections, can be invoked from softirq contexts."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:907
msgid "end a softirqs-disabled seqlock_t write section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:909
msgid ""
"write_sequnlock_bh closes the serialized, non-preemptible, and softirqs-"
"disabled, seqlock_t write side critical section opened with "
"write_seqlock_bh()."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:921
#: include/linux/seqlock.h:956
msgid "start a non-interruptible seqlock_t write section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:923
msgid ""
"_irq variant of write_seqlock(). Use only if the read side section, or other "
"write sections, can be invoked from hardirq contexts."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:934
msgid "end a non-interruptible seqlock_t write section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:936
msgid ""
"write_sequnlock_irq closes the serialized and non-interruptible seqlock_t "
"write side section opened with write_seqlock_irq()."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:958
msgid "``write_seqlock_irqsave (lock, flags)``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:962
#: include/linux/seqlock.h:1077
msgid "``lock``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:960
#: include/linux/seqlock.h:1075
msgid "``flags``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:959
msgid ""
"Stack-allocated storage for saving caller's local interrupt state, to be "
"passed to write_sequnlock_irqrestore()."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:961
msgid ""
"_irqsave variant of write_seqlock(). Use it only if the read side section, "
"or other write sections, can be invoked from hardirq context."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:969
msgid "end non-interruptible seqlock_t write section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:973
#: include/linux/seqlock.h:1089 include/linux/seqlock.h:1200
msgid "``unsigned long flags``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:972
msgid "Caller's saved interrupt state, from write_seqlock_irqsave()"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:973
msgid ""
"write_sequnlock_irqrestore closes the serialized and non-interruptible "
"seqlock_t write section previously opened with write_seqlock_irqsave()."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:985
msgid "begin a seqlock_t locking reader section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:987
msgid ""
"read_seqlock_excl opens a seqlock_t locking reader critical section.  A "
"locking reader exclusively locks out *both* other writers *and* other "
"locking readers, but it does not update the embedded sequence number."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:991
msgid "Locking readers act like a normal spin_lock()/spin_unlock()."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:994
msgid "The opened read section must be closed with read_sequnlock_excl()."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:994
#: include/linux/seqlock.h:1115
msgid ""
"if the seqlock_t write section, *or other read sections*, can be invoked "
"from hardirq or softirq contexts, use the _irqsave or _bh variant of this "
"function instead."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1006
msgid "end a seqlock_t locking reader critical section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1015
msgid "start a seqlock_t locking reader section with softirqs disabled"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1018
msgid ""
"_bh variant of read_seqlock_excl(). Use this variant only if the seqlock_t "
"write side section, *or other read sections*, can be invoked from softirq "
"contexts."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1029
msgid "stop a seqlock_t softirq-disabled locking reader section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1039
#: include/linux/seqlock.h:1071
msgid "start a non-interruptible seqlock_t locking reader section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1042
msgid ""
"_irq variant of read_seqlock_excl(). Use this only if the seqlock_t write "
"side section, *or other read sections*, can be invoked from a hardirq "
"context."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1053
msgid "end an interrupts-disabled seqlock_t locking reader section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1073
msgid "``read_seqlock_excl_irqsave (lock, flags)``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1074
msgid ""
"Stack-allocated storage for saving caller's local interrupt state, to be "
"passed to read_sequnlock_excl_irqrestore()."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1076
msgid ""
"_irqsave variant of read_seqlock_excl(). Use this only if the seqlock_t "
"write side section, *or other read sections*, can be invoked from a hardirq "
"context."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1085
msgid "end non-interruptible seqlock_t locking reader section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1088
msgid "Caller saved interrupt state, from read_seqlock_excl_irqsave()"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1097
msgid "begin a seqlock_t lockless or locking reader"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1103
#: include/linux/seqlock.h:1142 include/linux/seqlock.h:1154
#: include/linux/seqlock.h:1168 include/linux/seqlock.h:1201
msgid "``seqlock_t *lock``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1100
#: include/linux/seqlock.h:1166
msgid "``int *seq``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1099
msgid ""
"Marker and return parameter. If the passed value is even, the reader will "
"become a *lockless* seqlock_t reader as in read_seqbegin(). If the passed "
"value is odd, the reader will become a *locking* reader as in "
"read_seqlock_excl().  In the first call to this function, the caller *must* "
"initialize and pass an even value to **seq**; this way, a lockless read can "
"be optimistically tried first."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1105
msgid ""
"read_seqbegin_or_lock is an API designed to optimistically try a normal "
"lockless seqlock_t read section first.  If an odd counter is found, the "
"lockless read trial has failed, and the next read iteration transforms "
"itself into a full seqlock_t locking reader."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1110
msgid ""
"This is typically used to avoid seqlock_t lockless readers starvation (too "
"much retry loops) in the case of a sharp spike in write side activity."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1115
msgid "Check Documentation/locking/seqlock.rst for template example code."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1121
msgid ""
"the encountered sequence counter value, through the **seq** parameter, which "
"is overloaded as a return parameter. This returned value must be checked "
"with need_seqretry(). If the read section need to be retried, this returned "
"value must also be passed as the **seq** parameter of the next "
"read_seqbegin_or_lock() iteration."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1136
msgid "validate seqlock_t \"locking or lockless\" read section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1139
#: include/linux/seqlock.h:1151 include/linux/seqlock.h:1199
msgid "``int seq``"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1138
msgid "sequence count, from read_seqbegin_or_lock()"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1140
msgid "true if a read section retry is required, false otherwise"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1148
msgid "end seqlock_t \"locking or lockless\" reader section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1150
msgid "count, from read_seqbegin_or_lock()"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1151
msgid ""
"done_seqretry finishes the seqlock_t read side critical section started with "
"read_seqbegin_or_lock() and validated by need_seqretry()."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1162
msgid ""
"begin a seqlock_t lockless reader, or a non-interruptible locking reader"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1165
msgid "Marker and return parameter. Check read_seqbegin_or_lock()."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1166
msgid ""
"This is the _irqsave variant of read_seqbegin_or_lock(). Use it only if the "
"seqlock_t write section, *or other read sections*, can be invoked from "
"hardirq context."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1171
msgid ""
"The saved local interrupts state in case of a locking reader, to be passed "
"to done_seqretry_irqrestore()."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1174
msgid ""
"The encountered sequence counter value, returned through **seq** overloaded "
"as a return parameter. Check read_seqbegin_or_lock()."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1177
msgid "**Note**"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1171
msgid "Interrupts will be disabled only for \"locking reader\" mode."
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1195
msgid ""
"end a seqlock_t lockless reader, or a non-interruptible locking reader "
"section"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1198
msgid "Count, from read_seqbegin_or_lock_irqsave()"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1199
msgid ""
"Caller's saved local interrupt state in case of a locking reader, also from "
"read_seqbegin_or_lock_irqsave()"
msgstr ""

#: ../../../locking/seqlock:239: include/linux/seqlock.h:1201
msgid ""
"This is the _irqrestore variant of done_seqretry(). The read section must've "
"been opened with read_seqbegin_or_lock_irqsave(), and validated by "
"need_seqretry()."
msgstr ""
