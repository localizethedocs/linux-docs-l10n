# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/driver-model/platform.rst:3
msgid "Platform Devices and Drivers"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:5
msgid ""
"See <linux/platform_device.h> for the driver model interface to the platform "
"bus:  platform_device, and platform_driver.  This pseudo-bus is used to "
"connect devices on busses with minimal infrastructure, like those used to "
"integrate peripherals on many system-on-chip processors, or some \"legacy\" "
"PC interconnects; as opposed to large formally specified ones like PCI or "
"USB."
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:14
msgid "Platform devices"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:15
msgid ""
"Platform devices are devices that typically appear as autonomous entities in "
"the system. This includes legacy port-based devices and host bridges to "
"peripheral buses, and most controllers integrated into system-on-chip "
"platforms.  What they usually have in common is direct addressing from a CPU "
"bus.  Rarely, a platform_device will be connected through a segment of some "
"other kind of bus; but its registers will still be directly addressable."
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:23
msgid ""
"Platform devices are given a name, used in driver binding, and a list of "
"resources such as addresses and IRQs::"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:36
msgid "Platform drivers"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:37
msgid ""
"Platform drivers follow the standard driver model convention, where "
"discovery/enumeration is handled outside the drivers, and drivers provide "
"probe() and remove() methods.  They support power management and shutdown "
"notifications using the standard conventions::"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:54
msgid ""
"Note that probe() should in general verify that the specified device "
"hardware actually exists; sometimes platform setup code can't be sure.  The "
"probing can use device resources, including clocks, and device platform_data."
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:58
msgid "Platform drivers register themselves the normal way::"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:62
msgid ""
"Or, in common situations where the device is known not to be hot-pluggable, "
"the probe() routine can live in an init section to reduce the driver's "
"runtime memory footprint::"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:69
msgid ""
"Kernel modules can be composed of several platform drivers. The platform "
"core provides helpers to register and unregister an array of drivers::"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:77
msgid ""
"If one of the drivers fails to register, all drivers registered up to that "
"point will be unregistered in reverse order. Note that there is a "
"convenience macro that passes THIS_MODULE as owner parameter::"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:85
msgid "Device Enumeration"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:86
msgid ""
"As a rule, platform specific (and often board-specific) setup code will "
"register platform devices::"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:93
msgid ""
"The general rule is to register only those devices that actually exist, but "
"in some cases extra devices might be registered.  For example, a kernel "
"might be configured to work with an external network adapter that might not "
"be populated on all boards, or likewise to work with an integrated "
"controller that some boards might not hook up to any peripherals."
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:99
msgid ""
"In some cases, boot firmware will export tables describing the devices that "
"are populated on a given board.   Without such tables, often the only way "
"for system setup code to set up the correct devices is to build a kernel for "
"a specific target board.  Such board-specific kernels are common with "
"embedded and custom systems development."
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:105
msgid ""
"In many cases, the memory and IRQ resources associated with the platform "
"device are not enough to let the device's driver work.  Board setup code "
"will often provide additional information using the device's platform_data "
"field to hold additional information."
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:110
msgid ""
"Embedded systems frequently need one or more clocks for platform devices, "
"which are normally kept off until they're actively needed (to save power). "
"System setup also associates those clocks with the device, so that calls to "
"clk_get(&pdev->dev, clock_name) return them as needed."
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:117
msgid "Legacy Drivers:  Device Probing"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:118
msgid ""
"Some drivers are not fully converted to the driver model, because they take "
"on a non-driver role:  the driver registers its platform device, rather than "
"leaving that for system infrastructure.  Such drivers can't be hotplugged or "
"coldplugged, since those mechanisms require device creation to be in a "
"different system component than the driver."
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:124
msgid ""
"The only \"good\" reason for this is to handle older system designs which, "
"like original IBM PCs, rely on error-prone \"probe-the-hardware\" models for "
"hardware configuration.  Newer systems have largely abandoned that model, in "
"favor of bus-level support for dynamic configuration (PCI, USB), or device "
"tables provided by the boot firmware (e.g. PNPACPI on x86).  There are too "
"many conflicting options about what might be where, and even educated "
"guesses by an operating system will be wrong often enough to make trouble."
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:132
msgid ""
"This style of driver is discouraged.  If you're updating such a driver, "
"please try to move the device enumeration to a more appropriate location, "
"outside the driver.  This will usually be cleanup, since such drivers tend "
"to already have \"normal\" modes, such as ones using device nodes that were "
"created by PNP or by platform device setup."
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:138
msgid ""
"None the less, there are some APIs to support such legacy drivers.  Avoid "
"using these calls except with such hotplug-deficient drivers::"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:144
msgid ""
"You can use platform_device_alloc() to dynamically allocate a device, which "
"you will then initialize with resources and platform_device_register(). A "
"better solution is usually::"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:152
msgid ""
"You can use platform_device_register_simple() as a one-step call to allocate "
"and register a device."
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:157
msgid "Device Naming and Driver Binding"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:158
msgid ""
"The platform_device.dev.bus_id is the canonical name for the devices. It's "
"built from two components:"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:161
msgid "platform_device.name ... which is also used to for driver matching."
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:163
msgid ""
"platform_device.id ... the device instance number, or else \"-1\" to "
"indicate there's only one."
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:166
msgid ""
"These are concatenated, so name/id \"serial\"/0 indicates bus_id "
"\"serial.0\", and \"serial/3\" indicates bus_id \"serial.3\"; both would use "
"the platform_driver named \"serial\".  While \"my_rtc\"/-1 would be bus_id "
"\"my_rtc\" (no instance id) and use the platform_driver called \"my_rtc\"."
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:171
msgid ""
"Driver binding is performed automatically by the driver core, invoking "
"driver probe() after finding a match between device and driver.  If the "
"probe() succeeds, the driver and device are bound as usual.  There are three "
"different ways to find such a match:"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:176
msgid ""
"Whenever a device is registered, the drivers for that bus are checked for "
"matches.  Platform devices should be registered very early during system "
"boot."
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:180
msgid ""
"When a driver is registered using platform_driver_register(), all unbound "
"devices on that bus are checked for matches.  Drivers usually register later "
"during booting, or by module loading."
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:184
msgid ""
"Registering a driver using platform_driver_probe() works just like using "
"platform_driver_register(), except that the driver won't be probed later if "
"another device registers.  (Which is OK, since this interface is only for "
"use with non-hotpluggable devices.)"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:191
msgid "Early Platform Devices and Drivers"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:192
msgid ""
"The early platform interfaces provide platform data to platform device "
"drivers early on during the system boot. The code is built on top of the "
"early_param() command line parsing and can be executed very early on."
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:196
msgid "Example: \"earlyprintk\" class early serial console in 6 steps"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:199
msgid "1. Registering early platform device data"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:200
msgid ""
"The architecture code registers platform device data using the function "
"early_platform_add_devices(). In the case of early serial console this "
"should be hardware configuration for the serial port. Devices registered at "
"this point will later on be matched against early platform drivers."
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:206
msgid "2. Parsing kernel command line"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:207
msgid ""
"The architecture code calls parse_early_param() to parse the kernel command "
"line. This will execute all matching early_param() callbacks. User specified "
"early platform devices will be registered at this point. For the early "
"serial console case the user can specify port on the kernel command line as "
"\"earlyprintk=serial.0\" where \"earlyprintk\" is the class string, "
"\"serial\" is the name of the platform driver and 0 is the platform device "
"id. If the id is -1 then the dot and the id can be omitted."
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:217
msgid "3. Installing early platform drivers belonging to a certain class"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:218
msgid ""
"The architecture code may optionally force registration of all early "
"platform drivers belonging to a certain class using the function "
"early_platform_driver_register_all(). User specified devices from step 2 "
"have priority over these. This step is omitted by the serial driver example "
"since the early serial driver code should be disabled unless the user has "
"specified port on the kernel command line."
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:226
msgid "4. Early platform driver registration"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:227
msgid ""
"Compiled-in platform drivers making use of early_platform_init() are "
"automatically registered during step 2 or 3. The serial driver example "
"should use early_platform_init(\"earlyprintk\", &platform_driver)."
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:232
msgid "5. Probing of early platform drivers belonging to a certain class"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:233
msgid ""
"The architecture code calls early_platform_driver_probe() to match "
"registered early platform devices associated with a certain class with "
"registered early platform drivers. Matched devices will get probed(). This "
"step can be executed at any point during the early boot. As soon as possible "
"may be good for the serial port case."
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:240
msgid "6. Inside the early platform driver probe()"
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:241
msgid ""
"The driver code needs to take special care during early boot, especially "
"when it comes to memory allocation and interrupt registration. The code in "
"the probe() function can use is_early_platform_device() to check if it is "
"called at early platform device or at the regular platform device time. The "
"early serial driver performs register_console() at this point."
msgstr ""

#: ../../../driver-api/driver-model/platform.rst:247
msgid "For further information, see <linux/platform_device.h>."
msgstr ""
