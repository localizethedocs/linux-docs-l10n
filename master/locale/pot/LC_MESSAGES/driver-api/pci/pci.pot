# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-16 08:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/pci/pci.rst:2
msgid "PCI Support Library"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:181
msgid "returns maximum PCI bus number of given bus' children"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:148
#: ../drivers/pci/devres.c:179 ../drivers/pci/devres.c:209
#: ../drivers/pci/devres.c:275 ../drivers/pci/devres.c:320
#: ../drivers/pci/devres.c:366 ../drivers/pci/devres.c:400
#: ../drivers/pci/devres.c:423 ../drivers/pci/devres.c:522
#: ../drivers/pci/devres.c:572 ../drivers/pci/devres.c:598
#: ../drivers/pci/devres.c:647 ../drivers/pci/devres.c:668
#: ../drivers/pci/devres.c:713 ../drivers/pci/devres.c:790
#: ../drivers/pci/devres.c:821 ../../../driver-api/pci/pci:13:
#: ../drivers/pci/pci-driver.c:37 ../drivers/pci/pci-driver.c:98
#: ../drivers/pci/pci-driver.c:1456 ../drivers/pci/pci-driver.c:1486
#: ../drivers/pci/pci-driver.c:1507 ../drivers/pci/pci-driver.c:1555
#: ../drivers/pci/pci-driver.c:1575 ../../../driver-api/pci/pci:16:
#: ../drivers/pci/remove.c:121 ../../../driver-api/pci/pci:19:
#: ../drivers/pci/search.c:139 ../drivers/pci/search.c:164
#: ../drivers/pci/search.c:187 ../drivers/pci/search.c:220
#: ../drivers/pci/search.c:331 ../drivers/pci/search.c:356
#: ../drivers/pci/search.c:390 ../drivers/pci/search.c:419
#: ../drivers/pci/search.c:450 ../../../driver-api/pci/pci:22:
#: ../drivers/pci/msi/msi.c:135 ../drivers/pci/msi/msi.c:147
#: ../drivers/pci/msi/msi.c:479 ../../../driver-api/pci/pci:25:
#: ../drivers/pci/bus.c:254 ../drivers/pci/bus.c:344 ../drivers/pci/bus.c:385
#: ../drivers/pci/bus.c:454 ../drivers/pci/bus.c:475
#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:191
#: ../drivers/pci/access.c:285 ../drivers/pci/access.c:305
#: ../drivers/pci/access.c:329 ../../../driver-api/pci/pci:31:
#: ../drivers/pci/irq.c:23 ../drivers/pci/irq.c:67 ../drivers/pci/irq.c:126
#: ../drivers/pci/irq.c:240 ../drivers/pci/irq.c:253
#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:2336
#: ../drivers/pci/probe.c:2861 ../drivers/pci/probe.c:3204
#: ../drivers/pci/probe.c:3491 ../../../driver-api/pci/pci:37:
#: ../drivers/pci/slot.c:193 ../drivers/pci/slot.c:313
#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:26
#: ../drivers/pci/rebar.c:45 ../drivers/pci/rebar.c:103
#: ../drivers/pci/rebar.c:134 ../drivers/pci/rebar.c:154
#: ../drivers/pci/rebar.c:279 ../../../driver-api/pci/pci:43:
#: ../drivers/pci/rom.c:20 ../drivers/pci/rom.c:56 ../drivers/pci/rom.c:130
#: ../drivers/pci/rom.c:185 ../../../driver-api/pci/pci:46:
#: ../drivers/pci/iov.c:59 ../drivers/pci/iov.c:1158 ../drivers/pci/iov.c:1176
#: ../drivers/pci/iov.c:1191 ../drivers/pci/iov.c:1206
#: ../drivers/pci/iov.c:1247 ../drivers/pci/iov.c:1277
#: ../drivers/pci/iov.c:1294 ../drivers/pci/iov.c:1330
#: ../drivers/pci/iov.c:1359 ../../../driver-api/pci/pci:49:
#: ../drivers/pci/pci-sysfs.c:925 ../drivers/pci/pci-sysfs.c:950
#: ../drivers/pci/pci-sysfs.c:975 ../drivers/pci/pci-sysfs.c:995
#: ../drivers/pci/pci-sysfs.c:1015 ../drivers/pci/pci-sysfs.c:1027
#: ../drivers/pci/pci-sysfs.c:1102 ../drivers/pci/pci-sysfs.c:1212
#: ../drivers/pci/pci-sysfs.c:1296 ../drivers/pci/pci-sysfs.c:1335
#: ../drivers/pci/pci-sysfs.c:1360 ../drivers/pci/pci-sysfs.c:1704
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:185
#: ../drivers/pci/pci.c:207 ../drivers/pci/pci.c:461 ../drivers/pci/pci.c:492
#: ../drivers/pci/pci.c:519 ../drivers/pci/pci.c:540 ../drivers/pci/pci.c:560
#: ../drivers/pci/pci.c:623 ../drivers/pci/pci.c:642 ../drivers/pci/pci.c:665
#: ../drivers/pci/pci.c:698 ../drivers/pci/pci.c:730 ../drivers/pci/pci.c:773
#: ../drivers/pci/pci.c:1174 ../drivers/pci/pci.c:1584
#: ../drivers/pci/pci.c:1739 ../drivers/pci/pci.c:1829
#: ../drivers/pci/pci.c:1866 ../drivers/pci/pci.c:1907
#: ../drivers/pci/pci.c:1943 ../drivers/pci/pci.c:2030
#: ../drivers/pci/pci.c:2102 ../drivers/pci/pci.c:2116
#: ../drivers/pci/pci.c:2193 ../drivers/pci/pci.c:2233
#: ../drivers/pci/pci.c:2331 ../drivers/pci/pci.c:2435
#: ../drivers/pci/pci.c:2572 ../drivers/pci/pci.c:2590
#: ../drivers/pci/pci.c:2672 ../drivers/pci/pci.c:2701
#: ../drivers/pci/pci.c:2746 ../drivers/pci/pci.c:2861
#: ../drivers/pci/pci.c:3092 ../drivers/pci/pci.c:3109
#: ../drivers/pci/pci.c:3669 ../drivers/pci/pci.c:3752
#: ../drivers/pci/pci.c:3826 ../drivers/pci/pci.c:3847
#: ../drivers/pci/pci.c:3885 ../drivers/pci/pci.c:3900
#: ../drivers/pci/pci.c:3916 ../drivers/pci/pci.c:3931
#: ../drivers/pci/pci.c:3950 ../drivers/pci/pci.c:4032
#: ../drivers/pci/pci.c:4068 ../drivers/pci/pci.c:4142
#: ../drivers/pci/pci.c:4156 ../drivers/pci/pci.c:4166
#: ../drivers/pci/pci.c:4204 ../drivers/pci/pci.c:4235
#: ../drivers/pci/pci.c:4254 ../drivers/pci/pci.c:4291
#: ../drivers/pci/pci.c:4316 ../drivers/pci/pci.c:4332
#: ../drivers/pci/pci.c:4372 ../drivers/pci/pci.c:4824
#: ../drivers/pci/pci.c:5083 ../drivers/pci/pci.c:5173
#: ../drivers/pci/pci.c:5220 ../drivers/pci/pci.c:5258
#: ../drivers/pci/pci.c:5537 ../drivers/pci/pci.c:5640
#: ../drivers/pci/pci.c:5678 ../drivers/pci/pci.c:5691
#: ../drivers/pci/pci.c:5714 ../drivers/pci/pci.c:5737
#: ../drivers/pci/pci.c:5784 ../drivers/pci/pci.c:5800
#: ../drivers/pci/pci.c:5851 ../drivers/pci/pci.c:5867
#: ../drivers/pci/pci.c:5913 ../drivers/pci/pci.c:6020
#: ../drivers/pci/pci.c:6034 ../drivers/pci/pci.c:6113
#: ../drivers/pci/pci.c:6125 ../drivers/pci/pci.c:6590
#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:163
#: ../drivers/pci/tph.c:239 ../drivers/pci/tph.c:284 ../drivers/pci/tph.c:346
#: ../drivers/pci/tph.c:368 ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:341
#: ../drivers/pci/hotplug/pci_hotplug_core.c:374
#: ../drivers/pci/hotplug/pci_hotplug_core.c:419
#: ../drivers/pci/hotplug/pci_hotplug_core.c:448
#: ../drivers/pci/hotplug/pci_hotplug_core.c:462
#: ../drivers/pci/hotplug/pci_hotplug_core.c:477 ../../../driver-api/pci/pci:7:
#: ../drivers/pci/iomap.c:19 ../drivers/pci/iomap.c:65
#: ../drivers/pci/iomap.c:114 ../drivers/pci/iomap.c:134
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:189
#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:256
#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:193
#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:2863
#: ../drivers/pci/probe.c:3206 ../drivers/pci/probe.c:3493
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:187
#: ../drivers/pci/pci.c:494 ../drivers/pci/pci.c:5642
#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:340
#: ../drivers/pci/hotplug/pci_hotplug_core.c:373
msgid "``struct pci_bus *bus``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:182
msgid "pointer to PCI bus structure to search"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:149
#: ../drivers/pci/devres.c:180 ../drivers/pci/devres.c:209
#: ../drivers/pci/devres.c:274 ../drivers/pci/devres.c:322
#: ../drivers/pci/devres.c:367 ../drivers/pci/devres.c:399
#: ../drivers/pci/devres.c:424 ../drivers/pci/devres.c:525
#: ../drivers/pci/devres.c:572 ../drivers/pci/devres.c:601
#: ../drivers/pci/devres.c:647 ../drivers/pci/devres.c:671
#: ../drivers/pci/devres.c:716 ../drivers/pci/devres.c:792
#: ../drivers/pci/devres.c:825 ../../../driver-api/pci/pci:13:
#: ../drivers/pci/pci-driver.c:43 ../drivers/pci/pci-driver.c:98
#: ../drivers/pci/pci-driver.c:1457 ../drivers/pci/pci-driver.c:1485
#: ../drivers/pci/pci-driver.c:1506 ../drivers/pci/pci-driver.c:1554
#: ../drivers/pci/pci-driver.c:1574 ../../../driver-api/pci/pci:16:
#: ../drivers/pci/remove.c:120 ../../../driver-api/pci/pci:19:
#: ../drivers/pci/search.c:139 ../drivers/pci/search.c:163
#: ../drivers/pci/search.c:189 ../drivers/pci/search.c:223
#: ../drivers/pci/search.c:334 ../drivers/pci/search.c:357
#: ../drivers/pci/search.c:390 ../drivers/pci/search.c:419
#: ../drivers/pci/search.c:450 ../../../driver-api/pci/pci:22:
#: ../drivers/pci/msi/msi.c:478 ../../../driver-api/pci/pci:25:
#: ../drivers/pci/bus.c:260 ../drivers/pci/bus.c:343 ../drivers/pci/bus.c:384
#: ../drivers/pci/bus.c:455 ../drivers/pci/bus.c:476
#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:191
#: ../drivers/pci/access.c:284 ../drivers/pci/access.c:304
#: ../drivers/pci/access.c:328 ../../../driver-api/pci/pci:31:
#: ../drivers/pci/irq.c:3 ../drivers/pci/irq.c:68 ../drivers/pci/irq.c:126
#: ../drivers/pci/irq.c:239 ../drivers/pci/irq.c:252
#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:2335
#: ../drivers/pci/probe.c:2861 ../drivers/pci/probe.c:3203
#: ../drivers/pci/probe.c:3490 ../../../driver-api/pci/pci:37:
#: ../drivers/pci/slot.c:195 ../drivers/pci/slot.c:312
#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:25
#: ../drivers/pci/rebar.c:103 ../drivers/pci/rebar.c:154
#: ../drivers/pci/rebar.c:281 ../../../driver-api/pci/pci:43:
#: ../drivers/pci/rom.c:19 ../drivers/pci/rom.c:55 ../drivers/pci/rom.c:132
#: ../drivers/pci/rom.c:185 ../../../driver-api/pci/pci:46:
#: ../drivers/pci/iov.c:59 ../drivers/pci/iov.c:1158 ../drivers/pci/iov.c:1190
#: ../drivers/pci/iov.c:1205 ../drivers/pci/iov.c:1247
#: ../drivers/pci/iov.c:1276 ../drivers/pci/iov.c:1294
#: ../drivers/pci/iov.c:1331 ../drivers/pci/iov.c:1360
#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:929
#: ../drivers/pci/pci-sysfs.c:954 ../drivers/pci/pci-sysfs.c:977
#: ../drivers/pci/pci-sysfs.c:997 ../drivers/pci/pci-sysfs.c:1015
#: ../drivers/pci/pci-sysfs.c:1026 ../drivers/pci/pci-sysfs.c:1104
#: ../drivers/pci/pci-sysfs.c:1211 ../drivers/pci/pci-sysfs.c:1295
#: ../drivers/pci/pci-sysfs.c:1339 ../drivers/pci/pci-sysfs.c:1364
#: ../drivers/pci/pci-sysfs.c:1703 ../../../driver-api/pci/pci:4:
#: ../drivers/pci/pci.c:184 ../drivers/pci/pci.c:206 ../drivers/pci/pci.c:461
#: ../drivers/pci/pci.c:493 ../drivers/pci/pci.c:520 ../drivers/pci/pci.c:540
#: ../drivers/pci/pci.c:559 ../drivers/pci/pci.c:624 ../drivers/pci/pci.c:642
#: ../drivers/pci/pci.c:666 ../drivers/pci/pci.c:699 ../drivers/pci/pci.c:731
#: ../drivers/pci/pci.c:773 ../drivers/pci/pci.c:1584 ../drivers/pci/pci.c:1866
#: ../drivers/pci/pci.c:2101 ../drivers/pci/pci.c:2115
#: ../drivers/pci/pci.c:2192 ../drivers/pci/pci.c:2233
#: ../drivers/pci/pci.c:2435 ../drivers/pci/pci.c:2573
#: ../drivers/pci/pci.c:2590 ../drivers/pci/pci.c:2672
#: ../drivers/pci/pci.c:2701 ../drivers/pci/pci.c:2745
#: ../drivers/pci/pci.c:2861 ../drivers/pci/pci.c:3091
#: ../drivers/pci/pci.c:3108 ../drivers/pci/pci.c:3672
#: ../drivers/pci/pci.c:3753 ../drivers/pci/pci.c:3829
#: ../drivers/pci/pci.c:3847 ../drivers/pci/pci.c:3916
#: ../drivers/pci/pci.c:3931 ../drivers/pci/pci.c:3952
#: ../drivers/pci/pci.c:4032 ../drivers/pci/pci.c:4067
#: ../drivers/pci/pci.c:4141 ../drivers/pci/pci.c:4165
#: ../drivers/pci/pci.c:4203 ../drivers/pci/pci.c:4234
#: ../drivers/pci/pci.c:4253 ../drivers/pci/pci.c:4291
#: ../drivers/pci/pci.c:4315 ../drivers/pci/pci.c:4331
#: ../drivers/pci/pci.c:4372 ../drivers/pci/pci.c:4823
#: ../drivers/pci/pci.c:5083 ../drivers/pci/pci.c:5172
#: ../drivers/pci/pci.c:5219 ../drivers/pci/pci.c:5257
#: ../drivers/pci/pci.c:5536 ../drivers/pci/pci.c:5639
#: ../drivers/pci/pci.c:5677 ../drivers/pci/pci.c:5690
#: ../drivers/pci/pci.c:5713 ../drivers/pci/pci.c:5738
#: ../drivers/pci/pci.c:5783 ../drivers/pci/pci.c:5801
#: ../drivers/pci/pci.c:5850 ../drivers/pci/pci.c:5868
#: ../drivers/pci/pci.c:5916 ../drivers/pci/pci.c:6019
#: ../drivers/pci/pci.c:6033 ../drivers/pci/pci.c:6112
#: ../drivers/pci/pci.c:6125 ../../../driver-api/pci/pci:52:
#: ../drivers/pci/tph.c:242 ../drivers/pci/tph.c:285 ../drivers/pci/tph.c:368
#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:345
#: ../drivers/pci/hotplug/pci_hotplug_core.c:378
#: ../drivers/pci/hotplug/pci_hotplug_core.c:418
#: ../drivers/pci/hotplug/pci_hotplug_core.c:447
#: ../drivers/pci/hotplug/pci_hotplug_core.c:461
#: ../drivers/pci/hotplug/pci_hotplug_core.c:476 ../../../driver-api/pci/pci:7:
#: ../drivers/pci/iomap.c:21 ../drivers/pci/iomap.c:67
#: ../drivers/pci/iomap.c:115 ../drivers/pci/iomap.c:135
msgid "**Description**"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:183
msgid ""
"Given a PCI bus, returns the highest PCI bus number present in the set "
"including the given PCI bus and its list of child PCI buses."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:203
msgid "return and clear error bits in PCI_STATUS"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:277
#: ../drivers/pci/devres.c:322 ../drivers/pci/devres.c:368
#: ../drivers/pci/devres.c:402 ../drivers/pci/devres.c:425
#: ../drivers/pci/devres.c:524 ../drivers/pci/devres.c:574
#: ../drivers/pci/devres.c:600 ../drivers/pci/devres.c:649
#: ../drivers/pci/devres.c:670 ../drivers/pci/devres.c:715
#: ../drivers/pci/devres.c:792 ../drivers/pci/devres.c:823
#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:105
#: ../drivers/pci/rebar.c:136 ../drivers/pci/rebar.c:156
#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:22
#: ../drivers/pci/rom.c:58 ../drivers/pci/rom.c:132 ../drivers/pci/rom.c:187
#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1214
#: ../drivers/pci/pci-sysfs.c:1298 ../drivers/pci/pci-sysfs.c:1706
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:209
#: ../drivers/pci/pci.c:3754 ../drivers/pci/pci.c:3828
#: ../drivers/pci/pci.c:3849 ../drivers/pci/pci.c:3887
#: ../drivers/pci/pci.c:3902 ../drivers/pci/pci.c:3918
#: ../drivers/pci/pci.c:3933 ../drivers/pci/pci.c:3952
#: ../drivers/pci/pci.c:4293 ../drivers/pci/pci.c:5680
#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:165
#: ../drivers/pci/tph.c:241 ../drivers/pci/tph.c:286 ../drivers/pci/tph.c:348
#: ../drivers/pci/tph.c:370
msgid "``struct pci_dev *pdev``"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:123
#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:276
#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1155
#: ../drivers/pci/iov.c:1173 ../drivers/pci/iov.c:1188
#: ../drivers/pci/iov.c:1203 ../drivers/pci/iov.c:1291
#: ../drivers/pci/iov.c:1327 ../drivers/pci/iov.c:1356
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:204
#: ../drivers/pci/pci.c:3666
msgid "the PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:205
msgid "Returns error bits set in PCI_STATUS and clears them."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:457
#: ../drivers/pci/pci.c:488
msgid "query for devices' capabilities"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:97
#: ../drivers/pci/pci-driver.c:1557 ../drivers/pci/pci-driver.c:1577
#: ../../../driver-api/pci/pci:16: ../drivers/pci/remove.c:123
#: ../../../driver-api/pci/pci:22: ../drivers/pci/msi/msi.c:481
#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:346
#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:287
#: ../drivers/pci/access.c:307 ../drivers/pci/access.c:331
#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:25
#: ../drivers/pci/irq.c:69 ../drivers/pci/irq.c:128 ../drivers/pci/irq.c:242
#: ../drivers/pci/irq.c:255 ../../../driver-api/pci/pci:34:
#: ../drivers/pci/probe.c:2338 ../../../driver-api/pci/pci:40:
#: ../drivers/pci/rebar.c:281 ../../../driver-api/pci/pci:46:
#: ../drivers/pci/iov.c:61 ../drivers/pci/iov.c:1160 ../drivers/pci/iov.c:1178
#: ../drivers/pci/iov.c:1193 ../drivers/pci/iov.c:1208
#: ../drivers/pci/iov.c:1249 ../drivers/pci/iov.c:1279
#: ../drivers/pci/iov.c:1296 ../drivers/pci/iov.c:1332
#: ../drivers/pci/iov.c:1361 ../../../driver-api/pci/pci:4:
#: ../drivers/pci/pci.c:463 ../drivers/pci/pci.c:521 ../drivers/pci/pci.c:542
#: ../drivers/pci/pci.c:562 ../drivers/pci/pci.c:625 ../drivers/pci/pci.c:644
#: ../drivers/pci/pci.c:667 ../drivers/pci/pci.c:700 ../drivers/pci/pci.c:775
#: ../drivers/pci/pci.c:1176 ../drivers/pci/pci.c:1586
#: ../drivers/pci/pci.c:1741 ../drivers/pci/pci.c:1831
#: ../drivers/pci/pci.c:1868 ../drivers/pci/pci.c:1909
#: ../drivers/pci/pci.c:1945 ../drivers/pci/pci.c:2032
#: ../drivers/pci/pci.c:2104 ../drivers/pci/pci.c:2118
#: ../drivers/pci/pci.c:2195 ../drivers/pci/pci.c:2235
#: ../drivers/pci/pci.c:2333 ../drivers/pci/pci.c:2437
#: ../drivers/pci/pci.c:2592 ../drivers/pci/pci.c:2674
#: ../drivers/pci/pci.c:2703 ../drivers/pci/pci.c:2748
#: ../drivers/pci/pci.c:2863 ../drivers/pci/pci.c:3094
#: ../drivers/pci/pci.c:3111 ../drivers/pci/pci.c:3671
#: ../drivers/pci/pci.c:4144 ../drivers/pci/pci.c:4158
#: ../drivers/pci/pci.c:4168 ../drivers/pci/pci.c:4206
#: ../drivers/pci/pci.c:4237 ../drivers/pci/pci.c:4256
#: ../drivers/pci/pci.c:4318 ../drivers/pci/pci.c:4334
#: ../drivers/pci/pci.c:4374 ../drivers/pci/pci.c:4826
#: ../drivers/pci/pci.c:5085 ../drivers/pci/pci.c:5175
#: ../drivers/pci/pci.c:5222 ../drivers/pci/pci.c:5260
#: ../drivers/pci/pci.c:5693 ../drivers/pci/pci.c:5716
#: ../drivers/pci/pci.c:5739 ../drivers/pci/pci.c:5786
#: ../drivers/pci/pci.c:5802 ../drivers/pci/pci.c:5853
#: ../drivers/pci/pci.c:5869 ../drivers/pci/pci.c:5915
#: ../drivers/pci/pci.c:6022 ../drivers/pci/pci.c:6036
#: ../drivers/pci/pci.c:6115 ../drivers/pci/pci.c:6127
#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:21
#: ../drivers/pci/iomap.c:67 ../drivers/pci/iomap.c:116
#: ../drivers/pci/iomap.c:136
msgid "``struct pci_dev *dev``"
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:2333
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:458
#: ../drivers/pci/pci.c:490 ../drivers/pci/pci.c:516 ../drivers/pci/pci.c:537
#: ../drivers/pci/pci.c:557 ../drivers/pci/pci.c:620 ../drivers/pci/pci.c:639
#: ../drivers/pci/pci.c:662 ../drivers/pci/pci.c:695 ../drivers/pci/pci.c:770
#: ../drivers/pci/pci.c:5688 ../drivers/pci/pci.c:5711
#: ../drivers/pci/pci.c:5734 ../drivers/pci/pci.c:5781
#: ../drivers/pci/pci.c:5797 ../drivers/pci/pci.c:5848
#: ../drivers/pci/pci.c:5864 ../drivers/pci/pci.c:5911
#: ../drivers/pci/pci.c:6017 ../drivers/pci/pci.c:6031
#: ../drivers/pci/pci.c:6110 ../../../driver-api/pci/pci:52:
#: ../drivers/pci/tph.c:160
msgid "PCI device to query"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:460
#: ../drivers/pci/pci.c:492 ../drivers/pci/pci.c:519 ../drivers/pci/pci.c:539
#: ../drivers/pci/pci.c:665
msgid "``int cap``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:459
#: ../drivers/pci/pci.c:491 ../drivers/pci/pci.c:518 ../drivers/pci/pci.c:538
msgid "capability code"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:460
msgid ""
"Tell if a device supports a given PCI capability. Returns the address of the "
"requested capability structure within the device's PCI configuration space "
"or 0 in case the device does not support it.  Possible values for **cap** "
"include:"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:465
msgid ""
"``PCI_CAP_ID_PM``           Power Management ``PCI_CAP_ID_AGP``          "
"Accelerated Graphics Port ``PCI_CAP_ID_VPD``          Vital Product Data "
"``PCI_CAP_ID_SLOTID``       Slot Identification ``PCI_CAP_ID_MSI``          "
"Message Signalled Interrupts ``PCI_CAP_ID_CHSWP``        CompactPCI HotSwap "
"``PCI_CAP_ID_PCIX``         PCI-X ``PCI_CAP_ID_EXP``          PCI Express"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:489
msgid "the PCI bus to query"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:186
#: ../drivers/pci/search.c:220 ../../../driver-api/pci/pci:4:
#: ../drivers/pci/pci.c:491
msgid "``unsigned int devfn``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:492
msgid ""
"Like pci_find_capability() but works for PCI devices that do not have a "
"pci_dev structure set up yet."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:495
msgid ""
"Returns the address of the requested capability structure within the "
"device's PCI configuration space or 0 in case the device does not support it."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:515
#: ../drivers/pci/pci.c:536
msgid "Find an extended capability"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:518
msgid "``u16 start``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:517
msgid "address at which to start looking (0 to start at beginning of list)"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:519
msgid ""
"Returns the address of the next matching extended capability structure "
"within the device's PCI configuration space or 0 if the device does not "
"support it.  Some capabilities can occur several times, e.g., the vendor-"
"specific capability, and this provides a way to find them all."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:539
msgid ""
"Returns the address of the requested extended capability structure within "
"the device's PCI configuration space or 0 if the device does not support "
"it.  Possible values for **cap** include:"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:543
msgid ""
"``PCI_EXT_CAP_ID_ERR``         Advanced Error Reporting "
"``PCI_EXT_CAP_ID_VC``          Virtual Channel "
"``PCI_EXT_CAP_ID_DSN``         Device Serial Number "
"``PCI_EXT_CAP_ID_PWR``         Power Budgeting"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:556
msgid "Read and return the 8-byte Device Serial Number"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:558
msgid ""
"Looks up the PCI_EXT_CAP_ID_DSN and reads the 8 bytes of the Device Serial "
"Number."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:561
msgid "Returns the DSN, or zero if the capability does not exist."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:619
#: ../drivers/pci/pci.c:638
msgid "query a device's HyperTransport capabilities"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:622
msgid "``u8 pos``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:621
msgid "Position from which to continue searching"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:623
#: ../drivers/pci/pci.c:641
msgid "``int ht_cap``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:622
#: ../drivers/pci/pci.c:640
msgid "HyperTransport capability code"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:623
msgid ""
"To be used in conjunction with pci_find_ht_capability() to search for all "
"capabilities matching **ht_cap**. **pos** should always be a value returned "
"from pci_find_ht_capability()."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:627
msgid ""
"NB. To be 100% safe against broken PCI devices, the caller should take steps "
"to avoid an infinite loop."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:641
msgid ""
"Tell if a device supports a given HyperTransport capability. Returns an "
"address within the device's PCI configuration space or 0 in case the device "
"does not support the request capability. The address points to the PCI "
"capability, of type PCI_CAP_ID_HT, which has a HyperTransport capability "
"matching **ht_cap**."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:661
msgid "Find a vendor-specific extended capability"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:664
#: ../drivers/pci/pci.c:697
msgid "``u16 vendor``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:663
msgid "Vendor ID for which capability is defined"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:664
msgid "Vendor-specific capability ID"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:665
msgid ""
"If **dev** has Vendor ID **vendor**, search for a VSEC capability with VSEC "
"ID **cap**. If found, return the capability offset in config space; "
"otherwise return 0."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:694
msgid "Find DVSEC for vendor"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:696
msgid "Vendor ID to match for the DVSEC"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:698
msgid "``u16 dvsec``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:697
msgid "Designated Vendor-specific capability ID"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:698
msgid ""
"If DVSEC has Vendor ID **vendor** and DVSEC ID **dvsec** return the "
"capability offset in config space; otherwise return 0."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:726
msgid "return resource region of parent bus of given region"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1509
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:732
msgid "``const struct pci_dev *dev``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:728
msgid "PCI device structure contains resources to be searched"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:208
#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:253
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:730
#: ../drivers/pci/pci.c:772 ../drivers/pci/pci.c:4070
msgid "``struct resource *res``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:729
msgid "child resource record for which parent is sought"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:730
msgid ""
"For given resource region of given device, return the resource region of "
"parent bus the given region is contained in."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:769
msgid "Return matching PCI device resource"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:771
msgid "Resource to look for"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:772
msgid ""
"Goes over standard PCI resources (BARs) and checks if the given resource is "
"partially or fully contained in any of them. In that case the matching "
"resource is returned, ``NULL`` otherwise."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1170
msgid "Use platform to change device power state"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1171
#: ../drivers/pci/pci.c:1581 ../drivers/pci/pci.c:2328
#: ../drivers/pci/pci.c:2432
msgid "PCI device to handle."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1173
#: ../drivers/pci/pci.c:1583 ../drivers/pci/pci.c:2330
#: ../drivers/pci/pci.c:2571
msgid "``pci_power_t state``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1172
msgid "State to put the device into."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1580
msgid "Set the power state of a PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1582
msgid "PCI power state (D0, D1, D2, D3hot) to put the device into."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1583
msgid ""
"Transition a device to a new power state, using the platform firmware and/or "
"the device's PCI PM registers."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1586
msgid ""
"RETURN VALUE: -EINVAL if the requested state is invalid. -EIO if device does "
"not support PCI PM or its PM capabilities register has a wrong version, or "
"device doesn't support the requested state. 0 if the transition is to D1 or "
"D2 but D1 and D2 are not supported. 0 if device already is in the requested "
"state. 0 if the transition is to D3 but D3 is not supported. 0 if device's "
"power state has been successfully changed."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1735
msgid "save the PCI configuration space of a device before suspending"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1737
#: ../drivers/pci/pci.c:1826 ../drivers/pci/pci.c:1864
#: ../drivers/pci/pci.c:1904 ../drivers/pci/pci.c:1941
msgid "PCI device that we're dealing with"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1825
msgid "Restore the saved state of a PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1862
msgid "Allocate and return an opaque struct containing the device saved state."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1865
msgid "Return NULL if no state or error."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1903
msgid "Reload the provided save state into struct pci_dev."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1906
msgid "``struct pci_saved_state *state``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1905
msgid "Saved state returned from pci_store_saved_state()"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1939
msgid ""
"Reload the save state pointed to by state, and free the memory allocated for "
"it."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1943
msgid "``struct pci_saved_state **state``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:1942
msgid "Pointer to saved state returned from pci_store_saved_state()"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2026
msgid "Resume abandoned device"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2027
msgid "PCI device to be resumed"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:529
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2029
msgid "**NOTE**"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2029
msgid ""
"This function is a backend of pci_default_resume() and is not supposed to be "
"called by normal code, write proper resume handler and use it instead."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2098
msgid "Initialize a device for use with Memory space"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:363
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2099
#: ../drivers/pci/pci.c:2113
msgid "PCI device to be initialized"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2100
msgid ""
"Initialize device before it's used by a driver. Ask low-level code to enable "
"Memory resources. Wake up the device if it was suspended. Beware, this "
"function can fail."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2112
msgid "Initialize device before it's used by a driver."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2114
msgid ""
"Initialize device before it's used by a driver. Ask low-level code to enable "
"I/O and memory. Wake up the device if it was suspended. Beware, this "
"function can fail."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2118
msgid ""
"Note we don't actually enable the device many times if we call this function "
"repeatedly (we just increment the count)."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2189
msgid "Disable PCI device after use"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2190
msgid "PCI device to be disabled"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2191
msgid ""
"Signal to the system that the PCI device is not in use by the system "
"anymore.  This only involves disabling PCI bus-mastering, if active."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2194
msgid ""
"Note we don't actually disable the device until all callers of "
"pci_enable_device() have called pci_disable_device()."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2229
msgid "set reset state for device dev"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2230
msgid "the PCIe device reset"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2232
msgid "``enum pcie_reset_state state``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2231
msgid "Reset state to enter into"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2232
msgid "Sets the PCI reset state for the device."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2327
msgid "check the capability of PCI device to generate PME#"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2329
msgid "PCI state from which device will issue PME#."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2431
msgid "enable or disable PCI device's PME# function"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2434
#: ../drivers/pci/pci.c:2572 ../drivers/pci/pci.c:2589
msgid "``bool enable``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2433
msgid "'true' to enable PME# generation; 'false' to disable it."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2434
msgid ""
"The caller must verify that the device is capable of generating PME# before "
"calling this function with **enable** equal to 'true'."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2568
msgid "change wakeup settings for a PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2574
msgid "``struct pci_dev *pci_dev``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2569
msgid "Target device"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2570
msgid "PCI state from which device will issue wakeup events"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2571
msgid "Whether or not to enable event generation"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2572
msgid ""
"If **enable** is set, check device_may_wakeup() for the device before "
"calling __pci_enable_wake() for it."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2586
msgid "enable/disable device to wake up from D3_hot or D3_cold"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2587
msgid "PCI device to prepare"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2588
msgid "True to enable wake-up event generation; false to disable"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2589
msgid ""
"Many drivers want the device to wake up the system from D3_hot or D3_cold "
"and this function allows them to set that up cleanly - pci_enable_wake() "
"should not be called twice in a row to enable wake-up due to PCI PM vs ACPI "
"ordering constraints."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2594
msgid ""
"This function only returns error code if the device is not allowed to wake "
"up the system from sleep or it is not capable of generating PME# from both "
"D3_hot and D3_cold and the platform is unable to enable wake-up power for it."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2668
msgid "prepare PCI device for system-wide transition into a sleep state"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2670
#: ../drivers/pci/pci.c:2699
msgid "Device to handle."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2671
msgid ""
"Choose the power state appropriate for the device depending on whether it "
"can wake up the system and/or is power manageable by the platform (PCI_D3hot "
"is the default) and put the device into that state."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2697
msgid "turn PCI device on during system-wide transition into working state"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2700
msgid "Disable device's system wake-up capability and put it into D0."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2742
msgid "Check if device can generate run-time wake-up events."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2743
msgid "Device to check."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2744
msgid ""
"Return true if the device itself is capable of generating wake-up events "
"(through the platform or using the native PCIe PME) or if the device "
"supports PME and one of its upstream bridges can generate wake-up events."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2857
msgid "Choose the power state of a PCI device."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2858
msgid "Target PCI device."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2860
msgid "``pm_message_t state``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2859
msgid "Target state for the whole system."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:2860
msgid "Returns PCI power state suitable for **dev** and **state**."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3088
msgid "Enable D3cold for device"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3089
#: ../drivers/pci/pci.c:3106
msgid "PCI device to handle"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3090
msgid ""
"This function can be used in drivers to enable D3cold from the device they "
"handle.  It also updates upstream PCI bridge PM capabilities accordingly."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3105
msgid "Disable D3cold for device"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3107
msgid ""
"This function can be used in drivers to disable D3cold from the device they "
"handle.  It also updates upstream PCI bridge PM capabilities accordingly."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3665
msgid "enable AtomicOp requests to root port"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3668
msgid "``u32 cap_mask``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3667
msgid ""
"mask of desired AtomicOp sizes, including one or more of: "
"PCI_EXP_DEVCAP2_ATOMIC_COMP32 PCI_EXP_DEVCAP2_ATOMIC_COMP64 "
"PCI_EXP_DEVCAP2_ATOMIC_COMP128"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3671
msgid ""
"Return 0 if all upstream bridges support AtomicOp routing, egress blocking "
"is disabled on all upstream ports, and the root port supports the requested "
"completion capabilities (32-bit, 64-bit and/or 128-bit AtomicOp completion), "
"or negative otherwise."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3748
msgid "Release a PCI bar"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3749
msgid ""
"PCI device whose resources were previously reserved by pci_request_region()"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:521
#: ../drivers/pci/devres.c:597 ../drivers/pci/devres.c:646
#: ../drivers/pci/devres.c:712 ../drivers/pci/devres.c:820
#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:102
#: ../drivers/pci/rebar.c:133 ../drivers/pci/rebar.c:153
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3752
#: ../drivers/pci/pci.c:3825 ../../../driver-api/pci/pci:7:
#: ../drivers/pci/iomap.c:18 ../drivers/pci/iomap.c:64
#: ../drivers/pci/iomap.c:113 ../drivers/pci/iomap.c:133
msgid "``int bar``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3751
msgid "BAR to release"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3752
msgid ""
"Releases the PCI I/O and memory resources previously reserved by a "
"successful call to pci_request_region().  Call this function only after all "
"use of the PCI regions has ceased."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3822
msgid "Reserve PCI I/O and memory resource"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3823
#: ../drivers/pci/pci.c:3882 ../drivers/pci/pci.c:3928
#: ../drivers/pci/pci.c:3947
msgid "PCI device whose resources are to be reserved"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3824
msgid "BAR to be reserved"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:598
#: ../drivers/pci/devres.c:668 ../drivers/pci/devres.c:713
#: ../drivers/pci/devres.c:789 ../../../driver-api/pci/pci:37:
#: ../drivers/pci/slot.c:193 ../../../driver-api/pci/pci:4:
#: ../drivers/pci/pci.c:3826 ../drivers/pci/pci.c:3885
#: ../drivers/pci/pci.c:3900 ../drivers/pci/pci.c:3930
#: ../drivers/pci/pci.c:3949 ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:342
#: ../drivers/pci/hotplug/pci_hotplug_core.c:375
msgid "``const char *name``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3825
msgid "name of the driver requesting the resource"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:275
#: ../drivers/pci/devres.c:320 ../drivers/pci/devres.c:365
#: ../drivers/pci/devres.c:422 ../drivers/pci/devres.c:523
#: ../drivers/pci/devres.c:599 ../drivers/pci/devres.c:669
#: ../drivers/pci/devres.c:714 ../drivers/pci/devres.c:790
#: ../drivers/pci/devres.c:823 ../../../driver-api/pci/pci:13:
#: ../drivers/pci/pci-driver.c:49 ../../../driver-api/pci/pci:19:
#: ../drivers/pci/search.c:426 ../../../driver-api/pci/pci:40:
#: ../drivers/pci/rebar.c:27 ../drivers/pci/rebar.c:44
#: ../drivers/pci/rebar.c:104 ../drivers/pci/rebar.c:135
#: ../drivers/pci/rebar.c:155 ../drivers/pci/rebar.c:290
#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:130
#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1336
#: ../drivers/pci/iov.c:1362 ../../../driver-api/pci/pci:4:
#: ../drivers/pci/pci.c:3827 ../drivers/pci/pci.c:3886
#: ../drivers/pci/pci.c:3901 ../drivers/pci/pci.c:3950
#: ../drivers/pci/pci.c:4168 ../drivers/pci/pci.c:4204
#: ../drivers/pci/pci.c:4236 ../drivers/pci/pci.c:5097
#: ../drivers/pci/pci.c:5231 ../drivers/pci/pci.c:6020
#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:162
#: ../drivers/pci/tph.c:244 ../drivers/pci/tph.c:288 ../drivers/pci/tph.c:345
#: ../drivers/pci/tph.c:376
msgid "**Return**"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:365
#: ../drivers/pci/devres.c:669 ../drivers/pci/devres.c:790
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3827
#: ../drivers/pci/pci.c:3886 ../drivers/pci/pci.c:3901
#: ../drivers/pci/pci.c:3950
msgid "0 on success, negative error code on failure."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3828
msgid ""
"Mark the PCI region associated with PCI device **pdev** BAR **bar** as being "
"reserved by owner **name**. Do not access any address inside the PCI regions "
"unless this call returns successfully."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3832
#: ../drivers/pci/pci.c:3934 ../drivers/pci/pci.c:3958
msgid ""
"Returns 0 on success, or ``EBUSY`` on error.  A warning message is also "
"printed on failure."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3843
msgid "Release selected PCI I/O and memory resources"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3844
msgid "PCI device whose resources were previously reserved"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3846
#: ../drivers/pci/pci.c:3884 ../drivers/pci/pci.c:3899
msgid "``int bars``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3845
msgid "Bitmask of BARs to be released"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3846
msgid ""
"Release selected PCI I/O and memory resources previously reserved. Call this "
"function only after all use of the PCI regions has ceased."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3881
msgid "Reserve selected PCI I/O and memory resources"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3883
msgid "Bitmask of BARs to be requested"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:667
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3884
msgid "Name of the driver requesting the resources"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3896
msgid "Request regions exclusively"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3897
msgid "PCI device to request regions from"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3898
msgid "bit mask of BARs to request"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:788
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3899
#: ../drivers/pci/pci.c:3929 ../drivers/pci/pci.c:3948
msgid "name of the driver requesting the resources"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3912
msgid "Release reserved PCI I/O and memory resources"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3913
msgid ""
"PCI device whose resources were previously reserved by pci_request_regions()"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3915
msgid ""
"Releases all PCI I/O and memory resources previously reserved by a "
"successful call to pci_request_regions().  Call this function only after all "
"use of the PCI regions has ceased."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3927
#: ../drivers/pci/pci.c:3946
msgid "Reserve PCI I/O and memory resources"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3930
#: ../drivers/pci/pci.c:3951
msgid ""
"Mark all PCI regions associated with PCI device **pdev** as being reserved "
"by owner **name**. Do not access any address inside the PCI regions unless "
"this call returns successfully."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:3955
msgid ""
"pci_request_regions_exclusive() will mark the region so that /dev/mem and "
"the sysfs MMIO access will not be allowed."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4028
msgid "Remap the memory mapped I/O space"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:147
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4034
msgid "``const struct resource *res``"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:146
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4029
msgid "Resource describing the I/O space"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:148
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4031
msgid "``phys_addr_t phys_addr``"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:147
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4030
msgid "physical address of range to be mapped"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4031
msgid ""
"Remap the memory mapped I/O space described by the **res** and the CPU "
"physical address **phys_addr** into virtual address space.  Only "
"architectures that have memory mapped IO functions defined (and the "
"PCI_IOBASE value defined) should call this function."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4064
msgid "Unmap the memory mapped I/O space"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4065
msgid "resource to be unmapped"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4066
msgid ""
"Unmap the CPU virtual address **res** from virtual address space.  Only "
"architectures that have memory mapped IO functions defined (and the "
"PCI_IOBASE value defined) should call this function."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4138
msgid "enables bus-mastering for device dev"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4139
msgid "the PCI device to enable"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4140
msgid ""
"Enables bus-mastering on the device and calls pcibios_set_master() to do the "
"needed arch specific settings."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4152
msgid "disables bus-mastering for device dev"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4153
#: ../drivers/pci/pci.c:4251
msgid "the PCI device to disable"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4162
msgid "ensure the CACHE_LINE_SIZE register is programmed"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4163
msgid "the PCI device for which MWI is to be enabled"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4164
msgid ""
"Helper function for pci_set_mwi. Originally copied from drivers/net/acenic."
"c. Copyright 1998-2001 by Jes Sorensen, <jes**trained**-monkey.org>."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:276
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4169
#: ../drivers/pci/pci.c:4205 ../drivers/pci/pci.c:4237
msgid "An appropriate -ERRNO error value on error, or zero for success."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4200
#: ../drivers/pci/pci.c:4231
msgid "enables memory-write-invalidate PCI transaction"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:272
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4201
#: ../drivers/pci/pci.c:4232
msgid "the PCI device for which MWI is enabled"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4202
msgid "Enables the Memory-Write-Invalidate transaction in ``PCI_COMMAND``."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4233
msgid ""
"Enables the Memory-Write-Invalidate transaction in ``PCI_COMMAND``. Callers "
"are not required to check the return value."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4250
msgid "disables Memory-Write-Invalidate for device dev"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4252
msgid "Disables PCI Memory-Write-Invalidate transaction on the device"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4287
msgid "enables/disables PCI INTx for device dev"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:317
#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:237
#: ../drivers/pci/irq.c:250 ../../../driver-api/pci/pci:4:
#: ../drivers/pci/pci.c:4288 ../drivers/pci/pci.c:4313
msgid "the PCI device to operate on"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:319
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4290
msgid "``int enable``"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:318
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4289
msgid "boolean: whether to enable or disable PCI INTx"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4290
msgid "Enables/disables PCI INTx for device **pdev**"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4312
msgid "wait for pending transaction"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4314
msgid "Return 0 if transaction is pending 1 otherwise."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4328
#: ../drivers/pci/pci.c:4368
msgid "initiate a PCIe function level reset"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4329
#: ../drivers/pci/pci.c:4369
msgid "device to reset"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4330
msgid ""
"Initiate a function level reset unconditionally on **dev** without checking "
"any flags and DEVCAP"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4371
msgid "``bool probe``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4370
msgid "if true, return 0 if device can be reset this way"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4371
msgid "Initiate a function level reset on **dev**."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4820
msgid "Reset the secondary bus on a PCI bridge."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4821
msgid "Bridge device"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:4822
msgid ""
"Use the bridge control register to assert reset on the secondary bus. "
"Devices on the secondary bus are left in power-on state."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5079
msgid "reset a PCI device function while holding the **dev** mutex lock."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5081
#: ../drivers/pci/pci.c:5170 ../drivers/pci/pci.c:5217
#: ../drivers/pci/pci.c:5255
msgid "PCI device to reset"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5082
#: ../drivers/pci/pci.c:5171 ../drivers/pci/pci.c:5218
msgid ""
"Some devices allow an individual function to be reset without affecting "
"other functions in the same device.  The PCI device must be responsive to "
"PCI config space in order to use this function."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5086
msgid ""
"The device function is presumed to be unused and the caller is holding the "
"device mutex lock when this function is called."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5089
msgid ""
"Resetting the device will make the contents of PCI configuration space "
"random, so any caller of this must be prepared to reinitialise the device "
"including MSI, bus mastering, BARs, decoding IO and memory spaces, etc."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:46
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5094
#: ../drivers/pci/pci.c:5228
msgid "**Context**"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5095
#: ../drivers/pci/pci.c:5229
msgid "The caller must hold the device lock."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5097
#: ../drivers/pci/pci.c:5231
msgid ""
"0 if the device function was successfully reset or negative if the device "
"doesn't support resetting a single function."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5169
#: ../drivers/pci/pci.c:5216 ../drivers/pci/pci.c:5254
msgid "quiesce and reset a PCI device function"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5175
msgid ""
"This function does not just reset the PCI portion of a device, but clears "
"all the state associated with the device.  This function differs from "
"__pci_reset_function_locked() in that it saves and restores device state "
"over the reset and takes the PCI device lock."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5180
msgid ""
"Returns 0 if the device function was successfully reset or negative if the "
"device doesn't support resetting a single function."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5222
msgid ""
"This function does not just reset the PCI portion of a device, but clears "
"all the state associated with the device.  This function differs from "
"__pci_reset_function_locked() in that it saves and restores device state "
"over the reset.  It also differs from pci_reset_function() in that it "
"requires the PCI device lock to be held."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5256
msgid "Same as above, except return -EAGAIN if unable to lock device."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5533
msgid "probe whether a PCI slot can be reset"
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:315
#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5539
msgid "``struct pci_slot *slot``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5534
msgid "PCI slot to probe"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5535
msgid ""
"Return 0 if slot can be reset, negative if a slot reset is not supported."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5636
msgid "probe whether a PCI bus can be reset"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5637
msgid "PCI bus to probe"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5638
msgid "Return 0 if bus can be reset, negative if a bus reset is not supported."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5674
msgid "Try to reset a PCI bus"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5675
msgid "top level PCI device to reset via slot/bus"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5676
msgid "Same as above except return -EAGAIN if the bus cannot be locked"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5687
msgid "get PCI-X maximum designed memory read byte count"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5689
msgid ""
"Returns mmrbc: maximum designed memory read count in bytes or appropriate "
"error value."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5710
msgid "get PCI-X maximum memory read byte count"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5712
msgid ""
"Returns mmrbc: maximum memory read count in bytes or appropriate error value."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5733
msgid "set PCI-X maximum memory read byte count"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5736
msgid "``int mmrbc``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5735
msgid ""
"maximum memory read count in bytes valid values are 512, 1024, 2048, 4096"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5737
msgid ""
"If possible sets maximum memory read byte count, some bridges have errata "
"that prevent this."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5780
msgid "get PCI Express read request size"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5782
msgid ""
"Returns maximum memory read request in bytes or appropriate error value."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5796
msgid "set PCI Express maximum memory read request"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5799
msgid "``int rq``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5798
msgid ""
"maximum memory read count in bytes valid values are 128, 256, 512, 1024, "
"2048, 4096"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5800
msgid "If possible sets maximum memory read request in bytes"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5847
msgid "get PCI Express maximum payload size"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5849
msgid "Returns maximum payload size in bytes"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5863
msgid "set PCI Express maximum payload size"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5866
msgid "``int mps``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5865
msgid ""
"maximum payload size in bytes valid values are 128, 256, 512, 1024, 2048, "
"4096"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5867
msgid "If possible sets maximum payload size"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5909
msgid ""
"determine minimum link settings of a PCIe device and its bandwidth limitation"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5913
msgid "``struct pci_dev **limiting_dev``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5912
msgid "storage for device causing the bandwidth limitation"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5914
msgid "``enum pci_bus_speed *speed``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5913
msgid "storage for speed of limiting device"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5915
msgid "``enum pcie_link_width *width``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5914
msgid "storage for width of limiting device"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:5915
msgid ""
"Walk up the PCI device chain and find the point where the minimum bandwidth "
"is available.  Return the bandwidth available there and (if limiting_dev, "
"speed, and width pointers are supplied) information about that point.  The "
"bandwidth returned is in Mb/s, i.e., megabits/second of raw bandwidth."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6016
msgid "query for the PCI device's link speed capability"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6018
msgid "Query the PCI device speed capability."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6021
msgid "the maximum link speed supported by the device."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6030
msgid "query for the PCI device's link width capability"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6032
msgid ""
"Query the PCI device width capability.  Return the maximum link width "
"supported by the device."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6109
msgid "Report the PCI device's link speed and width"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6111
msgid "Report the available bandwidth at the device."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6121
msgid "Make BAR mask from the type of resource"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6122
msgid "the PCI device for which BAR mask is made"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6124
msgid "``unsigned long flags``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6123
msgid "resource type mask to be selected"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6124
msgid "This helper routine makes bar mask from the type of resource."
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6586
msgid "allocate a PCI domain number per constraints"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6592
msgid "``u32 hint``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6587
msgid ""
"desired domain, 0 if any ID in the range of **min** to **max** is acceptable"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6589
msgid "``u32 min``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6588
msgid "minimum allowable domain"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6590
msgid "``u32 max``"
msgstr ""

#: ../../../driver-api/pci/pci:4: ../drivers/pci/pci.c:6589
msgid "maximum allowable domain, no IDs higher than INT_MAX will be returned"
msgstr ""

#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:15
#: ../drivers/pci/iomap.c:110
msgid "create a virtual mapping cookie for a PCI BAR"
msgstr ""

#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:16
#: ../drivers/pci/iomap.c:62 ../drivers/pci/iomap.c:111
#: ../drivers/pci/iomap.c:131
msgid "PCI device that owns the BAR"
msgstr ""

#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:17
#: ../drivers/pci/iomap.c:63 ../drivers/pci/iomap.c:112
#: ../drivers/pci/iomap.c:132
msgid "BAR number"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:821
#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:19
#: ../drivers/pci/iomap.c:65
msgid "``unsigned long offset``"
msgstr ""

#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:18
#: ../drivers/pci/iomap.c:64
msgid "map memory at the given offset in BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:522
#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:20
#: ../drivers/pci/iomap.c:66 ../drivers/pci/iomap.c:114
#: ../drivers/pci/iomap.c:134
msgid "``unsigned long maxlen``"
msgstr ""

#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:19
#: ../drivers/pci/iomap.c:65
msgid "max length of the memory to map"
msgstr ""

#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:20
#: ../drivers/pci/iomap.c:114
msgid ""
"Using this function you will get a __iomem address to your device BAR. You "
"can access it using ioread*() and iowrite*(). These functions hide the "
"details if this is a MMIO or PIO address space and will just do what you "
"expect from them in the correct way."
msgstr ""

#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:25
#: ../drivers/pci/iomap.c:72
msgid ""
"**maxlen** specifies the maximum length to map. If you want to get access to "
"the complete BAR from offset to the end, pass ``0`` here."
msgstr ""

#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:61
#: ../drivers/pci/iomap.c:130
msgid "create a virtual WC mapping cookie for a PCI BAR"
msgstr ""

#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:66
#: ../drivers/pci/iomap.c:134
msgid ""
"Using this function you will get a __iomem address to your device BAR. You "
"can access it using ioread*() and iowrite*(). These functions hide the "
"details if this is a MMIO or PIO address space and will just do what you "
"expect from them in the correct way. When possible write combining is used."
msgstr ""

#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:113
#: ../drivers/pci/iomap.c:133
msgid "length of the memory to map"
msgstr ""

#: ../../../driver-api/pci/pci:7: ../drivers/pci/iomap.c:119
#: ../drivers/pci/iomap.c:140
msgid ""
"**maxlen** specifies the maximum length to map. If you want to get access to "
"the complete BAR without checking for its length first, pass ``0`` here."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:144
msgid "Managed pci_remap_iospace()"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:150
#: ../drivers/pci/devres.c:181 ../drivers/pci/devres.c:211
msgid "``struct device *dev``"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:145
#: ../drivers/pci/devres.c:176
msgid "Generic device to remap IO address for"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:148
msgid ""
"Managed pci_remap_iospace().  Map is automatically unmapped on driver detach."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:175
msgid "Managed pci_remap_cfgspace()"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:178
msgid "``resource_size_t offset``"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:177
msgid "Resource address to map"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:179
#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:254
msgid "``resource_size_t size``"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:178
msgid "Size of map"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:179
msgid ""
"Managed pci_remap_cfgspace().  Map is automatically unmapped on driver "
"detach."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:205
msgid "check, request region and ioremap cfg resource"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:206
msgid "generic device to handle the resource for"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:207
msgid "configuration space resource to be handled"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:208
msgid ""
"Checks that a resource is a valid memory region, requests the memory region "
"and ioremaps with pci_remap_cfgspace() API that ensures the proper PCI "
"configuration space memory attributes are guaranteed."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:212
msgid "All operations are managed and will be undone on driver detach."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:214
msgid ""
"Returns a pointer to the remapped memory or an IOMEM_ERR_PTR() encoded error "
"code on failure. Usage example::"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:271
msgid "a device-managed pci_set_mwi()"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:273
msgid "Managed pci_set_mwi()."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:316
msgid "managed pci_intx()"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:320
msgid "0 on success, -ENOMEM on error."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:321
msgid ""
"Enable/disable PCI INTx for device **pdev**. Restore the original state on "
"driver detach."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:362
msgid "Managed pci_enable_device()"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:366
msgid ""
"Managed pci_enable_device(). Device will automatically be disabled on driver "
"detach."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:396
msgid "Pin managed PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:397
msgid "PCI device to pin"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:398
msgid ""
"Pin managed PCI device **pdev**. Pinned device won't be disabled on driver "
"detach. **pdev** must have been enabled with pcim_enable_device()."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:419
msgid "access iomap allocation table (DEPRECATED)"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:420
msgid "PCI device to access iomap table for"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:422
msgid "Const pointer to array of __iomem pointers on success, NULL on failure."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:424
msgid ""
"Access iomap allocation table for **dev**.  If iomap table doesn't exist and "
"**pdev** is managed, it will be allocated.  All iomaps recorded in the iomap "
"table are automatically unmapped on driver detach."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:429
msgid ""
"This function might sleep when the table is first allocated but can be "
"safely called without context and guaranteed to succeed once allocated."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:433
msgid ""
"This function is DEPRECATED. Do not use it in new code. Instead, obtain a "
"mapping's address directly from one of the pcim_* mapping functions. For"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:436
msgid "**example**"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:436
msgid "void __iomem \\*mappy = pcim_iomap(pdev, bar, length);"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:518
msgid "Managed pcim_iomap()"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:519
msgid "PCI device to iomap for"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:520
msgid "BAR to iomap"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:521
msgid "Maximum length of iomap"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:523
msgid "__iomem pointer on success, NULL on failure."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:524
msgid ""
"Managed pci_iomap(). Map is automatically unmapped on driver detach. If "
"desired, unmap manually only with pcim_iounmap()."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:527
msgid "This SHOULD only be used once per BAR."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:530
msgid ""
"Contrary to the other pcim_* functions, this function does not return an "
"IOMEM_ERR_PTR() on failure, but a simple NULL. This is done for backwards "
"compatibility."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:568
msgid "Managed pci_iounmap()"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:569
msgid "PCI device to iounmap for"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:571
msgid "``void __iomem *addr``"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:570
msgid "Address to unmap"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:571
msgid ""
"Managed pci_iounmap(). **addr** must have been mapped using a pcim_* mapping "
"function."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:594
msgid "Request and iomap a PCI BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:595
#: ../drivers/pci/devres.c:665 ../drivers/pci/devres.c:787
#: ../drivers/pci/devres.c:818
msgid "PCI device to map IO resources for"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:596
msgid "Index of a BAR to map"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:597
#: ../drivers/pci/devres.c:712
msgid "Name of the driver requesting the resource"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:599
#: ../drivers/pci/devres.c:823
msgid "__iomem pointer on success, an IOMEM_ERR_PTR on failure."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:600
msgid ""
"Mapping and region will get automatically released on driver detach. If "
"desired, release manually only with pcim_iounmap_region()."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:643
msgid "Unmap and release a PCI BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:644
#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:20
#: ../drivers/pci/irq.c:64
msgid "PCI device to operate on"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:645
msgid "Index of BAR to unmap and release"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:646
msgid ""
"Unmap a BAR and release its region manually. Only pass BARs that were "
"previously mapped by pcim_iomap_region()."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:664
msgid "Request and iomap PCI BARs (DEPRECATED)"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:667
msgid "``int mask``"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:666
msgid "Mask of BARs to request and iomap"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:670
msgid "Request and iomap regions specified by **mask**."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:672
msgid ""
"This function is DEPRECATED. Do not use it in new code. Use "
"pcim_iomap_region() instead."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:709
msgid "Request a PCI BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:710
msgid "PCI device to request region for"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:711
msgid "Index of BAR to request"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:714
msgid "0 on success, a negative error code on failure."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:715
msgid "Request region specified by **bar**."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:717
msgid ""
"The region will automatically be released on driver detach. If desired, "
"release manually only with pcim_release_region()."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:786
msgid "Request all regions"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:791
msgid ""
"Requested regions will automatically be released at driver detach. If "
"desired, release individual regions with pcim_release_region() or all of "
"them at once with pcim_release_all_regions()."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:817
msgid "Create a ranged __iomap mapping within a PCI BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:819
msgid "Index of the BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:820
msgid "Offset from the begin of the BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:822
msgid "``unsigned long len``"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:821
msgid "Length in bytes for the mapping"
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:824
msgid ""
"Creates a new IO-Mapping within the specified **bar**, ranging from "
"**offset** to **offset** + **len**."
msgstr ""

#: ../../../driver-api/pci/pci:10: ../drivers/pci/devres.c:827
msgid ""
"The mapping will automatically get unmapped on driver detach. If desired, "
"release manually only with pcim_iounmap()."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:33
msgid "add a new PCI device ID to this driver and re-probe devices"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:39
#: ../drivers/pci/pci-driver.c:1458 ../drivers/pci/pci-driver.c:1488
msgid "``struct pci_driver *drv``"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:34
msgid "target pci driver"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:36
#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:333
#: ../drivers/pci/search.c:358
msgid "``unsigned int vendor``"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:35
msgid "PCI vendor ID"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:37
#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:330
#: ../drivers/pci/search.c:355
msgid "``unsigned int device``"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:36
msgid "PCI device ID"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:38
msgid "``unsigned int subvendor``"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:37
msgid "PCI subvendor ID"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:39
msgid "``unsigned int subdevice``"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:38
msgid "PCI subdevice ID"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:40
#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:392
#: ../drivers/pci/search.c:421
msgid "``unsigned int class``"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:39
msgid "PCI class"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:41
msgid "``unsigned int class_mask``"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:40
msgid "PCI class mask"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:42
msgid "``unsigned long driver_data``"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:41
msgid "private driver data"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:42
msgid ""
"Adds a new dynamic pci device ID to this driver and causes the driver to "
"probe for all devices again.  **drv** must have been registered prior to "
"calling this function."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:47
msgid "Does GFP_KERNEL allocation."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:50
msgid "0 on success, -errno on failure."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:94
msgid "See if a PCI device matches a given pci_id table"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:100
#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:452
msgid "``const struct pci_device_id *ids``"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:95
msgid "array of PCI device ID structures to search in"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:96
msgid "the PCI device structure to match against."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:97
msgid ""
"Used by a driver to check whether a PCI device is in its list of supported "
"devices.  Returns the matching pci_device_id structure or ``NULL`` if there "
"is no match."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:101
msgid ""
"Deprecated; don't use this as it will not catch any dynamic IDs that a "
"driver might want to check for."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1452
msgid "register a new pci driver"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1453
msgid "the driver structure to register"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1455
#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:343
#: ../drivers/pci/hotplug/pci_hotplug_core.c:376
msgid "``struct module *owner``"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1454
msgid "owner module of drv"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1456
#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:344
#: ../drivers/pci/hotplug/pci_hotplug_core.c:377
msgid "``const char *mod_name``"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1455
msgid "module name string"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1456
msgid ""
"Adds the driver structure to the list of registered drivers. Returns a "
"negative value on error, otherwise 0. If no error occurred, the driver "
"remains registered even if no device was claimed during registration."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1482
msgid "unregister a pci driver"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1483
msgid "the driver structure to unregister"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1484
msgid ""
"Deletes the driver structure from the list of registered PCI drivers, gives "
"it a chance to clean up by calling its remove() function for each device it "
"was responsible for, and marks those devices as driverless."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1503
msgid "get the pci_driver of a device"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1504
msgid "the device to query"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1505
msgid ""
"Returns the appropriate pci_driver structure or ``NULL`` if there is no "
"registered driver for the device."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1551
msgid "increments the reference count of the pci device structure"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1552
msgid "the device being referenced"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1553
msgid "Each live reference to a device should be refcounted."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1555
msgid ""
"Drivers for PCI devices should normally record such references in their "
"probe() methods, when they bind to a device, and release them by calling "
"pci_dev_put(), in their disconnect() methods."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1559
msgid ""
"A pointer to the device with the incremented reference counter is returned."
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1571
msgid "release a use of the pci device structure"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1572
msgid "device that's been disconnected"
msgstr ""

#: ../../../driver-api/pci/pci:13: ../drivers/pci/pci-driver.c:1573
msgid ""
"Must be called when a user of a device is finished with it.  When the last "
"user of the device calls this function, the memory of the device is freed."
msgstr ""

#: ../../../driver-api/pci/pci:16: ../drivers/pci/remove.c:117
msgid "remove a PCI device and any children"
msgstr ""

#: ../../../driver-api/pci/pci:16: ../drivers/pci/remove.c:118
msgid "the device to remove"
msgstr ""

#: ../../../driver-api/pci/pci:16: ../drivers/pci/remove.c:119
msgid ""
"Remove a PCI device from the device lists, informing the drivers that the "
"device has been removed.  We also remove any subordinate buses and children "
"in a depth-first manner."
msgstr ""

#: ../../../driver-api/pci/pci:16: ../drivers/pci/remove.c:123
msgid ""
"For each device we remove, delete the device structure from the device "
"lists, remove the /proc entry, and notify userspace (/sbin/hotplug)."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:135
msgid "locate PCI bus from a given domain and bus number"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:141
#: ../drivers/pci/search.c:222
msgid "``int domain``"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:136
msgid "number of PCI domain to search"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:138
msgid "``int busnr``"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:137
msgid "number of desired PCI bus"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:138
msgid ""
"Given a PCI bus number and domain number, the desired PCI bus is located in "
"the global list of PCI buses.  If the bus is found, a pointer to its data "
"structure is returned.  If no bus is found, ``NULL`` is returned."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:160
msgid "begin or continue searching for a PCI bus"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:166
msgid "``const struct pci_bus *from``"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:161
msgid "Previous PCI bus found, or ``NULL`` for new search."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:162
msgid ""
"Iterates through the list of known PCI buses.  A new search is initiated by "
"passing ``NULL`` as the **from** argument.  Otherwise if **from** is not "
"``NULL``, searches continue from next device on the global list."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:183
msgid "locate PCI device for a given PCI slot"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:184
#: ../drivers/pci/search.c:218
msgid "PCI bus on which desired PCI device resides"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:185
#: ../drivers/pci/search.c:219
msgid ""
"encodes number of PCI slot in which the desired PCI device resides and the "
"logical device number within that slot in case of multi-function devices."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:188
msgid ""
"Given a PCI bus and slot/function number, the desired PCI device is located "
"in the list of PCI devices. If the device is found, its reference count is "
"increased and this function returns a pointer to its data structure.  The "
"caller must decrement the reference count by calling pci_dev_put(). If no "
"device is found, ``NULL`` is returned."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:216
msgid "locate PCI device for a given PCI domain (segment), bus, and slot"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:217
msgid "PCI domain/segment on which the PCI device resides."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:219
msgid "``unsigned int bus``"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:222
msgid ""
"Given a PCI domain, bus, and slot/function number, the desired PCI device is "
"located in the list of PCI devices. If the device is found, its reference "
"count is increased and this function returns a pointer to its data "
"structure.  The caller must decrement the reference count by calling "
"pci_dev_put().  If no device is found, ``NULL`` is returned."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:327
msgid ""
"begin or continue searching for a PCI device by vendor/subvendor/device/"
"subdevice id"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:328
#: ../drivers/pci/search.c:353
msgid "PCI vendor id to match, or ``PCI_ANY_ID`` to match all vendor ids"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:329
#: ../drivers/pci/search.c:354
msgid "PCI device id to match, or ``PCI_ANY_ID`` to match all device ids"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:331
msgid "``unsigned int ss_vendor``"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:330
msgid ""
"PCI subsystem vendor id to match, or ``PCI_ANY_ID`` to match all vendor ids"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:332
msgid "``unsigned int ss_device``"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:331
msgid ""
"PCI subsystem device id to match, or ``PCI_ANY_ID`` to match all device ids"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:333
#: ../drivers/pci/search.c:356 ../drivers/pci/search.c:389
#: ../drivers/pci/search.c:418
msgid "``struct pci_dev *from``"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:332
#: ../drivers/pci/search.c:355 ../drivers/pci/search.c:388
#: ../drivers/pci/search.c:417
msgid "Previous PCI device found in search, or ``NULL`` for new search."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:333
msgid ""
"Iterates through the list of known PCI devices.  If a PCI device is found "
"with a matching **vendor**, **device**, **ss_vendor** and **ss_device**, a "
"pointer to its device structure is returned, and the reference count to the "
"device is incremented.  Otherwise, ``NULL`` is returned.  A new search is "
"initiated by passing ``NULL`` as the **from** argument.  Otherwise if "
"**from** is not ``NULL``, searches continue from next device on the global "
"list. The reference count for **from** is always decremented if it is not "
"``NULL``."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:352
msgid "begin or continue searching for a PCI device by vendor/device id"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:356
msgid ""
"Iterates through the list of known PCI devices.  If a PCI device is found "
"with a matching **vendor** and **device**, the reference count to the device "
"is incremented and a pointer to its device structure is returned. Otherwise, "
"``NULL`` is returned.  A new search is initiated by passing ``NULL`` as the "
"**from** argument.  Otherwise if **from** is not ``NULL``, searches continue "
"from next device on the global list.  The reference count for **from** is "
"always decremented if it is not ``NULL``."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:386
msgid "begin or continue searching for a PCI device by class"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:387
msgid "search for a PCI device with this class designation"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:389
msgid ""
"Iterates through the list of known PCI devices.  If a PCI device is found "
"with a matching **class**, the reference count to the device is incremented "
"and a pointer to its device structure is returned. Otherwise, ``NULL`` is "
"returned. A new search is initiated by passing ``NULL`` as the **from** "
"argument. Otherwise if **from** is not ``NULL``, searches continue from next "
"device on the global list.  The reference count for **from** is always "
"decremented if it is not ``NULL``."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:415
msgid "searching for a PCI device by matching against the base class code only"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:416
msgid "search for a PCI device with this base class code"
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:418
msgid ""
"Iterates through the list of known PCI devices. If a PCI device is found "
"with a matching base class code, the reference count to the device is "
"incremented. See pci_match_one_device() to figure out how does this works. A "
"new search is initiated by passing ``NULL`` as the **from** argument. "
"Otherwise if **from** is not ``NULL``, searches continue from next device on "
"the global list. The reference count for **from** is always decremented if "
"it is not ``NULL``."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:427
msgid "A pointer to a matched PCI device, ``NULL`` Otherwise."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:446
msgid "Returns 1 if device matching the device list is present, 0 if not."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:447
msgid ""
"A pointer to a null terminated list of struct pci_device_id structures that "
"describe the type of PCI device the caller is trying to find."
msgstr ""

#: ../../../driver-api/pci/pci:19: ../drivers/pci/search.c:449
msgid ""
"Obvious fact: You do not have a reference to any device that might be found "
"by this function, so if that device is removed from the system right after "
"this function is finished, the value will be stale.  Use this function to "
"find devices that are usually built into a system, or for a general hint as "
"to if another device happens to be present at this specific moment in time."
msgstr ""

#: ../../../driver-api/pci/pci:22: ../drivers/pci/msi/msi.c:131
msgid "Generic IRQ chip callback to mask PCI/MSI interrupts"
msgstr ""

#: ../../../driver-api/pci/pci:22: ../drivers/pci/msi/msi.c:137
#: ../drivers/pci/msi/msi.c:149
msgid "``struct irq_data *data``"
msgstr ""

#: ../../../driver-api/pci/pci:22: ../drivers/pci/msi/msi.c:132
#: ../drivers/pci/msi/msi.c:144
msgid "pointer to irqdata associated to that interrupt"
msgstr ""

#: ../../../driver-api/pci/pci:22: ../drivers/pci/msi/msi.c:143
msgid "Generic IRQ chip callback to unmask PCI/MSI interrupts"
msgstr ""

#: ../../../driver-api/pci/pci:22: ../drivers/pci/msi/msi.c:475
msgid "Return the number of MSI vectors a device can send"
msgstr ""

#: ../../../driver-api/pci/pci:22: ../drivers/pci/msi/msi.c:476
msgid "device to report about"
msgstr ""

#: ../../../driver-api/pci/pci:22: ../drivers/pci/msi/msi.c:477
msgid ""
"This function returns the number of MSI vectors a device requested via "
"Multiple Message Capable register. It returns a negative errno if the device "
"is not capable sending MSI interrupts. Otherwise, the call succeeds and "
"returns a power of two, up to a maximum of 2^5 (32), according to the MSI "
"specification."
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:250
msgid "allocate a resource from a parent bus"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:251
msgid "PCI bus"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:252
msgid "resource to allocate"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:253
msgid "size of resource to allocate"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:255
msgid "``resource_size_t align``"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:254
msgid "alignment of resource to allocate"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:256
msgid "``resource_size_t min``"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:255
msgid "minimum /proc/iomem address to allocate"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:257
msgid "``unsigned long type_mask``"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:256
msgid "IORESOURCE_* type flags"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:258
msgid "``resource_alignf alignf``"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:257
msgid "resource alignment function"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:259
msgid "``void *alignf_data``"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:258
msgid "data argument for resource alignment function"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:259
msgid ""
"Given the PCI bus a device resides on, the size, minimum address, alignment "
"and type, try to find an acceptable resource allocation for a specific "
"device resource."
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:340
msgid "start driver for a single device"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:341
msgid "device to add"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:342
msgid "This adds add sysfs entries and start device drivers"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:381
msgid "start driver for PCI devices"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:387
msgid "``const struct pci_bus *bus``"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:382
msgid "bus to check for new devices"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:383
msgid "Start driver for PCI devices and add some sysfs entries."
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:450
#: ../drivers/pci/bus.c:471
msgid "walk devices on/under bus, calling callback."
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:456
#: ../drivers/pci/bus.c:477
msgid "``struct pci_bus *top``"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:451
#: ../drivers/pci/bus.c:472
msgid "bus whose devices should be walked"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:453
#: ../drivers/pci/bus.c:474
msgid "``int (*cb)(struct pci_dev *, void *)``"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:452
#: ../drivers/pci/bus.c:473
msgid "callback to be called for each device found"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:454
#: ../drivers/pci/bus.c:475
msgid "``void *userdata``"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:453
#: ../drivers/pci/bus.c:474
msgid "arbitrary pointer to be passed to callback"
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:454
msgid ""
"Walk the given bus, including any bridged devices on buses under this bus.  "
"Call the provided callback on each device found."
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:458
msgid ""
"We check the return of **cb** each time. If it returns anything other than "
"0, we break out."
msgstr ""

#: ../../../driver-api/pci/pci:25: ../drivers/pci/bus.c:475
msgid "Same semantics as pci_walk_bus(), but walks the bus in reverse order."
msgstr ""

#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:187
msgid "Set raw operations of pci bus"
msgstr ""

#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:188
msgid "pci bus struct"
msgstr ""

#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:190
msgid "``struct pci_ops *ops``"
msgstr ""

#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:189
msgid "new raw operations"
msgstr ""

#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:190
msgid "Return previous raw operations"
msgstr ""

#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:281
msgid "Lock PCI config reads/writes"
msgstr ""

#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:282
#: ../drivers/pci/access.c:302 ../drivers/pci/access.c:326
msgid "pci device struct"
msgstr ""

#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:283
msgid ""
"When access is locked, any userspace reads or writes to config space and "
"concurrent lock requests will sleep until access is allowed via "
"pci_cfg_access_unlock() again."
msgstr ""

#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:301
msgid "try to lock PCI config reads/writes"
msgstr ""

#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:303
msgid ""
"Same as pci_cfg_access_lock, but will return 0 if access is already locked, "
"1 otherwise. This function can be used from atomic contexts."
msgstr ""

#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:325
msgid "Unlock PCI config reads/writes"
msgstr ""

#: ../../../driver-api/pci/pci:28: ../drivers/pci/access.c:327
msgid "This function allows PCI config accesses to resume."
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:19
msgid "allocate an interrupt line for a PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:22
#: ../drivers/pci/irq.c:66
msgid "``unsigned int nr``"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:21
#: ../drivers/pci/irq.c:65
msgid "device-relative interrupt vector index (0-based)."
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:23
msgid "``irq_handler_t handler``"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:22
msgid ""
"Function to be called when the IRQ occurs. Primary handler for threaded "
"interrupts. If NULL and thread_fn != NULL the default primary handler is "
"installed."
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:27
msgid "``irq_handler_t thread_fn``"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:26
msgid ""
"Function called from the IRQ handler thread If NULL, no IRQ thread is created"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:29
#: ../drivers/pci/irq.c:67
msgid "``void *dev_id``"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:28
msgid "Cookie passed back to the handler function"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:30
msgid "``const char *fmt``"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:29
msgid "Printf-like format string naming the handler"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:31
msgid "``...``"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:1
msgid "variable arguments"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:30
msgid ""
"This call allocates interrupt resources and enables the interrupt line and "
"IRQ handling. From the point this call is made **handler** and **thread_fn** "
"may be invoked.  All interrupts requested using this function might be "
"shared."
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:34
msgid "**dev_id** must not be NULL and must be globally unique."
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:63
msgid "free an interrupt allocated with pci_request_irq"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:66
msgid "Device identity to free"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:67
msgid ""
"Remove an interrupt handler. The handler is removed and if the interrupt "
"line is no longer in use by any driver it is disabled.  The caller must "
"ensure the interrupt is disabled on the device before calling this function. "
"The function does not return until any executing interrupts for this IRQ "
"have completed."
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:73
msgid "This function must not be called from interrupt context."
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:122
msgid "swizzle INTx all the way to root bridge"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:125
msgid "``u8 *pinp``"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:124
msgid "pointer to the INTx pin value (1=INTA, 2=INTB, 3=INTD, 4=INTD)"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:125
msgid ""
"Perform INTx swizzling for a device.  This traverses through all PCI-to-PCI "
"bridges all the way up to a PCI root bus."
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:236
msgid "mask INTx on pending interrupt"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:238
msgid ""
"Check if the device dev has its INTx line asserted, mask it and return true "
"in that case. False is returned if no interrupt was pending."
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:249
msgid "unmask INTx if no interrupt is pending"
msgstr ""

#: ../../../driver-api/pci/pci:31: ../drivers/pci/irq.c:251
msgid ""
"Check if the device dev has its INTx line asserted, unmask it if not and "
"return true. False is returned and the mask remains active if there was "
"still an interrupt pending."
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:2332
msgid "Probe for PCIe relaxed ordering enable"
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:2334
msgid "Returns true if the device has enabled relaxed ordering attribute."
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:2857
msgid "Scan a PCI slot on a bus for devices"
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:2858
#: ../drivers/pci/probe.c:3488
msgid "PCI bus to scan"
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:2860
msgid "``int devfn``"
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:2859
msgid "slot number to scan (must have zero function)"
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:2860
msgid ""
"Scan a PCI slot on the specified PCI bus for devices, adding discovered "
"devices to the **bus->devices** list.  New devices will not have is_added "
"set."
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:2864
msgid "Returns the number of new devices found."
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:3200
msgid "Scan devices below a bus"
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:3201
msgid "Bus to scan for devices"
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:3202
msgid ""
"Scans devices below **bus** including subordinate buses. Returns new "
"subordinate number including all the found devices."
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:3487
msgid "Scan a PCI bus for devices"
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:3489
msgid ""
"Scan a PCI bus and child buses for new devices, add them, and enable them."
msgstr ""

#: ../../../driver-api/pci/pci:34: ../drivers/pci/probe.c:3492
msgid "Returns the max number of subordinate bus discovered."
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:189
msgid "create or increment refcount for physical PCI slot"
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:195
msgid "``struct pci_bus *parent``"
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:190
msgid "struct pci_bus of parent bridge"
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:192
msgid "``int slot_nr``"
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:191
msgid "PCI_SLOT(pci_dev->devfn) or -1 for placeholder"
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:192
msgid "user visible string presented in /sys/bus/pci/slots/<name>"
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:194
msgid "``struct hotplug_slot *hotplug``"
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:193
msgid "set if caller is hotplug driver, NULL otherwise"
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:194
msgid ""
"PCI slots have first class attributes such as address, speed, width, and a :"
"c:type:`struct pci_slot <pci_slot>` is used to manage them. This interface "
"will either return a new :c:type:`struct pci_slot <pci_slot>` to the caller, "
"or if the pci_slot already exists, its refcount will be incremented."
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:199
msgid "Slots are uniquely identified by a **pci_bus**, **slot_nr** tuple."
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:201
msgid ""
"There are known platforms with broken firmware that assign the same name to "
"multiple slots. Workaround these broken platforms by renaming the slots on "
"behalf of the caller. If firmware assigns name N to multiple slots:"
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:206
msgid ""
"The first slot is assigned N The second slot is assigned N-1 The third slot "
"is assigned N-2 etc."
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:211
msgid ""
"Placeholder slots: In most cases, **pci_bus**, **slot_nr** will be "
"sufficient to uniquely identify a slot. There is one notable exception - "
"pSeries (rpaphp), where the **slot_nr** cannot be determined until a device "
"is actually inserted into the slot. In this scenario, the caller may pass -1 "
"for **slot_nr**."
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:217
msgid ""
"The following semantics are imposed when the caller passes **slot_nr** == "
"-1. First, we no longer check for an existing ``struct`` pci_slot, as there "
"may be many slots with **slot_nr** of -1.  The other change in semantics is "
"user-visible, which is the 'address' parameter presented in sysfs will "
"consist solely of a dddd:bb tuple, where dddd is the PCI domain of the "
"``struct`` pci_bus and bb is the bus number. In other words, the devfn of "
"the 'placeholder' slot will not be displayed."
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:309
msgid "decrement refcount for physical PCI slot"
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:310
msgid "struct pci_slot to decrement"
msgstr ""

#: ../../../driver-api/pci/pci:37: ../drivers/pci/slot.c:311
msgid ""
"``struct`` pci_slot is refcounted, so destroying them is really easy; we "
"just call kobject_put on its kobj and let our release methods do the rest."
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:22
msgid "Convert size in bytes to PCI BAR Size"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:28
msgid "``u64 bytes``"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:23
msgid "size in bytes"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:24
msgid ""
"Convert size in bytes to encoded BAR Size in Resizable BAR Capability (PCIe "
"r6.2, sec. 7.8.6.3)."
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:28
#: ../drivers/pci/rebar.c:42
msgid "encoded BAR Size as defined in the PCIe spec (0=1MB, 31=128TB)"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:41
msgid "Convert encoded BAR Size to size in bytes"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:47
#: ../drivers/pci/rebar.c:134 ../drivers/pci/rebar.c:279
#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1330
msgid "``int size``"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:44
msgid "BAR size in bytes"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:99
msgid "get possible sizes for Resizable BAR"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:100
#: ../drivers/pci/rebar.c:131 ../drivers/pci/rebar.c:151
#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:237
#: ../drivers/pci/tph.c:281 ../drivers/pci/tph.c:343 ../drivers/pci/tph.c:365
msgid "PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:101
#: ../drivers/pci/rebar.c:152
msgid "BAR to query"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:102
msgid "Get the possible sizes of a resizable BAR as bitmask."
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:105
msgid ""
"A bitmask of possible sizes (bit 0=1MB, bit 31=128TB), or ``0`` if BAR isn't "
"resizable."
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:130
msgid "check if size is supported for BAR"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:132
msgid "BAR to check"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:133
msgid "encoded size as defined in the PCIe spec (0=1MB, 31=128TB)"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:135
msgid ""
"``true`` if **bar** is resizable and **size** is supported, otherwise "
"``false``."
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:150
msgid "get the maximum supported size of a BAR"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:153
msgid "Get the largest supported size of a resizable BAR as a size."
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:156
msgid ""
"the encoded maximum BAR size as defined in the PCIe spec (0=1MB, 31=128TB), "
"or ``-NOENT`` on error."
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:275
msgid "reconfigure a Resizable BAR and resources"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:278
#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1329
#: ../drivers/pci/iov.c:1358
msgid "``int resno``"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:277
msgid "index of the BAR to be resized"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:278
#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1329
msgid "new size as defined in the spec (0=1MB, 31=128TB)"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:280
msgid "``int exclude_bars``"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:279
msgid "a mask of BARs that should not be released"
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:280
msgid ""
"Reconfigure **resno** to **size** and re-run resource assignment algorithm "
"with the new size."
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:283
msgid ""
"Prior to resize, release **dev** resources that share a bridge window with "
"**resno**.  This unpins the bridge window resource to allow changing it."
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:286
msgid ""
"The caller may prevent releasing a particular BAR by providing "
"**exclude_bars** mask, but this may result in the resize operation failing "
"due to insufficient space."
msgstr ""

#: ../../../driver-api/pci/pci:40: ../drivers/pci/rebar.c:291
msgid ""
"0 on success, or negative on error. In case of an error, the resources are "
"restored to their original places."
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:16
msgid "enable ROM decoding for a PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:17
msgid "PCI device to enable"
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:18
msgid ""
"Enable ROM decoding on **dev**.  This involves simply turning on the last "
"bit of the PCI ROM BAR.  Note that some cards may share address decoders "
"between the ROM and other resources, so enabling it may disable access to "
"MMIO registers or other card memory."
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:52
msgid "disable ROM decoding for a PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:53
msgid "PCI device to disable"
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:54
msgid ""
"Disable ROM decoding on a PCI device by turning off the last bit in the ROM "
"BAR."
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:126
msgid "map a PCI ROM to kernel space"
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:127
#: ../drivers/pci/rom.c:182
msgid "pointer to pci device struct"
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:129
msgid "``size_t *size``"
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:128
msgid "pointer to receive size of pci window over ROM"
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:130
msgid "kernel virtual pointer to image of ROM"
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:131
msgid ""
"Map a PCI ROM into kernel space. If ROM is boot video ROM, the shadow BIOS "
"copy will be returned instead of the actual ROM."
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:181
msgid "unmap the ROM from kernel space"
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:184
msgid "``void __iomem *rom``"
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:183
msgid "virtual address of the previous mapping"
msgstr ""

#: ../../../driver-api/pci/pci:43: ../drivers/pci/rom.c:184
msgid "Remove a mapping of a previously mapped ROM"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:55
msgid "Return the drvdata of a PF"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:56
msgid "VF pci_dev"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:58
msgid "``struct pci_driver *pf_driver``"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:57
msgid "Device driver required to own the PF"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:58
msgid ""
"This must be called from a context that ensures that a VF driver is "
"attached. The value returned is invalid once the VF driver completes its "
"remove() callback."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:62
msgid ""
"Locking is achieved by the driver core. A VF driver cannot be probed until "
"pci_enable_sriov() is called and pci_disable_sriov() does not return until "
"all VF drivers have completed their remove()."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:66
msgid ""
"The PF driver must call pci_disable_sriov() before it begins to destroy the "
"drvdata."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1154
msgid "enable the SR-IOV capability"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1157
#: ../drivers/pci/iov.c:1293
msgid "``int nr_virtfn``"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1156
msgid "number of virtual functions to enable"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1157
msgid "Returns 0 on success, or negative on failure."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1172
msgid "disable the SR-IOV capability"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1187
msgid "return number of VFs associated with a PF device_release_driver"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1189
msgid "Returns number of VFs, or 0 if SR-IOV is not enabled."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1202
msgid "returns number of VFs are assigned to a guest"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1204
msgid ""
"Returns number of VFs belonging to this device that are assigned to a guest. "
"If device is not a physical function returns 0."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1243
msgid "reduce the TotalVFs available"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1244
#: ../drivers/pci/iov.c:1274
msgid "the PCI PF device"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1246
msgid "``u16 numvfs``"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1245
msgid "number that should be used for TotalVFs supported"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1246
msgid ""
"Should be called from PF driver's probe routine with device's mutex held."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1249
msgid ""
"Returns 0 if PF is an SRIOV-capable device and value of numvfs valid. If not "
"a PF return -ENOSYS; if numvfs is invalid return -EINVAL; if VFs already "
"enabled, return -EBUSY."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1273
msgid "get total VFs supported on this device"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1275
msgid ""
"For a PCIe device with SRIOV support, return the PCIe SRIOV capability value "
"of TotalVFs or the value of driver_max_VFs if the driver reduced it.  "
"Otherwise 0."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1290
msgid "helper to configure SR-IOV"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1292
msgid "number of virtual functions to enable, 0 to disable"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1293
msgid ""
"Enable or disable SR-IOV for devices that don't require any PF setup before "
"enabling SR-IOV.  Return value is negative on error, or number of VFs "
"allocated on success."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1326
msgid "set a new size for a VF BAR"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1328
#: ../drivers/pci/iov.c:1357
msgid "the resource number"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1330
msgid ""
"Set the new size of a VF BAR that supports VF resizable BAR capability. "
"Unlike pci_resize_resource(), this does not cause the resource that reserves "
"the MMIO space (originally up to total_VFs) to be resized, which means that "
"following calls to pci_enable_sriov() can fail if the resources no longer "
"fit."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1337
msgid "0 on success, or negative on failure."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1355
msgid "get VF BAR sizes allowing to create up to num_vfs"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1359
msgid "``int num_vfs``"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1358
msgid "number of VFs"
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1359
msgid ""
"Get the sizes of a VF resizable BAR that can accommodate **num_vfs** within "
"the currently assigned size of the resource **resno**."
msgstr ""

#: ../../../driver-api/pci/pci:46: ../drivers/pci/iov.c:1363
msgid ""
"A bitmask of sizes in format defined in the spec (bit 0=1MB, bit 31=128TB)."
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:921
msgid "read byte(s) from legacy I/O port space"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:927
#: ../drivers/pci/pci-sysfs.c:952 ../drivers/pci/pci-sysfs.c:977
#: ../drivers/pci/pci-sysfs.c:997 ../drivers/pci/pci-sysfs.c:1337
#: ../drivers/pci/pci-sysfs.c:1362
msgid "``struct file *filp``"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:922
#: ../drivers/pci/pci-sysfs.c:947 ../drivers/pci/pci-sysfs.c:972
#: ../drivers/pci/pci-sysfs.c:992
msgid "open sysfs file"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:924
#: ../drivers/pci/pci-sysfs.c:949 ../drivers/pci/pci-sysfs.c:974
#: ../drivers/pci/pci-sysfs.c:994 ../drivers/pci/pci-sysfs.c:1104
#: ../drivers/pci/pci-sysfs.c:1334 ../drivers/pci/pci-sysfs.c:1359
msgid "``struct kobject *kobj``"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:923
#: ../drivers/pci/pci-sysfs.c:948
msgid "kobject corresponding to file to read from"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:925
#: ../drivers/pci/pci-sysfs.c:950 ../drivers/pci/pci-sysfs.c:1335
#: ../drivers/pci/pci-sysfs.c:1360
msgid "``const struct bin_attribute *bin_attr``"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:924
#: ../drivers/pci/pci-sysfs.c:949 ../drivers/pci/pci-sysfs.c:974
#: ../drivers/pci/pci-sysfs.c:994 ../drivers/pci/pci-sysfs.c:1334
#: ../drivers/pci/pci-sysfs.c:1359
msgid "struct bin_attribute for this file"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:926
#: ../drivers/pci/pci-sysfs.c:951 ../drivers/pci/pci-sysfs.c:1336
#: ../drivers/pci/pci-sysfs.c:1361
msgid "``char *buf``"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:925
msgid "buffer to store results"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:927
#: ../drivers/pci/pci-sysfs.c:952 ../drivers/pci/pci-sysfs.c:1337
#: ../drivers/pci/pci-sysfs.c:1362
msgid "``loff_t off``"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:926
#: ../drivers/pci/pci-sysfs.c:951
msgid "offset into legacy I/O port space"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:928
#: ../drivers/pci/pci-sysfs.c:953 ../drivers/pci/pci-sysfs.c:1338
#: ../drivers/pci/pci-sysfs.c:1363
msgid "``size_t count``"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:927
#: ../drivers/pci/pci-sysfs.c:1362
msgid "number of bytes to read"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:928
msgid ""
"Reads 1, 2, or 4 bytes from legacy I/O port space using an arch specific "
"callback routine (pci_legacy_read)."
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:946
msgid "write byte(s) to legacy I/O port space"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:950
msgid "buffer containing value to be written"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:952
msgid "number of bytes to write"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:953
msgid ""
"Writes 1, 2, or 4 bytes from legacy I/O port space using an arch specific "
"callback routine (pci_legacy_write)."
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:971
msgid "map legacy PCI memory into user memory space"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:973
#: ../drivers/pci/pci-sysfs.c:993
msgid "kobject corresponding to device to be mapped"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:975
#: ../drivers/pci/pci-sysfs.c:995 ../drivers/pci/pci-sysfs.c:1101
msgid "``const struct bin_attribute *attr``"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:976
#: ../drivers/pci/pci-sysfs.c:996 ../drivers/pci/pci-sysfs.c:1102
msgid "``struct vm_area_struct *vma``"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:975
#: ../drivers/pci/pci-sysfs.c:995
msgid "struct vm_area_struct passed to mmap"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:976
msgid ""
"Uses an arch specific callback, pci_mmap_legacy_mem_page_range, to mmap "
"legacy memory space (first meg of bus space) into application virtual memory "
"space."
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:991
msgid "map legacy PCI IO into user memory space"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:996
msgid ""
"Uses an arch specific callback, pci_mmap_legacy_io_page_range, to mmap "
"legacy IO space (first meg of bus space) into application virtual memory "
"space. Returns -ENOSYS if the operation isn't supported"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1011
msgid "adjustment of legacy file attributes"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1017
#: ../drivers/pci/pci-sysfs.c:1029
msgid "``struct pci_bus *b``"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1012
#: ../drivers/pci/pci-sysfs.c:1024
msgid "bus to create files under"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1014
msgid "``enum pci_mmap_state mmap_type``"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1013
msgid "I/O port or memory"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1014
msgid "Stub implementation. Can be overridden by arch if necessary."
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1023
msgid "create legacy I/O port and memory files"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1025
msgid ""
"Some platforms allow access to legacy I/O port and ISA memory space on a per-"
"bus basis.  This routine creates the files and ties them into their "
"associated read, write and mmap files from pci-sysfs.c"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1029
msgid ""
"On error unwind, but don't propagate the error to the caller as it is ok to "
"set up the PCI bus without these files."
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1098
msgid "map a PCI resource into user memory space"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1099
msgid "kobject for mapping"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1100
msgid "struct bin_attribute for the file being mapped"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1101
msgid "struct vm_area_struct passed into the mmap"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1103
msgid "``int write_combine``"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1102
msgid "1 for write_combine mapping"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1103
msgid ""
"Use the regular PCI mapping routines to map a PCI resource into userspace."
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1208
msgid "cleanup resource files"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1209
msgid "dev to cleanup"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1210
msgid ""
"If we created resource files for **pdev**, remove them from sysfs and free "
"their resources."
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1292
msgid "create resource files in sysfs for **dev**"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1293
msgid "dev in question"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1294
msgid ""
"Walk the resources in **pdev** creating files for each resource available."
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1331
msgid "used to enable access to the PCI ROM display"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1332
#: ../drivers/pci/pci-sysfs.c:1357
msgid "sysfs file"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1333
#: ../drivers/pci/pci-sysfs.c:1358
msgid "kernel object handle"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1335
msgid "user input"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1336
#: ../drivers/pci/pci-sysfs.c:1361
msgid "file offset"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1337
msgid "number of byte in input"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1338
msgid "writing anything except 0 enables it"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1356
msgid "read a PCI ROM"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1360
msgid "where to put the data we read from the ROM"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1363
msgid ""
"Put **count** bytes starting at **off** into **buf** from the ROM in the PCI "
"device corresponding to **kobj**."
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1700
msgid "cleanup PCI specific sysfs files"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1701
msgid "device whose entries we should free"
msgstr ""

#: ../../../driver-api/pci/pci:49: ../drivers/pci/pci-sysfs.c:1702
msgid "Cleanup when **pdev** is removed from sysfs."
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:159
msgid "Return the device's ST table location"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:162
msgid ""
"PCI_TPH_LOC_NONE - Not present PCI_TPH_LOC_CAP  - Located in the TPH "
"Requester Extended Capability PCI_TPH_LOC_MSIX - Located in the MSI-X Table"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:235
msgid ""
"Retrieve Steering Tag for a target memory associated with a specific CPU"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:239
msgid "``enum tph_mem_type mem_type``"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:238
msgid "target memory type (volatile or persistent RAM)"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:240
msgid "``unsigned int cpu_uid``"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:239
msgid "associated CPU id"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:241
msgid "``u16 *tag``"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:240
msgid "Steering Tag to be returned"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:241
msgid ""
"Return the Steering Tag for a target memory that is associated with a "
"specific CPU as indicated by cpu_uid."
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:245
#: ../drivers/pci/tph.c:289
msgid "0 if success, otherwise negative value (-errno)"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:280
msgid "Set Steering Tag in the ST table entry"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:283
msgid "``unsigned int index``"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:282
msgid "ST table entry index"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:284
msgid "``u16 tag``"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:283
msgid "Steering Tag to be written"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:284
msgid ""
"Figure out the proper location of ST table, either in the MSI-X table or in "
"the TPH Extended Capability space, and write the Steering Tag into the ST "
"entry pointed by index."
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:342
msgid "Turn off TPH support for device"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:345
msgid "none"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:364
msgid "Enable TPH support for device using a specific ST mode"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:367
msgid "``int mode``"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:366
msgid "ST mode to enable. Current supported modes include:"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:367
msgid "PCI_TPH_ST_NS_MODE: NO ST Mode"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:368
msgid "PCI_TPH_ST_IV_MODE: Interrupt Vector Mode"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:369
msgid "PCI_TPH_ST_DS_MODE: Device Specific Mode"
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:371
msgid ""
"Check whether the mode is actually supported by the device before enabling "
"and return an error if not. Additionally determine what types of requests, "
"TPH or extended TPH, can be issued by the device based on its TPH requester "
"capability and the Root Port's completer capability."
msgstr ""

#: ../../../driver-api/pci/pci:52: ../drivers/pci/tph.c:377
msgid "0 on success, otherwise negative value (-errno)"
msgstr ""

#: ../../../driver-api/pci/pci.rst:56
msgid "PCI Hotplug Support Library"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:337
msgid "register a hotplug_slot with the PCI hotplug subsystem"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:343
#: ../drivers/pci/hotplug/pci_hotplug_core.c:376
#: ../drivers/pci/hotplug/pci_hotplug_core.c:421
#: ../drivers/pci/hotplug/pci_hotplug_core.c:450
#: ../drivers/pci/hotplug/pci_hotplug_core.c:464
#: ../drivers/pci/hotplug/pci_hotplug_core.c:479
msgid "``struct hotplug_slot *slot``"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:338
msgid "pointer to the :c:type:`struct hotplug_slot <hotplug_slot>` to register"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:339
#: ../drivers/pci/hotplug/pci_hotplug_core.c:372
msgid "bus this slot is on"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:341
#: ../drivers/pci/hotplug/pci_hotplug_core.c:374
msgid "``int devnr``"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:340
msgid "device number"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:341
#: ../drivers/pci/hotplug/pci_hotplug_core.c:374
msgid "name registered with kobject core"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:342
#: ../drivers/pci/hotplug/pci_hotplug_core.c:375
msgid "caller module owner"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:343
#: ../drivers/pci/hotplug/pci_hotplug_core.c:376
msgid "caller module name"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:344
msgid ""
"Prepares a hotplug slot for in-kernel use and immediately publishes it to "
"user space in one go.  Drivers may alternatively carry out the two steps "
"separately by invoking pci_hp_initialize() and pci_hp_add()."
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:348
msgid "Returns 0 if successful, anything else for an error."
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:370
msgid "prepare hotplug slot for in-kernel use"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:371
msgid ""
"pointer to the :c:type:`struct hotplug_slot <hotplug_slot>` to initialize"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:373
msgid "slot number"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:377
msgid ""
"Allocate and fill in a PCI slot for use by a hotplug driver.  Once this has "
"been called, the driver may invoke hotplug_slot_name() to get the slot's "
"unique name.  The driver must be prepared to handle a ->reset_slot callback "
"from this point on."
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:382
#: ../drivers/pci/hotplug/pci_hotplug_core.c:421
msgid "Returns 0 on success or a negative int on error."
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:415
msgid "publish hotplug slot to user space"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:416
msgid "pointer to the :c:type:`struct hotplug_slot <hotplug_slot>` to publish"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:417
msgid ""
"Make a hotplug slot's sysfs interface available and inform user space of its "
"addition by sending a uevent.  The hotplug driver must be prepared to handle "
"all :c:type:`struct hotplug_slot_ops <hotplug_slot_ops>` callbacks from this "
"point on."
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:444
msgid "deregister a hotplug_slot with the PCI hotplug subsystem"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:445
msgid ""
"pointer to the :c:type:`struct hotplug_slot <hotplug_slot>` to deregister"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:446
msgid ""
"The **slot** must have been registered with the pci hotplug subsystem "
"previously with a call to pci_hp_register()."
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:458
msgid "unpublish hotplug slot from user space"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:459
msgid ""
"pointer to the :c:type:`struct hotplug_slot <hotplug_slot>` to unpublish"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:460
msgid "Remove a hotplug slot's sysfs interface."
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:473
msgid "remove hotplug slot from in-kernel use"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:474
msgid "pointer to the :c:type:`struct hotplug_slot <hotplug_slot>` to destroy"
msgstr ""

#: ../../../driver-api/pci/pci:58:
#: ../drivers/pci/hotplug/pci_hotplug_core.c:475
msgid ""
"Destroy a PCI slot used by a hotplug driver.  Once this has been called, the "
"driver may no longer invoke hotplug_slot_name() to get the slot's unique "
"name.  The driver no longer needs to handle a ->reset_slot callback from "
"this point on."
msgstr ""
