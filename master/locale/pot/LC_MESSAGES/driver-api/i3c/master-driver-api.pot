# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-16 08:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/i3c/master-driver-api.rst:5
msgid "I3C master controller driver API"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:30
msgid "Lock the bus for a maintenance operation"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:34
#: ../drivers/i3c/master.c:55 ../drivers/i3c/master.c:69
#: ../drivers/i3c/master.c:90 ../drivers/i3c/master.c:953
#: ../drivers/i3c/master.c:1027 ../drivers/i3c/master.c:1082
#: ../drivers/i3c/master.c:1103 ../drivers/i3c/master.c:1124
#: ../drivers/i3c/master.c:1775 ../drivers/i3c/master.c:1825
#: ../drivers/i3c/master.c:1841 ../drivers/i3c/master.c:1893
#: ../drivers/i3c/master.c:1913 ../drivers/i3c/master.c:2000
#: ../drivers/i3c/master.c:2223 ../drivers/i3c/master.c:2749
#: ../drivers/i3c/master.c:2807 ../drivers/i3c/master.c:2837
#: ../drivers/i3c/master.c:2898 ../drivers/i3c/master.c:2925
#: ../drivers/i3c/master.c:2963 ../drivers/i3c/master.c:3118
#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:554 ../include/linux/i3c/master.h:565
#: ../include/linux/i3c/master.h:632 ../include/linux/i3c/master.h:645
#: ../include/linux/i3c/master.h:660 ../include/linux/i3c/master.h:673
#: ../include/linux/i3c/master.h:688 ../include/linux/i3c/master.h:700
#: ../include/linux/i3c/master.h:712
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:36
#: ../drivers/i3c/master.c:57 ../drivers/i3c/master.c:71
#: ../drivers/i3c/master.c:92
msgid "``struct i3c_bus *bus``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:31
#: ../drivers/i3c/master.c:66
msgid "I3C bus to take the lock on"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:33
#: ../drivers/i3c/master.c:55 ../drivers/i3c/master.c:68
#: ../drivers/i3c/master.c:89 ../drivers/i3c/master.c:953
#: ../drivers/i3c/master.c:1027 ../drivers/i3c/master.c:1083
#: ../drivers/i3c/master.c:1104 ../drivers/i3c/master.c:1123
#: ../drivers/i3c/master.c:1775 ../drivers/i3c/master.c:1824
#: ../drivers/i3c/master.c:1845 ../drivers/i3c/master.c:1892
#: ../drivers/i3c/master.c:1913 ../drivers/i3c/master.c:1999
#: ../drivers/i3c/master.c:2223 ../drivers/i3c/master.c:2749
#: ../drivers/i3c/master.c:2806 ../drivers/i3c/master.c:2837
#: ../drivers/i3c/master.c:2897 ../drivers/i3c/master.c:2925
#: ../drivers/i3c/master.c:2968 ../drivers/i3c/master.c:3117
#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:49 ../include/linux/i3c/master.h:70
#: ../include/linux/i3c/master.h:87 ../include/linux/i3c/master.h:110
#: ../include/linux/i3c/master.h:148 ../include/linux/i3c/master.h:184
#: ../include/linux/i3c/master.h:211 ../include/linux/i3c/master.h:234
#: ../include/linux/i3c/master.h:330 ../include/linux/i3c/master.h:362
#: ../include/linux/i3c/master.h:527 ../include/linux/i3c/master.h:555
#: ../include/linux/i3c/master.h:566 ../include/linux/i3c/master.h:646
#: ../include/linux/i3c/master.h:674
msgid "**Description**"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:32
msgid ""
"This function takes the bus lock so that no other operations can occur on "
"the bus. This is needed for all kind of bus maintenance operation, like - "
"enabling/disabling slave events - re-triggering DAA - changing the dynamic "
"address of a device - relinquishing mastership - ..."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:40
msgid ""
"The reason for this kind of locking is that we don't want drivers and core "
"logic to rely on I3C device information that could be changed behind their "
"back."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:51
msgid "Release the bus lock after a maintenance operation"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:53
#: ../drivers/i3c/master.c:87
msgid "I3C bus to release the lock on"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:54
msgid ""
"Should be called when the bus maintenance operation is done. See "
"i3c_bus_maintenance_lock() for more details on what these maintenance "
"operations are."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:65
msgid "Lock the bus for a normal operation"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:67
msgid ""
"This function takes the bus lock for any operation that is not a maintenance "
"operation (see i3c_bus_maintenance_lock() for a non-exhaustive list of "
"maintenance operations). Basically all communications with I3C devices are "
"normal operations (HDR, SDR transfers or CCC commands that do not change bus "
"state or I3C dynamic address)."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:73
msgid ""
"Note that this lock is not guaranteeing serialization of normal operations. "
"In other words, transfer requests passed to the I3C master can be submitted "
"in parallel and I3C master drivers have to use their own locking to make "
"sure two different communications are not inter-mixed, or access to the "
"output/input queue is not done while the engine is busy."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:86
msgid "Release the bus lock after a normal operation"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:88
msgid ""
"Should be called when a normal operation is done. See "
"i3c_bus_normaluse_lock() for more details on what these normal operations "
"are."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:949
msgid "get a free address on the bus"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:955
#: ../drivers/i3c/master.c:1029 ../drivers/i3c/master.c:1084
#: ../drivers/i3c/master.c:1105 ../drivers/i3c/master.c:1126
#: ../drivers/i3c/master.c:1777 ../drivers/i3c/master.c:1827
#: ../drivers/i3c/master.c:1915 ../drivers/i3c/master.c:2002
#: ../drivers/i3c/master.c:2225 ../drivers/i3c/master.c:2965
#: ../drivers/i3c/master.c:3120 ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:714
msgid "``struct i3c_master_controller *master``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:950
msgid "I3C master object"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:952
msgid "``u8 start_addr``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:951
msgid "where to start searching"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:952
#: ../drivers/i3c/master.c:1032 ../drivers/i3c/master.c:1085
#: ../drivers/i3c/master.c:1106 ../drivers/i3c/master.c:1132
#: ../drivers/i3c/master.c:2229
msgid "This function must be called with the bus lock held in write mode."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:954
#: ../drivers/i3c/master.c:1034 ../drivers/i3c/master.c:1087
#: ../drivers/i3c/master.c:1108 ../drivers/i3c/master.c:1134
#: ../drivers/i3c/master.c:1783 ../drivers/i3c/master.c:1827
#: ../drivers/i3c/master.c:1846 ../drivers/i3c/master.c:1927
#: ../drivers/i3c/master.c:2024 ../drivers/i3c/master.c:2231
#: ../drivers/i3c/master.c:2838 ../drivers/i3c/master.c:2900
#: ../drivers/i3c/master.c:2976 ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:632 ../include/linux/i3c/master.h:660
#: ../include/linux/i3c/master.h:687 ../include/linux/i3c/master.h:699
#: ../include/linux/i3c/master.h:711
msgid "**Return**"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:955
msgid ""
"the first free address starting at **start_addr** (included) or -ENOMEM if "
"there's no more address available."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1023
msgid "start a DAA (Dynamic Address Assignment) procedure"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1025
#: ../drivers/i3c/master.c:1079 ../drivers/i3c/master.c:1100
#: ../drivers/i3c/master.c:1121 ../drivers/i3c/master.c:1910
#: ../drivers/i3c/master.c:2220 ../drivers/i3c/master.c:2960
#: ../drivers/i3c/master.c:3115
msgid "master used to send frames on the bus"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1026
msgid "Send a ENTDAA CCC command to start a DAA procedure."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1028
msgid ""
"Note that this function only sends the ENTDAA CCC command, all the logic "
"behind dynamic address assignment has to be handled in the I3C master driver."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1035
#: ../drivers/i3c/master.c:1088 ../drivers/i3c/master.c:1109
#: ../drivers/i3c/master.c:1135
msgid ""
"0 in case of success, a positive I3C error code if the error is one of the "
"official Mx error codes, and a negative error code otherwise."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1078
msgid "send a DISEC CCC command"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1081
#: ../drivers/i3c/master.c:1102 ../drivers/i3c/master.c:2222
msgid "``u8 addr``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1080
#: ../drivers/i3c/master.c:1101
msgid "a valid I3C slave address or ``I3C_BROADCAST_ADDR``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1082
#: ../drivers/i3c/master.c:1103
msgid "``u8 evts``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1081
#: ../drivers/i3c/master.c:1102
msgid "events to disable"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1082
msgid ""
"Send a DISEC CCC command to disable some or all events coming from a "
"specific slave, or all devices if **addr** is ``I3C_BROADCAST_ADDR``."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1099
msgid "send an ENEC CCC command"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1103
msgid ""
"Sends an ENEC CCC command to enable some or all events coming from a "
"specific slave, or all devices if **addr** is ``I3C_BROADCAST_ADDR``."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1120
msgid "send a DEFSLVS CCC command"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1122
msgid ""
"Send a DEFSLVS CCC command containing all the devices known to the "
"**master**. This is useful when you have secondary masters on the bus to "
"propagate device information."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1126
msgid ""
"This should be called after all I3C devices have been discovered (in other "
"words, after the DAA procedure has finished) and instantiated in :c:type:"
"`i3c_master_controller_ops->bus_init\\(\\) <i3c_master_controller_ops>`. It "
"should also be called if a master ACKed an Hot-Join request and assigned a "
"dynamic address to the device joining the bus."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1771
msgid "Dynamic Address Assignment (extended version)"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1772
msgid "controller"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1774
msgid "``bool rstdaa``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1773
msgid "whether to first perform Reset of Dynamic Addresses (RSTDAA)"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1774
msgid ""
"Perform Dynamic Address Assignment with optional support for System "
"Hibernation (**rstdaa** is true)."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1777
msgid ""
"After System Hibernation, Dynamic Addresses can have been reassigned at boot "
"time to different values. A simple strategy is followed to handle that. "
"Perform a Reset of Dynamic Addresses (RSTDAA) followed by the normal DAA "
"procedure which has provision for reassigning addresses that differ from the "
"previously recorded addresses."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1784
#: ../drivers/i3c/master.c:1828 ../drivers/i3c/master.c:2025
#: ../drivers/i3c/master.c:2232
msgid "a 0 in case of success, an negative error code otherwise."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1821
msgid "do a DAA (Dynamic Address Assignment)"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1822
msgid "master doing the DAA"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1823
msgid ""
"This function instantiates I3C device objects and adds them to the I3C "
"device list. All device information is automatically retrieved using "
"standard CCC commands."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1837
msgid "Map buffer for single DMA transfer"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1843
msgid "``struct device *dev``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1838
#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:574
msgid "device object of a device doing DMA"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1840
msgid "``void *buf``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1839
#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:575
msgid "destination/source buffer for DMA"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1841
msgid "``size_t len``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1840
#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:576
msgid "length of transfer"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1842
msgid "``bool force_bounce``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1841
msgid ""
"true, force to use a bounce buffer, false, function will auto check is a "
"bounce buffer required"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1844
msgid "``enum dma_data_direction dir``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1843
#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:579
msgid "DMA direction"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1844
msgid "Map buffer for a DMA transfer and allocate a bounce buffer if required."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1847
msgid "I3C DMA transfer descriptor or NULL in case of error."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1889
msgid "Unmap buffer after DMA"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1895
msgid "``struct i3c_dma *dma_xfer``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1890
#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:572
msgid "DMA transfer and mapping descriptor"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1891
msgid "Unmap buffer and cleanup DMA transfer descriptor."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1909
msgid "set master device information"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1912
msgid "``const struct i3c_device_info *info``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1911
msgid "I3C device information"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1912
msgid ""
"Set master device info. This should be called from :c:type:"
"`i3c_master_controller_ops->bus_init\\(\\) <i3c_master_controller_ops>`."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1915
msgid ""
"Not all :c:type:`i3c_device_info` fields are meaningful for a master device. "
"Here is a list of fields that should be properly filled:"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1918
msgid ":c:type:`i3c_device_info->dyn_addr <i3c_device_info>`"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1919
msgid ":c:type:`i3c_device_info->bcr <i3c_device_info>`"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1920
msgid ":c:type:`i3c_device_info->dcr <i3c_device_info>`"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1921
msgid ":c:type:`i3c_device_info->pid <i3c_device_info>`"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1922
msgid ""
":c:type:`i3c_device_info->hdr_cap <i3c_device_info>` if ``I3C_BCR_HDR_CAP`` "
"bit is set in :c:type:`i3c_device_info->bcr <i3c_device_info>`"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1925
msgid ""
"This function must be called with the bus lock held in maintenance mode."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1928
msgid ""
"0 if **info** contains valid information (not every piece of information can "
"be checked, but we can at least make sure **info->dyn_addr** and **info-"
">bcr** are correct), -EINVAL otherwise."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1996
msgid "initialize an I3C bus"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1997
msgid "main master initializing the bus"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:1998
msgid ""
"This function is following all initialisation steps described in the I3C "
"specification:"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2001
msgid ""
"Attach I2C devs to the master so that the master can fill its internal "
"device table appropriately"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2004
msgid ""
"Call :c:type:`i3c_master_controller_ops->bus_init\\(\\) "
"<i3c_master_controller_ops>` method to initialize the master controller. "
"That's usually where the bus mode is selected (pure bus or mixed fast/slow "
"bus)"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2008
msgid ""
"Instruct all devices on the bus to drop their dynamic address. This is "
"particularly important when the bus was previously configured by someone "
"else (for example the bootloader)"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2012
msgid "Disable all slave events."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2014
msgid ""
"Reserve address slots for I3C devices with init_dyn_addr. And if devices "
"also have static_addr, try to pre-assign dynamic addresses requested by the "
"FW with SETDASA and attach corresponding statically defined I3C devices to "
"the master."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2019
msgid ""
"Do a DAA (Dynamic Address Assignment) to assign dynamic addresses to all "
"remaining I3C devices"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2022
msgid "Once this is done, all I3C and I2C devices should be usable."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2219
msgid "add an I3C slave to the bus"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2221
msgid "I3C slave dynamic address assigned to the device"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2222
msgid ""
"This function is instantiating an I3C device object and adding it to the I3C "
"device list. All device information are automatically retrieved using "
"standard CCC commands."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2226
msgid ""
"The I3C device object is returned in case the master wants to attach private "
"data to it using i3c_dev_set_master_data()."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2745
msgid "Queue an IBI"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2751
#: ../drivers/i3c/master.c:2839 ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:647 ../include/linux/i3c/master.h:690
msgid "``struct i3c_dev_desc *dev``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2746
msgid "the device this IBI is coming from"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2748
msgid "``struct i3c_ibi_slot *slot``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2747
msgid "the IBI slot used to store the payload"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2748
msgid ""
"Queue an IBI to the controller workqueue. The IBI handler attached to the "
"dev will be called from a workqueue context."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2803
msgid "Free a generic IBI pool"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2809
#: ../drivers/i3c/master.c:2900 ../drivers/i3c/master.c:2927
msgid "``struct i3c_generic_ibi_pool *pool``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2804
msgid "the IBI pool to free"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2805
msgid "Free all IBI slots allated by a generic IBI pool."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2833
msgid "Create a generic IBI pool"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2834
msgid "the device this pool will be used for"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2836
msgid "``const struct i3c_ibi_setup *req``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2835
msgid "IBI setup request describing what the device driver expects"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2836
msgid "Create a generic IBI pool based on the information provided in **req**."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2839
msgid "a valid IBI pool in case of success, an ERR_PTR() otherwise."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2894
msgid "Get a free slot from a generic IBI pool"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2895
msgid "the pool to query an IBI slot on"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2896
msgid ""
"Search for a free slot in a generic IBI pool. The slot should be returned to "
"the pool using i3c_generic_ibi_recycle_slot() when it's no longer needed."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2901
msgid "a pointer to a free slot, or NULL if there's no free slot available."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2921
msgid "Return a slot to a generic IBI pool"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2922
msgid "the pool to return the IBI slot to"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2924
msgid "``struct i3c_ibi_slot *s``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2923
msgid "IBI slot to recycle"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2924
msgid ""
"Add an IBI slot back to its generic IBI pool. Should be called from the "
"master driver struct_master_controller_ops->recycle_ibi() method."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2959
msgid "register an I3C master"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2962
msgid "``struct device *parent``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2961
msgid "the parent device (the one that provides this I3C master controller)"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2964
msgid "``const struct i3c_master_controller_ops *ops``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2963
msgid "the master controller operations"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2965
msgid "``bool secondary``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2964
msgid ""
"true if you are registering a secondary master. Will return -EOPNOTSUPP if "
"set to true since secondary masters are not yet supported"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2967
msgid "This function takes care of everything for you:"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2969
msgid "creates and initializes the I3C bus"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2970
msgid ""
"populates the bus with static I2C devs if **parent->of_node** is not NULL"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2972
msgid ""
"registers all I3C devices added by the controller during bus initialization"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2974
msgid "registers the I2C adapter and all I2C devices"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:2977
msgid "0 in case of success, a negative error code otherwise."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:3114
msgid "unregister an I3C master"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:7: ../drivers/i3c/master.c:3116
msgid "Basically undo everything done in i3c_master_register()."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:39
msgid "Common part of the I3C/I2C device descriptor"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:43 ../include/linux/i3c/master.h:66
#: ../include/linux/i3c/master.h:82 ../include/linux/i3c/master.h:105
#: ../include/linux/i3c/master.h:129 ../include/linux/i3c/master.h:171
#: ../include/linux/i3c/master.h:200 ../include/linux/i3c/master.h:229
#: ../include/linux/i3c/master.h:332 ../include/linux/i3c/master.h:386
#: ../include/linux/i3c/master.h:505 ../include/linux/i3c/master.h:576
msgid "**Definition**::"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:51 ../include/linux/i3c/master.h:74
#: ../include/linux/i3c/master.h:91 ../include/linux/i3c/master.h:114
#: ../include/linux/i3c/master.h:141 ../include/linux/i3c/master.h:181
#: ../include/linux/i3c/master.h:211 ../include/linux/i3c/master.h:237
#: ../include/linux/i3c/master.h:350 ../include/linux/i3c/master.h:412
#: ../include/linux/i3c/master.h:526 ../include/linux/i3c/master.h:588
msgid "**Members**"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:40 ../include/linux/i3c/master.h:63
#: ../include/linux/i3c/master.h:168
msgid "``node``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:41
msgid "node element used to insert the slot into the I2C or I3C device list"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:42
msgid "``master``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:43
msgid ""
"I3C master that instantiated this device. Will be used to do I2C/I3C "
"transfers"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:44
msgid "``master_priv``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:45
msgid ""
"master private data assigned to the device. Can be used to add master "
"specific information"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:46
msgid "This structure is describing common I3C/I2C dev information."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:62
msgid "I2C device board information"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:64
msgid "used to insert the boardinfo object in the I2C boardinfo list"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:64
msgid "``base``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:65
msgid "regular I2C board information"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:65 ../include/linux/i3c/master.h:82
msgid "``lvr``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:66 ../include/linux/i3c/master.h:83
msgid ""
"LVR (Legacy Virtual Register) needed by the I3C core to know about the I2C "
"device limitations"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:67
msgid ""
"This structure is used to attach board-level information to an I2C device. "
"Each I2C device connected on the I3C bus should have one."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:78
msgid "I2C device descriptor"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:79 ../include/linux/i3c/master.h:197
msgid "``common``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:80
msgid "common part of the I2C device descriptor"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:80 ../include/linux/i3c/master.h:104
#: ../include/linux/i3c/master.h:203 ../include/linux/i3c/master.h:226
#: ../include/linux/i3c/master.h:502 ../include/linux/i3c/master.h:553
#: ../include/linux/i3c/master.h:564 ../include/linux/i3c/master.h:573
msgid "``dev``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:81
msgid "I2C device object registered to the I2C framework"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:81 ../include/linux/i3c/master.h:577
msgid "``addr``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:82
msgid "I2C device address"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:84
msgid ""
"Each I2C device connected on the bus will have an i2c_dev_desc. This object "
"is created by the core and later attached to the controller using :c:type:"
"`struct_i3c_master_controller->ops <struct_i3c_master_controller>`-"
">attach_i2c_dev()."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:88
msgid ""
":c:type:`struct_i2c_dev_desc <_i2c_dev_desc>` is the internal representation "
"of an I2C device connected on an I3C bus. This object is also passed to all :"
"c:type:`struct_i3c_master_controller_ops <_i3c_master_controller_ops>` hooks."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:101
msgid "I3C IBI (In-Band Interrupt) slot"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:102
msgid "``work``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:103
msgid "work associated to this slot. The IBI handler will be called from there"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:105
msgid "the I3C device that has generated this IBI"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:105 ../include/linux/i3c/master.h:575
msgid "``len``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:106
msgid "length of the payload associated to this IBI"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:106
msgid "``data``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:107
msgid "payload buffer"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:107
msgid ""
"An IBI slot is an object pre-allocated by the controller and used when an "
"IBI comes in. Every time an IBI comes in, the I3C master driver should find "
"a free IBI slot in its IBI slot pool, retrieve the IBI payload and queue the "
"IBI using i3c_master_queue_ibi()."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:113
msgid ""
"How IBI slots are allocated is left to the I3C master driver, though, for "
"simple kmalloc-based allocation, the generic IBI slot pool can be used."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:125
msgid "IBI information attached to a specific device"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:126
msgid "``all_ibis_handled``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:127
msgid ""
"used to be informed when no more IBIs are waiting to be processed. Used by "
"i3c_device_disable_ibi() to wait for all IBIs to be dequeued"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:129
msgid "``pending_ibis``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:130
msgid ""
"count the number of pending IBIs. Each pending IBI has its work element "
"queued to the controller workqueue"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:131
msgid "``max_payload_len``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:132
msgid ""
"maximum payload length for an IBI coming from this device. this value is "
"specified when calling i3c_device_request_ibi() and should not change at run "
"time. All messages IBIs exceeding this limit should be rejected by the master"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:136
msgid "``num_slots``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:137
msgid "number of IBI slots reserved for this device"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:137
msgid "``enabled``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:138
msgid "reflect the IBI status"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:138 ../include/linux/i3c/master.h:518
msgid "``wq``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:139
msgid "workqueue used to execute IBI handlers."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:139
msgid "``handler``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:140
msgid ""
"IBI handler specified at i3c_device_request_ibi() call time. This handler "
"will be called from the controller workqueue, and as such is allowed to "
"sleep (though it is recommended to process the IBI as fast as possible to "
"not stall processing of other IBIs queued on the same workqueue). New I3C "
"messages can be sent from the IBI handler"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:145
msgid ""
"The :c:type:`struct_i3c_device_ibi_info <_i3c_device_ibi_info>` object is "
"allocated when i3c_device_request_ibi() is called and attached to a specific "
"device. This object is here to manage IBIs coming from a specific I3C device."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:149
msgid ""
"Note that this structure is the generic view of the IBI management "
"infrastructure. I3C master drivers may have their own internal "
"representation which they can associate to the device using controller-"
"private data."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:167
msgid "I3C device board information"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:169
msgid "used to insert the boardinfo object in the I3C boardinfo list"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:169
msgid "``init_dyn_addr``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:170
msgid ""
"initial dynamic address requested by the FW. We provide no guarantee that "
"the device will end up using this address, but try our best to assign this "
"specific address to the device"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:173
msgid "``static_addr``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:174
msgid ""
"static address the I3C device listen on before it's been assigned a dynamic "
"address by the master. Will be used during bus initialization to assign it a "
"specific dynamic address before starting DAA (Dynamic Address Assignment)"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:177
msgid "``pid``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:178
msgid ""
"I3C Provisioned ID exposed by the device. This is a unique identifier that "
"may be used to attach boardinfo to i3c_dev_desc when the device does not "
"have a static address"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:180
msgid "``of_node``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:181
msgid "optional DT node in case the device has been described in the DT"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:181
msgid ""
"This structure is used to attach board-level information to an I3C device. "
"Not all I3C devices connected on the bus will have a boardinfo. It's only "
"needed if you want to attach extra resources to a device or assign it a "
"specific dynamic address."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:196
msgid "I3C device descriptor"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:198
msgid "common part of the I3C device descriptor"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:198
msgid "``info``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:199
msgid ""
"I3C device information. Will be automatically filled when you create your "
"device with i3c_master_add_i3c_dev_locked()"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:200
msgid "``ibi_lock``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:201
msgid ""
"lock used to protect the :c:type:`struct_i3c_device->ibi <struct_i3c_device>`"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:201
msgid "``ibi``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:202
msgid ""
"IBI info attached to a device. Should be NULL until i3c_device_request_ibi() "
"is called"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:204
msgid ""
"pointer to the I3C device object exposed to I3C device drivers. This should "
"never be accessed from I3C master controller drivers. Only core code should "
"manipulate it in when updating the dev <-> desc link or when propagating IBI "
"events to the driver"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:207 ../include/linux/i3c/master.h:516
msgid "``boardinfo``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:208
msgid "pointer to the boardinfo attached to this I3C device"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:208
msgid ""
"Internal representation of an I3C device. This object is only used by the "
"core and passed to I3C master controller drivers when they're requested to "
"do some operations on the device. The core maintains the link between the "
"internal I3C dev descriptor and the object exposed to the I3C device drivers "
"(:c:type:`struct_i3c_device <_i3c_device>`)."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:225
msgid "I3C device object"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:227
msgid "device object to register the I3C dev to the device model"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:227
msgid "``desc``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:228
msgid ""
"pointer to an i3c device descriptor object. This link is updated every time "
"the I3C device is rediscovered with a different dynamic address assigned"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:230 ../include/linux/i3c/master.h:517
#: ../include/linux/i3c/master.h:556 ../include/linux/i3c/master.h:567
msgid "``bus``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:231
msgid "I3C bus this device is attached to"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:231
msgid ""
"I3C device object exposed to I3C device drivers. The takes care of linking "
"this object to the relevant :c:type:`struct_i3c_dev_desc <_i3c_dev_desc>` "
"one. All I3C devs on the I3C bus are represented, including I3C masters. For "
"each of them, we have an instance of :c:type:`struct i3c_device "
"<i3c_device>`."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:264
msgid "I3C bus mode"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:268 ../include/linux/i3c/master.h:290
#: ../include/linux/i3c/master.h:304
msgid "**Constants**"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:270
msgid "``I3C_BUS_MODE_PURE``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:271
msgid "only I3C devices are connected to the bus. No limitation expected"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:274
msgid "``I3C_BUS_MODE_MIXED_FAST``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:275
msgid ""
"I2C devices with 50ns spike filter are present on the bus. The only impact "
"in this mode is that the high SCL pulse has to stay below 50ns to trick I2C "
"devices when transmitting I3C frames"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:280
msgid "``I3C_BUS_MODE_MIXED_LIMITED``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:281
msgid ""
"I2C devices without 50ns spike filter are present on the bus. However they "
"allow compliance up to the maximum SDR SCL clock frequency."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:286
msgid "``I3C_BUS_MODE_MIXED_SLOW``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:287
msgid "I2C devices without 50ns spike filter are present on the bus"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:286
msgid "I3C open-drain speed"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:292
msgid "``I3C_OPEN_DRAIN_SLOW_SPEED``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:293
msgid ""
"Slow open-drain speed for sending the first broadcast address. The first "
"broadcast address at this speed will be visible to all devices on the I3C "
"bus. I3C devices working in I2C mode will turn off their spike filter when "
"switching into I3C mode."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:299
msgid "``I3C_OPEN_DRAIN_NORMAL_SPEED``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:300
msgid "Normal open-drain speed in I3C bus mode."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:300
msgid "I3C address slot status"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:306
msgid "``I3C_ADDR_SLOT_FREE``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:307
msgid "address is free"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:309
msgid "``I3C_ADDR_SLOT_RSVD``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:310
msgid "address is reserved"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:312
msgid "``I3C_ADDR_SLOT_I2C_DEV``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:313
msgid "address is assigned to an I2C device"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:315
msgid "``I3C_ADDR_SLOT_I3C_DEV``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:316
msgid "address is assigned to an I3C device"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:318
msgid "``I3C_ADDR_SLOT_STATUS_MASK``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:319
msgid "address slot mask"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:321
msgid "``I3C_ADDR_SLOT_EXT_STATUS_MASK``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:322
msgid "address slot mask with extended information"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:324
msgid "``I3C_ADDR_SLOT_EXT_DESIRED``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:325
msgid ""
"the bitmask represents addresses that are preferred by some devices, such as "
"the \"assigned-address\" property in a device tree source. On an I3C bus, "
"addresses are assigned dynamically, and we need to know which addresses are "
"free to use and which ones are already assigned."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:311
msgid ""
"Addresses marked as reserved are those reserved by the I3C protocol "
"(broadcast address, ...)."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:328
msgid "I3C bus object"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:329
msgid "``cur_master``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:330
msgid ""
"I3C master currently driving the bus. Since I3C is multi-master this can "
"change over the time. Will be used to let a master know whether it needs to "
"request bus ownership before sending a frame or not"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:333
msgid "``id``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:334
msgid "bus ID. Assigned by the framework when register the bus"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:334
msgid "``addrslots``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:335
msgid ""
"a bitmap with 2-bits per-slot to encode the address status and ease the DAA "
"(Dynamic Address Assignment) procedure (see :c:type:`enum "
"i3c_addr_slot_status <i3c_addr_slot_status>`)"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:337
msgid "``mode``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:338
msgid "bus mode (see :c:type:`enum i3c_bus_mode <i3c_bus_mode>`)"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:341
msgid "``scl_rate``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:342
msgid "SCL signal rate for I3C and I2C mode"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:338
msgid "``scl_rate.i3c``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:339
msgid "maximum rate for the clock signal when doing I3C SDR/priv transfers"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:340
msgid "``scl_rate.i2c``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:341
msgid "maximum rate for the clock signal when doing I2C transfers"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:348
msgid "``devs``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:349
msgid "2 lists containing all I3C/I2C devices connected to the bus"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:342
msgid "``devs.i3c``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:343
msgid ""
"contains a list of I3C device descriptors representing I3C devices connected "
"on the bus and successfully attached to the I3C master"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:345
msgid "``devs.i2c``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:346
msgid ""
"contains a list of I2C device descriptors representing I2C devices connected "
"on the bus and successfully attached to the I3C master"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:349
msgid "``lock``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:350
msgid ""
"read/write lock on the bus. This is needed to protect against operations "
"that have an impact on the whole bus and the devices connected to it. For "
"example, when asking slaves to drop their dynamic address (RSTDAA CCC), we "
"need to make sure no one is trying to send I3C frames to these devices. Note "
"that this lock does not protect against concurrency between devices: several "
"drivers can send different I3C/I2C frames through the same master in "
"parallel. This is the responsibility of the master to guarantee that frames "
"are actually sent sequentially and not interlaced"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:359
msgid ""
"The I3C bus is represented with its own object and not implicitly described "
"by the I3C master to cope with the multi-master functionality, where one bus "
"can be shared amongst several masters, each of them requesting bus ownership "
"when they need to."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:382
msgid "I3C master methods"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:383
msgid "``bus_init``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:384
msgid ""
"hook responsible for the I3C bus initialization. You should at least call "
"master_set_info() from there and set the bus mode. You can also put "
"controller specific initialization in there. This method is mandatory."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:387
msgid "``bus_cleanup``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:388
msgid ""
"cleanup everything done in :c:type:`i3c_master_controller_ops-"
">bus_init\\(\\) <i3c_master_controller_ops>`. This method is optional."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:390
msgid "``attach_i3c_dev``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:391
msgid ""
"called every time an I3C device is attached to the bus. It can be after a "
"DAA or when a device is statically declared by the FW, in which case it will "
"only have a static address and the dynamic address will be 0. When this "
"function is called, device information have not been retrieved yet. This is "
"a good place to attach master controller specific data to I3C devices. This "
"method is optional."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:399
msgid "``reattach_i3c_dev``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:400
msgid ""
"called every time an I3C device has its addressed changed. It can be because "
"the device has been powered down and has lost its address, or it can happen "
"when a device had a static address and has been assigned a dynamic address "
"with SETDASA. This method is optional."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:405
msgid "``detach_i3c_dev``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:406
msgid ""
"called when an I3C device is detached from the bus. Usually happens when the "
"master device is unregistered. This method is optional."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:408
msgid "``do_daa``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:409
msgid ""
"do a DAA (Dynamic Address Assignment) procedure. This is procedure should "
"send an ENTDAA CCC command and then add all devices discovered sure the DAA "
"using i3c_master_add_i3c_dev_locked(). Add devices added with "
"i3c_master_add_i3c_dev_locked() will then be attached or re-attached to the "
"controller. This method is mandatory."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:414
msgid "``supports_ccc_cmd``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:415
msgid ""
"should return true if the CCC command is supported, false otherwise. This "
"method is optional, if not provided the core assumes all CCC commands are "
"supported."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:418
msgid "``send_ccc_cmd``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:419
msgid "send a CCC command This method is mandatory."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:420
msgid "``i3c_xfers``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:421
msgid "do one or several I3C SDR or HDR transfers. This method is mandatory."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:422
msgid "``attach_i2c_dev``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:423
msgid ""
"called every time an I2C device is attached to the bus. This is a good place "
"to attach master controller specific data to I2C devices. This method is "
"optional."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:426
msgid "``detach_i2c_dev``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:427
msgid ""
"called when an I2C device is detached from the bus. Usually happens when the "
"master device is unregistered. This method is optional."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:429
msgid "``i2c_xfers``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:430
msgid ""
"do one or several I2C transfers. Note that, unlike i3c transfers, the core "
"does not guarantee that buffers attached to the transfers are DMA-safe. If "
"drivers want to have DMA-safe buffers, they should use the "
"i2c_get_dma_safe_msg_buf() and i2c_put_dma_safe_msg_buf() helpers provided "
"by the I2C framework. This method is mandatory."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:436
msgid "``request_ibi``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:437
msgid ""
"attach an IBI handler to an I3C device. This implies defining an IBI handler "
"and the constraints of the IBI (maximum payload length and number of pre-"
"allocated slots). Some controllers support less IBI-capable devices than "
"regular devices, so this method might return -``EBUSY`` if there's no more "
"space for an extra IBI registration This method is optional."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:443
msgid "``free_ibi``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:444
msgid ""
"free an IBI previously requested with ->request_ibi(). The IBI should have "
"been disabled with ->disable_irq() prior to that This method is mandatory "
"only if ->request_ibi is not NULL."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:446
msgid "``enable_ibi``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:447
msgid ""
"enable the IBI. Only valid if ->request_ibi() has been called prior to -"
">enable_ibi(). The controller should first enable the IBI on the controller "
"end (for example, unmask the hardware IRQ) and then send the ENEC CCC "
"command (with the IBI flag set) to the I3C device. This method is mandatory "
"only if ->request_ibi is not NULL."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:452
msgid "``disable_ibi``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:453
msgid ""
"disable an IBI. First send the DISEC CCC command with the IBI flag set and "
"then deactivate the hardware IRQ on the controller end. This method is "
"mandatory only if ->request_ibi is not NULL."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:456
msgid "``recycle_ibi_slot``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:457
msgid ""
"recycle an IBI slot. Called every time an IBI has been processed by its "
"handler. The IBI slot should be put back in the IBI slot pool so that the "
"controller can re-use it for a future IBI This method is mandatory only if -"
">request_ibi is not NULL."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:462
msgid "``enable_hotjoin``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:463
msgid "enable hot join event detect."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:463
msgid "``disable_hotjoin``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:464
msgid "disable hot join event detect."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:464
msgid "``set_speed``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:465
msgid "adjust I3C open drain mode timing."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:465
msgid "``set_dev_nack_retry``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:466
msgid "configure device NACK retry count for the master controller."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:501
msgid "I3C master controller object"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:503
msgid "device to be registered to the device-model"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:503
msgid "``this``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:504
msgid ""
"an I3C device object representing this master. This device will be added to "
"the list of I3C devs available on the bus"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:505
msgid "``i2c``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:506
msgid ""
"I2C adapter used for backward compatibility. This adapter is registered to "
"the I2C subsystem to be as transparent as possible to existing I2C drivers"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:508
msgid "``ops``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:509
msgid ""
"master operations. See :c:type:`struct i3c_master_controller_ops "
"<i3c_master_controller_ops>`"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:509
msgid "``secondary``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:510
msgid "true if the master is a secondary master"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:510
msgid "``init_done``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:511
msgid "true when the bus initialization is done"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:511
msgid "``hotjoin``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:512
msgid "true if the master support hotjoin"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:512
msgid "``rpm_allowed``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:513
msgid "true if Runtime PM allowed"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:513
msgid "``rpm_ibi_allowed``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:514
msgid "true if IBI and Hot-Join allowed while runtime suspended"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:517
msgid "board-level information attached to devices connected on the bus"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:514
msgid "``boardinfo.i3c``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:515
msgid "list of I3C  boardinfo objects"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:515
msgid "``boardinfo.i2c``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:516
msgid "list of I2C boardinfo objects"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:518
msgid "I3C bus exposed by this master"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:519
msgid ""
"workqueue which can be used by master drivers if they need to postpone "
"operations that need to take place in a thread context. Typical examples are "
"Hot Join processing which requires taking the bus lock in maintenance, which "
"in turn, can only be done from a sleep-able context"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:523
msgid "``dev_nack_retry_count``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:524
msgid "retry count when slave device nack"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:524
msgid ""
"A :c:type:`struct i3c_master_controller <i3c_master_controller>` has to be "
"registered to the I3C subsystem through i3c_master_register(). None of :c:"
"type:`struct i3c_master_controller <i3c_master_controller>` fields should be "
"set manually, just pass appropriate values to i3c_master_register()."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:552
msgid "``i3c_bus_for_each_i2cdev (bus, dev)``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:550
msgid "iterate over all I2C devices present on the bus"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:551 ../include/linux/i3c/master.h:562
msgid "the I3C bus"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:552
msgid ""
"an I2C device descriptor pointer updated to point to the current slot at "
"each iteration of the loop"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:554
msgid "Iterate over all I2C devs present on the bus."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:563
msgid "``i3c_bus_for_each_i3cdev (bus, dev)``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:561
msgid "iterate over all I3C devices present on the bus"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:563
msgid ""
"and I3C device descriptor pointer updated to point to the current slot at "
"each iteration of the loop"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:565
msgid "Iterate over all I3C devs present on the bus."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:574
msgid "``buf``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:576
msgid "``map_len``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:577
msgid "length of DMA mapping"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:578
msgid "mapped DMA address for a Host Controller Driver"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:578
msgid "``dir``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:579
msgid "``bounce_buf``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:580
msgid "an allocated bounce buffer if transfer needs it or NULL"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:628
msgid "get master private data attached to an I3C device descriptor"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:634
msgid "``const struct i3c_dev_desc *dev``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:630
msgid "the I3C device descriptor to get private data from"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:632
msgid ""
"the private data previously attached with i3c_dev_set_master_data() or NULL "
"if no data has been attached to the device."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:641
msgid "attach master private data to an I3C device descriptor"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:643
msgid "the I3C device descriptor to attach private data to"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:645 ../include/linux/i3c/master.h:673
msgid "``void *data``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:644 ../include/linux/i3c/master.h:672
msgid "private data"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:645
msgid ""
"This functions allows a master controller to attach per-device private data "
"which can then be retrieved with i3c_dev_get_master_data()."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:656
msgid "get master private data attached to an I2C device descriptor"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:662
msgid "``const struct i2c_dev_desc *dev``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:658
msgid "the I2C device descriptor to get private data from"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:660
msgid ""
"the private data previously attached with i2c_dev_set_master_data() or NULL "
"if no data has been attached to the device."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:669
msgid "attach master private data to an I2C device descriptor"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:675 ../include/linux/i3c/master.h:702
msgid "``struct i2c_dev_desc *dev``"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:671
msgid "the I2C device descriptor to attach private data to"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:673
msgid ""
"This functions allows a master controller to attach per-device private data "
"which can then be retrieved with i2c_device_get_master_data()."
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:684 ../include/linux/i3c/master.h:696
msgid "get master used to communicate with a device"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:685
msgid "I3C dev"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:687 ../include/linux/i3c/master.h:699
msgid "the master controller driving **dev**"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:697
msgid "I2C dev"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:708
msgid "get the bus attached to a master"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:709
msgid "master object"
msgstr ""

#: ../../../driver-api/i3c/master-driver-api:9:
#: ../include/linux/i3c/master.h:711
msgid "the I3C bus **master** is connected to"
msgstr ""
