# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/connector.rst:5
msgid "Kernel Connector"
msgstr ""

#: ../../../driver-api/connector.rst:7
msgid ""
"Kernel connector - new netlink based userspace <-> kernel space easy to use "
"communication module."
msgstr ""

#: ../../../driver-api/connector.rst:10
msgid ""
"The Connector driver makes it easy to connect various agents using a netlink "
"based network.  One must register a callback and an identifier. When the "
"driver receives a special netlink message with the appropriate identifier, "
"the appropriate callback will be called."
msgstr ""

#: ../../../driver-api/connector.rst:15
msgid "From the userspace point of view it's quite straightforward:"
msgstr ""

#: ../../../driver-api/connector.rst:17
msgid "socket();"
msgstr ""

#: ../../../driver-api/connector.rst:18
msgid "bind();"
msgstr ""

#: ../../../driver-api/connector.rst:19
msgid "send();"
msgstr ""

#: ../../../driver-api/connector.rst:20
msgid "recv();"
msgstr ""

#: ../../../driver-api/connector.rst:22
msgid ""
"But if kernelspace wants to use the full power of such connections, the "
"driver writer must create special sockets, must know about struct sk_buff "
"handling, etc...  The Connector driver allows any kernelspace agents to use "
"netlink based networking for inter-process communication in a significantly "
"easier way::"
msgstr ""

#: ../../../driver-api/connector.rst:38
msgid ""
"idx and val are unique identifiers which must be registered in the connector."
"h header for in-kernel usage.  `void (*callback) (void *)` is a callback "
"function which will be called when a message with above idx.val is received "
"by the connector core.  The argument for that function must be dereferenced "
"to `struct cn_msg *`::"
msgstr ""

#: ../../../driver-api/connector.rst:57
msgid "Connector interfaces"
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:58
msgid "Registers new callback with connector core."
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:62
#: include/linux/connector.h:74 include/linux/connector.h:82
#: include/linux/connector.h:111
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:64
#: include/linux/connector.h:76
msgid "``const struct cb_id *id``"
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:60
msgid ""
"unique connector's user identifier. It must be registered in connector.h for "
"legal in-kernel users."
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:64
msgid "``const char *name``"
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:63
msgid "connector's callback symbolic name."
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:65
msgid "``void (*callback)(struct cn_msg *, struct netlink_skb_parms *)``"
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:64
msgid ""
"connector's callback. parameters are ``cn_msg`` and the sender's credentials"
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:70
msgid "Unregisters new callback with connector core."
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:72
msgid "unique connector's user identifier."
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:78
#: include/linux/connector.h:107
msgid "Sends message to the specified groups."
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:84
#: include/linux/connector.h:113
msgid "``struct cn_msg *msg``"
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:80
#: include/linux/connector.h:109
msgid "message header(with attached data)."
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:82
msgid "``u16 len``"
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:81
msgid "Number of **msg** to be sent."
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:83
#: include/linux/connector.h:111
msgid "``u32 portid``"
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:82
#: include/linux/connector.h:110
msgid ""
"destination port. If non-zero the message will be sent to the given port, "
"which should be set to the original sender."
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:86
#: include/linux/connector.h:114
msgid "``u32 group``"
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:85
#: include/linux/connector.h:113
msgid ""
"destination group. If **portid** and **group** is zero, then appropriate "
"group will be searched through all registered connector users, and message "
"will be delivered to the group which was created for user with the same ID "
"as in **msg**. If **group** is not zero, then message will be delivered to "
"the specified group."
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:93
#: include/linux/connector.h:121
msgid "``gfp_t gfp_mask``"
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:92
#: include/linux/connector.h:120
msgid "GFP mask."
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:94
msgid "``netlink_filter_fn filter``"
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:93
msgid "Filter function to be used at netlink layer."
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:95
msgid "``void *filter_data``"
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:94
msgid "Filter data to be supplied to the filter function"
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:96
#: include/linux/connector.h:122
msgid "**Description**"
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:95
#: include/linux/connector.h:121
msgid ""
"It can be safely called from softirq context, but may silently fail under "
"strong memory pressure."
msgstr ""

#: ../../../driver-api/connector:59: include/linux/connector.h:98
#: include/linux/connector.h:124
msgid "If there are no listeners for given group ``-ESRCH`` can be returned."
msgstr ""

#: ../../../driver-api/connector.rst:61
msgid "Note:"
msgstr ""

#: ../../../driver-api/connector.rst:62
msgid ""
"When registering new callback user, connector core assigns netlink group to "
"the user which is equal to its id.idx."
msgstr ""

#: ../../../driver-api/connector.rst:66
msgid "Protocol description"
msgstr ""

#: ../../../driver-api/connector.rst:68
msgid ""
"The current framework offers a transport layer with fixed headers.  The "
"recommended protocol which uses such a header is as following:"
msgstr ""

#: ../../../driver-api/connector.rst:71
msgid ""
"msg->seq and msg->ack are used to determine message genealogy.  When someone "
"sends a message, they use a locally unique sequence and random acknowledge "
"number.  The sequence number may be copied into nlmsghdr->nlmsg_seq too."
msgstr ""

#: ../../../driver-api/connector.rst:76
msgid "The sequence number is incremented with each message sent."
msgstr ""

#: ../../../driver-api/connector.rst:78
msgid ""
"If you expect a reply to the message, then the sequence number in the "
"received message MUST be the same as in the original message, and the "
"acknowledge number MUST be the same + 1."
msgstr ""

#: ../../../driver-api/connector.rst:82
msgid ""
"If we receive a message and its sequence number is not equal to one we are "
"expecting, then it is a new message.  If we receive a message and its "
"sequence number is the same as one we are expecting, but its acknowledge is "
"not equal to the sequence number in the original message + 1, then it is a "
"new message."
msgstr ""

#: ../../../driver-api/connector.rst:88
msgid "Obviously, the protocol header contains the above id."
msgstr ""

#: ../../../driver-api/connector.rst:90
msgid ""
"The connector allows event notification in the following form: kernel driver "
"or userspace process can ask connector to notify it when selected ids will "
"be turned on or off (registered or unregistered its callback).  It is done "
"by sending a special command to the connector driver (it also registers "
"itself with id={-1, -1})."
msgstr ""

#: ../../../driver-api/connector.rst:96
msgid ""
"As example of this usage can be found in the cn_test.c module which uses the "
"connector to request notification and to send messages."
msgstr ""

#: ../../../driver-api/connector.rst:100
msgid "Reliability"
msgstr ""

#: ../../../driver-api/connector.rst:102
msgid ""
"Netlink itself is not a reliable protocol.  That means that messages can be "
"lost due to memory pressure or process' receiving queue overflowed, so "
"caller is warned that it must be prepared.  That is why the struct cn_msg "
"[main connector's message header] contains u32 seq and u32 ack fields."
msgstr ""

#: ../../../driver-api/connector.rst:109
msgid "Userspace usage"
msgstr ""

#: ../../../driver-api/connector.rst:111
msgid ""
"2.6.14 has a new netlink socket implementation, which by default does not "
"allow people to send data to netlink groups other than 1. So, if you wish to "
"use a netlink socket (for example using connector) with a different group "
"number, the userspace application must subscribe to that group first.  It "
"can be achieved by the following pseudocode::"
msgstr ""

#: ../../../driver-api/connector.rst:134
msgid ""
"Where 270 above is SOL_NETLINK, and 1 is a NETLINK_ADD_MEMBERSHIP socket "
"option.  To drop a multicast subscription, one should call the above socket "
"option with the NETLINK_DROP_MEMBERSHIP parameter which is defined as 0."
msgstr ""

#: ../../../driver-api/connector.rst:138
msgid ""
"2.6.14 netlink code only allows to select a group which is less or equal to "
"the maximum group number, which is used at netlink_kernel_create() time. In "
"case of connector it is CN_NETLINK_USERS + 0xf, so if you want to use group "
"number 12345, you must increment CN_NETLINK_USERS to that number. Additional "
"0xf numbers are allocated to be used by non-in-kernel users."
msgstr ""

#: ../../../driver-api/connector.rst:144
msgid ""
"Due to this limitation, group 0xffffffff does not work now, so one can not "
"use add/remove connector's group notifications, but as far as I know, only "
"cn_test.c test module used it."
msgstr ""

#: ../../../driver-api/connector.rst:148
msgid ""
"Some work in netlink area is still being done, so things can be changed in "
"2.6.15 timeframe, if it will happen, documentation will be updated for that "
"kernel."
msgstr ""

#: ../../../driver-api/connector.rst:153
msgid "Code samples"
msgstr ""

#: ../../../driver-api/connector.rst:155
msgid ""
"Sample code for a connector test module and user space can be found in "
"samples/connector/. To build this code, enable CONFIG_CONNECTOR and "
"CONFIG_SAMPLES."
msgstr ""
