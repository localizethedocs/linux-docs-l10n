# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/mtd/nand_ecc.rst:3
msgid "NAND Error-correction Code"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:6
msgid "Introduction"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:8
msgid ""
"Having looked at the linux mtd/nand Hamming software ECC engine driver I "
"felt there was room for optimisation. I bashed the code for a few hours "
"performing tricks like table lookup removing superfluous code etc. After "
"that the speed was increased by 35-40%. Still I was not too happy as I felt "
"there was additional room for improvement."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:14
msgid ""
"Bad! I was hooked. I decided to annotate my steps in this file. Perhaps it "
"is useful to someone or someone learns something from it."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:20
msgid "The problem"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:22
msgid ""
"NAND flash (at least SLC one) typically has sectors of 256 bytes. However "
"NAND flash is not extremely reliable so some error detection (and sometimes "
"correction) is needed."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:26
msgid ""
"This is done by means of a Hamming code. I'll try to explain it in laymans "
"terms (and apologies to all the pro's in the field in case I do not use the "
"right terminology, my coding theory class was almost 30 years ago, and I "
"must admit it was not one of my favourites)."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:31
msgid ""
"As I said before the ecc calculation is performed on sectors of 256 bytes. "
"This is done by calculating several parity bits over the rows and columns. "
"The parity used is even parity which means that the parity bit = 1 if the "
"data over which the parity is calculated is 1 and the parity bit = 0 if the "
"data over which the parity is calculated is 0. So the total number of bits "
"over the data over which the parity is calculated + the parity bit is even. "
"(see wikipedia if you can't follow this). Parity is often calculated by "
"means of an exclusive or operation, sometimes also referred to as xor. In C "
"the operator for xor is ^"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:41
msgid "Back to ecc. Let's give a small figure:"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:45
msgid "byte   0:"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:45
#: ../../../driver-api/mtd/nand_ecc.rst:46
#: ../../../driver-api/mtd/nand_ecc.rst:47
#: ../../../driver-api/mtd/nand_ecc.rst:48
#: ../../../driver-api/mtd/nand_ecc.rst:49
#: ../../../driver-api/mtd/nand_ecc.rst:51
msgid "bit7"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:45
#: ../../../driver-api/mtd/nand_ecc.rst:46
#: ../../../driver-api/mtd/nand_ecc.rst:47
#: ../../../driver-api/mtd/nand_ecc.rst:48
#: ../../../driver-api/mtd/nand_ecc.rst:49
#: ../../../driver-api/mtd/nand_ecc.rst:51
msgid "bit6"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:45
#: ../../../driver-api/mtd/nand_ecc.rst:46
#: ../../../driver-api/mtd/nand_ecc.rst:47
#: ../../../driver-api/mtd/nand_ecc.rst:48
#: ../../../driver-api/mtd/nand_ecc.rst:49
#: ../../../driver-api/mtd/nand_ecc.rst:51
msgid "bit5"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:45
#: ../../../driver-api/mtd/nand_ecc.rst:46
#: ../../../driver-api/mtd/nand_ecc.rst:47
#: ../../../driver-api/mtd/nand_ecc.rst:48
#: ../../../driver-api/mtd/nand_ecc.rst:49
#: ../../../driver-api/mtd/nand_ecc.rst:51
msgid "bit4"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:45
#: ../../../driver-api/mtd/nand_ecc.rst:46
#: ../../../driver-api/mtd/nand_ecc.rst:47
#: ../../../driver-api/mtd/nand_ecc.rst:48
#: ../../../driver-api/mtd/nand_ecc.rst:49
#: ../../../driver-api/mtd/nand_ecc.rst:51
msgid "bit3"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:45
#: ../../../driver-api/mtd/nand_ecc.rst:46
#: ../../../driver-api/mtd/nand_ecc.rst:47
#: ../../../driver-api/mtd/nand_ecc.rst:48
#: ../../../driver-api/mtd/nand_ecc.rst:49
#: ../../../driver-api/mtd/nand_ecc.rst:51
msgid "bit2"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:45
#: ../../../driver-api/mtd/nand_ecc.rst:46
#: ../../../driver-api/mtd/nand_ecc.rst:47
#: ../../../driver-api/mtd/nand_ecc.rst:48
#: ../../../driver-api/mtd/nand_ecc.rst:49
#: ../../../driver-api/mtd/nand_ecc.rst:51
msgid "bit1"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:45
#: ../../../driver-api/mtd/nand_ecc.rst:46
#: ../../../driver-api/mtd/nand_ecc.rst:47
#: ../../../driver-api/mtd/nand_ecc.rst:48
#: ../../../driver-api/mtd/nand_ecc.rst:49
#: ../../../driver-api/mtd/nand_ecc.rst:51
msgid "bit0"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:45
#: ../../../driver-api/mtd/nand_ecc.rst:47
#: ../../../driver-api/mtd/nand_ecc.rst:49
#: ../../../driver-api/mtd/nand_ecc.rst:51
msgid "rp0"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:45
#: ../../../driver-api/mtd/nand_ecc.rst:46
#: ../../../driver-api/mtd/nand_ecc.rst:49
msgid "rp2"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:45
#: ../../../driver-api/mtd/nand_ecc.rst:46
#: ../../../driver-api/mtd/nand_ecc.rst:47
#: ../../../driver-api/mtd/nand_ecc.rst:48
msgid "rp4"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:45
#: ../../../driver-api/mtd/nand_ecc.rst:46
#: ../../../driver-api/mtd/nand_ecc.rst:47
#: ../../../driver-api/mtd/nand_ecc.rst:48
#: ../../../driver-api/mtd/nand_ecc.rst:49
#: ../../../driver-api/mtd/nand_ecc.rst:50
#: ../../../driver-api/mtd/nand_ecc.rst:51
#: ../../../driver-api/mtd/nand_ecc.rst:52
msgid "..."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:45
#: ../../../driver-api/mtd/nand_ecc.rst:46
#: ../../../driver-api/mtd/nand_ecc.rst:47
#: ../../../driver-api/mtd/nand_ecc.rst:48
#: ../../../driver-api/mtd/nand_ecc.rst:49
#: ../../../driver-api/mtd/nand_ecc.rst:108
msgid "rp14"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:46
msgid "byte   1:"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:46
#: ../../../driver-api/mtd/nand_ecc.rst:48
#: ../../../driver-api/mtd/nand_ecc.rst:52
msgid "rp1"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:47
msgid "byte   2:"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:47
#: ../../../driver-api/mtd/nand_ecc.rst:48
#: ../../../driver-api/mtd/nand_ecc.rst:51
#: ../../../driver-api/mtd/nand_ecc.rst:52
msgid "rp3"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:48
msgid "byte   3:"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:49
msgid "byte   4:"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:49
#: ../../../driver-api/mtd/nand_ecc.rst:51
#: ../../../driver-api/mtd/nand_ecc.rst:52
msgid "rp5"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:51
msgid "byte 254:"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:51
#: ../../../driver-api/mtd/nand_ecc.rst:52
#: ../../../driver-api/mtd/nand_ecc.rst:108
msgid "rp15"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:52
msgid "byte 255:"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:52
msgid "bit7 cp1 cp3 cp5"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:52
msgid "bit6 cp0 cp3 cp5"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:52
msgid "bit5 cp1 cp2 cp5"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:52
msgid "bit4 cp0 cp2 cp5"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:52
msgid "bit3 cp1 cp3 cp4"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:52
msgid "bit2 cp0 cp3 cp4"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:52
msgid "bit1 cp1 cp2 cp4"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:52
msgid "bit0 cp0 cp2 cp4"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:58
msgid ""
"This figure represents a sector of 256 bytes. cp is my abbreviation for "
"column parity, rp for row parity."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:61
msgid "Let's start to explain column parity."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:63
msgid "cp0 is the parity that belongs to all bit0, bit2, bit4, bit6."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:65
msgid ""
"so the sum of all bit0, bit2, bit4 and bit6 values + cp0 itself is even."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:67
msgid "Similarly cp1 is the sum of all bit1, bit3, bit5 and bit7."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:69
msgid "cp2 is the parity over bit0, bit1, bit4 and bit5"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:70
msgid "cp3 is the parity over bit2, bit3, bit6 and bit7."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:71
msgid "cp4 is the parity over bit0, bit1, bit2 and bit3."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:72
msgid "cp5 is the parity over bit4, bit5, bit6 and bit7."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:74
msgid "Note that each of cp0 .. cp5 is exactly one bit."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:76
msgid "Row parity actually works almost the same."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:78
msgid "rp0 is the parity of all even bytes (0, 2, 4, 6, ... 252, 254)"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:79
msgid "rp1 is the parity of all odd bytes (1, 3, 5, 7, ..., 253, 255)"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:80
msgid ""
"rp2 is the parity of all bytes 0, 1, 4, 5, 8, 9, ... (so handle two bytes, "
"then skip 2 bytes)."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:82
msgid ""
"rp3 is covers the half rp2 does not cover (bytes 2, 3, 6, 7, 10, 11, ...)"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:83
msgid ""
"for rp4 the rule is cover 4 bytes, skip 4 bytes, cover 4 bytes, skip 4 etc."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:85
msgid "so rp4 calculates parity over bytes 0, 1, 2, 3, 8, 9, 10, 11, 16, ...)"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:86
msgid ""
"and rp5 covers the other half, so bytes 4, 5, 6, 7, 12, 13, 14, 15, 20, .."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:88
msgid "The story now becomes quite boring. I guess you get the idea."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:90
msgid "rp6 covers 8 bytes then skips 8 etc"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:91
msgid "rp7 skips 8 bytes then covers 8 etc"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:92
msgid "rp8 covers 16 bytes then skips 16 etc"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:93
msgid "rp9 skips 16 bytes then covers 16 etc"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:94
msgid "rp10 covers 32 bytes then skips 32 etc"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:95
msgid "rp11 skips 32 bytes then covers 32 etc"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:96
msgid "rp12 covers 64 bytes then skips 64 etc"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:97
msgid "rp13 skips 64 bytes then covers 64 etc"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:98
msgid "rp14 covers 128 bytes then skips 128"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:99
msgid "rp15 skips 128 bytes then covers 128"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:101
msgid ""
"In the end the parity bits are grouped together in three bytes as follows:"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:105
msgid "ECC"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:105
msgid "Bit 7"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:105
msgid "Bit 6"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:105
msgid "Bit 5"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:105
msgid "Bit 4"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:105
msgid "Bit 3"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:105
msgid "Bit 2"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:105
msgid "Bit 1"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:105
msgid "Bit 0"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:107
msgid "ECC 0"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:107
msgid "rp07"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:107
msgid "rp06"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:107
msgid "rp05"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:107
msgid "rp04"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:107
msgid "rp03"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:107
msgid "rp02"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:107
msgid "rp01"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:107
msgid "rp00"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:108
msgid "ECC 1"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:108
msgid "rp13"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:108
msgid "rp12"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:108
msgid "rp11"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:108
msgid "rp10"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:108
msgid "rp09"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:108
msgid "rp08"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:109
msgid "ECC 2"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:109
msgid "cp5"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:109
msgid "cp4"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:109
msgid "cp3"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:109
msgid "cp2"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:109
msgid "cp1"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:109
msgid "cp0"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:109
msgid "1"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:112
msgid ""
"I detected after writing this that ST application note AN1823 (http://www.st."
"com/stonline/) gives a much nicer picture.(but they use line parity as term "
"where I use row parity) Oh well, I'm graphically challenged, so suffer with "
"me for a moment :-)"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:117
msgid "And I could not reuse the ST picture anyway for copyright reasons."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:121
msgid "Attempt 0"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:123
msgid "Implementing the parity calculation is pretty simple. In C pseudocode::"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:170
msgid "Analysis 0"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:172
msgid ""
"C does have bitwise operators but not really operators to do the above "
"efficiently (and most hardware has no such instructions either). Therefore "
"without implementing this it was clear that the code above was not going to "
"bring me a Nobel prize :-)"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:177
msgid ""
"Fortunately the exclusive or operation is commutative, so we can combine the "
"values in any order. So instead of calculating all the bits individually, "
"let us try to rearrange things. For the column parity this is easy. We can "
"just xor the bytes and in the end filter out the relevant bits. This is "
"pretty nice as it will bring all cp calculation out of the for loop."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:184
msgid ""
"Similarly we can first xor the bytes for the various rows. This leads to:"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:189
msgid "Attempt 1"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:270
msgid ""
"Still pretty straightforward. The last three invert statements are there to "
"give a checksum of 0xff 0xff 0xff for an empty flash. In an empty flash all "
"data is 0xff, so the checksum then matches."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:274
msgid ""
"I also introduced the parity lookup. I expected this to be the fastest way "
"to calculate the parity, but I will investigate alternatives later on."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:280
msgid "Analysis 1"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:282
msgid ""
"The code works, but is not terribly efficient. On my system it took almost 4 "
"times as much time as the linux driver code. But hey, if it was *that* easy "
"this would have been done long before. No pain. no gain."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:287
msgid "Fortunately there is plenty of room for improvement."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:289
msgid ""
"In step 1 we moved from bit-wise calculation to byte-wise calculation. "
"However in C we can also use the unsigned long data type and virtually every "
"modern microprocessor supports 32 bit operations, so why not try to write "
"our code in such a way that we process data in 32 bit chunks."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:294
msgid ""
"Of course this means some modification as the row parity is byte by byte. A "
"quick analysis: for the column parity we use the par variable. When "
"extending to 32 bits we can in the end easily calculate rp0 and rp1 from it. "
"(because par now consists of 4 bytes, contributing to rp1, rp0, rp1, rp0 "
"respectively, from MSB to LSB) also rp2 and rp3 can be easily retrieved from "
"par as rp3 covers the first two MSBs and rp2 covers the last two LSBs."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:303
msgid ""
"Note that of course now the loop is executed only 64 times (256/4). And note "
"that care must taken wrt byte ordering. The way bytes are ordered in a long "
"is machine dependent, and might affect us. Anyway, if there is an issue: "
"this code is developed on x86 (to be precise: a DELL PC with a D920 Intel "
"CPU)"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:309
msgid ""
"And of course the performance might depend on alignment, but I expect that "
"the I/O buffers in the nand driver are aligned properly (and otherwise that "
"should be fixed to get maximum performance)."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:313
msgid "Let's give it a try..."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:317
msgid "Attempt 2"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:404
msgid ""
"The parity array is not shown any more. Note also that for these examples I "
"kinda deviated from my regular programming style by allowing multiple "
"statements on a line, not using { } in then and else blocks with only a "
"single statement and by using operators like ^="
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:411
msgid "Analysis 2"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:413
msgid ""
"The code (of course) works, and hurray: we are a little bit faster than the "
"linux driver code (about 15%). But wait, don't cheer too quickly. There is "
"more to be gained. If we look at e.g. rp14 and rp15 we see that we either "
"xor our data with rp14 or with rp15. However we also have par which goes "
"over all data. This means there is no need to calculate rp14 as it can be "
"calculated from rp15 through rp14 = par ^ rp15, because par = rp14 ^ rp15; "
"(or if desired we can avoid calculating rp15 and calculate it from rp14).  "
"That is why some places refer to inverse parity. Of course the same thing "
"holds for rp4/5, rp6/7, rp8/9, rp10/11 and rp12/13. Effectively this means "
"we can eliminate the else clause from the if statements. Also we can "
"optimise the calculation in the end a little bit by going from long to byte "
"first. Actually we can even avoid the table lookups"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:429
msgid "Attempt 3"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:431
msgid "Odd replaced::"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:440
msgid "with::"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:449
msgid "and outside the loop added::"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:458
msgid ""
"And after that the code takes about 30% more time, although the number of "
"statements is reduced. This is also reflected in the assembly code."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:463
msgid "Analysis 3"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:465
msgid ""
"Very weird. Guess it has to do with caching or instruction parallelism or "
"so. I also tried on an eeePC (Celeron, clocked at 900 Mhz). Interesting "
"observation was that this one is only 30% slower (according to time) "
"executing the code as my 3Ghz D920 processor."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:470
msgid ""
"Well, it was expected not to be easy so maybe instead move to a different "
"track: let's move back to the code from attempt2 and do some loop unrolling. "
"This will eliminate a few if statements. I'll try different amounts of "
"unrolling to see what works best."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:477
msgid "Attempt 4"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:479
msgid "Unrolled the loop 1, 2, 3 and 4 times. For 4 the code starts with::"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:500
msgid "Analysis 4"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:502
msgid "Unrolling once gains about 15%"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:504
msgid "Unrolling twice keeps the gain at about 15%"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:506
msgid "Unrolling three times gives a gain of 30% compared to attempt 2."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:508
msgid ""
"Unrolling four times gives a marginal improvement compared to unrolling "
"three times."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:511
msgid ""
"I decided to proceed with a four time unrolled loop anyway. It was my gut "
"feeling that in the next steps I would obtain additional gain from it."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:514
msgid ""
"The next step was triggered by the fact that par contains the xor of all "
"bytes and rp4 and rp5 each contain the xor of half of the bytes. So in "
"effect par = rp4 ^ rp5. But as xor is commutative we can also say that rp5 = "
"par ^ rp4. So no need to keep both rp4 and rp5 around. We can eliminate rp5 "
"(or rp4, but I already foresaw another optimisation). The same holds for "
"rp6/7, rp8/9, rp10/11 rp12/13 and rp14/15."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:523
msgid "Attempt 5"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:525
msgid ""
"Effectively so all odd digit rp assignments in the loop were removed. This "
"included the else clause of the if statements. Of course after the loop we "
"need to correct things by adding code like::"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:531
msgid ""
"Also the initial assignments (rp5 = 0; etc) could be removed. Along the line "
"I also removed the initialisation of rp0/1/2/3."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:536
msgid "Analysis 5"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:538
msgid ""
"Measurements showed this was a good move. The run-time roughly halved "
"compared with attempt 4 with 4 times unrolled, and we only require 1/3rd of "
"the processor time compared to the current code in the linux kernel."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:542
msgid ""
"However, still I thought there was more. I didn't like all the if "
"statements. Why not keep a running parity and only keep the last if "
"statement. Time for yet another version!"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:548
msgid "Attempt 6"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:550
msgid "THe code within the for loop was changed to::"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:579
msgid ""
"As you can see tmppar is used to accumulate the parity within a for "
"iteration. In the last 3 statements is added to par and, if needed, to rp12 "
"and rp14."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:583
msgid ""
"While making the changes I also found that I could exploit that tmppar "
"contains the running parity for this iteration. So instead of having: rp4 ^= "
"cur; rp6 ^= cur; I removed the rp6 ^= cur; statement and did rp6 ^= tmppar; "
"on next statement. A similar change was done for rp8 and rp10"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:591
msgid "Analysis 6"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:593
msgid ""
"Measuring this code again showed big gain. When executing the original linux "
"code 1 million times, this took about 1 second on my system. (using time to "
"measure the performance). After this iteration I was back to 0.075 sec. "
"Actually I had to decide to start measuring over 10 million iterations in "
"order not to lose too much accuracy. This one definitely seemed to be the "
"jackpot!"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:600
msgid ""
"There is a little bit more room for improvement though. There are three "
"places with statements::"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:605
msgid ""
"It seems more efficient to also maintain a variable rp4_6 in the while loop; "
"This eliminates 3 statements per loop. Of course after the loop we need to "
"correct by adding::"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:612
msgid ""
"Furthermore there are 4 sequential assignments to rp8. This can be encoded "
"slightly more efficiently by saving tmppar before those 4 lines and later do "
"rp8 = rp8 ^ tmppar ^ notrp8; (where notrp8 is the value of rp8 before those "
"4 lines). Again a use of the commutative property of xor. Time for a new "
"test!"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:621
msgid "Attempt 7"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:623
msgid "The new code now looks like::"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:657
msgid "Not a big change, but every penny counts :-)"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:661
msgid "Analysis 7"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:663
msgid ""
"Actually this made things worse. Not very much, but I don't want to move "
"into the wrong direction. Maybe something to investigate later. Could have "
"to do with caching again."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:667
msgid ""
"Guess that is what there is to win within the loop. Maybe unrolling one more "
"time will help. I'll keep the optimisations from 7 for now."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:672
msgid "Attempt 8"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:674
msgid "Unrolled the loop one more time."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:678
msgid "Analysis 8"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:680
msgid ""
"This makes things worse. Let's stick with attempt 6 and continue from there. "
"Although it seems that the code within the loop cannot be optimised further "
"there is still room to optimize the generation of the ecc codes. We can "
"simply calculate the total parity. If this is 0 then rp4 = rp5 etc. If the "
"parity is 1, then rp4 = !rp5;"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:686
msgid ""
"But if rp4 = rp5 we do not need rp5 etc. We can just write the even bits in "
"the result byte and then do something like::"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:691
msgid "Lets test this."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:695
msgid "Attempt 9"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:697
msgid ""
"Changed the code but again this slightly degrades performance. Tried all "
"kind of other things, like having dedicated parity arrays to avoid the shift "
"after parity[rp7] << 7; No gain. Change the lookup using the parity array by "
"using shift operators (e.g. replace parity[rp7] << 7 with::"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:708
msgid "No gain."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:710
msgid ""
"The only marginal change was inverting the parity bits, so we can remove the "
"last three invert statements."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:713
msgid ""
"Ah well, pity this does not deliver more. Then again 10 million iterations "
"using the linux driver code takes between 13 and 13.5 seconds, whereas my "
"code now takes about 0.73 seconds for those 10 million iterations. So "
"basically I've improved the performance by a factor 18 on my system. Not "
"that bad. Of course on different hardware you will get different results. No "
"warranties!"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:720
msgid ""
"But of course there is no such thing as a free lunch. The codesize almost "
"tripled (from 562 bytes to 1434 bytes). Then again, it is not that much."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:725
msgid "Correcting errors"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:727
msgid ""
"For correcting errors I again used the ST application note as a starter, but "
"I also peeked at the existing code."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:730
msgid ""
"The algorithm itself is pretty straightforward. Just xor the given and the "
"calculated ecc. If all bytes are 0 there is no problem. If 11 bits are 1 we "
"have one correctable bit error. If there is 1 bit 1, we have an error in the "
"given ecc code."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:735
msgid ""
"It proved to be fastest to do some table lookups. Performance gain "
"introduced by this is about a factor 2 on my system when a repair had to be "
"done, and 1% or so if no repair had to be done."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:739
msgid ""
"Code size increased from 330 bytes to 686 bytes for this function. (gcc 4.2, "
"-O3)"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:744
msgid "Conclusion"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:746
msgid ""
"The gain when calculating the ecc is tremendous. Om my development hardware "
"a speedup of a factor of 18 for ecc calculation was achieved. On a test on "
"an embedded system with a MIPS core a factor 7 was obtained."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:750
msgid ""
"On a test with a Linksys NSLU2 (ARMv5TE processor) the speedup was a factor "
"5 (big endian mode, gcc 4.1.2, -O3)"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:753
msgid ""
"For correction not much gain could be obtained (as bitflips are rare). Then "
"again there are also much less cycles spent there."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:756
msgid ""
"It seems there is not much more gain possible in this, at least when "
"programmed in C. Of course it might be possible to squeeze something more "
"out of it with an assembler program, but due to pipeline behaviour etc this "
"is very tricky (at least for intel hw)."
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:761
msgid "Author: Frans Meulenbroeks"
msgstr ""

#: ../../../driver-api/mtd/nand_ecc.rst:763
msgid "Copyright (C) 2008 Koninklijke Philips Electronics NV."
msgstr ""
