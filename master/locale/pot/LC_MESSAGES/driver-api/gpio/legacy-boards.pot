# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 08:27+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/gpio/legacy-boards.rst:2
msgid "Supporting Legacy Boards"
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:4
msgid ""
"Many drivers in the kernel, such as ``leds-gpio`` and ``gpio-keys``, are "
"migrating away from using board-specific ``platform_data`` to a unified "
"device properties interface. This interface allows drivers to be simpler and "
"more generic, as they can query properties in a standardized way."
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:9
msgid ""
"On modern systems, these properties are provided via device tree. However, "
"some older platforms have not been converted to device tree and instead rely "
"on board files to describe their hardware configuration. To bridge this gap "
"and allow these legacy boards to work with modern, generic drivers, the "
"kernel provides a mechanism called **software nodes**."
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:15
msgid ""
"This document provides a guide on how to convert a legacy board file from "
"using ``platform_data`` and ``gpiod_lookup_table`` to the modern software "
"node approach for describing GPIO-connected devices."
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:20
msgid "The Core Idea: Software Nodes"
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:22
msgid ""
"Software nodes allow board-specific code to construct an in-memory, device-"
"tree-like structure using struct software_node and struct property_entry. "
"This structure can then be associated with a platform device, allowing "
"drivers to use the standard device properties API (e.g., "
"device_property_read_u32(), device_property_read_string()) to query "
"configuration, just as they would on an ACPI or device tree system."
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:29
msgid ""
"The gpiolib code has support for handling software nodes, so that if GPIO is "
"described properly, as detailed in the section below, then regular gpiolib "
"APIs, such as gpiod_get(), gpiod_get_optional(), and others will work."
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:34
msgid "Requirements for GPIO Properties"
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:36
msgid ""
"When using software nodes to describe GPIO connections, the following "
"requirements must be met for the GPIO core to correctly resolve the "
"reference:"
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:39
msgid ""
"**The GPIO controller's software node \"name\" must match the controller's "
"\"label\".** The gpiolib core uses this name to find the corresponding "
"struct gpio_chip at runtime. This software node has to be registered, but "
"need not be attached to the device representing the GPIO controller that is "
"providing the GPIO in question. It may be left as a \"free floating\" node."
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:46
msgid ""
"**The GPIO property must be a reference.** The ``PROPERTY_ENTRY_GPIO()`` "
"macro handles this as it is an alias for ``PROPERTY_ENTRY_REF()``."
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:49
msgid "**The reference must have exactly two arguments:**"
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:51
msgid "The first argument is the GPIO offset within the controller."
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:52
msgid ""
"The second argument is the flags for the GPIO line (e.g., GPIO_ACTIVE_HIGH, "
"GPIO_ACTIVE_LOW)."
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:55
msgid ""
"The ``PROPERTY_ENTRY_GPIO()`` macro is the preferred way of defining GPIO "
"properties in software nodes."
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:59
msgid "Conversion Example"
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:61
msgid ""
"Let's walk through an example of converting a board file that defines a "
"GPIO- connected LED and a button."
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:65
msgid "Before: Using Platform Data"
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:67
msgid "A typical legacy board file might look like this:"
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:136
msgid "After: Using Software Nodes"
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:138
msgid ""
"Here is how the same configuration can be expressed using software nodes."
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:141
msgid "Step 1: Define the GPIO Controller Node"
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:143
msgid ""
"First, define a software node that represents the GPIO controller that the "
"LEDs and buttons are connected to. The ``name`` of this node must match the "
"name of the driver for the GPIO controller (e.g., \"gpio-foo\")."
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:159
msgid "Step 2: Define Consumer Device Nodes and Properties"
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:161
msgid ""
"Next, define the software nodes for the consumer devices (the LEDs and "
"buttons). This involves creating a parent node for each device type and "
"child nodes for each individual LED or button."
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:206
msgid "Step 3: Group and Register the Nodes"
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:208
msgid ""
"For maintainability, it is often beneficial to group all software nodes into "
"a single array and register them with one call."
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:236
msgid ""
"When splitting registration of nodes by devices that they represent, it is "
"essential that the software node representing the GPIO controller itself is "
"registered first, before any of the nodes that reference it."
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:241
msgid "Step 4: Register Platform Devices with Software Nodes"
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:243
msgid ""
"Finally, register the platform devices and associate them with their "
"respective software nodes using the ``fwnode`` field in struct "
"platform_device_info."
msgstr ""

#: ../../../driver-api/gpio/legacy-boards.rst:295
msgid ""
"With these changes, the generic ``leds-gpio`` and ``gpio-keys`` drivers will "
"be able to probe successfully and get their configuration from the "
"properties defined in the software nodes, removing the need for board-"
"specific platform data."
msgstr ""
