# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-06 06:05+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/generic_pt.rst:5
msgid "Generic Radix Page Table"
msgstr ""

#: ../../../driver-api/generic_pt:7: ../include/linux/generic_pt/common.h:13
msgid ""
"Generic Radix Page Table is a set of functions and helpers to efficiently "
"parse radix style page tables typically seen in HW implementations. The "
"interface is built to deliver similar code generation as the mm's pte/pmd/"
"etc system by fully inlining the exact code required to handle each table "
"level."
msgstr ""

#: ../../../driver-api/generic_pt:7: ../include/linux/generic_pt/common.h:18
msgid ""
"Like the mm subsystem each format contributes its parsing implementation "
"under common names and the common code implements the required algorithms."
msgstr ""

#: ../../../driver-api/generic_pt:7: ../include/linux/generic_pt/common.h:21
msgid "The system is divided into three logical levels:"
msgstr ""

#: ../../../driver-api/generic_pt:7: ../include/linux/generic_pt/common.h:23
msgid "The page table format and its manipulation functions"
msgstr ""

#: ../../../driver-api/generic_pt:7: ../include/linux/generic_pt/common.h:24
msgid ""
"Generic helpers to give a consistent API regardless of underlying format"
msgstr ""

#: ../../../driver-api/generic_pt:7: ../include/linux/generic_pt/common.h:25
msgid "An algorithm implementation (e.g. IOMMU/DRM/KVM/MM)"
msgstr ""

#: ../../../driver-api/generic_pt:7: ../include/linux/generic_pt/common.h:27
msgid ""
"Multiple implementations are supported. The intention is to have the generic "
"format code be re-usable for whatever specialized implementation is "
"required. The generic code is solely about the format of the radix tree; it "
"does not include memory allocation or higher level decisions that are left "
"for the implementation."
msgstr ""

#: ../../../driver-api/generic_pt:7: ../include/linux/generic_pt/common.h:33
msgid ""
"The generic framework supports a superset of functions across many HW "
"implementations:"
msgstr ""

#: ../../../driver-api/generic_pt:7: ../include/linux/generic_pt/common.h:36
msgid "Entries comprised of contiguous blocks of IO PTEs for larger page sizes"
msgstr ""

#: ../../../driver-api/generic_pt:7: ../include/linux/generic_pt/common.h:37
msgid "Multi-level tables, up to 6 levels. Runtime selected top level"
msgstr ""

#: ../../../driver-api/generic_pt:7: ../include/linux/generic_pt/common.h:38
msgid "Runtime variable table level size (ARM's concatenated tables)"
msgstr ""

#: ../../../driver-api/generic_pt:7: ../include/linux/generic_pt/common.h:39
msgid "Expandable top level allowing dynamic sizing of table levels"
msgstr ""

#: ../../../driver-api/generic_pt:7: ../include/linux/generic_pt/common.h:40
msgid "Optional leaf entries at any level"
msgstr ""

#: ../../../driver-api/generic_pt:7: ../include/linux/generic_pt/common.h:41
msgid "32-bit/64-bit virtual and output addresses, using every address bit"
msgstr ""

#: ../../../driver-api/generic_pt:7: ../include/linux/generic_pt/common.h:42
msgid "Dirty tracking"
msgstr ""

#: ../../../driver-api/generic_pt:7: ../include/linux/generic_pt/common.h:43
msgid "Sign extended addressing"
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:74
msgid "Language used in Generic Page Table"
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:75
msgid "VA"
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:76
msgid "The input address to the page table, often the virtual address."
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:77
msgid "OA"
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:78
msgid "The output address from the page table, often the physical address."
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:79
msgid "leaf"
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:80
msgid "An entry that results in an output address."
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:81
msgid "start/end"
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:82
msgid "An half-open range, e.g. [0,0) refers to no VA."
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:83
msgid "start/last"
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:84
msgid "An inclusive closed range, e.g. [0,0] refers to the VA 0"
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:85
msgid "common"
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:86
msgid "The generic page table container struct pt_common"
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:87
msgid "level"
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:88
msgid ""
"Level 0 is always a table of only leaves with no futher table pointers. "
"Increasing levels increase the size of the table items. The least "
"significant VA bits used to index page tables are used to index the Level 0 "
"table. The various labels for table levels used by HW descriptions are not "
"used."
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:93
msgid "top_level"
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:94
msgid ""
"The inclusive highest level of the table. A two-level table has a top level "
"of 1."
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:96
msgid "table"
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:97
msgid "A linear array of translation items for that level."
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:98
msgid "index"
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:99
msgid "The position in a table of an element: item = table[index]"
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:100
msgid "item"
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:101
msgid "A single index in a table"
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:102
msgid "entry"
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:103
msgid ""
"A single logical element in a table. If contiguous pages are not supported "
"then item and entry are the same thing, otherwise entry refers to all the "
"items that comprise a single contiguous translation."
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:106
msgid "item/entry_size"
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:107
msgid ""
"The number of bytes of VA the table index translates for. If the item is a "
"table entry then the next table covers this size. If the entry translates to "
"an output address then the full OA is: OA | (VA % entry_size)"
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:111
msgid "contig_count"
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:112
msgid ""
"The number of consecutive items fused into a single entry. item_size * "
"contig_count is the size of that entry's translation."
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:114
msgid "lg2"
msgstr ""

#: ../../../driver-api/generic_pt:10: ../drivers/iommu/generic_pt/pt_defs.h:115
msgid ""
"Indicates the value is encoded as log2, i.e. 1<<x is the actual value. "
"Normally the compiler is fine to optimize divide and mod with log2 values "
"automatically when inlining, however if the values are not constant "
"expressions it can't. So we do it by hand; we want to avoid 64-bit divmod."
msgstr ""

#: ../../../driver-api/generic_pt.rst:14
msgid "Usage"
msgstr ""

#: ../../../driver-api/generic_pt.rst:16
msgid ""
"Generic PT is structured as a multi-compilation system. Since each format "
"provides an API using a common set of names there can be only one format "
"active within a compilation unit. This design avoids function pointers "
"around the low level API."
msgstr ""

#: ../../../driver-api/generic_pt.rst:21
msgid ""
"Instead the function pointers can end up at the higher level API (i.e. map/"
"unmap, etc.) and the per-format code can be directly inlined into the per-"
"format compilation unit. For something like IOMMU each format will be "
"compiled into a per-format IOMMU operations kernel module."
msgstr ""

#: ../../../driver-api/generic_pt.rst:26
msgid ""
"For this to work the .c file for each compilation unit will include both the "
"format headers and the generic code for the implementation. For instance in "
"an implementation compilation unit the headers would normally be included as "
"follows:"
msgstr ""

#: ../../../driver-api/generic_pt.rst:31
msgid "generic_pt/fmt/iommu_amdv1.c::"
msgstr ""

#: ../../../driver-api/generic_pt.rst:41
msgid ""
"iommu_pt.h includes definitions that will generate the operations functions "
"for map/unmap/etc. using the definitions provided by AMDv1. The resulting "
"module will have exported symbols named like pt_iommu_amdv1_init()."
msgstr ""

#: ../../../driver-api/generic_pt.rst:45
msgid ""
"Refer to drivers/iommu/generic_pt/fmt/iommu_template.h for an example of how "
"the IOMMU implementation uses multi-compilation to generate per-format ops "
"structs pointers."
msgstr ""

#: ../../../driver-api/generic_pt.rst:49
msgid ""
"The format code is written so that the common names arise from #defines to "
"distinct format specific names. This is intended to aid debuggability by "
"avoiding symbol clashes across all the different formats."
msgstr ""

#: ../../../driver-api/generic_pt.rst:53
msgid ""
"Exported symbols and other global names are mangled using a per-format "
"string via the NS() helper macro."
msgstr ""

#: ../../../driver-api/generic_pt.rst:56
msgid ""
"The format uses struct pt_common as the top-level struct for the table, and "
"each format will have its own struct pt_xxx which embeds it to store format-"
"specific information."
msgstr ""

#: ../../../driver-api/generic_pt.rst:60
msgid ""
"The implementation will further wrap struct pt_common in its own top-level "
"struct, such as struct pt_iommu_amdv1."
msgstr ""

#: ../../../driver-api/generic_pt.rst:64
msgid "Format functions at the struct pt_common level"
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:49
msgid "struct for all page table implementations"
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:53
msgid "**Definition**::"
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:62
msgid "**Members**"
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:53
msgid "``top_of_table``"
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:54
msgid ""
"Encodes the table top pointer and the top level in a single value. Must use "
"READ_ONCE/WRITE_ONCE to access it. The lower bits of the aligned table "
"pointer are used for the level."
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:59
msgid "``max_oasz_lg2``"
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:60
msgid ""
"Maximum number of bits the OA can contain. Upper bits must be zero. This may "
"be less than what the page table format supports, but must not be more."
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:65
msgid "``max_vasz_lg2``"
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:66
msgid ""
"Maximum number of bits the VA can contain. Upper bits are 0 or 1 depending "
"on pt_full_va_prefix(). This may be less than what the page table format "
"supports, but must not be more. When PT_FEAT_DYNAMIC_TOP is set this "
"reflects the maximum VA capability."
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:72
msgid "``features``"
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:73
msgid "Bitmap of `enum pt_features`"
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:84
msgid "Features turned on in the table. Each symbol is a bit position."
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:88
msgid "**Constants**"
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:90
msgid "``PT_FEAT_DMA_INCOHERENT``"
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:91
msgid ""
"Cache flush page table memory before assuming the HW can read it. Otherwise "
"a SMP release is sufficient for HW to read it."
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:95
msgid "``PT_FEAT_FULL_VA``"
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:96
msgid "The table can span the full VA range from 0 to PT_VADDR_MAX."
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:99
msgid "``PT_FEAT_DYNAMIC_TOP``"
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:100
msgid ""
"The table's top level can be increased dynamically during map. This requires "
"HW support for atomically setting both the table top pointer and the "
"starting table level."
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:104
msgid "``PT_FEAT_SIGN_EXTEND``"
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:105
msgid ""
"The top most bit of the valid VA range sign extends up to the full "
"pt_vaddr_t. This divides the page table into three VA ranges::"
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:113
msgid ""
"In this mode pt_common::max_vasz_lg2 includes the sign bit and the upper "
"bits that don't fall within the translation are just validated."
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:116
msgid ""
"If not set there is no sign extension and valid VA goes from 0 to 2^N - 1."
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:119
msgid "``PT_FEAT_FLUSH_RANGE``"
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:120
msgid ""
"IOTLB maintenance is done by flushing IOVA ranges which will clean out any "
"walk cache or any IOPTE fully contained by the range. The optimization "
"objective is to minimize the number of flushes even if ranges include IOVA "
"gaps that do not need to be flushed."
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:126
msgid "``PT_FEAT_FLUSH_RANGE_NO_GAPS``"
msgstr ""

#: ../../../driver-api/generic_pt:66: ../include/linux/generic_pt/common.h:127
msgid ""
"Like PT_FEAT_FLUSH_RANGE except that the optimization objective is to only "
"flush IOVA that has been changed. This mode is suitable for cases like "
"hypervisor shadowing where flushing unchanged ranges may cause the "
"hypervisor to reparse significant amount of page table."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:32
msgid "Convert the permission bits back to attrs"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:36
#: ../drivers/iommu/generic_pt/pt_common.h:48
#: ../drivers/iommu/generic_pt/pt_common.h:57
#: ../drivers/iommu/generic_pt/pt_common.h:69
#: ../drivers/iommu/generic_pt/pt_common.h:81
#: ../drivers/iommu/generic_pt/pt_common.h:91
#: ../drivers/iommu/generic_pt/pt_common.h:106
#: ../drivers/iommu/generic_pt/pt_common.h:116
#: ../drivers/iommu/generic_pt/pt_common.h:122
#: ../drivers/iommu/generic_pt/pt_common.h:131
#: ../drivers/iommu/generic_pt/pt_common.h:145
#: ../drivers/iommu/generic_pt/pt_common.h:157
#: ../drivers/iommu/generic_pt/pt_common.h:171
#: ../drivers/iommu/generic_pt/pt_common.h:181
#: ../drivers/iommu/generic_pt/pt_common.h:191
#: ../drivers/iommu/generic_pt/pt_common.h:211
#: ../drivers/iommu/generic_pt/pt_common.h:228
#: ../drivers/iommu/generic_pt/pt_common.h:240
#: ../drivers/iommu/generic_pt/pt_common.h:249
#: ../drivers/iommu/generic_pt/pt_common.h:260
#: ../drivers/iommu/generic_pt/pt_common.h:276
#: ../drivers/iommu/generic_pt/pt_common.h:287
#: ../drivers/iommu/generic_pt/pt_common.h:305
#: ../drivers/iommu/generic_pt/pt_common.h:316
#: ../drivers/iommu/generic_pt/pt_common.h:330
#: ../drivers/iommu/generic_pt/pt_common.h:339
#: ../drivers/iommu/generic_pt/pt_common.h:350
#: ../drivers/iommu/generic_pt/pt_common.h:359
#: ../drivers/iommu/generic_pt/pt_common.h:370
#: ../drivers/iommu/generic_pt/pt_common.h:381
#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:25
#: ../drivers/iommu/generic_pt/pt_iter.h:54
#: ../drivers/iommu/generic_pt/pt_iter.h:81
#: ../drivers/iommu/generic_pt/pt_iter.h:107
#: ../drivers/iommu/generic_pt/pt_iter.h:126
#: ../drivers/iommu/generic_pt/pt_iter.h:173
#: ../drivers/iommu/generic_pt/pt_iter.h:190
#: ../drivers/iommu/generic_pt/pt_iter.h:201
#: ../drivers/iommu/generic_pt/pt_iter.h:248
#: ../drivers/iommu/generic_pt/pt_iter.h:265
#: ../drivers/iommu/generic_pt/pt_iter.h:288
#: ../drivers/iommu/generic_pt/pt_iter.h:307
#: ../drivers/iommu/generic_pt/pt_iter.h:346
#: ../drivers/iommu/generic_pt/pt_iter.h:365
#: ../drivers/iommu/generic_pt/pt_iter.h:379
#: ../drivers/iommu/generic_pt/pt_iter.h:400
#: ../drivers/iommu/generic_pt/pt_iter.h:463
#: ../drivers/iommu/generic_pt/pt_iter.h:489
#: ../drivers/iommu/generic_pt/pt_iter.h:514
#: ../drivers/iommu/generic_pt/pt_iter.h:612
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:38
#: ../drivers/iommu/generic_pt/pt_common.h:50
#: ../drivers/iommu/generic_pt/pt_common.h:59
#: ../drivers/iommu/generic_pt/pt_common.h:108
#: ../drivers/iommu/generic_pt/pt_common.h:124
#: ../drivers/iommu/generic_pt/pt_common.h:133
#: ../drivers/iommu/generic_pt/pt_common.h:147
#: ../drivers/iommu/generic_pt/pt_common.h:159
#: ../drivers/iommu/generic_pt/pt_common.h:230
#: ../drivers/iommu/generic_pt/pt_common.h:262
#: ../drivers/iommu/generic_pt/pt_common.h:289
#: ../drivers/iommu/generic_pt/pt_common.h:307
#: ../drivers/iommu/generic_pt/pt_common.h:318
#: ../drivers/iommu/generic_pt/pt_common.h:332
#: ../drivers/iommu/generic_pt/pt_common.h:341
#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:83
#: ../drivers/iommu/generic_pt/pt_iter.h:109
#: ../drivers/iommu/generic_pt/pt_iter.h:128
#: ../drivers/iommu/generic_pt/pt_iter.h:465
msgid "``const struct pt_state *pts``"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:33
msgid "Entry to convert from"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:35
msgid "``struct pt_write_attrs *attrs``"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:34
msgid "Resulting attrs"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:36
#: ../drivers/iommu/generic_pt/pt_common.h:47
#: ../drivers/iommu/generic_pt/pt_common.h:56
#: ../drivers/iommu/generic_pt/pt_common.h:69
#: ../drivers/iommu/generic_pt/pt_common.h:80
#: ../drivers/iommu/generic_pt/pt_common.h:90
#: ../drivers/iommu/generic_pt/pt_common.h:105
#: ../drivers/iommu/generic_pt/pt_common.h:121
#: ../drivers/iommu/generic_pt/pt_common.h:130
#: ../drivers/iommu/generic_pt/pt_common.h:144
#: ../drivers/iommu/generic_pt/pt_common.h:156
#: ../drivers/iommu/generic_pt/pt_common.h:170
#: ../drivers/iommu/generic_pt/pt_common.h:180
#: ../drivers/iommu/generic_pt/pt_common.h:193
#: ../drivers/iommu/generic_pt/pt_common.h:212
#: ../drivers/iommu/generic_pt/pt_common.h:227
#: ../drivers/iommu/generic_pt/pt_common.h:239
#: ../drivers/iommu/generic_pt/pt_common.h:248
#: ../drivers/iommu/generic_pt/pt_common.h:259
#: ../drivers/iommu/generic_pt/pt_common.h:276
#: ../drivers/iommu/generic_pt/pt_common.h:286
#: ../drivers/iommu/generic_pt/pt_common.h:304
#: ../drivers/iommu/generic_pt/pt_common.h:315
#: ../drivers/iommu/generic_pt/pt_common.h:329
#: ../drivers/iommu/generic_pt/pt_common.h:338
#: ../drivers/iommu/generic_pt/pt_common.h:350
#: ../drivers/iommu/generic_pt/pt_common.h:359
#: ../drivers/iommu/generic_pt/pt_common.h:370
#: ../drivers/iommu/generic_pt/pt_common.h:380
#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:24
#: ../drivers/iommu/generic_pt/pt_iter.h:53
#: ../drivers/iommu/generic_pt/pt_iter.h:172
#: ../drivers/iommu/generic_pt/pt_iter.h:189
#: ../drivers/iommu/generic_pt/pt_iter.h:200
#: ../drivers/iommu/generic_pt/pt_iter.h:247
#: ../drivers/iommu/generic_pt/pt_iter.h:264
#: ../drivers/iommu/generic_pt/pt_iter.h:287
#: ../drivers/iommu/generic_pt/pt_iter.h:308
#: ../drivers/iommu/generic_pt/pt_iter.h:347
#: ../drivers/iommu/generic_pt/pt_iter.h:364
#: ../drivers/iommu/generic_pt/pt_iter.h:380
#: ../drivers/iommu/generic_pt/pt_iter.h:401
#: ../drivers/iommu/generic_pt/pt_iter.h:464
#: ../drivers/iommu/generic_pt/pt_iter.h:489
#: ../drivers/iommu/generic_pt/pt_iter.h:516
#: ../drivers/iommu/generic_pt/pt_iter.h:612
msgid "**Description**"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:35
msgid ""
"Fill in the attrs with the permission bits encoded in the current leaf "
"entry. The attrs should be usable with pt_install_leaf_entry() to "
"reconstruct the same entry."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:44
msgid "True if the current level can have an OA entry"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:45
#: ../drivers/iommu/generic_pt/pt_common.h:54
#: ../drivers/iommu/generic_pt/pt_common.h:257
#: ../drivers/iommu/generic_pt/pt_common.h:284
#: ../drivers/iommu/generic_pt/pt_common.h:302
#: ../drivers/iommu/generic_pt/pt_common.h:313
msgid "The current level"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:46
msgid ""
"True if the current level can support pt_install_leaf_entry(). A leaf entry "
"produce an OA."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:53
msgid "True if the current level can have a lower table"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:55
msgid "Every level except 0 is allowed to have a lower table."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:65
msgid "Make entries empty (non-present)"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:71
#: ../drivers/iommu/generic_pt/pt_common.h:83
#: ../drivers/iommu/generic_pt/pt_common.h:93
#: ../drivers/iommu/generic_pt/pt_common.h:193
#: ../drivers/iommu/generic_pt/pt_common.h:213
#: ../drivers/iommu/generic_pt/pt_common.h:242
#: ../drivers/iommu/generic_pt/pt_common.h:361
#: ../drivers/iommu/generic_pt/pt_common.h:372
#: ../drivers/iommu/generic_pt/pt_common.h:383
#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:56
#: ../drivers/iommu/generic_pt/pt_iter.h:175
#: ../drivers/iommu/generic_pt/pt_iter.h:203
#: ../drivers/iommu/generic_pt/pt_iter.h:381
msgid "``struct pt_state *pts``"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:66
msgid "Starting table index"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:68
msgid "``unsigned int num_contig_lg2``"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:67
msgid "Number of contiguous items to clear"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:68
msgid ""
"Clear a run of entries. A cleared entry will load back as PT_ENTRY_EMPTY and "
"does not have any effect on table walking. The starting index must be "
"aligned to num_contig_lg2."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:77
msgid "Make an entry dirty"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:78
#: ../drivers/iommu/generic_pt/pt_common.h:88
msgid "Table entry to change"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:79
msgid ""
"Make pt_entry_is_write_dirty() return true for this entry. This can be "
"called asynchronously with any other table manipulation under a RCU lock and "
"must not corrupt the table."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:87
msgid "Make the entry write clean"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:89
msgid ""
"Modify the entry so that pt_entry_is_write_dirty() == false. The HW will "
"eventually be notified of this change via a TLB flush, which is the point "
"that the HW must become synchronized. Any \"write dirty\" prior to the TLB "
"flush can be lost, but once the TLB flush completes all writes must make "
"their entries write dirty."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:95
msgid ""
"The format should alter the entry in a way that is compatible with any "
"concurrent update from HW. The entire contiguous entry is changed."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:102
msgid "True if the entry has been written to"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:103
#: ../drivers/iommu/generic_pt/pt_common.h:119
#: ../drivers/iommu/generic_pt/pt_common.h:128
#: ../drivers/iommu/generic_pt/pt_common.h:142
#: ../drivers/iommu/generic_pt/pt_common.h:154
#: ../drivers/iommu/generic_pt/pt_common.h:327
#: ../drivers/iommu/generic_pt/pt_common.h:336
msgid "Entry to query"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:104
msgid ""
"\"write dirty\" means that the HW has written to the OA translated by this "
"entry. If the entry is contiguous then the consolidated \"write dirty\" for "
"all the items must be returned."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:112
msgid "True if the page table supports dirty tracking"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:118
#: ../drivers/iommu/generic_pt/pt_common.h:278
#: ../drivers/iommu/generic_pt/pt_common.h:352
#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:250
#: ../drivers/iommu/generic_pt/pt_iter.h:267
#: ../drivers/iommu/generic_pt/pt_iter.h:290
#: ../drivers/iommu/generic_pt/pt_iter.h:309
#: ../drivers/iommu/generic_pt/pt_iter.h:491
msgid "``struct pt_common *common``"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:113
#: ../drivers/iommu/generic_pt/pt_common.h:168
#: ../drivers/iommu/generic_pt/pt_common.h:178
#: ../drivers/iommu/generic_pt/pt_common.h:246
#: ../drivers/iommu/generic_pt/pt_common.h:273
msgid "Page table to query"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:118
msgid "Number of contiguous items for this leaf entry"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:120
msgid ""
"Return the number of contiguous items this leaf entry spans. If the entry is "
"single item it returns ilog2(1)."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:127
msgid "Output Address for this leaf entry"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:129
msgid ""
"Return the output address for the start of the entry. If the entry is "
"contiguous this returns the same value for each sub-item. I.e.::"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:134
msgid ""
"See pt_item_oa(). The format should implement one of these two functions "
"depending on how it stores the OAs in the table."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:141
msgid "Return the size of an OA entry"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:143
msgid ""
"If the entry is not contiguous this returns pt_table_item_lg2sz(), otherwise "
"it returns the total VA/OA size of the entire contiguous entry."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:153
msgid "Return the complete OA for an entry"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:155
msgid ""
"During iteration the first entry could have a VA with an offset from the "
"natural start of the entry. Return the exact OA including the pts's VA "
"offset."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:167
msgid "The top bits of the VA"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:173
#: ../drivers/iommu/generic_pt/pt_common.h:183
#: ../drivers/iommu/generic_pt/pt_common.h:251
msgid "``const struct pt_common *common``"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:169
msgid ""
"This is usually 0, but some formats have their VA space going downward from "
"PT_VADDR_MAX, and will return that instead. This value must always be "
"adjusted by struct pt_common max_vasz_lg2."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:177
msgid "True if level 0 can install a PAGE_SHIFT entry"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:179
msgid ""
"If true the caller can use, at level 0, pt_install_leaf_entry(PAGE_SHIFT). "
"This is useful to create optimized paths for common cases of PAGE_SIZE "
"mappings."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:187
msgid "Write a leaf entry to the table"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:188
#: ../drivers/iommu/generic_pt/pt_common.h:208
msgid "Table index to change"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:190
#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:515
msgid "``pt_oaddr_t oa``"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:189
msgid "Output Address for this leaf"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:191
#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:81
msgid "``unsigned int oasz_lg2``"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:190
msgid "Size in VA/OA for this leaf"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:192
#: ../drivers/iommu/generic_pt/pt_common.h:211
msgid "``const struct pt_write_attrs *attrs``"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:191
msgid "Attributes to modify the entry"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:192
msgid ""
"A leaf OA entry will return PT_ENTRY_OA from pt_load_entry(). It translates "
"the VA indicated by pts to the given OA."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:195
msgid ""
"For a single item non-contiguous entry oasz_lg2 is pt_table_item_lg2sz(). "
"For contiguous it is pt_table_item_lg2sz() + num_contig_lg2."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:198
msgid ""
"This must not be called if pt_can_have_leaf() == false. Contiguous sizes not "
"indicated by pt_possible_sizes() must not be specified."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:207
msgid "Write a table entry to the table"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:210
msgid "``pt_oaddr_t table_pa``"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:209
msgid "CPU physical address of the lower table's memory"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:210
msgid "Attributes to modify the table index"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:211
msgid ""
"A table entry will return PT_ENTRY_TABLE from pt_load_entry(). The table_pa "
"is the table at pts->level - 1. This is done by cmpxchg so pts must have the "
"current entry loaded. The pts is updated with the installed entry."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:215
msgid "This must not be called if pt_can_have_table() == false."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:217
#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:83
#: ../drivers/iommu/generic_pt/pt_iter.h:106
#: ../drivers/iommu/generic_pt/pt_iter.h:125
msgid "**Return**"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:218
msgid "true if the table was installed successfully."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:224
msgid "Output Address for this leaf item"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:225
msgid "Item to query"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:226
msgid ""
"Return the output address for this item. If the item is part of a contiguous "
"entry it returns the value of the OA for this individual sub item."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:229
msgid ""
"See pt_entry_oa(). The format should implement one of these two functions "
"depending on how it stores the OA's in the table."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:236
#: ../drivers/iommu/generic_pt/pt_common.h:377
msgid "Read from the location pts points at into the pts"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:237
#: ../drivers/iommu/generic_pt/pt_common.h:378
msgid "Table index to load"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:238
msgid ""
"Return the type of entry that was loaded. pts->entry will be filled in with "
"the entry's content. See pt_load_entry()"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:245
msgid "Return the maximum OA the table format can hold"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:247
msgid ""
"The value oalog2_to_max_int(pt_max_oa_lg2()) is the MAX for the OA. This is "
"the absolute maximum address the table can hold. struct pt_common "
"max_oasz_lg2 sets a lower dynamic maximum based on HW capability."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:256
msgid "Return the number of items in this table level"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:258
msgid ""
"The number of items in a table level defines the number of bits this level "
"decodes from the VA. This function is not called for the top level, so it "
"does not need to compute a special value for the top case. The result for "
"the top is based on pt_common max_vasz_lg2."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:263
msgid ""
"The value is used as part of determining the table indexes via the equation::"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:272
msgid "Return the level that maps the page size"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:275
msgid "``unsigned int pgsize_lg2``"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:274
msgid "Log2 page size"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:275
msgid ""
"Returns the table level that will map the given page size. The page size "
"must be part of the pt_possible_sizes() for some level."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:283
msgid "Return a bitmap of possible output sizes at this level"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:285
msgid ""
"Each level has a list of possible output sizes that can be installed as leaf "
"entries. If pt_can_have_leaf() is false returns zero."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:288
msgid ""
"Otherwise the bit in position pt_table_item_lg2sz() should be set indicating "
"that a non-contiguous single item leaf entry is supported. The following "
"pt_num_items_lg2() number of bits can be set indicating contiguous entries "
"are supported. Bit pt_table_item_lg2sz() + pt_num_items_lg2() must not be "
"set, contiguous entries cannot span the entire table."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:294
msgid ""
"The OR of pt_possible_sizes() of all levels is the typical bitmask of all "
"supported sizes in the entire table."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:301
msgid "Size of a single item entry in this table level"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:303
msgid ""
"The size of the item specifies how much VA and OA a single item occupies."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:305
msgid ""
"See pt_entry_oa_lg2sz() for the same value including the effect of "
"contiguous entries."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:312
msgid "Return the VA/OA size of the entire table"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:314
msgid "Return the size of VA decoded by the entire table level."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:326
msgid "Return the CPU physical address of the table entry"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:328
msgid ""
"This is only ever called on PT_ENTRY_TABLE entries. Must return the same "
"value passed to pt_install_table()."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:335
msgid "Return a CPU pointer for a table item"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:337
msgid "Same as pt_table_pa() but returns a CPU pointer."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:346
msgid "Return the maximum software bit usable for any level and entry"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:348
msgid "Page table"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:349
msgid "The swbit can be passed as bitnr to the other sw_bit functions."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:355
msgid "Read a software bit in an item"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:356
msgid "Entry to read"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:358
#: ../drivers/iommu/generic_pt/pt_common.h:369
msgid "``unsigned int bitnr``"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:357
msgid "Bit to read"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:358
msgid ""
"Software bits are ignored by HW and can be used for any purpose by the "
"software. This does a test bit and acquire operation."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:366
msgid "Set a software bit in an item"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:367
msgid "Entry to set"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:368
msgid "Bit to set"
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:369
msgid ""
"Software bits are ignored by HW and can be used for any purpose by the "
"software. This does a set bit and release operation."
msgstr ""

#: ../../../driver-api/generic_pt:68:
#: ../drivers/iommu/generic_pt/pt_common.h:379
msgid ""
"Set the type of entry that was loaded. pts->entry and pts->table_lower will "
"be filled in with the entry's content."
msgstr ""

#: ../../../driver-api/generic_pt.rst:71
msgid "Iteration Helpers"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:21
msgid "Validate the range can be iterated"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:27
#: ../drivers/iommu/generic_pt/pt_iter.h:348
#: ../drivers/iommu/generic_pt/pt_iter.h:367
#: ../drivers/iommu/generic_pt/pt_iter.h:402
msgid "``struct pt_range *range``"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:22
msgid "Range to validate"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:23
msgid ""
"Check that VA and last_va fall within the permitted range of VAs. If the "
"format is using PT_FEAT_SIGN_EXTEND then this also checks the sign extension "
"is correct."
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:50
msgid "Update range->va to the current pts->index"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:51
#: ../drivers/iommu/generic_pt/pt_iter.h:79
#: ../drivers/iommu/generic_pt/pt_iter.h:104
#: ../drivers/iommu/generic_pt/pt_iter.h:123
#: ../drivers/iommu/generic_pt/pt_iter.h:170
#: ../drivers/iommu/generic_pt/pt_iter.h:187
#: ../drivers/iommu/generic_pt/pt_iter.h:198
#: ../drivers/iommu/generic_pt/pt_iter.h:376
#: ../drivers/iommu/generic_pt/pt_iter.h:460
msgid "Iteration State"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:52
msgid ""
"Adjust range->va to match the current index. This is done in a lazy manner "
"since computing the VA takes several instructions and is rarely required."
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:77
msgid "Check if the item or entry is entirely contained within pts->range"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:80
msgid ""
"The size of the item to check, pt_table_item_lg2sz() or pt_entry_oa_lg2sz()"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:83
msgid "true if the item is fully enclosed by the pts->range."
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:103
msgid "Starting index for an iteration"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:106
msgid "the starting index for the iteration in pts."
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:122
msgid "Ending index iteration"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:125
msgid "the last index for the iteration in pts."
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:169
msgid "Advance pts to the next entry"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:171
msgid ""
"Update pts to go to the next index at this level. If pts is pointing at a "
"contiguous entry then the index may advance my more than one."
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:188
msgid "``for_each_pt_level_entry (pts)``"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:186
msgid "For loop wrapper over entries in the range"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:192
msgid "``pts``"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:188
msgid ""
"This is the basic iteration primitive. It iterates over all the entries in "
"pts->range that fall within the pts's current table level. Each step does "
"pt_load_entry(pts)."
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:197
msgid "Version of pt_load_entry() usable within a walker"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:199
msgid ""
"Alternative to for_each_pt_level_entry() if the walker function uses only a "
"single entry."
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:244
#: ../drivers/iommu/generic_pt/pt_iter.h:284
msgid "Return a range that spans part of the top level"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:245
#: ../drivers/iommu/generic_pt/pt_iter.h:262
#: ../drivers/iommu/generic_pt/pt_iter.h:285
#: ../drivers/iommu/generic_pt/pt_iter.h:304
#: ../drivers/iommu/generic_pt/pt_iter.h:486
msgid "Table"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:246
msgid ""
"For PT_FEAT_SIGN_EXTEND this will return the lower range, and cover half the "
"total page table. Otherwise it returns the entire page table."
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:261
msgid "Return a range that spans the entire page table"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:263
msgid ""
"The returned range spans the whole page table. Due to how "
"PT_FEAT_SIGN_EXTEND is supported range->va and range->last_va will be "
"incorrect during the iteration and must not be accessed."
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:286
msgid ""
"For PT_FEAT_SIGN_EXTEND this will return the upper range, and cover half the "
"total page table. Otherwise it returns the entire page table."
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:303
msgid "Return a range that spans part of the table"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:306
#: ../drivers/iommu/generic_pt/pt_iter.h:513
msgid "``pt_vaddr_t va``"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:305
msgid "Start address"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:307
#: ../drivers/iommu/generic_pt/pt_iter.h:514
msgid "``pt_vaddr_t last_va``"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:306
msgid "Last address"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:307
msgid ""
"The caller must validate the range with pt_check_range() before using it."
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:342
#: ../drivers/iommu/generic_pt/pt_iter.h:361
msgid "Initialize a pt_state on the stack"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:343
#: ../drivers/iommu/generic_pt/pt_iter.h:362
msgid "Range pointer to embed in the state"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:345
msgid "``unsigned int level``"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:344
msgid "Table level for the state"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:346
msgid "``struct pt_table_p *table``"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:345
msgid "Pointer to the table memory at level"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:346
msgid "Helper to initialize the on-stack pt_state from walker arguments."
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:363
msgid "The pt_state points to the top most level."
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:375
msgid "Recursively invoke the walker for the lower level"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:378
#: ../drivers/iommu/generic_pt/pt_iter.h:400
msgid "``void *arg``"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:377
#: ../drivers/iommu/generic_pt/pt_iter.h:399
msgid "Value to pass to the function"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:379
#: ../drivers/iommu/generic_pt/pt_iter.h:399
msgid "``pt_level_fn_t fn``"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:378
#: ../drivers/iommu/generic_pt/pt_iter.h:398
msgid "Walker function to call"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:379
msgid ""
"pts must point to a table item. Invoke fn as a walker on the table pts "
"points to."
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:396
msgid "Walk over a VA range"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:397
msgid "Range pointer"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:400
msgid ""
"Walk over a VA range. The caller should have done a validity check, at least "
"calling pt_check_range(), when building range. The walk will start at the "
"top most table."
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:459
msgid "Return a range that spans indexes"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:462
msgid "``unsigned int start_index``"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:461
msgid "Starting index within pts"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:463
msgid "``unsigned int end_index``"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:462
msgid "Ending index within pts"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:463
msgid ""
"Create a range than spans an index range of the current table level pt_state "
"points at."
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:488
msgid "``uintptr_t top_of_table``"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:487
msgid "Top of table value from _pt_top_set()"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:488
msgid ""
"Compute the allocation size of the top table. For PT_FEAT_DYNAMIC_TOP this "
"will compute the top size assuming the table will grow."
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:510
msgid "Determine the best page size for leaf entries"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:516
msgid "``pt_vaddr_t pgsz_bitmap``"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:511
msgid "Permitted page sizes"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:512
msgid "Starting virtual address for the leaf entry"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:513
msgid "Last virtual address for the leaf entry, sets the max page size"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:514
msgid "Starting output address for the leaf entry"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:515
msgid ""
"Compute the largest page size for va, last_va, and oa together and return it "
"in lg2. The largest page size depends on the format's supported page sizes "
"at this level, and the relative alignment of the VA and OA addresses. 0 "
"means the OA cannot be stored with the provided pgsz_bitmap."
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:610
msgid "``PT_MAKE_LEVELS (fn, do_fn)``"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:608
msgid "Build an unwound walker"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:614
msgid "``fn``"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:609
msgid "Name of the walker function"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:611
msgid "``do_fn``"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:610
msgid "Function to call at each level"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:611
msgid ""
"This builds a function call tree that can be fully inlined. The caller must "
"provide a function body in an __always_inline function::"
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:618
msgid ""
"An inline function will be created for each table level that calls do_fn "
"with a compile time constant for level and a pointer to the next lower "
"function. This generates an optimally inlined walk where each of the "
"functions sees a constant level and can codegen the exact constants/etc for "
"that level."
msgstr ""

#: ../../../driver-api/generic_pt:73: ../drivers/iommu/generic_pt/pt_iter.h:623
msgid "Note this can produce a lot of code!"
msgstr ""

#: ../../../driver-api/generic_pt.rst:76
msgid "Writing a Format"
msgstr ""

#: ../../../driver-api/generic_pt.rst:78
msgid ""
"It is best to start from a simple format that is similar to the target. "
"x86_64 is usually a good reference for something simple, and AMDv1 is "
"something fairly complete."
msgstr ""

#: ../../../driver-api/generic_pt.rst:82
msgid ""
"The required inline functions need to be implemented in the format header. "
"These should all follow the standard pattern of::"
msgstr ""

#: ../../../driver-api/generic_pt.rst:91
msgid ""
"where a uniquely named per-format inline function provides the "
"implementation and a define maps it to the generic name. This is intended to "
"make debug symbols work better. inline functions should always be used as "
"the prototypes in pt_common.h will cause the compiler to validate the "
"function signature to prevent errors."
msgstr ""

#: ../../../driver-api/generic_pt.rst:97
msgid "Review pt_fmt_defaults.h to understand some of the optional inlines."
msgstr ""

#: ../../../driver-api/generic_pt.rst:99
msgid ""
"Once the format compiles then it should be run through the generic page "
"table kunit test in kunit_generic_pt.h using kunit. For example::"
msgstr ""

#: ../../../driver-api/generic_pt.rst:107
msgid ""
"The generic tests are intended to prove out the format functions and give "
"clearer failures to speed up finding the problems. Once those pass then the "
"entire kunit suite should be run."
msgstr ""

#: ../../../driver-api/generic_pt.rst:112
msgid "IOMMU Invalidation Features"
msgstr ""

#: ../../../driver-api/generic_pt.rst:114
msgid ""
"Invalidation is how the page table algorithms synchronize with a HW cache of "
"the page table memory, typically called the TLB (or IOTLB for IOMMU cases)."
msgstr ""

#: ../../../driver-api/generic_pt.rst:117
msgid ""
"The TLB can store present PTEs, non-present PTEs and table pointers, "
"depending on its design. Every HW has its own approach on how to describe "
"what has changed to have changed items removed from the TLB."
msgstr ""

#: ../../../driver-api/generic_pt.rst:122
msgid "PT_FEAT_FLUSH_RANGE"
msgstr ""

#: ../../../driver-api/generic_pt.rst:124
msgid ""
"PT_FEAT_FLUSH_RANGE is the easiest scheme to understand. It tries to "
"generate a single range invalidation for each operation, over-invalidating "
"if there are gaps of VA that don't need invalidation. This trades off "
"impacted VA for number of invalidation operations. It does not keep track of "
"what is being invalidated; however, if pages have to be freed then page "
"table pointers have to be cleaned from the walk cache. The range can start/"
"end at any page boundary."
msgstr ""

#: ../../../driver-api/generic_pt.rst:132
msgid "PT_FEAT_FLUSH_RANGE_NO_GAPS"
msgstr ""

#: ../../../driver-api/generic_pt.rst:134
msgid ""
"PT_FEAT_FLUSH_RANGE_NO_GAPS is similar to PT_FEAT_FLUSH_RANGE; however, it "
"tries to minimize the amount of impacted VA by issuing extra flush "
"operations. This is useful if the cost of processing VA is very high, for "
"instance because a hypervisor is processing the page table with a shadowing "
"algorithm."
msgstr ""
