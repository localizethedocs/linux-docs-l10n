# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-27 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/spi.rst:2
msgid "Serial Peripheral Interface (SPI)"
msgstr ""

#: ../../../driver-api/spi.rst:4
msgid ""
"SPI is the \"Serial Peripheral Interface\", widely used with embedded "
"systems because it is a simple and efficient interface: basically a "
"multiplexed shift register. Its three signal wires hold a clock (SCK, often "
"in the range of 1-20 MHz), a \"Master Out, Slave In\" (MOSI) data line, and "
"a \"Master In, Slave Out\" (MISO) data line. SPI is a full duplex protocol; "
"for each bit shifted out the MOSI line (one per clock) another is shifted in "
"on the MISO line. Those bits are assembled into words of various sizes on "
"the way to and from system memory. An additional chipselect line is usually "
"active-low (nCS); four signals are normally used for each peripheral, plus "
"sometimes an interrupt."
msgstr ""

#: ../../../driver-api/spi.rst:15
msgid ""
"The SPI bus facilities listed here provide a generalized interface to "
"declare SPI buses and devices, manage them according to the standard Linux "
"driver model, and perform input/output operations. At this time, only "
"\"master\" side interfaces are supported, where Linux talks to SPI "
"peripherals and does not implement such a peripheral itself. (Interfaces to "
"support implementing SPI slaves would necessarily look different.)"
msgstr ""

#: ../../../driver-api/spi.rst:22
msgid ""
"The programming interface is structured around two kinds of driver, and two "
"kinds of device. A \"Controller Driver\" abstracts the controller hardware, "
"which may be as simple as a set of GPIO pins or as complex as a pair of "
"FIFOs connected to dual DMA engines on the other side of the SPI shift "
"register (maximizing throughput). Such drivers bridge between whatever bus "
"they sit on (often the platform bus) and SPI, and expose the SPI side of "
"their device as a :c:type:`struct spi_controller <spi_controller>`. SPI "
"devices are children of that master, represented as a :c:type:`struct "
"spi_device <spi_device>` and manufactured from :c:type:`struct "
"spi_board_info <spi_board_info>` descriptors which are usually provided by "
"board-specific initialization code. A :c:type:`struct spi_driver "
"<spi_driver>` is called a \"Protocol Driver\", and is bound to a spi_device "
"using normal driver model calls."
msgstr ""

#: ../../../driver-api/spi.rst:37
msgid ""
"The I/O model is a set of queued messages. Protocol drivers submit one or "
"more :c:type:`struct spi_message <spi_message>` objects, which are processed "
"and completed asynchronously. (There are synchronous wrappers, however.) "
"Messages are built from one or more :c:type:`struct spi_transfer "
"<spi_transfer>` objects, each of which wraps a full duplex SPI transfer. A "
"variety of protocol tweaking options are needed, because different chips "
"adopt very different policies for how they use the bits transferred with SPI."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:44
msgid "statistics for spi transfers"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:48
#: include/linux/spi/spi.h:119 include/linux/spi/spi.h:137
#: include/linux/spi/spi.h:332 include/linux/spi/spi.h:399
#: include/linux/spi/spi.h:923 include/linux/spi/spi.h:957
#: include/linux/spi/spi.h:1128 include/linux/spi/spi.h:1398
#: include/linux/spi/spi.h:1615
msgid "**Definition**::"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:67
#: include/linux/spi/spi.h:129 include/linux/spi/spi.h:166
#: include/linux/spi/spi.h:342 include/linux/spi/spi.h:495
#: include/linux/spi/spi.h:931 include/linux/spi/spi.h:996
#: include/linux/spi/spi.h:1148 include/linux/spi/spi.h:1409
#: include/linux/spi/spi.h:1629
msgid "**Members**"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:45
msgid "``syncp``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:46
msgid ""
"seqcount to protect members in this struct for per-cpu update on 32-bit "
"systems"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:48
msgid "``messages``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:49
msgid "number of spi-messages handled"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:49
#: include/linux/spi/spi.h:1125
msgid "``transfers``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:50
msgid "number of spi_transfers handled"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:50
msgid "``errors``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:51
msgid "number of errors during spi_transfer"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:51
msgid "``timedout``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:52
msgid "number of timeouts during spi_transfer"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:53
msgid "``spi_sync``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:54
msgid "number of times spi_sync is used"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:54
msgid "``spi_sync_immediate``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:55
msgid ""
"number of times spi_sync is executed immediately in calling context without "
"queuing and scheduling"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:57
msgid "``spi_async``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:58
msgid "number of times spi_async is used"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:59
msgid "``bytes``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:60
msgid "number of bytes transferred to/from device"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:61
msgid "``bytes_rx``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:62
msgid "number of bytes received from device"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:60
msgid "``bytes_tx``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:61
msgid "number of bytes sent to device"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:63
msgid "``transfer_bytes_histo``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:64
msgid "transfer bytes histogram"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:66
msgid "``transfers_split_maxsize``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:67
msgid "number of transfers that have been split because of maxsize limit"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:115
msgid "SPI delay information"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:116
msgid "``value``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:117
msgid "Value for the delay"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:117
msgid "``unit``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:118
msgid "Unit for the delay"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:133
msgid "Controller side proxy for an SPI target device"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:134
#: include/linux/spi/spi.h:396
msgid "``dev``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:135
msgid "Driver model representation of the device."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:135
msgid "``controller``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:136
msgid "SPI controller used with the device."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:136
#: include/linux/spi/spi.h:413 include/linux/spi/spi.h:1619
msgid "``max_speed_hz``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:137
msgid ""
"Maximum clock rate to be used with this chip (on this board); may be changed "
"by the device's driver. The spi_transfer.speed_hz can override this for each "
"transfer."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:139
#: include/linux/spi/spi.h:965
msgid "``bits_per_word``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:140
msgid ""
"Data transfers involve one or more words; word sizes like eight or 12 bits "
"are common.  In-memory wordsizes are powers of two bytes (e.g. 20 bit "
"samples use 32 bits). This may be changed by the device's driver, or left at "
"the default (0) indicating protocol words are eight bit bytes. The "
"spi_transfer.bits_per_word can override this for each transfer."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:145
#: include/linux/spi/spi.h:463
msgid "``rt``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:146
msgid "Make the pump thread real time priority."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:146
#: include/linux/spi/spi.h:1625
msgid "``mode``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:147
msgid ""
"The spi mode defines how data is clocked out and in. This may be changed by "
"the device's driver. The \"active low\" default for chipselect mode can be "
"overridden (by specifying SPI_CS_HIGH) as can the \"MSB first\" default for "
"each word in a transfer (by specifying SPI_LSB_FIRST)."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:151
#: include/linux/spi/spi.h:1618
msgid "``irq``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:152
msgid ""
"Negative, or the number passed to request_irq() to receive interrupts from "
"this device."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:153
msgid "``controller_state``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:154
msgid "Controller's runtime state"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:154
#: include/linux/spi/spi.h:1616
msgid "``controller_data``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:155
msgid ""
"Board-specific definitions for controller, such as FIFO initialization "
"parameters; from board_info.controller_data"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:156
#: include/linux/spi/spi.h:1612
msgid "``modalias``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:157
msgid ""
"Name of the driver to use with this device, or an alias for that name.  This "
"appears in the sysfs \"modalias\" attribute for driver coldplugging, and in "
"uevents used for hotplugging"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:159
msgid "``driver_override``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:160
msgid ""
"If the name of a driver is written to this attribute, then the device will "
"bind to the named driver and only the named driver. Do not set directly, "
"because core frees it; use driver_set_override() to set or clear it."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:163
#: include/linux/spi/spi.h:526
msgid "``pcpu_statistics``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:164
msgid "statistics for the spi_device"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:164
#: include/linux/spi/spi.h:975
msgid "``word_delay``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:165
msgid "delay to be inserted between consecutive words of a transfer"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:166
msgid "``cs_setup``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:167
msgid "delay to be introduced by the controller after CS is asserted"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:167
msgid "``cs_hold``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:168
msgid "delay to be introduced by the controller before CS is deasserted"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:168
msgid "``cs_inactive``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:169
msgid ""
"delay to be introduced by the controller after CS is deasserted. If "
"**cs_change_delay** is used from **spi_transfer**, then the two delays will "
"be added up."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:171
#: include/linux/spi/spi.h:1623
msgid "``chip_select``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:172
msgid ""
"Array of physical chipselect, spi->chipselect[i] gives the corresponding "
"physical CS for logical CS i."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:173
#: include/linux/spi/spi.h:400
msgid "``num_chipselect``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:174
msgid "Number of physical chipselects used."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:174
msgid "``cs_index_mask``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:175
msgid "Bit mask of the active chipselect(s) in the chipselect array"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:175
msgid "``cs_gpiod``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:176
msgid ""
"Array of GPIO descriptors of the corresponding chipselect lines (optional, "
"NULL when not using a GPIO line)"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:180
#: include/linux/spi/spi.h:342 include/linux/spi/spi.h:386
#: include/linux/spi/spi.h:550 include/linux/spi/spi.h:926
#: include/linux/spi/spi.h:984 include/linux/spi/spi.h:1143
#: include/linux/spi/spi.h:1247 include/linux/spi/spi.h:1327
#: include/linux/spi/spi.h:1346 include/linux/spi/spi.h:1373
#: include/linux/spi/spi.h:1452 include/linux/spi/spi.h:1476
#: include/linux/spi/spi.h:1499 include/linux/spi/spi.h:1526
#: include/linux/spi/spi.h:1548 include/linux/spi/spi.h:1573
#: include/linux/spi/spi.h:1631 ../../../driver-api/spi:49:
#: drivers/spi/spi.c:901 ../../../driver-api/spi:52: drivers/spi/spi.c:552
#: drivers/spi/spi.c:761 drivers/spi/spi.c:787 drivers/spi/spi.c:857
#: drivers/spi/spi.c:1709 drivers/spi/spi.c:1949 drivers/spi/spi.c:1989
#: drivers/spi/spi.c:2075 drivers/spi/spi.c:2137 drivers/spi/spi.c:2546
#: drivers/spi/spi.c:2763 drivers/spi/spi.c:3022 drivers/spi/spi.c:3082
#: drivers/spi/spi.c:3228 drivers/spi/spi.c:3381 drivers/spi/spi.c:3419
#: drivers/spi/spi.c:3722 drivers/spi/spi.c:3764 drivers/spi/spi.c:3856
#: drivers/spi/spi.c:4286 drivers/spi/spi.c:4332 drivers/spi/spi.c:4385
#: drivers/spi/spi.c:4407 drivers/spi/spi.c:4567 drivers/spi/spi.c:4600
#: drivers/spi/spi.c:4621 drivers/spi/spi.c:4652 drivers/spi/spi.c:4684
msgid "**Description**"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:177
msgid ""
"A **spi_device** is used to interchange data between an SPI target device "
"(usually a discrete chip) and CPU memory."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:180
msgid ""
"In **dev**, the platform_data is used to hold information about this device "
"that's meaningful to the device's protocol driver, but not to its "
"controller.  One example might be an identifier for a chip variant with "
"slightly different functionality; another might be information about how "
"this particular board wires the chip's pins."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:328
msgid "Host side \"protocol\" driver"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:329
msgid "``id_table``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:330
msgid "List of SPI devices supported by this driver"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:330
msgid "``probe``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:331
msgid ""
"Binds this driver to the SPI device.  Drivers can verify that the device is "
"actually present, and may need to configure characteristics (such as "
"bits_per_word) which weren't needed for the initial configuration done "
"during system setup."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:334
msgid "``remove``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:335
msgid "Unbinds this driver from the SPI device"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:335
msgid "``shutdown``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:336
msgid ""
"Standard shutdown callback used during system state transitions such as "
"powerdown/halt and kexec"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:337
msgid "``driver``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:338
msgid ""
"SPI device drivers should initialize the name and owner field of this "
"structure."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:339
msgid ""
"This represents the kind of device driver that uses SPI messages to interact "
"with the hardware at the other end of a SPI link.  It's called a "
"\"protocol\" driver because it works through messages rather than talking "
"directly to SPI hardware (which is what the underlying SPI controller driver "
"does to pass those messages).  These protocols are defined in the "
"specification for the device(s) supported by the driver."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:346
msgid ""
"As a rule, those device protocols represent the lowest level interface "
"supported by a driver, and it will support upper level interfaces too. "
"Examples of such upper levels include frameworks like MTD, networking, MMC, "
"RTC, filesystem character device nodes, and hardware monitoring."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:366
msgid "reverse effect of spi_register_driver"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:370
#: include/linux/spi/spi.h:387 include/linux/spi/spi.h:1246
#: include/linux/spi/spi.h:1327 include/linux/spi/spi.h:1347
#: include/linux/spi/spi.h:1373 include/linux/spi/spi.h:1450
#: include/linux/spi/spi.h:1474 include/linux/spi/spi.h:1497
#: include/linux/spi/spi.h:1525 include/linux/spi/spi.h:1547
#: include/linux/spi/spi.h:1572 ../../../driver-api/spi:49:
#: drivers/spi/spi.c:900 ../../../driver-api/spi:52: drivers/spi/spi.c:475
#: drivers/spi/spi.c:552 drivers/spi/spi.c:762 drivers/spi/spi.c:786
#: drivers/spi/spi.c:858 drivers/spi/spi.c:1710 drivers/spi/spi.c:1942
#: drivers/spi/spi.c:1987 drivers/spi/spi.c:2075 drivers/spi/spi.c:2138
#: drivers/spi/spi.c:2546 drivers/spi/spi.c:2632 drivers/spi/spi.c:2762
#: drivers/spi/spi.c:2920 drivers/spi/spi.c:3015 drivers/spi/spi.c:3080
#: drivers/spi/spi.c:3227 drivers/spi/spi.c:3379 drivers/spi/spi.c:3419
#: drivers/spi/spi.c:3719 drivers/spi/spi.c:3761 drivers/spi/spi.c:3856
#: drivers/spi/spi.c:4286 drivers/spi/spi.c:4333 drivers/spi/spi.c:4383
#: drivers/spi/spi.c:4406 drivers/spi/spi.c:4566 drivers/spi/spi.c:4599
#: drivers/spi/spi.c:4621 drivers/spi/spi.c:4652 drivers/spi/spi.c:4680
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:372
#: ../../../driver-api/spi:52: drivers/spi/spi.c:474
msgid "``struct spi_driver *sdrv``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:367
msgid "the driver to unregister"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:369
#: include/linux/spi/spi.h:1451 include/linux/spi/spi.h:1475
#: include/linux/spi/spi.h:1498 include/linux/spi/spi.h:1525
#: include/linux/spi/spi.h:1547 include/linux/spi/spi.h:1572
#: ../../../driver-api/spi:49: drivers/spi/spi.c:900
#: ../../../driver-api/spi:52: drivers/spi/spi.c:475 drivers/spi/spi.c:551
#: drivers/spi/spi.c:786 drivers/spi/spi.c:3021 drivers/spi/spi.c:3081
#: drivers/spi/spi.c:3227 drivers/spi/spi.c:3380 drivers/spi/spi.c:3418
#: drivers/spi/spi.c:3855 drivers/spi/spi.c:4297 drivers/spi/spi.c:4333
#: drivers/spi/spi.c:4406 drivers/spi/spi.c:4566 drivers/spi/spi.c:4599
#: drivers/spi/spi.c:4620 drivers/spi/spi.c:4651 drivers/spi/spi.c:4683
msgid "**Context**"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:368
#: include/linux/spi/spi.h:1450 include/linux/spi/spi.h:1474
#: include/linux/spi/spi.h:1497 include/linux/spi/spi.h:1524
#: include/linux/spi/spi.h:1546 include/linux/spi/spi.h:1571
#: ../../../driver-api/spi:49: drivers/spi/spi.c:899
#: ../../../driver-api/spi:52: drivers/spi/spi.c:474 drivers/spi/spi.c:550
#: drivers/spi/spi.c:785 drivers/spi/spi.c:3020 drivers/spi/spi.c:3080
#: drivers/spi/spi.c:3226 drivers/spi/spi.c:3379 drivers/spi/spi.c:3417
#: drivers/spi/spi.c:4298 drivers/spi/spi.c:4334 drivers/spi/spi.c:4565
#: drivers/spi/spi.c:4598 drivers/spi/spi.c:4619 drivers/spi/spi.c:4650
#: drivers/spi/spi.c:4682
msgid "can sleep"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:385
msgid "``module_spi_driver (__spi_driver)``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:383
msgid "Helper macro for registering a SPI driver"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:389
msgid "``__spi_driver``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:384
msgid "spi_driver struct"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:385
msgid ""
"Helper macro for SPI drivers which do not do anything special in module init/"
"exit. This eliminates a lot of boilerplate. Each module may only use this "
"macro once, and calling it replaces module_init() and module_exit()"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:395
msgid "interface to SPI host or target controller"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:397
msgid "device interface to this driver"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:397
msgid "``list``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:398
msgid "link with the global spi_controller list"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:398
#: include/linux/spi/spi.h:1621
msgid "``bus_num``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:399
msgid ""
"board-specific (and often SOC-specific) identifier for a given SPI "
"controller."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:401
msgid ""
"chipselects are used to distinguish individual SPI targets, and are numbered "
"from zero to num_chipselects. each target has a chipselect signal, but it's "
"common that not every chipselect is connected to a target."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:404
msgid "``dma_alignment``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:405
msgid "SPI controller constraint on DMA buffers alignment."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:405
msgid "``mode_bits``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:406
msgid "flags understood by this controller driver"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:406
msgid "``buswidth_override_bits``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:407
msgid "flags to override for this controller driver"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:407
msgid "``bits_per_word_mask``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:408
msgid ""
"A mask indicating which values of bits_per_word are supported by the driver. "
"Bit n indicates that a bits_per_word n+1 is supported. If set, the SPI core "
"will reject any transfer with an unsupported bits_per_word. If not set, this "
"value is simply ignored, and it's up to the individual driver to perform any "
"validation."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:412
msgid "``min_speed_hz``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:413
msgid "Lowest supported transfer speed"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:414
msgid "Highest supported transfer speed"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:414
msgid "``flags``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:415
msgid "other constraints relevant to this driver"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:417
msgid "``devm_allocated``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:418
msgid "whether the allocation of this struct is devres-managed"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1
msgid "``{unnamed_union}``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:2
msgid "anonymous"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:415
msgid "``slave``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:416
msgid "indicates that this is an SPI slave controller"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:416
msgid "``target``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:417
msgid "indicates that this is an SPI target controller"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:418
msgid "``max_transfer_size``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:419
msgid ""
"function that returns the max transfer size for a :c:type:`spi_device`; may "
"be ``NULL``, so the default ``SIZE_MAX`` will be used."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:420
msgid "``max_message_size``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:421
msgid ""
"function that returns the max message size for a :c:type:`spi_device`; may "
"be ``NULL``, so the default ``SIZE_MAX`` will be used."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:422
msgid "``io_mutex``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:423
msgid "mutex for physical bus access"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:423
msgid "``add_lock``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:424
msgid "mutex to avoid adding devices to the same chipselect"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:424
msgid "``bus_lock_spinlock``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:425
msgid "spinlock for SPI bus locking"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:425
msgid "``bus_lock_mutex``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:426
msgid "mutex for exclusion of multiple callers"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:426
msgid "``bus_lock_flag``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:427
msgid "indicates that the SPI bus is locked for exclusive use"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:427
msgid "``setup``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:428
msgid ""
"updates the device mode and clocking records used by a device's SPI "
"controller; protocol code may call this.  This must fail if an unrecognized "
"or unsupported mode is requested. It's always safe to call this unless "
"transfers are pending on the device whose settings are being modified."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:432
msgid "``set_cs_timing``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:433
msgid ""
"optional hook for SPI devices to request SPI controller for configuring "
"specific CS setup time, hold time and inactive delay in terms of clock counts"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:435
msgid "``transfer``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:436
msgid "adds a message to the controller's transfer queue."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:436
msgid "``cleanup``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:437
msgid "frees controller-specific state"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:437
msgid "``can_dma``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:438
msgid "determine whether this controller supports DMA"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:438
msgid "``dma_map_dev``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:439
msgid "device which can be used for DMA mapping"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:439
msgid "``cur_rx_dma_dev``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:440
msgid "device which is currently used for RX DMA mapping"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:440
msgid "``cur_tx_dma_dev``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:441
msgid "device which is currently used for TX DMA mapping"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:441
msgid "``queued``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:442
msgid "whether this controller is providing an internal message queue"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:442
msgid "``kworker``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:443
msgid "pointer to thread struct for message pump"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:443
msgid "``pump_messages``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:444
msgid "work struct for scheduling work to the message pump"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:444
msgid "``queue_lock``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:445
msgid "spinlock to synchronise access to message queue"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:445
#: include/linux/spi/spi.h:1136
msgid "``queue``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:446
msgid "message queue"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:446
msgid "``cur_msg``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:447
msgid "the currently in-flight message"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:447
msgid "``cur_msg_completion``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:448
msgid "a completion for the current in-flight message"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:448
msgid "``cur_msg_incomplete``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:449
msgid ""
"Flag used internally to opportunistically skip the **cur_msg_completion**. "
"This flag is used to check if the driver has already called "
"spi_finalize_current_message()."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:451
msgid "``cur_msg_need_completion``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:452
msgid ""
"Flag used internally to opportunistically skip the **cur_msg_completion**. "
"This flag is used to signal the context that is running "
"spi_finalize_current_message() that it needs to complete()"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:461
msgid "``busy``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:462
msgid "message pump is busy"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:462
msgid "``running``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:463
msgid "message pump is running"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:464
msgid "whether this queue is set to run as a realtime task"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:464
msgid "``auto_runtime_pm``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:465
msgid ""
"the core should ensure a runtime PM reference is held while the hardware is "
"prepared, using the parent device for the spidev"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:454
msgid "``fallback``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:455
msgid ""
"fallback to PIO if DMA transfer return failure with SPI_TRANS_FAIL_NO_START."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:456
msgid "``last_cs_mode_high``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:457
msgid "was (mode & SPI_CS_HIGH) true on the last call to set_cs."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:457
msgid "``last_cs``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:458
msgid ""
"the last chip_select that is recorded by set_cs, -1 on non chip selected"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:459
msgid "``last_cs_index_mask``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:460
msgid "bit mask the last chip selects that were used"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:460
msgid "``xfer_completion``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:461
msgid "used by core transfer_one_message()"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:467
msgid "``max_dma_len``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:468
msgid "Maximum length of a DMA transfer for the device."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:482
msgid "``optimize_message``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:483
msgid "optimize the message for reuse"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:483
msgid "``unoptimize_message``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:484
msgid "release resources allocated by optimize_message"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:468
msgid "``prepare_transfer_hardware``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:469
msgid ""
"a message will soon arrive from the queue so the subsystem requests the "
"driver to prepare the transfer hardware by issuing this call"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:471
msgid "``transfer_one_message``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:472
msgid ""
"the subsystem calls the driver to transfer a single message while queuing "
"transfers that arrive in the meantime. When the driver is finished with this "
"message, it must call spi_finalize_current_message() so the subsystem can "
"issue the next message"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:476
msgid "``unprepare_transfer_hardware``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:477
msgid ""
"there are currently no more messages on the queue so the subsystem notifies "
"the driver that it may relax the hardware by issuing this call"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:484
msgid "``prepare_message``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:485
msgid ""
"set up the controller to transfer a single message, for example doing DMA "
"mapping.  Called from threaded context."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:512
msgid "``unprepare_message``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:513
msgid "undo any work done by prepare_message()."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:513
msgid "``target_abort``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:514
#: ../../../driver-api/spi:52: drivers/spi/spi.c:2916
msgid "abort the ongoing transfer request on an SPI target controller"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:480
msgid "``set_cs``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:481
msgid ""
"set the logic level of the chip select line.  May be called from interrupt "
"context."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:487
msgid "``transfer_one``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:488
msgid "transfer a single spi_transfer."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:500
msgid "``handle_err``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:501
msgid ""
"the subsystem calls the driver to handle an error that occurs in the generic "
"implementation of transfer_one_message()."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:502
msgid "``mem_ops``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:503
msgid ""
"optimized/dedicated operations for interactions with SPI memory. This field "
"is optional and should only be implemented if the controller has native "
"support for memory like operations."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:509
msgid "``mem_caps``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:510
msgid "controller capabilities for the handling of memory operations."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:510
msgid "``dtr_caps``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:511
msgid ""
"true if controller has dtr(single/dual transfer rate) capability. QSPI based "
"controller should fill this based on controller's capability."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:505
msgid "``get_offload``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:506
msgid ""
"callback for controllers with offload support to get matching offload "
"instance. Implementations should return -ENODEV if no match is found."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:508
msgid "``put_offload``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:509
msgid "release the offload instance acquired by **get_offload**."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:514
msgid "``cs_gpiods``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:515
msgid ""
"Array of GPIO descriptors to use as chip select lines; one per CS number. "
"Any individual value may be NULL for CS lines that are not GPIOs (driven by "
"the SPI controller itself)."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:517
msgid "``use_gpio_descriptors``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:518
msgid ""
"Turns on the code in the SPI core to parse and grab GPIO descriptors. This "
"will fill in **cs_gpiods** and SPI devices will have the cs_gpiod assigned "
"if a GPIO line is found for the chipselect."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:520
msgid "``unused_native_cs``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:521
msgid ""
"When cs_gpiods is used, spi_register_controller() will fill in this field "
"with the first unused native CS, to be used by SPI controller drivers that "
"need to drive a native CS when using GPIO CS."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:523
msgid "``max_native_cs``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:524
msgid ""
"When cs_gpiods is used, and this field is filled in, "
"spi_register_controller() will validate all native CS (including the unused "
"native CS) against this value."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:527
msgid "statistics for the spi_controller"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:527
msgid "``dma_tx``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:528
msgid "DMA transmit channel"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:528
msgid "``dma_rx``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:529
msgid "DMA receive channel"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:529
msgid "``dummy_rx``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:530
msgid "dummy receive buffer for full-duplex devices"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:530
msgid "``dummy_tx``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:531
msgid "dummy transmit buffer for full-duplex devices"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:531
msgid "``fw_translate_cs``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:532
msgid ""
"If the boot firmware uses different numbering scheme what Linux expects, "
"this optional hook can be used to translate between the two."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:534
msgid "``ptp_sts_supported``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:535
msgid ""
"If the driver sets this to true, it must provide a time snapshot in "
"**spi_transfer->ptp_sts** as close as possible to the moment in time when "
"**spi_transfer->ptp_sts_word_pre** and **spi_transfer->ptp_sts_word_post** "
"were transmitted. If the driver does not set this, the SPI core takes the "
"snapshot as close to the driver hand-over as possible."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:540
msgid "``irq_flags``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:541
msgid "Interrupt enable state during PTP system timestamping"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:541
msgid "``queue_empty``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:542
msgid ""
"signal green light for opportunistically skipping the queue for spi_sync "
"transfers."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:543
msgid "``must_async``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:544
msgid "disable all fast paths in the core"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:544
msgid "``defer_optimize_message``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:545
msgid ""
"set to true if controller cannot pre-optimize messages and needs to defer "
"the optimization step until the message is actually being transferred"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:488
msgid "return 0 if the transfer is finished,"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:489
msgid ""
"return 1 if the transfer is still in progress. When the driver is finished "
"with this transfer it must call spi_finalize_current_transfer() so the "
"subsystem can issue the next transfer. If the transfer fails, the driver "
"must set the flag SPI_TRANS_FAIL_IO to spi_transfer->error first, before "
"calling spi_finalize_current_transfer()."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:497
msgid ""
"Each SPI controller can communicate with one or more **spi_device** "
"children.  These make a small bus, sharing MOSI, MISO and SCK signals but "
"not chip select signals.  Each device may be configured to use a different "
"clock rate, since those shared signals are ignored unless the chip is "
"selected."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:503
msgid ""
"The driver for an SPI controller manages access to those devices through a "
"queue of spi_message transactions, copying data between CPU memory and an "
"SPI target device.  For each such message it queues, it calls the message's "
"completion function when the transaction completes."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:508
#: include/linux/spi/spi.h:1410 ../../../driver-api/spi:52:
#: drivers/spi/spi.c:2769
msgid "**Note**"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:497
msgid "transfer_one and transfer_one_message are mutually"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:498
msgid ""
"exclusive; when both are set, the generic subsystem does not call your "
"transfer_one callback."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:919
msgid "SPI resource management structure"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:920
msgid "``entry``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:921
msgid "list entry"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:921
#: include/linux/spi/spi.h:1397
msgid "``release``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:922
msgid "release code called prior to freeing this resource"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:922
msgid "``data``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:923
msgid "extra data allocated for the specific use-case"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:923
msgid ""
"This is based on ideas from devres, but focused on life-cycle management "
"during spi_message processing."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:953
msgid "a read/write buffer pair"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:954
msgid "``tx_buf``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:955
msgid "data to be written (DMA-safe memory), or NULL"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:955
msgid "``rx_buf``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:956
msgid "data to be read (DMA-safe memory), or NULL"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:962
msgid "``len``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:963
msgid "size of rx and tx buffers (in bytes)"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1012
msgid "``error``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1013
msgid "Error status logged by SPI controller driver."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:981
msgid "``tx_sg_mapped``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:982
msgid "If true, the **tx_sg** is mapped for DMA"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:982
msgid "``rx_sg_mapped``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:983
msgid "If true, the **rx_sg** is mapped for DMA"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:983
msgid "``tx_sg``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:984
msgid "Scatterlist for transmit, currently not for client use"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:984
msgid "``rx_sg``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:985
msgid "Scatterlist for receive, currently not for client use"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:956
msgid "``tx_dma``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:957
msgid "DMA address of tx_buf, currently not for client use"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:957
msgid "``rx_dma``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:958
msgid "DMA address of rx_buf, currently not for client use"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:967
msgid "``dummy_data``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:968
msgid "indicates transfer is dummy bytes transfer."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:968
msgid "``cs_off``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:969
msgid "performs the transfer with chipselect off."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:969
msgid "``cs_change``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:970
msgid "affects chipselect after this transfer completes"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:958
msgid "``tx_nbits``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:959
msgid ""
"number of bits used for writing. If 0 the default (SPI_NBITS_SINGLE) is used."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:960
msgid "``rx_nbits``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:961
msgid ""
"number of bits used for reading. If 0 the default (SPI_NBITS_SINGLE) is used."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1011
msgid "``timestamped``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1012
msgid "true if the transfer has been timestamped"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1010
msgid "``dtr_mode``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1011
msgid "true if supports double transfer rate."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:966
msgid ""
"select a bits_per_word other than the device default for this transfer. If 0 "
"the default (from **spi_device**) is used."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:972
msgid "``delay``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:973
msgid ""
"delay to be introduced after this transfer before (optionally) changing the "
"chipselect status, then starting the next transfer or completing this "
"**spi_message**."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:970
msgid "``cs_change_delay``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:971
msgid ""
"delay between cs deassert and assert when **cs_change** is set and "
"**spi_transfer** is not the last in **spi_message**"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:976
msgid ""
"inter word delay to be introduced after each word size (set by "
"bits_per_word) transmission."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:963
msgid "``speed_hz``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:964
msgid ""
"Select a speed other than the device default for this transfer. If 0 the "
"default (from **spi_device**) is used."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:977
msgid "``effective_speed_hz``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:978
msgid ""
"the effective SCK-speed that was used to transfer this transfer. Set to 0 if "
"the SPI bus driver does not support it."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:985
msgid "``offload_flags``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:986
msgid ""
"Flags that are only applicable to specialized SPI offload transfers. See "
"``SPI_OFFLOAD_XFER_*`` in spi-offload.h."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:987
msgid "``ptp_sts_word_pre``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:988
msgid ""
"The word (subject to bits_per_word semantics) offset within **tx_buf** for "
"which the SPI device is requesting that the time snapshot for this transfer "
"begins. Upon completing the SPI transfer, this value may have changed "
"compared to what was requested, depending on the available snapshotting "
"resolution (DMA transfer, **ptp_sts_supported** is false, etc)."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:993
msgid "``ptp_sts_word_post``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:994
msgid ""
"See **ptp_sts_word_post**. The two can be equal (meaning that a single byte "
"should be snapshotted). If the core takes care of the timestamp (if "
"**ptp_sts_supported** is false for this controller), it will set "
"**ptp_sts_word_pre** to 0, and **ptp_sts_word_post** to the length of the "
"transfer. This is done purposefully (instead of setting to spi_transfer->len "
"- 1) to denote that a transfer-level snapshot taken from within the driver "
"may still be of higher quality."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1001
msgid "``ptp_sts``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1002
msgid ""
"Pointer to a memory location held by the SPI target device where a PTP "
"system timestamp structure may lie. If drivers use PIO or their hardware has "
"some sort of assist for retrieving exact transfer timing, they can (and "
"should) assert **ptp_sts_supported** and populate this structure using the "
"ptp_read_system_*ts helper functions. The timestamp must represent the time "
"at which the SPI target device has processed the word, i.e. the \"pre\" "
"timestamp should be taken before transmitting the \"pre\" word, and the "
"\"post\" timestamp after receiving transmit confirmation from the controller "
"for the \"post\" word."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:980
msgid "``transfer_list``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:981
msgid "transfers are sequenced through **spi_message.transfers**"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1013
msgid ""
"SPI transfers always write the same number of bytes as they read. Protocol "
"drivers should always provide **rx_buf** and/or **tx_buf**. In some cases, "
"they may also want to provide DMA addresses for the data being transferred; "
"that may reduce overhead, when the underlying driver uses DMA."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1019
msgid ""
"If the transmit buffer is NULL, zeroes will be shifted out while filling "
"**rx_buf**.  If the receive buffer is NULL, the data shifted in will be "
"discarded.  Only \"len\" bytes shift out (or in). It's an error to try to "
"shift out a partial word.  (For example, by shifting out three bytes with "
"word size of sixteen or twenty bits; the former uses two bytes per word, the "
"latter uses four bytes.)"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1026
msgid ""
"In-memory data values are always in native CPU byte order, translated from "
"the wire byte order (big-endian except with SPI_LSB_FIRST).  So for example "
"when bits_per_word is sixteen, buffers are 2N bytes long (**len** = 2N) and "
"hold N sixteen bit words in CPU byte order."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1031
msgid ""
"When the word size of the SPI transfer is not a power-of-two multiple of "
"eight bits, those in-memory words include extra bits.  In-memory words are "
"always seen by protocol drivers as right-justified, so the undefined (rx) or "
"unused (tx) bits are always the most significant bits."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1036
msgid ""
"All SPI transfers start with the relevant chipselect active.  Normally it "
"stays selected until after the last transfer in a message.  Drivers can "
"affect the chipselect signal using cs_change."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1040
msgid ""
"(i) If the transfer isn't the last one in the message, this flag is used to "
"make the chipselect briefly go inactive in the middle of the message.  "
"Toggling chipselect in this way may be needed to terminate a chip command, "
"letting a single spi_message perform all of group of chip transactions "
"together."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1046
msgid ""
"(ii) When the transfer is the last one in the message, the chip may stay "
"selected until the next transfer.  On multi-device SPI busses with nothing "
"blocking messages going to other devices, this is just a performance hint; "
"starting a message to another device deselects this one.  But in other "
"cases, this can be used to ensure correctness. Some devices need protocol "
"transactions to be built from a series of spi_message submissions, where the "
"content of one message is determined by the results of previous messages and "
"where the whole transaction ends when the chipselect goes inactive."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1056
msgid ""
"When SPI can transfer in 1x,2x or 4x. It can get this transfer information "
"from device through **tx_nbits** and **rx_nbits**. In Bi-direction, these "
"two should both be set. User can set transfer mode with SPI_NBITS_SINGLE(1x) "
"SPI_NBITS_DUAL(2x) and SPI_NBITS_QUAD(4x) to support these three transfer."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1061
msgid ""
"User may also set dtr_mode to true to use dual transfer mode if desired. if "
"not, default considered as single transfer mode."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1064
#: include/linux/spi/spi.h:1149
msgid ""
"The code that submits an spi_message (and its spi_transfers) to the lower "
"layers is responsible for managing its memory. Zero-initialize every field "
"you don't set up explicitly, to insulate against future API updates.  After "
"you submit a message and its transfers, ignore them until its completion "
"callback."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1124
msgid "one multi-segment SPI transaction"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1126
msgid "list of transfer segments in this transaction"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1126
msgid "``spi``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1127
msgid "SPI device to which the transaction is queued"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1127
msgid "``pre_optimized``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1128
msgid "peripheral driver pre-optimized the message"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1128
msgid "``optimized``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1129
msgid "the message is in the optimized state"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1129
msgid "``prepared``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1130
msgid "spi_prepare_message was called for the this message"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1130
msgid "``status``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1131
msgid "zero for success, else negative errno"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1131
msgid "``complete``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1132
msgid "called to report transaction completions"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1132
msgid "``context``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1133
msgid "the argument to complete() when it's called"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1133
msgid "``frame_length``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1134
msgid "the total number of bytes in the message"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1134
msgid "``actual_length``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1135
msgid ""
"the total number of bytes that were transferred in all successful segments"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1137
#: include/linux/spi/spi.h:1138 include/linux/spi/spi.h:1139
msgid "for use by whichever driver currently owns the message"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1137
msgid "``state``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1138
msgid "``opt_state``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1140
msgid "``offload``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1141
msgid "(optional) offload instance used by this message"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1139
msgid "``resources``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1140
msgid "for resource management when the SPI message is processed"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1141
msgid ""
"A **spi_message** is used to execute an atomic sequence of data transfers, "
"each represented by a struct spi_transfer.  The sequence is \"atomic\" in "
"the sense that no other spi_message may use that SPI bus until that sequence "
"completes.  On some systems, many such sequences can execute as a single "
"programmed DMA transfer.  On all systems, these messages are queued, and "
"might complete after transactions to other devices.  Messages sent to a "
"given spi_device are always executed in FIFO order."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1242
msgid "Initialize spi_message and append transfers"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1248
msgid "``struct spi_message *m``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1243
msgid "spi_message to be initialized"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1245
#: include/linux/spi/spi.h:1449
msgid "``struct spi_transfer *xfers``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1244
msgid "An array of SPI transfers"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1246
#: include/linux/spi/spi.h:1450
msgid "``unsigned int num_xfers``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1245
#: include/linux/spi/spi.h:1449
msgid "Number of items in the xfer array"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1246
msgid ""
"This function initializes the given spi_message and adds each spi_transfer "
"in the given array to the message."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1323
msgid "Check if bits per word is supported"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1329
#: include/linux/spi/spi.h:1452 include/linux/spi/spi.h:1476
#: include/linux/spi/spi.h:1499 include/linux/spi/spi.h:1527
#: include/linux/spi/spi.h:1549 include/linux/spi/spi.h:1574
#: ../../../driver-api/spi:52: drivers/spi/spi.c:764 drivers/spi/spi.c:860
#: drivers/spi/spi.c:2548 drivers/spi/spi.c:2922 drivers/spi/spi.c:3858
#: drivers/spi/spi.c:4288 drivers/spi/spi.c:4382 drivers/spi/spi.c:4408
#: drivers/spi/spi.c:4568 drivers/spi/spi.c:4601 drivers/spi/spi.c:4682
msgid "``struct spi_device *spi``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1324
#: include/linux/spi/spi.h:1370
msgid "SPI device"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1326
#: include/linux/spi/spi.h:1349
msgid "``u32 bpw``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1325
#: include/linux/spi/spi.h:1344
msgid "Bits per word"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1326
msgid "This function checks to see if the SPI controller supports **bpw**."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1328
#: include/linux/spi/spi.h:1359 include/linux/spi/spi.h:1376
#: include/linux/spi/spi.h:1455 include/linux/spi/spi.h:1478
#: include/linux/spi/spi.h:1501 include/linux/spi/spi.h:1527
#: include/linux/spi/spi.h:1552 include/linux/spi/spi.h:1577
#: ../../../driver-api/spi:49: drivers/spi/spi.c:913
#: ../../../driver-api/spi:52: drivers/spi/spi.c:476 drivers/spi/spi.c:561
#: drivers/spi/spi.c:763 drivers/spi/spi.c:792 drivers/spi/spi.c:2077
#: drivers/spi/spi.c:2550 drivers/spi/spi.c:2631 drivers/spi/spi.c:2771
#: drivers/spi/spi.c:3032 drivers/spi/spi.c:3087 drivers/spi/spi.c:3242
#: drivers/spi/spi.c:3383 drivers/spi/spi.c:3725 drivers/spi/spi.c:3767
#: drivers/spi/spi.c:3868 drivers/spi/spi.c:4300 drivers/spi/spi.c:4384
#: drivers/spi/spi.c:4429 drivers/spi/spi.c:4579 drivers/spi/spi.c:4607
#: drivers/spi/spi.c:4628 drivers/spi/spi.c:4657 drivers/spi/spi.c:4692
msgid "**Return**"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1329
msgid "True if **bpw** is supported, false otherwise."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1343
msgid "Covert bits per word to bytes"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1345
msgid ""
"This function converts the given **bpw** to bytes. The result is always "
"power-of-two, e.g.,"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1349
msgid "Input (in bits)"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1349
msgid "Output (in bytes)"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1351
msgid "5"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1351
msgid "1"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1352
msgid "9"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1352
msgid "2"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1353
msgid "21"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1353
msgid "4"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1354
msgid "37"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1354
msgid "8"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1357
msgid "It will return 0 for the 0 input."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1360
msgid "Bytes for the given **bpw**."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1369
msgid "Compute a suitable timeout value"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1375
#: ../../../driver-api/spi:52: drivers/spi/spi.c:554 drivers/spi/spi.c:788
#: drivers/spi/spi.c:1712 drivers/spi/spi.c:1944 drivers/spi/spi.c:1989
#: drivers/spi/spi.c:2077 drivers/spi/spi.c:2140 drivers/spi/spi.c:2764
#: drivers/spi/spi.c:3229 drivers/spi/spi.c:3378 drivers/spi/spi.c:3421
#: drivers/spi/spi.c:3721 drivers/spi/spi.c:3763 drivers/spi/spi.c:4623
#: drivers/spi/spi.c:4654
msgid "``struct spi_controller *ctlr``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1372
#: ../../../driver-api/spi:52: drivers/spi/spi.c:1941 drivers/spi/spi.c:1986
msgid "``struct spi_transfer *xfer``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1371
msgid "Transfer descriptor"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1372
msgid ""
"Compute a relevant timeout value for the given transfer. We derive the time "
"that it would take on a single data line and take twice this amount of time "
"with a minimum of 500ms to avoid false positives on loaded systems."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1377
msgid "Transfer timeout value in milliseconds."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1394
msgid ""
"structure describing the spi_transfer replacements that have occurred so "
"that they can get reverted"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1398
msgid ""
"some extra release code to get executed prior to releasing this structure"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1399
msgid "``extradata``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1400
msgid "pointer to some extra data if requested or NULL"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1400
msgid "``replaced_transfers``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1401
msgid "transfers that have been replaced and which need to get restored"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1402
msgid "``replaced_after``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1403
msgid ""
"the transfer after which the **replaced_transfers** are to get re-inserted"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1404
msgid "``inserted``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1405
msgid "number of transfers inserted"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1405
msgid "``inserted_transfers``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1406
msgid ""
"array of spi_transfers of array-size **inserted**, that have been replacing "
"replaced_transfers"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1408
msgid ""
"that **extradata** will point to **inserted_transfers**[**inserted**] if "
"some extra allocation is requested, so alignment will be the same as for "
"spi_transfers."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1446
msgid "synchronous SPI data transfer"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1447
#: include/linux/spi/spi.h:1522 include/linux/spi/spi.h:1544
#: include/linux/spi/spi.h:1569 ../../../driver-api/spi:52:
#: drivers/spi/spi.c:4403 drivers/spi/spi.c:4563 drivers/spi/spi.c:4596
#: drivers/spi/spi.c:4677
msgid "device with which data will be exchanged"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1448
msgid "An array of spi_transfers"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1451
msgid "Does a synchronous SPI data transfer of the given spi_transfer array."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1453
msgid "For more specific semantics see spi_sync()."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1456
#: include/linux/spi/spi.h:1479 include/linux/spi/spi.h:1502
#: ../../../driver-api/spi:49: drivers/spi/spi.c:914
#: ../../../driver-api/spi:52: drivers/spi/spi.c:476 drivers/spi/spi.c:3243
#: drivers/spi/spi.c:3384 drivers/spi/spi.c:3869 drivers/spi/spi.c:4430
#: drivers/spi/spi.c:4580 drivers/spi/spi.c:4608 drivers/spi/spi.c:4693
msgid "zero on success, else a negative error code."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1470
msgid "SPI synchronous write"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1471
msgid "device to which data will be written"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1473
msgid "``const void *buf``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1472
#: include/linux/spi/spi.h:1495
msgid "data buffer"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1474
#: include/linux/spi/spi.h:1497
msgid "``size_t len``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1473
#: include/linux/spi/spi.h:1496
msgid "data buffer size"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1475
msgid ""
"This function writes the buffer **buf**. Callable only from contexts that "
"can sleep."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1493
msgid "SPI synchronous read"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1494
msgid "device from which data will be read"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1496
msgid "``void *buf``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1498
msgid ""
"This function reads the buffer **buf**. Callable only from contexts that can "
"sleep."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1521
msgid "SPI synchronous 8 bit write followed by 8 bit read"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1524
#: include/linux/spi/spi.h:1546 include/linux/spi/spi.h:1571
msgid "``u8 cmd``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1523
#: include/linux/spi/spi.h:1545 include/linux/spi/spi.h:1570
msgid "command to be written before data is read back"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1525
#: include/linux/spi/spi.h:1550 include/linux/spi/spi.h:1575
msgid "Callable only from contexts that can sleep."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1528
msgid ""
"the (unsigned) eight bit number returned by the device, or else a negative "
"error code."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1543
msgid "SPI synchronous 8 bit write followed by 16 bit read"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1547
msgid ""
"The number is returned in wire-order, which is at least sometimes big-endian."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1553
msgid ""
"the (unsigned) sixteen bit number returned by the device, or else a negative "
"error code."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1568
msgid "SPI synchronous 8 bit write followed by 16 bit big-endian read"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1572
msgid ""
"This function is similar to spi_w8r16, with the exception that it will "
"convert the read 16 bit data word from big-endian to native endianness."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1578
msgid ""
"the (unsigned) sixteen bit number returned by the device in CPU endianness, "
"or else a negative error code."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1611
msgid "board-specific template for a SPI device"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1613
msgid "Initializes spi_device.modalias; identifies the driver."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1613
msgid "``platform_data``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1614
msgid ""
"Initializes spi_device.platform_data; the particular data stored there is "
"driver-specific."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1615
msgid "``swnode``"
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1616
msgid "Software node for the device."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1617
msgid ""
"Initializes spi_device.controller_data; some controllers need hints about "
"hardware setup, e.g. for DMA."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1619
msgid "Initializes spi_device.irq; depends on how the board is wired."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1620
msgid ""
"Initializes spi_device.max_speed_hz; based on limits from the chip datasheet "
"and board-specific signal quality issues."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1622
msgid ""
"Identifies which spi_controller parents the spi_device; unused by "
"spi_new_device(), and otherwise depends on board wiring."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1624
msgid "Initializes spi_device.chip_select; depends on how the board is wired."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1626
msgid ""
"Initializes spi_device.mode; based on the chip datasheet, board wiring (some "
"devices support both 3WIRE and standard modes), and possibly presence of an "
"inverter in the chipselect path."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1628
msgid ""
"When adding new SPI devices to the device tree, these structures serve as a "
"partial device template.  They hold information which can't always be "
"determined by drivers.  Information that probe() can establish (such as the "
"default transfer wordsize) is not included here."
msgstr ""

#: ../../../driver-api/spi:46: include/linux/spi/spi.h:1633
msgid ""
"These structures are used in two places.  Their primary role is to be stored "
"in tables of board-specific device descriptors, which are declared early in "
"board initialization and then used (much later) to populate a controller's "
"device tree after the that controller's driver initializes.  A secondary "
"(and atypical) role is as a parameter to spi_new_device() call, which "
"happens after those controller drivers are active in some dynamic board "
"configuration models."
msgstr ""

#: ../../../driver-api/spi:49: drivers/spi/spi.c:896
msgid "register SPI devices for a given board"
msgstr ""

#: ../../../driver-api/spi:49: drivers/spi/spi.c:902
msgid "``struct spi_board_info const *info``"
msgstr ""

#: ../../../driver-api/spi:49: drivers/spi/spi.c:897
msgid "array of chip descriptors"
msgstr ""

#: ../../../driver-api/spi:49: drivers/spi/spi.c:899
msgid "``unsigned n``"
msgstr ""

#: ../../../driver-api/spi:49: drivers/spi/spi.c:898
msgid "how many descriptors are provided"
msgstr ""

#: ../../../driver-api/spi:49: drivers/spi/spi.c:900
msgid ""
"Board-specific early init code calls this (probably during arch_initcall) "
"with segments of the SPI device table.  Any device nodes are created later, "
"after the relevant parent SPI controller (bus_num) is defined.  We keep this "
"table of devices forever, so that reloading a controller driver will not "
"make Linux forget about these hard-wired devices."
msgstr ""

#: ../../../driver-api/spi:49: drivers/spi/spi.c:906
msgid ""
"Other code can also call this, e.g. a particular add-on board might provide "
"SPI devices through its expansion connector, so code initializing that board "
"would naturally declare its SPI devices."
msgstr ""

#: ../../../driver-api/spi:49: drivers/spi/spi.c:910
msgid ""
"The board info passed can safely be __initdata ... but be careful of any "
"embedded pointers (platform_data, etc), they're copied as-is."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:471
msgid "register a SPI driver"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:477
msgid "``struct module *owner``"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:472
msgid "owner module of the driver to register"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:473
msgid "the driver to register"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:548
msgid "Allocate a new SPI device"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:549 drivers/spi/spi.c:783
msgid "Controller to which device is connected"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:551
msgid ""
"Allows a driver to allocate and initialize a spi_device without registering "
"it immediately.  This allows a driver to directly fill the spi_device with "
"device parameters before calling spi_add_device() on it."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:556
msgid ""
"Caller is responsible to call spi_add_device() on the returned spi_device "
"structure to add it to the SPI controller.  If the caller needs to discard "
"the spi_device without adding it, then it should call spi_dev_put() on it."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:562
msgid "a pointer to the new device, or NULL."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:758
msgid "Add spi_device allocated with spi_alloc_device"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:759
msgid "spi_device to register"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:760
msgid ""
"Companion function to spi_alloc_device.  Devices allocated with "
"spi_alloc_device can be added onto the SPI bus with this function."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:764 drivers/spi/spi.c:2551
msgid "0 on success; negative errno on failure"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:782
msgid "instantiate one new SPI device"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:785
msgid "``struct spi_board_info *chip``"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:784
msgid "Describes the SPI device"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:786
msgid ""
"On typical mainboards, this is purely internal; and it's not needed after "
"board init creates the hard-wired devices.  Some development platforms may "
"not be able to use spi_register_board_info though, and this is exported so "
"that for example a USB or parport based adapter driver could add devices "
"(which it would learn about out-of-band)."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:793
msgid "the new device, or NULL."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:854
msgid "unregister a single SPI device"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:855
msgid "spi_device to unregister"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:856
msgid ""
"Start making the passed SPI device vanish. Normally this would be handled by "
"spi_unregister_controller()."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:1706
msgid "report completion of a transfer"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:1707
msgid "the controller reporting completion"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:1708
msgid ""
"Called by SPI drivers using the core transfer_one_message() implementation "
"to notify it that the current interrupt driven transfer has finished and the "
"next one may be scheduled."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:1938
msgid "helper to collect the beginning of the TX timestamp"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:1939 drivers/spi/spi.c:1984
msgid "Pointer to the spi_controller structure of the driver"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:1940 drivers/spi/spi.c:1985
msgid "Pointer to the transfer being timestamped"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:1942 drivers/spi/spi.c:1987
msgid "``size_t progress``"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:1941 drivers/spi/spi.c:1986
msgid "How many words (not bytes) have been transferred so far"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:1943 drivers/spi/spi.c:1988
msgid "``bool irqs_off``"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:1942
msgid ""
"If true, will disable IRQs and preemption for the duration of the transfer, "
"for less jitter in time measurement. Only compatible with PIO drivers. If "
"true, must follow up with spi_take_timestamp_post or otherwise system will "
"crash. WARNING: for fully predictable results, the CPU frequency must also "
"be under control (governor)."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:1948
msgid ""
"This is a helper for drivers to collect the beginning of the TX timestamp "
"for the requested byte from the SPI transfer. The frequency with which this "
"function must be called (once per word, once for the whole transfer, once "
"per batch of words etc) is arbitrary as long as the **tx** buffer offset is "
"greater than or equal to the requested byte at the time of the call. The "
"timestamp is only taken once, at the first such call. It is assumed that the "
"driver advances its **tx** buffer pointer monotonically."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:1983
msgid "helper to collect the end of the TX timestamp"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:1987
msgid "If true, will re-enable IRQs and preemption for the local CPU."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:1988
msgid ""
"This is a helper for drivers to collect the end of the TX timestamp for the "
"requested byte from the SPI transfer. Can be called with an arbitrary "
"frequency: only the first call where **tx** exceeds or is equal to the "
"requested word will be timestamped."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2071
msgid "called by driver to check for queued messages"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2073
msgid "the controller to check for queued messages"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2074
msgid ""
"If there are more messages in the queue, the next message is returned from "
"this call."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2078
msgid "the next message in the queue, else NULL if the queue is empty."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2134
msgid "the current message is complete"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2135
msgid "the controller to return the message to"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2136
msgid ""
"Called by the driver to notify the core that the message in the front of the "
"queue is complete and can be removed from the queue."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2542
msgid "Register ancillary SPI device"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2543
msgid "Pointer to the main SPI device registering the ancillary device"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2545
msgid "``u8 chip_select``"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2544
msgid "Chip Select of the ancillary device"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2545
msgid ""
"Register an ancillary SPI device; for example some chips have a chip-select "
"for normal device usage and another one for setup/firmware upload."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2548
msgid "This may only be called from main SPI device's probe routine."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2628
msgid "Count the number of SpiSerialBus resources"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2634 drivers/spi/spi.c:2761
msgid "``struct acpi_device *adev``"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2629
msgid "ACPI device"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2631
msgid ""
"the number of SpiSerialBus resources in the ACPI-device's resource-list; or "
"a negative error code."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2758
msgid "Allocate a spi device, and fill it in with ACPI information"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2759
msgid "controller to which the spi device belongs"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2760
msgid "ACPI Device for the spi device"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2762
msgid "``int index``"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2761
msgid "Index of the spi resource inside the ACPI Node"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2762
msgid ""
"This should be used to allocate a new SPI device from and ACPI Device node. "
"The caller is responsible for calling spi_add_device to register the SPI "
"device."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2765
msgid ""
"If ctlr is set to NULL, the Controller for the SPI device will be looked up "
"using the resource. If index is set to -1, index is not used."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2769
msgid "If index is -1, ctlr must be set."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2771
msgid "a pointer to the new device, or ERR_PTR on error."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:2917
msgid "device used for the current transfer"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3011
msgid "allocate an SPI host or target controller"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3017 drivers/spi/spi.c:3082
#: drivers/spi/spi.c:3381 drivers/spi/spi.c:4385
msgid "``struct device *dev``"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3012
msgid "the controller, possibly using the platform_bus"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3014 drivers/spi/spi.c:3079
msgid "``unsigned int size``"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3013
msgid ""
"how much zeroed driver-private data to allocate; the pointer to this memory "
"is in the driver_data field of the returned device, accessible with "
"spi_controller_get_devdata(); the memory is cacheline aligned; drivers "
"granting DMA access to portions of their private data need to round up "
"**size** using ALIGN(size, dma_get_cache_alignment())."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3019 drivers/spi/spi.c:3080
msgid "``bool target``"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3018
msgid ""
"flag indicating whether to allocate an SPI host (false) or SPI target (true) "
"controller"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3021
msgid ""
"This call is used only by SPI controller drivers, which are the only ones "
"directly touching chip registers.  It's how they allocate an spi_controller "
"structure, prior to calling spi_register_controller()."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3025 drivers/spi/spi.c:3421
msgid "This must be called from context that can sleep."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3027
msgid ""
"The caller is responsible for assigning the bus number and initializing the "
"controller's methods before calling spi_register_controller(); and (after "
"errors adding the device) calling spi_controller_put() to prevent a memory "
"leak."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3033 drivers/spi/spi.c:3088
msgid "the SPI controller structure on success, else NULL."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3076
msgid "resource-managed __spi_alloc_controller()"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3077
msgid "physical device of SPI controller"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3078
msgid "how much zeroed driver-private data to allocate"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3079
msgid "whether to allocate an SPI host (false) or SPI target (true) controller"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3081
msgid ""
"Allocate an SPI controller and automatically release a reference on it when "
"**dev** is unbound from its driver.  Drivers are thus relieved from having "
"to call spi_controller_put()."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3085
msgid ""
"The arguments to this function are identical to __spi_alloc_controller()."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3223
msgid "register SPI host or target controller"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3224 drivers/spi/spi.c:3377
msgid ""
"initialized controller, originally from spi_alloc_host() or "
"spi_alloc_target()"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3227
msgid ""
"SPI controllers connect to their drivers using some non-SPI bus, such as the "
"platform bus.  The final stage of probe() in that code includes calling "
"spi_register_controller() to hook up to this SPI bus glue."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3231
msgid ""
"SPI controllers use board specific (often SOC specific) bus numbers, and "
"board-specific addressing for SPI devices combines those numbers with chip "
"select numbers.  Since SPI does not directly support dynamic device "
"identification, boards need configuration tables telling which chip is at "
"which address."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3237
msgid ""
"This must be called from context that can sleep.  It returns zero on "
"success, else a negative error code (dropping the controller's refcount). "
"After a successful return, the caller is responsible for calling "
"spi_unregister_controller()."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3375
msgid "register managed SPI host or target controller"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3376
msgid "device managing SPI controller"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3380
msgid ""
"Register a SPI device as with spi_register_controller() which will "
"automatically be unregistered and freed."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3415
msgid "unregister SPI host or target controller"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3416
msgid "the controller being unregistered"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3418
msgid ""
"This call is used only by SPI controller drivers, which are the only ones "
"directly touching chip registers."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3423
msgid "Note that this function also drops a reference to the controller."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3715
msgid ""
"split spi transfers into multiple transfers when an individual transfer "
"exceeds a certain size"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3718 drivers/spi/spi.c:3760
msgid "the **spi_controller** for this transfer"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3720 drivers/spi/spi.c:3762
#: drivers/spi/spi.c:4285 drivers/spi/spi.c:4335 drivers/spi/spi.c:4383
msgid "``struct spi_message *msg``"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3719 drivers/spi/spi.c:3761
msgid "the **spi_message** to transform"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3721
msgid "``size_t maxsize``"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3720
msgid "the maximum when to apply this"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3721 drivers/spi/spi.c:3763
msgid ""
"This function allocates resources that are automatically freed during the "
"spi message unoptimize phase so this function should only be called from "
"optimize_message callbacks."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3726 drivers/spi/spi.c:3768
msgid "status of transformation"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3757
msgid ""
"split SPI transfers into multiple transfers when an individual transfer "
"exceeds a certain number of SPI words"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3763
msgid "``size_t maxwords``"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3762
msgid "the number of words to limit each transfer to"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3852
msgid "setup SPI mode and clock rate"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3853
msgid "the device whose settings are being modified"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3854
msgid "can sleep, and no requests are queued to the device"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3855
msgid ""
"SPI protocol drivers may need to update the transfer mode if the device "
"doesn't work with its default.  They may likewise need to update clock rates "
"or word sizes from initial values.  This function changes those settings, "
"and must be called from a context that can sleep. Except for SPI_CS_HIGH, "
"which takes effect immediately, the changes take effect the next time the "
"device is selected and data is transferred to or from it.  When this "
"function returns, the SPI device is deselected."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:3863
msgid ""
"Note that this call will fail if the protocol driver specifies an option "
"that the underlying controller or its driver does not support.  For example, "
"not all hardware supports wire transfers using nine bit words, LSB-first "
"wire encoding, or active-high chipselects."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4282
msgid "do any one-time validation and setup for a SPI message"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4283 drivers/spi/spi.c:4381
msgid "the device that will be used for the message"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4284 drivers/spi/spi.c:4382
msgid "the message to optimize"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4285
msgid ""
"Peripheral drivers that reuse the same message repeatedly may call this to "
"perform as much message prep as possible once, rather than repeating it each "
"time a message transfer is performed to improve throughput and reduce CPU "
"usage."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4290
msgid ""
"Once a message has been optimized, it cannot be modified with the exception "
"of updating the contents of any xfer->tx_buf (the pointer can't be changed, "
"only the data in the memory it points to)."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4294
msgid ""
"Calls to this function must be balanced with calls to "
"spi_unoptimize_message() to avoid leaking resources."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4299 drivers/spi/spi.c:4383
msgid "zero on success, else a negative error code"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4329
msgid "releases any resources allocated by spi_optimize_message()"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4330
msgid "the message to unoptimize"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4331
msgid ""
"Calls to this function must be balanced with calls to spi_optimize_message()."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4379
msgid "managed version of spi_optimize_message()"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4380
msgid "the device that manages **msg** (usually **spi->dev**)"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4384
msgid ""
"spi_unoptimize_message() will automatically be called when the device is "
"removed."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4402
msgid "asynchronous SPI transfer"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4405 drivers/spi/spi.c:4565
#: drivers/spi/spi.c:4598
msgid "``struct spi_message *message``"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4404
msgid "describes the data transfers, including completion callback"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4405
msgid "any (IRQs may be blocked, etc)"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4406
msgid ""
"This call may be used in_irq and other contexts which can't sleep, as well "
"as from task contexts which can sleep."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4409
msgid ""
"The completion callback is invoked in a context which can't sleep. Before "
"that invocation, the value of message->status is undefined. When the "
"callback is issued, message->status holds either zero (to indicate complete "
"success) or a negative error code.  After that callback returns, the driver "
"which issued the transfer request may deallocate the associated memory; it's "
"no longer in use by any SPI core or controller driver code."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4417
msgid ""
"Note that although all messages to a spi_device are handled in FIFO order, "
"messages may go to different devices in other orders. Some device might be "
"higher priority, or have various \"hard\" access time requirements, for "
"example."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4422
msgid ""
"On detection of any fault during the transfer, processing of the entire "
"message is aborted, and the device is deselected. Until returning from the "
"associated message completion callback, no other spi_message queued to that "
"device will be processed. (This rule applies equally to all the synchronous "
"transfer calls, which are wrappers around this core asynchronous primitive.)"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4562
msgid "blocking/synchronous SPI data transfers"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4564 drivers/spi/spi.c:4597
msgid "describes the data transfers"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4566 drivers/spi/spi.c:4599
msgid ""
"This call may only be used from a context that may sleep.  The sleep is non-"
"interruptible, and has no timeout.  Low-overhead controller drivers may DMA "
"directly into and out of the message buffers."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4570
msgid ""
"Note that the SPI device's chip select is active during the message, and "
"then is normally disabled between messages.  Drivers for some frequently-"
"used devices may want to minimize costs of selecting a chip, by leaving it "
"selected in anticipation that the next message will go to the same chip.  "
"(That may increase power usage.)"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4576
msgid ""
"Also, the caller is guaranteeing that the memory associated with the message "
"will not be freed before this call returns."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4595
msgid "version of spi_sync with exclusive bus usage"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4603
msgid ""
"This call should be used by drivers that require exclusive access to the SPI "
"bus. It has to be preceded by a spi_bus_lock call. The SPI bus must be "
"released by a spi_bus_unlock call when the exclusive access is over."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4617
msgid "obtain a lock for exclusive SPI bus usage"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4618
msgid "SPI bus controller that should be locked for exclusive bus access"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4620 drivers/spi/spi.c:4651
msgid ""
"This call may only be used from a context that may sleep.  The sleep is non-"
"interruptible, and has no timeout."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4623
msgid ""
"This call should be used by drivers that require exclusive access to the SPI "
"bus. The SPI bus must be released by a spi_bus_unlock call when the "
"exclusive access is over. Data transfer must be done by spi_sync_locked and "
"spi_async_locked calls when the SPI bus lock is held."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4629 drivers/spi/spi.c:4658
msgid "always zero."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4648
msgid "release the lock for exclusive SPI bus usage"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4649
msgid "SPI bus controller that was locked for exclusive bus access"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4654
msgid ""
"This call releases an SPI bus lock previously obtained by an spi_bus_lock "
"call."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4676
msgid "SPI synchronous write followed by read"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4679
msgid "``const void *txbuf``"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4678
msgid "data to be written (need not be DMA-safe)"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4680
msgid "``unsigned n_tx``"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4679
msgid "size of txbuf, in bytes"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4681
msgid "``void *rxbuf``"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4680
msgid "buffer into which data will be read (need not be DMA-safe)"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4682
msgid "``unsigned n_rx``"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4681
msgid "size of rxbuf, in bytes"
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4683
msgid ""
"This performs a half duplex MicroWire style transaction with the device, "
"sending txbuf and then reading rxbuf.  The return value is zero for success, "
"else a negative errno status code. This call may only be used from a context "
"that may sleep."
msgstr ""

#: ../../../driver-api/spi:52: drivers/spi/spi.c:4688
msgid ""
"Parameters to this routine are always copied using a small buffer. "
"Performance-sensitive or bulk transfer code should instead use spi_{async,"
"sync}() calls with DMA-safe buffers."
msgstr ""
