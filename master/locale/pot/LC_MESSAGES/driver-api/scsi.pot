# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-19 08:29+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/scsi.rst:3
msgid "SCSI Interfaces Guide"
msgstr ""

#: ../../../driver-api/scsi.rst:0
msgid "Author"
msgstr ""

#: ../../../driver-api/scsi.rst:5
msgid "James Bottomley"
msgstr ""

#: ../../../driver-api/scsi.rst:6
msgid "Rob Landley"
msgstr ""

#: ../../../driver-api/scsi.rst:9
msgid "Introduction"
msgstr ""

#: ../../../driver-api/scsi.rst:12
msgid "Protocol vs bus"
msgstr ""

#: ../../../driver-api/scsi.rst:14
msgid ""
"Once upon a time, the Small Computer Systems Interface defined both a "
"parallel I/O bus and a data protocol to connect a wide variety of "
"peripherals (disk drives, tape drives, modems, printers, scanners, optical "
"drives, test equipment, and medical devices) to a host computer."
msgstr ""

#: ../../../driver-api/scsi.rst:19
msgid ""
"Although the old parallel (fast/wide/ultra) SCSI bus has largely fallen out "
"of use, the SCSI command set is more widely used than ever to communicate "
"with devices over a number of different buses."
msgstr ""

#: ../../../driver-api/scsi.rst:23
msgid ""
"The `SCSI protocol <https://www.t10.org/scsi-3.htm>`__ is a big-endian peer-"
"to-peer packet based protocol. SCSI commands are 6, 10, 12, or 16 bytes "
"long, often followed by an associated data payload."
msgstr ""

#: ../../../driver-api/scsi.rst:27
msgid ""
"SCSI commands can be transported over just about any kind of bus, and are "
"the default protocol for storage devices attached to USB, SATA, SAS, Fibre "
"Channel, FireWire, and ATAPI devices. SCSI packets are also commonly "
"exchanged over Infiniband, TCP/IP (`iSCSI <https://en.wikipedia.org/wiki/"
"ISCSI>`__), even `Parallel ports <http://cyberelk.net/tim/parport/parscsi."
"html>`__."
msgstr ""

#: ../../../driver-api/scsi.rst:35
msgid "Design of the Linux SCSI subsystem"
msgstr ""

#: ../../../driver-api/scsi.rst:37
msgid ""
"The SCSI subsystem uses a three layer design, with upper, mid, and low "
"layers. Every operation involving the SCSI subsystem (such as reading a "
"sector from a disk) uses one driver at each of the 3 levels: one upper layer "
"driver, one lower layer driver, and the SCSI midlayer."
msgstr ""

#: ../../../driver-api/scsi.rst:42
msgid ""
"The SCSI upper layer provides the interface between userspace and the "
"kernel, in the form of block and char device nodes for I/O and ioctl(). The "
"SCSI lower layer contains drivers for specific hardware devices."
msgstr ""

#: ../../../driver-api/scsi.rst:46
msgid ""
"In between is the SCSI mid-layer, analogous to a network routing layer such "
"as the IPv4 stack. The SCSI mid-layer routes a packet based data protocol "
"between the upper layer's /dev nodes and the corresponding devices in the "
"lower layer. It manages command queues, provides error handling and power "
"management functions, and responds to ioctl() requests."
msgstr ""

#: ../../../driver-api/scsi.rst:54
msgid "SCSI upper layer"
msgstr ""

#: ../../../driver-api/scsi.rst:56
msgid ""
"The upper layer supports the user-kernel interface by providing device nodes."
msgstr ""

#: ../../../driver-api/scsi.rst:60
msgid "sd (SCSI Disk)"
msgstr ""

#: ../../../driver-api/scsi.rst:62
msgid "sd (sd_mod.o)"
msgstr ""

#: ../../../driver-api/scsi.rst:65
msgid "sr (SCSI CD-ROM)"
msgstr ""

#: ../../../driver-api/scsi.rst:67
msgid "sr (sr_mod.o)"
msgstr ""

#: ../../../driver-api/scsi.rst:70
msgid "st (SCSI Tape)"
msgstr ""

#: ../../../driver-api/scsi.rst:72
msgid "st (st.o)"
msgstr ""

#: ../../../driver-api/scsi.rst:75
msgid "sg (SCSI Generic)"
msgstr ""

#: ../../../driver-api/scsi.rst:77
msgid "sg (sg.o)"
msgstr ""

#: ../../../driver-api/scsi.rst:80
msgid "ch (SCSI Media Changer)"
msgstr ""

#: ../../../driver-api/scsi.rst:82
msgid "ch (ch.c)"
msgstr ""

#: ../../../driver-api/scsi.rst:85
msgid "SCSI mid layer"
msgstr ""

#: ../../../driver-api/scsi.rst:88
msgid "SCSI midlayer implementation"
msgstr ""

#: ../../../driver-api/scsi.rst:91
msgid "include/scsi/scsi_device.h"
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:92
msgid "SCSI Vital Product Data"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:55
#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:96
msgid "**Definition**::"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:64
#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:104
msgid "**Members**"
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:93
msgid "``rcu``"
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:94
msgid "For kfree_rcu()."
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:94
msgid "``len``"
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:95
msgid "Length in bytes of **data**."
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:95
msgid "``data``"
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:96
msgid "VPD data as defined in various T10 SCSI standard documents."
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:434
msgid "``shost_for_each_device (sdev, shost)``"
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:432
msgid "iterate over all devices of a host"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:215
#: ../drivers/scsi/scsi.c:243 ../drivers/scsi/scsi.c:396
#: ../drivers/scsi/scsi.c:557 ../drivers/scsi/scsi.c:783
#: ../drivers/scsi/scsi.c:811 ../drivers/scsi/scsi.c:856
#: ../drivers/scsi/scsi.c:880 ../drivers/scsi/scsi.c:908
#: ../drivers/scsi/scsi.c:939 ../drivers/scsi/scsi.c:965
#: ../drivers/scsi/scsi.c:998 ../../../driver-api/scsi:111:
#: ../drivers/scsi/scsicam.c:30 ../drivers/scsi/scsicam.c:54
#: ../drivers/scsi/scsicam.c:211 ../../../driver-api/scsi:119:
#: ../drivers/scsi/scsi_error.c:81 ../drivers/scsi/scsi_error.c:378
#: ../drivers/scsi/scsi_error.c:533 ../drivers/scsi/scsi_error.c:1053
#: ../drivers/scsi/scsi_error.c:1145 ../drivers/scsi/scsi_error.c:1318
#: ../drivers/scsi/scsi_error.c:1336 ../drivers/scsi/scsi_error.c:2224
#: ../drivers/scsi/scsi_error.c:2244 ../drivers/scsi/scsi_error.c:2418
#: ../drivers/scsi/scsi_error.c:2450 ../drivers/scsi/scsi_error.c:2592
#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:334
#: ../drivers/scsi/scsi_devinfo.c:561 ../drivers/scsi/scsi_devinfo.c:750
#: ../drivers/scsi/scsi_devinfo.c:782 ../../../driver-api/scsi:136:
#: ../drivers/scsi/scsi_ioctl.c:131 ../drivers/scsi/scsi_ioctl.c:262
#: ../drivers/scsi/scsi_ioctl.c:873 ../drivers/scsi/scsi_ioctl.c:967
#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:192
#: ../drivers/scsi/scsi_lib.c:285 ../drivers/scsi/scsi_lib.c:1114
#: ../drivers/scsi/scsi_lib.c:1234 ../drivers/scsi/scsi_lib.c:2142
#: ../drivers/scsi/scsi_lib.c:2170 ../drivers/scsi/scsi_lib.c:2180
#: ../drivers/scsi/scsi_lib.c:2208 ../drivers/scsi/scsi_lib.c:2222
#: ../drivers/scsi/scsi_lib.c:2244 ../drivers/scsi/scsi_lib.c:2326
#: ../drivers/scsi/scsi_lib.c:2460 ../drivers/scsi/scsi_lib.c:2496
#: ../drivers/scsi/scsi_lib.c:2712 ../drivers/scsi/scsi_lib.c:2740
#: ../drivers/scsi/scsi_lib.c:2776 ../drivers/scsi/scsi_lib.c:2798
#: ../drivers/scsi/scsi_lib.c:2852 ../drivers/scsi/scsi_lib.c:2930
#: ../drivers/scsi/scsi_lib.c:2996 ../drivers/scsi/scsi_lib.c:3085
#: ../drivers/scsi/scsi_lib.c:3132 ../drivers/scsi/scsi_lib.c:3185
#: ../drivers/scsi/scsi_lib.c:3234 ../drivers/scsi/scsi_lib.c:3330
#: ../drivers/scsi/scsi_lib.c:3459 ../drivers/scsi/scsi_lib.c:3508
#: ../../../driver-api/scsi:153: ../drivers/scsi/scsi_lib_dma.c:21
#: ../drivers/scsi/scsi_lib_dma.c:44 ../../../driver-api/scsi:164:
#: ../drivers/scsi/scsi_proc.c:132 ../drivers/scsi/scsi_proc.c:153
#: ../drivers/scsi/scsi_proc.c:197 ../drivers/scsi/scsi_proc.c:219
#: ../drivers/scsi/scsi_proc.c:250 ../drivers/scsi/scsi_proc.c:270
#: ../drivers/scsi/scsi_proc.c:328 ../drivers/scsi/scsi_proc.c:361
#: ../drivers/scsi/scsi_proc.c:391 ../drivers/scsi/scsi_proc.c:527
#: ../drivers/scsi/scsi_proc.c:551 ../drivers/scsi/scsi_proc.c:574
#: ../../../driver-api/scsi:175: ../drivers/scsi/scsi_netlink.c:27
#: ../drivers/scsi/scsi_netlink.c:111 ../drivers/scsi/scsi_netlink.c:136
#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:611
#: ../drivers/scsi/scsi_scan.c:1658 ../drivers/scsi/scsi_scan.c:1816
#: ../drivers/scsi/scsi_scan.c:2064 ../../../driver-api/scsi:208:
#: ../drivers/scsi/scsi_sysfs.c:1480 ../drivers/scsi/scsi_sysfs.c:1525
#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:166
#: ../drivers/scsi/hosts.c:211 ../drivers/scsi/hosts.c:398
#: ../drivers/scsi/hosts.c:576 ../drivers/scsi/hosts.c:602
#: ../drivers/scsi/hosts.c:626 ../drivers/scsi/hosts.c:641
#: ../drivers/scsi/hosts.c:668 ../drivers/scsi/hosts.c:693
#: ../drivers/scsi/hosts.c:723 ../drivers/scsi/hosts.c:754
#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:57
#: ../drivers/scsi/scsi_common.c:115 ../drivers/scsi/scsi_common.c:148
#: ../drivers/scsi/scsi_common.c:177 ../drivers/scsi/scsi_common.c:240
#: ../drivers/scsi/scsi_common.c:279 ../drivers/scsi/scsi_common.c:307
#: ../drivers/scsi/scsi_common.c:355 ../../../driver-api/scsi:239:
#: ../drivers/scsi/scsi_transport_fc.c:504
#: ../drivers/scsi/scsi_transport_fc.c:519
#: ../drivers/scsi/scsi_transport_fc.c:597
#: ../drivers/scsi/scsi_transport_fc.c:617
#: ../drivers/scsi/scsi_transport_fc.c:638
#: ../drivers/scsi/scsi_transport_fc.c:887
#: ../drivers/scsi/scsi_transport_fc.c:2508
#: ../drivers/scsi/scsi_transport_fc.c:2859
#: ../drivers/scsi/scsi_transport_fc.c:3151
#: ../drivers/scsi/scsi_transport_fc.c:3372
#: ../drivers/scsi/scsi_transport_fc.c:3480
#: ../drivers/scsi/scsi_transport_fc.c:3743
#: ../drivers/scsi/scsi_transport_fc.c:3778
#: ../drivers/scsi/scsi_transport_fc.c:3954
#: ../drivers/scsi/scsi_transport_fc.c:3977 ../../../driver-api/scsi:249:
#: ../drivers/scsi/scsi_transport_iscsi.c:278
#: ../drivers/scsi/scsi_transport_iscsi.c:1225
#: ../drivers/scsi/scsi_transport_iscsi.c:1273
#: ../drivers/scsi/scsi_transport_iscsi.c:1383
#: ../drivers/scsi/scsi_transport_iscsi.c:1404
#: ../drivers/scsi/scsi_transport_iscsi.c:1431
#: ../drivers/scsi/scsi_transport_iscsi.c:1461
#: ../drivers/scsi/scsi_transport_iscsi.c:1845
#: ../drivers/scsi/scsi_transport_iscsi.c:1926
#: ../drivers/scsi/scsi_transport_iscsi.c:2367
#: ../drivers/scsi/scsi_transport_iscsi.c:2406
#: ../drivers/scsi/scsi_transport_iscsi.c:2449
#: ../drivers/scsi/scsi_transport_iscsi.c:2484
#: ../drivers/scsi/scsi_transport_iscsi.c:2858 ../../../driver-api/scsi:276:
#: ../drivers/scsi/scsi_transport_sas.c:299
#: ../drivers/scsi/scsi_transport_sas.c:312
#: ../drivers/scsi/scsi_transport_sas.c:329
#: ../drivers/scsi/scsi_transport_sas.c:343
#: ../drivers/scsi/scsi_transport_sas.c:381
#: ../drivers/scsi/scsi_transport_sas.c:397
#: ../drivers/scsi/scsi_transport_sas.c:426
#: ../drivers/scsi/scsi_transport_sas.c:703
#: ../drivers/scsi/scsi_transport_sas.c:744
#: ../drivers/scsi/scsi_transport_sas.c:769
#: ../drivers/scsi/scsi_transport_sas.c:786
#: ../drivers/scsi/scsi_transport_sas.c:808
#: ../drivers/scsi/scsi_transport_sas.c:898
#: ../drivers/scsi/scsi_transport_sas.c:943
#: ../drivers/scsi/scsi_transport_sas.c:976
#: ../drivers/scsi/scsi_transport_sas.c:1001
#: ../drivers/scsi/scsi_transport_sas.c:1018
#: ../drivers/scsi/scsi_transport_sas.c:1057
#: ../drivers/scsi/scsi_transport_sas.c:1070
#: ../drivers/scsi/scsi_transport_sas.c:1093
#: ../drivers/scsi/scsi_transport_sas.c:1131
#: ../drivers/scsi/scsi_transport_sas.c:1461
#: ../drivers/scsi/scsi_transport_sas.c:1499
#: ../drivers/scsi/scsi_transport_sas.c:1540
#: ../drivers/scsi/scsi_transport_sas.c:1594
#: ../drivers/scsi/scsi_transport_sas.c:1621
#: ../drivers/scsi/scsi_transport_sas.c:1635
#: ../drivers/scsi/scsi_transport_sas.c:1649
#: ../drivers/scsi/scsi_transport_sas.c:1679
#: ../drivers/scsi/scsi_transport_sas.c:1813
#: ../drivers/scsi/scsi_transport_sas.c:1922 ../../../driver-api/scsi:291:
#: ../drivers/scsi/scsi_transport_spi.c:993
#: ../drivers/scsi/scsi_transport_spi.c:1091
#: ../drivers/scsi/scsi_transport_spi.c:1128
#: ../drivers/scsi/scsi_transport_spi.c:1226 ../../../driver-api/scsi:300:
#: ../drivers/scsi/scsi_transport_srp.c:76
#: ../drivers/scsi/scsi_transport_srp.c:500
#: ../drivers/scsi/scsi_transport_srp.c:515
#: ../drivers/scsi/scsi_transport_srp.c:597
#: ../drivers/scsi/scsi_transport_srp.c:673
#: ../drivers/scsi/scsi_transport_srp.c:683
#: ../drivers/scsi/scsi_transport_srp.c:693
#: ../drivers/scsi/scsi_transport_srp.c:752
#: ../drivers/scsi/scsi_transport_srp.c:777
#: ../drivers/scsi/scsi_transport_srp.c:790
#: ../drivers/scsi/scsi_transport_srp.c:812
#: ../drivers/scsi/scsi_transport_srp.c:862 ../../../driver-api/scsi:93:
#: ../include/scsi/scsi_device.h:436 ../include/scsi/scsi_device.h:450
#: ../include/scsi/scsi_device.h:607 ../include/scsi/scsi_device.h:696
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:438
#: ../include/scsi/scsi_device.h:452
msgid "``sdev``"
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:433
#: ../include/scsi/scsi_device.h:447
msgid "the :c:type:`struct scsi_device <scsi_device>` to use as a cursor"
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:435
#: ../include/scsi/scsi_device.h:449
msgid "``shost``"
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:434
#: ../include/scsi/scsi_device.h:448
msgid "the :c:type:`struct scsi_host <scsi_host>` to iterate over"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:215
#: ../drivers/scsi/scsi.c:244 ../drivers/scsi/scsi.c:398
#: ../drivers/scsi/scsi.c:560 ../drivers/scsi/scsi.c:782
#: ../drivers/scsi/scsi.c:810 ../drivers/scsi/scsi.c:857
#: ../drivers/scsi/scsi.c:881 ../drivers/scsi/scsi.c:908
#: ../drivers/scsi/scsi.c:939 ../drivers/scsi/scsi.c:967
#: ../drivers/scsi/scsi.c:1000 ../../../driver-api/scsi:111:
#: ../drivers/scsi/scsicam.c:29 ../drivers/scsi/scsicam.c:55
#: ../drivers/scsi/scsicam.c:212 ../../../driver-api/scsi:119:
#: ../drivers/scsi/scsi_error.c:80 ../drivers/scsi/scsi_error.c:377
#: ../drivers/scsi/scsi_error.c:532 ../drivers/scsi/scsi_error.c:1056
#: ../drivers/scsi/scsi_error.c:1145 ../drivers/scsi/scsi_error.c:1336
#: ../drivers/scsi/scsi_error.c:2422 ../drivers/scsi/scsi_error.c:2455
#: ../drivers/scsi/scsi_error.c:2594 ../../../driver-api/scsi:128:
#: ../drivers/scsi/scsi_devinfo.c:338 ../drivers/scsi/scsi_devinfo.c:563
#: ../drivers/scsi/scsi_devinfo.c:750 ../drivers/scsi/scsi_devinfo.c:781
#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:262
#: ../drivers/scsi/scsi_ioctl.c:875 ../drivers/scsi/scsi_ioctl.c:968
#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:291
#: ../drivers/scsi/scsi_lib.c:1113 ../drivers/scsi/scsi_lib.c:2144
#: ../drivers/scsi/scsi_lib.c:2179 ../drivers/scsi/scsi_lib.c:2208
#: ../drivers/scsi/scsi_lib.c:2222 ../drivers/scsi/scsi_lib.c:2252
#: ../drivers/scsi/scsi_lib.c:2335 ../drivers/scsi/scsi_lib.c:2462
#: ../drivers/scsi/scsi_lib.c:2496 ../drivers/scsi/scsi_lib.c:2712
#: ../drivers/scsi/scsi_lib.c:2740 ../drivers/scsi/scsi_lib.c:2777
#: ../drivers/scsi/scsi_lib.c:2797 ../drivers/scsi/scsi_lib.c:2851
#: ../drivers/scsi/scsi_lib.c:2929 ../drivers/scsi/scsi_lib.c:2996
#: ../drivers/scsi/scsi_lib.c:3084 ../drivers/scsi/scsi_lib.c:3131
#: ../drivers/scsi/scsi_lib.c:3187 ../drivers/scsi/scsi_lib.c:3331
#: ../drivers/scsi/scsi_lib.c:3459 ../../../driver-api/scsi:153:
#: ../drivers/scsi/scsi_lib_dma.c:20 ../../../driver-api/scsi:164:
#: ../drivers/scsi/scsi_proc.c:152 ../drivers/scsi/scsi_proc.c:270
#: ../drivers/scsi/scsi_proc.c:330 ../drivers/scsi/scsi_proc.c:363
#: ../drivers/scsi/scsi_proc.c:393 ../drivers/scsi/scsi_proc.c:527
#: ../../../driver-api/scsi:175: ../drivers/scsi/scsi_netlink.c:26
#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:612
#: ../drivers/scsi/scsi_scan.c:1660 ../drivers/scsi/scsi_scan.c:1822
#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:575
#: ../drivers/scsi/hosts.c:668 ../drivers/scsi/hosts.c:723
#: ../drivers/scsi/hosts.c:755 ../../../driver-api/scsi:224:
#: ../drivers/scsi/scsi_common.c:114 ../drivers/scsi/scsi_common.c:148
#: ../drivers/scsi/scsi_common.c:309 ../drivers/scsi/scsi_common.c:359
#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:2507
#: ../drivers/scsi/scsi_transport_fc.c:2858
#: ../drivers/scsi/scsi_transport_fc.c:3153
#: ../drivers/scsi/scsi_transport_fc.c:3371
#: ../drivers/scsi/scsi_transport_fc.c:3480
#: ../drivers/scsi/scsi_transport_fc.c:3742
#: ../drivers/scsi/scsi_transport_fc.c:3777
#: ../drivers/scsi/scsi_transport_fc.c:3976 ../../../driver-api/scsi:249:
#: ../drivers/scsi/scsi_transport_iscsi.c:277
#: ../drivers/scsi/scsi_transport_iscsi.c:1227
#: ../drivers/scsi/scsi_transport_iscsi.c:1275
#: ../drivers/scsi/scsi_transport_iscsi.c:1384
#: ../drivers/scsi/scsi_transport_iscsi.c:1403
#: ../drivers/scsi/scsi_transport_iscsi.c:1430
#: ../drivers/scsi/scsi_transport_iscsi.c:1460
#: ../drivers/scsi/scsi_transport_iscsi.c:1844
#: ../drivers/scsi/scsi_transport_iscsi.c:1925
#: ../drivers/scsi/scsi_transport_iscsi.c:2366
#: ../drivers/scsi/scsi_transport_iscsi.c:2448
#: ../drivers/scsi/scsi_transport_iscsi.c:2483 ../../../driver-api/scsi:276:
#: ../drivers/scsi/scsi_transport_sas.c:298
#: ../drivers/scsi/scsi_transport_sas.c:311
#: ../drivers/scsi/scsi_transport_sas.c:328
#: ../drivers/scsi/scsi_transport_sas.c:342
#: ../drivers/scsi/scsi_transport_sas.c:380
#: ../drivers/scsi/scsi_transport_sas.c:396
#: ../drivers/scsi/scsi_transport_sas.c:425
#: ../drivers/scsi/scsi_transport_sas.c:703
#: ../drivers/scsi/scsi_transport_sas.c:743
#: ../drivers/scsi/scsi_transport_sas.c:768
#: ../drivers/scsi/scsi_transport_sas.c:785
#: ../drivers/scsi/scsi_transport_sas.c:899
#: ../drivers/scsi/scsi_transport_sas.c:943
#: ../drivers/scsi/scsi_transport_sas.c:975
#: ../drivers/scsi/scsi_transport_sas.c:1000
#: ../drivers/scsi/scsi_transport_sas.c:1017
#: ../drivers/scsi/scsi_transport_sas.c:1093
#: ../drivers/scsi/scsi_transport_sas.c:1131
#: ../drivers/scsi/scsi_transport_sas.c:1460
#: ../drivers/scsi/scsi_transport_sas.c:1499
#: ../drivers/scsi/scsi_transport_sas.c:1539
#: ../drivers/scsi/scsi_transport_sas.c:1593
#: ../drivers/scsi/scsi_transport_sas.c:1620
#: ../drivers/scsi/scsi_transport_sas.c:1634
#: ../drivers/scsi/scsi_transport_sas.c:1648 ../../../driver-api/scsi:291:
#: ../drivers/scsi/scsi_transport_spi.c:992
#: ../drivers/scsi/scsi_transport_spi.c:1090
#: ../drivers/scsi/scsi_transport_spi.c:1127 ../../../driver-api/scsi:300:
#: ../drivers/scsi/scsi_transport_srp.c:77
#: ../drivers/scsi/scsi_transport_srp.c:499
#: ../drivers/scsi/scsi_transport_srp.c:514
#: ../drivers/scsi/scsi_transport_srp.c:596
#: ../drivers/scsi/scsi_transport_srp.c:693
#: ../drivers/scsi/scsi_transport_srp.c:751
#: ../drivers/scsi/scsi_transport_srp.c:776
#: ../drivers/scsi/scsi_transport_srp.c:789 ../../../driver-api/scsi:93:
#: ../include/scsi/scsi_device.h:436 ../include/scsi/scsi_device.h:450
#: ../include/scsi/scsi_device.h:606 ../include/scsi/scsi_device.h:695
msgid "**Description**"
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:435
msgid ""
"Iterator that returns each device attached to **shost**.  This loop takes a "
"reference on each device and releases it at the end.  If you break out of "
"the loop, you must call scsi_device_put(sdev)."
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:448
msgid "``__shost_for_each_device (sdev, shost)``"
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:446
msgid "iterate over all devices of a host (UNLOCKED)"
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:449
msgid ""
"Iterator that returns each device attached to **shost**.  It does _not_ take "
"a reference on the scsi_device, so the whole loop must be protected by shost-"
">host_lock."
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:884
#: ../drivers/scsi/scsi.c:914 ../drivers/scsi/scsi.c:972
#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3088
#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:335
#: ../drivers/scsi/scsi_proc.c:399 ../../../driver-api/scsi:208:
#: ../drivers/scsi/scsi_sysfs.c:1524 ../../../driver-api/scsi:216:
#: ../drivers/scsi/hosts.c:212 ../drivers/scsi/hosts.c:398
#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:313
#: ../drivers/scsi/scsi_transport_sas.c:769
#: ../drivers/scsi/scsi_transport_sas.c:1001
#: ../drivers/scsi/scsi_transport_sas.c:1594 ../../../driver-api/scsi:300:
#: ../drivers/scsi/scsi_transport_srp.c:599 ../../../driver-api/scsi:93:
#: ../include/scsi/scsi_device.h:453
msgid "**Note**"
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:454
msgid ""
"The only reason to use this is because you need to access the device list in "
"interrupt context.  Otherwise you really want to use shost_for_each_device "
"instead."
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:603
msgid "Whether a device is a pseudo SCSI device."
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:217
#: ../drivers/scsi/scsi.c:245 ../drivers/scsi/scsi.c:398
#: ../drivers/scsi/scsi.c:559 ../drivers/scsi/scsi.c:785
#: ../drivers/scsi/scsi.c:813 ../../../driver-api/scsi:119:
#: ../drivers/scsi/scsi_error.c:380 ../../../driver-api/scsi:128:
#: ../drivers/scsi/scsi_devinfo.c:563 ../../../driver-api/scsi:136:
#: ../drivers/scsi/scsi_ioctl.c:133 ../drivers/scsi/scsi_ioctl.c:875
#: ../drivers/scsi/scsi_ioctl.c:969 ../../../driver-api/scsi:144:
#: ../drivers/scsi/scsi_lib.c:287 ../drivers/scsi/scsi_lib.c:2144
#: ../drivers/scsi/scsi_lib.c:2246 ../drivers/scsi/scsi_lib.c:2328
#: ../drivers/scsi/scsi_lib.c:2462 ../drivers/scsi/scsi_lib.c:2498
#: ../drivers/scsi/scsi_lib.c:2714 ../drivers/scsi/scsi_lib.c:2778
#: ../drivers/scsi/scsi_lib.c:2800 ../drivers/scsi/scsi_lib.c:2854
#: ../drivers/scsi/scsi_lib.c:2932 ../drivers/scsi/scsi_lib.c:2998
#: ../drivers/scsi/scsi_lib.c:3332 ../drivers/scsi/scsi_lib.c:3461
#: ../../../driver-api/scsi:208: ../drivers/scsi/scsi_sysfs.c:1482
#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:331
#: ../drivers/scsi/scsi_transport_sas.c:345
#: ../drivers/scsi/scsi_transport_sas.c:383
#: ../drivers/scsi/scsi_transport_sas.c:399
#: ../drivers/scsi/scsi_transport_sas.c:428 ../../../driver-api/scsi:291:
#: ../drivers/scsi/scsi_transport_spi.c:995
#: ../drivers/scsi/scsi_transport_spi.c:1093 ../../../driver-api/scsi:93:
#: ../include/scsi/scsi_device.h:609 ../include/scsi/scsi_device.h:698
msgid "``struct scsi_device *sdev``"
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:604
msgid "SCSI device to examine"
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:605
msgid ""
"A pseudo SCSI device can be used to allocate SCSI commands but does not show "
"up in sysfs. Additionally, the logical unit information in ***sdev** is made "
"up."
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:608
msgid ""
"This function tests the LUN number instead of comparing **sdev** with **sdev-"
">host->pseudo_sdev** because this function may be called before **sdev->host-"
">pseudo_sdev** has been initialized."
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:692
msgid "test if a device supports VPD pages"
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:693
msgid "the :c:type:`struct scsi_device <scsi_device>` to test"
msgstr ""

#: ../../../driver-api/scsi:93: ../include/scsi/scsi_device.h:694
msgid ""
"If the 'try_vpd_pages' flag is set it takes precedence. Otherwise we will "
"assume VPD pages are supported if the SCSI level is at least SPC-3 and "
"'skip_vpd_pages' is not set."
msgstr ""

#: ../../../driver-api/scsi.rst:97
msgid "drivers/scsi/scsi.c"
msgstr ""

#: ../../../driver-api/scsi.rst:99
msgid "Main file for the SCSI midlayer."
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:211
msgid "change a device's queue depth"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:212
#: ../drivers/scsi/scsi.c:240
msgid "SCSI Device in question"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:214
#: ../drivers/scsi/scsi.c:242
msgid "``int depth``"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:213
msgid "number of commands allowed to be queued to the driver"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:214
msgid "Sets the device queue depth and returns the new value."
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:239
msgid "track QUEUE_FULL events to adjust queue depth"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:241
msgid ""
"Current number of outstanding SCSI commands on this device, not counting the "
"one returned as QUEUE_FULL."
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:244
msgid "This function will track successive QUEUE_FULL events on a"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:245
msgid ""
"specific SCSI device to determine if and when there is a need to adjust the "
"queue depth on the device."
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:249
msgid "Lock Status: None held on entry"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:251
#: ../../../driver-api/scsi:111: ../drivers/scsi/scsicam.c:32
#: ../drivers/scsi/scsicam.c:57 ../drivers/scsi/scsicam.c:216
#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2421
#: ../drivers/scsi/scsi_error.c:2453 ../../../driver-api/scsi:128:
#: ../drivers/scsi/scsi_devinfo.c:344 ../../../driver-api/scsi:136:
#: ../drivers/scsi/scsi_ioctl.c:131 ../drivers/scsi/scsi_ioctl.c:264
#: ../drivers/scsi/scsi_ioctl.c:879 ../drivers/scsi/scsi_ioctl.c:969
#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:1115
#: ../drivers/scsi/scsi_lib.c:1236 ../drivers/scsi/scsi_lib.c:3462
#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:1669
#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3747
#: ../drivers/scsi/scsi_transport_fc.c:3782 ../../../driver-api/scsi:249:
#: ../drivers/scsi/scsi_transport_iscsi.c:1228
#: ../drivers/scsi/scsi_transport_iscsi.c:1276
#: ../drivers/scsi/scsi_transport_iscsi.c:1386
#: ../drivers/scsi/scsi_transport_iscsi.c:1405 ../../../driver-api/scsi:276:
#: ../drivers/scsi/scsi_transport_sas.c:706
#: ../drivers/scsi/scsi_transport_sas.c:807
#: ../drivers/scsi/scsi_transport_sas.c:902
#: ../drivers/scsi/scsi_transport_sas.c:948
#: ../drivers/scsi/scsi_transport_sas.c:1056
#: ../drivers/scsi/scsi_transport_sas.c:1461
#: ../drivers/scsi/scsi_transport_sas.c:1500
#: ../drivers/scsi/scsi_transport_sas.c:1678
msgid "**Return**"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:248
msgid "0 - No change needed"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:249
msgid ">0 - Adjust queue depth to this new depth,"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:250
msgid ""
"-1 - Drop back to untagged operation using host->cmd_per_lun as the untagged "
"command depth"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:253
#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:534
#: ../drivers/scsi/scsi_error.c:1318 ../drivers/scsi/scsi_error.c:1339
#: ../drivers/scsi/scsi_error.c:2424 ../drivers/scsi/scsi_error.c:2457
#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2932
#: ../drivers/scsi/scsi_lib.c:3000 ../../../driver-api/scsi:194:
#: ../drivers/scsi/scsi_scan.c:1661 ../drivers/scsi/scsi_scan.c:2063
#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:118
#: ../drivers/scsi/scsi_common.c:152 ../drivers/scsi/scsi_common.c:181
#: ../drivers/scsi/scsi_common.c:242 ../../../driver-api/scsi:239:
#: ../drivers/scsi/scsi_transport_fc.c:3
#: ../drivers/scsi/scsi_transport_fc.c:524
#: ../drivers/scsi/scsi_transport_fc.c:599
#: ../drivers/scsi/scsi_transport_fc.c:621
#: ../drivers/scsi/scsi_transport_fc.c:638
#: ../drivers/scsi/scsi_transport_fc.c:889
#: ../drivers/scsi/scsi_transport_fc.c:2521
#: ../drivers/scsi/scsi_transport_fc.c:2865
#: ../drivers/scsi/scsi_transport_fc.c:3180
#: ../drivers/scsi/scsi_transport_fc.c:3415
#: ../drivers/scsi/scsi_transport_fc.c:3492
#: ../drivers/scsi/scsi_transport_fc.c:3956
#: ../drivers/scsi/scsi_transport_fc.c:3978 ../../../driver-api/scsi:291:
#: ../drivers/scsi/scsi_transport_spi.c:1226 ../../../driver-api/scsi:300:
#: ../drivers/scsi/scsi_transport_srp.c:518
msgid "**Notes**"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:256
msgid "Low level drivers may call this at any time and we will do"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:257
msgid "\"The Right Thing.\"  We are interrupt context safe."
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:392
msgid "Get Vital Product Data from a SCSI device"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:393
msgid "The device to ask"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:395
msgid "``u8 page``"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:394
msgid "Which Vital Product Data to return"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:396
msgid "``unsigned char *buf``"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:395
msgid "where to store the VPD"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:397
#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:307
#: ../drivers/scsi/scsi_common.c:355
msgid "``int buf_len``"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:396
msgid "number of bytes in the VPD buffer area"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:397
msgid ""
"SCSI devices may optionally supply Vital Product Data.  Each 'page' of VPD "
"is defined in the appropriate SCSI document (eg SPC, SBC). If the device "
"supports this VPD page, this routine fills **buf** with the data from that "
"page and return 0. If the VPD page is not supported or its content cannot be "
"retrieved, -EINVAL is returned."
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:553
msgid "Find out if a given command is supported"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:554
msgid "scsi device to query"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:556
#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2245
#: ../drivers/scsi/scsi_lib.c:2328
msgid "``unsigned char *buffer``"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:555
msgid "scratch buffer (must be at least 20 bytes long)"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:557
msgid "``unsigned int len``"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:556
msgid "length of buffer"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:558
msgid "``unsigned char opcode``"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:557
msgid "opcode for the command to look up"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:559
msgid "``unsigned short sa``"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:558
msgid "service action for the command to look up"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:559
msgid ""
"Uses the REPORT SUPPORTED OPERATION CODES to check support for the command "
"identified with **opcode** and **sa**. If the command does not have a "
"service action, **sa** must be 0. Returns -EINVAL if RSOC fails, 0 if the "
"command is not supported and 1 if the device claims to support the command."
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:779
msgid "get an additional reference to a scsi_device"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:780
msgid "device to get a reference to"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:782
msgid ""
"Gets a reference to the scsi_device and increments the use count of the "
"underlying LLDD module.  You must hold host_lock of the parent Scsi_Host or "
"already have a reference when calling this."
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:786
msgid ""
"This will fail if a device is deleted or cancelled, or when the LLD module "
"is in the process of being unloaded."
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:807
msgid "release a reference to a scsi_device"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:808
msgid "device to release a reference on."
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:810
msgid ""
"Release a reference to the scsi_device and decrements the use count of the "
"underlying LLDD module.  The device is freed once the last user vanishes."
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:852
msgid "helper to walk all devices of a target"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:858
#: ../drivers/scsi/scsi.c:882 ../drivers/scsi/scsi.c:910
#: ../drivers/scsi/scsi.c:941 ../../../driver-api/scsi:291:
#: ../drivers/scsi/scsi_transport_spi.c:1130
msgid "``struct scsi_target *starget``"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:853
#: ../drivers/scsi/scsi.c:877
msgid "target whose devices we want to iterate over."
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:855
#: ../drivers/scsi/scsi.c:879 ../../../driver-api/scsi:164:
#: ../drivers/scsi/scsi_proc.c:269
msgid "``void *data``"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:854
msgid "Opaque passed to each function call."
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:856
#: ../drivers/scsi/scsi.c:880
msgid "``void (*fn)(struct scsi_device *, void *)``"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:855
msgid "Function to call on each device"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:856
msgid ""
"This traverses over each device of **starget**.  The devices have a "
"reference that must be released by scsi_host_put when breaking out of the "
"loop."
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:876
msgid "helper to walk all devices of a target (UNLOCKED)"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:878
msgid "parameter for callback **fn\\(\\)**"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:879
msgid "callback function that is invoked for each device"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:880
msgid ""
"This traverses over each device of **starget**.  It does _not_ take a "
"reference on the scsi_device, so the whole loop must be protected by shost-"
">host_lock."
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:885
msgid ""
"The only reason why drivers would want to use this is because they need to "
"access the device list in irq context.  Otherwise you really want to use "
"starget_for_each_device instead."
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:904
msgid "find a device given the target (UNLOCKED)"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:905
#: ../drivers/scsi/scsi.c:936
msgid "SCSI target pointer"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:907
#: ../drivers/scsi/scsi.c:938 ../drivers/scsi/scsi.c:966
#: ../drivers/scsi/scsi.c:999 ../../../driver-api/scsi:194:
#: ../drivers/scsi/scsi_scan.c:1659 ../drivers/scsi/scsi_scan.c:1817
#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:150
msgid "``u64 lun``"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:906
#: ../drivers/scsi/scsi.c:937 ../drivers/scsi/scsi.c:965
#: ../drivers/scsi/scsi.c:998
msgid "SCSI Logical Unit Number"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:908
msgid ""
"Looks up the scsi_device with the specified **lun** for a given "
"**starget**.  The returned scsi_device does not have an additional "
"reference.  You must hold the host's host_lock over this call and any access "
"to the returned scsi_device. A scsi_device in state SDEV_DEL is skipped."
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:914
msgid ""
"The only reason why drivers should use this is because they need to access "
"the device list in irq context.  Otherwise you really want to use "
"scsi_device_lookup_by_target instead."
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:935
msgid "find a device given the target"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:939
msgid ""
"Looks up the scsi_device with the specified **lun** for a given "
"**starget**.  The returned scsi_device has an additional reference that "
"needs to be released with scsi_device_put once you're done with it."
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:961
msgid "find a device given the host (UNLOCKED)"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:967
#: ../drivers/scsi/scsi.c:1000 ../../../driver-api/scsi:119:
#: ../drivers/scsi/scsi_error.c:83 ../drivers/scsi/scsi_error.c:2226
#: ../drivers/scsi/scsi_error.c:2420 ../drivers/scsi/scsi_error.c:2452
#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2210
#: ../drivers/scsi/scsi_lib.c:2224 ../drivers/scsi/scsi_lib.c:3087
#: ../drivers/scsi/scsi_lib.c:3134 ../../../driver-api/scsi:164:
#: ../drivers/scsi/scsi_proc.c:221 ../drivers/scsi/scsi_proc.c:252
#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:2066
#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:168
#: ../drivers/scsi/hosts.c:213 ../drivers/scsi/hosts.c:604
#: ../drivers/scsi/hosts.c:628 ../drivers/scsi/hosts.c:643
#: ../drivers/scsi/hosts.c:670 ../drivers/scsi/hosts.c:695
#: ../drivers/scsi/hosts.c:725 ../drivers/scsi/hosts.c:756
#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:521
#: ../drivers/scsi/scsi_transport_fc.c:599
#: ../drivers/scsi/scsi_transport_fc.c:619
#: ../drivers/scsi/scsi_transport_fc.c:640
#: ../drivers/scsi/scsi_transport_fc.c:889
#: ../drivers/scsi/scsi_transport_fc.c:2861
#: ../drivers/scsi/scsi_transport_fc.c:3153
#: ../drivers/scsi/scsi_transport_fc.c:3956 ../../../driver-api/scsi:249:
#: ../drivers/scsi/scsi_transport_iscsi.c:1227
#: ../drivers/scsi/scsi_transport_iscsi.c:1275
#: ../drivers/scsi/scsi_transport_iscsi.c:1385
#: ../drivers/scsi/scsi_transport_iscsi.c:1463 ../../../driver-api/scsi:276:
#: ../drivers/scsi/scsi_transport_sas.c:314 ../../../driver-api/scsi:300:
#: ../drivers/scsi/scsi_transport_srp.c:695
#: ../drivers/scsi/scsi_transport_srp.c:779
msgid "``struct Scsi_Host *shost``"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:962
#: ../drivers/scsi/scsi.c:995
msgid "SCSI host pointer"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:964
#: ../drivers/scsi/scsi.c:997 ../../../driver-api/scsi:164:
#: ../drivers/scsi/scsi_proc.c:327 ../drivers/scsi/scsi_proc.c:360
#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:1657
msgid "``uint channel``"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:963
#: ../drivers/scsi/scsi.c:996
msgid "SCSI channel (zero if only one channel)"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:965
#: ../drivers/scsi/scsi.c:998 ../../../driver-api/scsi:164:
#: ../drivers/scsi/scsi_proc.c:328 ../drivers/scsi/scsi_proc.c:361
msgid "``uint id``"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:964
#: ../drivers/scsi/scsi.c:997
msgid "SCSI target number (physical unit number)"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:967
msgid ""
"Looks up the scsi_device with the specified **channel**, **id**, **lun** for "
"a given host. The returned scsi_device does not have an additional "
"reference.  You must hold the host's host_lock over this call and any access "
"to the returned scsi_device."
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:972
msgid ""
"The only reason why drivers would want to use this is because they need to "
"access the device list in irq context.  Otherwise you really want to use "
"scsi_device_lookup instead."
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:994
msgid "find a device given the host"
msgstr ""

#: ../../../driver-api/scsi:101: ../drivers/scsi/scsi.c:1000
msgid ""
"Looks up the scsi_device with the specified **channel**, **id**, **lun** for "
"a given host.  The returned scsi_device has an additional reference that "
"needs to be released with scsi_device_put once you're done with it."
msgstr ""

#: ../../../driver-api/scsi.rst:105
msgid "drivers/scsi/scsicam.c"
msgstr ""

#: ../../../driver-api/scsi.rst:107
msgid ""
"`SCSI Common Access Method <http://www.t10.org/ftp/t10/drafts/cam/cam-r12b."
"pdf>`__ support functions, for use with HDIO_GETGEO, etc."
msgstr ""

#: ../../../driver-api/scsi:111: ../drivers/scsi/scsicam.c:26
msgid "Read PC partition table out of first sector of device."
msgstr ""

#: ../../../driver-api/scsi:111: ../drivers/scsi/scsicam.c:32
msgid "``struct gendisk *dev``"
msgstr ""

#: ../../../driver-api/scsi:111: ../drivers/scsi/scsicam.c:27
msgid "from this device"
msgstr ""

#: ../../../driver-api/scsi:111: ../drivers/scsi/scsicam.c:29
msgid "Reads the first sector from the device and returns ``0x42`` bytes"
msgstr ""

#: ../../../driver-api/scsi:111: ../drivers/scsi/scsicam.c:30
msgid "starting at offset ``0x1be``."
msgstr ""

#: ../../../driver-api/scsi:111: ../drivers/scsi/scsicam.c:31
msgid "partition table in kmalloc(GFP_KERNEL) memory, or NULL on error."
msgstr ""

#: ../../../driver-api/scsi:111: ../drivers/scsi/scsicam.c:50
msgid "Parse cylinders/heads/sectors from PC partition table"
msgstr ""

#: ../../../driver-api/scsi:111: ../drivers/scsi/scsicam.c:56
#: ../drivers/scsi/scsicam.c:213
msgid "``struct gendisk *disk``"
msgstr ""

#: ../../../driver-api/scsi:111: ../drivers/scsi/scsicam.c:51
msgid "gendisk of the disk to parse"
msgstr ""

#: ../../../driver-api/scsi:111: ../drivers/scsi/scsicam.c:53
#: ../drivers/scsi/scsicam.c:210
msgid "``sector_t capacity``"
msgstr ""

#: ../../../driver-api/scsi:111: ../drivers/scsi/scsicam.c:52
#: ../drivers/scsi/scsicam.c:209
msgid "size of the disk in sectors"
msgstr ""

#: ../../../driver-api/scsi:111: ../drivers/scsi/scsicam.c:54
msgid "``int geom[3]``"
msgstr ""

#: ../../../driver-api/scsi:111: ../drivers/scsi/scsicam.c:53
msgid "output in form of [hds, cylinders, sectors]"
msgstr ""

#: ../../../driver-api/scsi:111: ../drivers/scsi/scsicam.c:54
msgid ""
"Determine the BIOS mapping/geometry used to create the partition table, "
"storing the results in **geom**."
msgstr ""

#: ../../../driver-api/scsi:111: ../drivers/scsi/scsicam.c:58
msgid "``false`` on failure, ``true`` on success."
msgstr ""

#: ../../../driver-api/scsi:111: ../drivers/scsi/scsicam.c:207
msgid "Determine geometry of a disk in cylinders/heads/sectors."
msgstr ""

#: ../../../driver-api/scsi:111: ../drivers/scsi/scsicam.c:208
msgid "which device"
msgstr ""

#: ../../../driver-api/scsi:111: ../drivers/scsi/scsicam.c:211
msgid "``int *ip``"
msgstr ""

#: ../../../driver-api/scsi:111: ../drivers/scsi/scsicam.c:210
msgid "return value: ip[0]=heads, ip[1]=sectors, ip[2]=cylinders"
msgstr ""

#: ../../../driver-api/scsi:111: ../drivers/scsi/scsicam.c:212
msgid "determine the BIOS mapping/geometry used for a drive in a"
msgstr ""

#: ../../../driver-api/scsi:111: ../drivers/scsi/scsicam.c:213
msgid ""
"SCSI-CAM system, storing the results in ip as required by the HDIO_GETGEO "
"ioctl()."
msgstr ""

#: ../../../driver-api/scsi:111: ../drivers/scsi/scsicam.c:216
msgid "-1 on failure, 0 on success."
msgstr ""

#: ../../../driver-api/scsi.rst:115
msgid "drivers/scsi/scsi_error.c"
msgstr ""

#: ../../../driver-api/scsi.rst:117
msgid "Common SCSI error/timeout handling routines."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:77
msgid "schedule EH for SCSI host"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:78
msgid "SCSI host to invoke error handling on."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:79
msgid "Schedule SCSI EH without scmd."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:374
msgid "Prevent cmds from being queued."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:375
msgid "Device on which we are performing recovery."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:377
msgid ""
"We block until the host is out of error recovery, and then check to see "
"whether the host or the device is offline."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:380
#: ../drivers/scsi/scsi_error.c:531 ../drivers/scsi/scsi_error.c:2593
#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:216
#: ../drivers/scsi/hosts.c:402 ../drivers/scsi/hosts.c:574
#: ../drivers/scsi/hosts.c:667 ../../../driver-api/scsi:224:
#: ../drivers/scsi/scsi_common.c:187 ../drivers/scsi/scsi_common.c:244
#: ../drivers/scsi/scsi_common.c:308 ../drivers/scsi/scsi_common.c:358
msgid "Return value:"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:381
msgid "0 when dev was taken offline by error recovery. 1 OK to proceed."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:529
msgid "Examine scsi cmd sense"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:535
#: ../drivers/scsi/scsi_error.c:1055 ../drivers/scsi/scsi_error.c:1320
#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2172
#: ../drivers/scsi/scsi_lib.c:3510 ../../../driver-api/scsi:239:
#: ../drivers/scsi/scsi_transport_fc.c:2510 ../../../driver-api/scsi:300:
#: ../drivers/scsi/scsi_transport_srp.c:599
msgid "``struct scsi_cmnd *scmd``"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:530
msgid "Cmd to have sense checked."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:532
msgid "SUCCESS or FAILED or NEEDS_RETRY or ADD_TO_MLQUEUE"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:535
msgid ""
"When a deferred error is detected the current command has not been executed "
"and needs retrying."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1049
msgid "Save a scsi command info as part of error recovery"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1050
msgid "SCSI command structure to hijack"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1052
#: ../drivers/scsi/scsi_error.c:1144
msgid "``struct scsi_eh_save *ses``"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1051
msgid "structure to save restore information"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1053
msgid "``unsigned char *cmnd``"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1052
msgid "CDB to send. Can be NULL if no new cmnd is needed"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1054
msgid "``int cmnd_size``"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1053
msgid "size in bytes of **cmnd** (must be <= MAX_COMMAND_SIZE)"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1055
msgid "``unsigned sense_bytes``"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1054
msgid "size of sense data to copy. or 0 (if != 0 **cmnd** is ignored)"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1055
msgid ""
"This function is used to save a scsi command information before re-execution "
"as part of the error recovery process.  If **sense_bytes** is 0 the command "
"sent must be one that does not transfer any data.  If **sense_bytes** != 0 "
"**cmnd** is ignored and this functions sets up a REQUEST_SENSE command and "
"cmnd buffers to read **sense_bytes** into **scmd->sense_buffer**."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1141
msgid "Restore a scsi command info as part of error recovery"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1147
msgid "``struct scsi_cmnd* scmd``"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1142
msgid "SCSI command structure to restore"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1143
msgid "saved information from a coresponding call to scsi_eh_prep_cmnd"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1144
msgid "Undo any damage done by above scsi_eh_prep_cmnd()."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1314
msgid "Handle a cmd that eh is finished with."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1315
msgid "Original SCSI cmd that eh has finished."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1317
#: ../drivers/scsi/scsi_error.c:1335 ../drivers/scsi/scsi_error.c:2224
#: ../drivers/scsi/scsi_error.c:2246
msgid "``struct list_head *done_q``"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1316
msgid "Queue for processed commands."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1318
msgid ""
"We don't want to use the normal command completion while we are are still "
"handling errors - it may cause other commands to be queued, and that would "
"disturb what we are doing.  Thus we really want to keep a list of pending "
"commands for final completion, and once we are ready to leave error handling "
"we handle completion for real."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1332
msgid "Get device sense data."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1338
#: ../drivers/scsi/scsi_error.c:2223
msgid "``struct list_head *work_q``"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1333
msgid "Queue of commands to process."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1334
msgid "Queue of processed commands."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1336
msgid ""
"See if we need to request sense information.  if so, then get it now, so we "
"have a better idea of what to do."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1340
msgid ""
"This has the unfortunate side effect that if a shost adapter does not "
"automatically request sense information, we end up shutting it down before "
"we request it."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1344
msgid ""
"All drivers should request sense information internally these days, so for "
"now all I have to say is tough noogies if you end up in here."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1347
msgid "XXX: Long term this code should go away, but that needs an audit of"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:1348
msgid "all LLDDs first."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2220
msgid "check device ready state and recover if not."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2221
msgid "host to be recovered."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2222
msgid ":c:type:`list_head` for pending commands."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2223
msgid ":c:type:`list_head` for processed commands."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2240
msgid "finish processed commands or retry them."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2241
msgid "list_head of processed commands."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2414
msgid "report bus reset observed"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2419
#: ../drivers/scsi/scsi_error.c:2451
msgid "Host in question"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2421
#: ../drivers/scsi/scsi_error.c:2453 ../../../driver-api/scsi:239:
#: ../drivers/scsi/scsi_transport_fc.c:3150
#: ../drivers/scsi/scsi_transport_fc.c:3953
msgid "``int channel``"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2420
msgid "channel on which reset was observed."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2415
msgid ""
"Utility function used by low-level drivers to report that they have observed "
"a bus reset on the bus being handled."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2419
msgid "Lock status: Host lock must be held."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2422
#: ../drivers/scsi/scsi_error.c:2455
msgid "Nothing"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2426
#: ../drivers/scsi/scsi_error.c:2459
msgid "This only needs to be called if the reset is one which"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2427
#: ../drivers/scsi/scsi_error.c:2460
msgid ""
"originates from an unknown location.  Resets originated by the mid-level "
"itself don't need to call this, but there should be no harm."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2431
#: ../drivers/scsi/scsi_error.c:2464
msgid ""
"The main purpose of this is to make sure that a CHECK_CONDITION is properly "
"treated."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2446
msgid "report device reset observed"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2452
msgid "channel on which reset was observed"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2454
msgid "``int target``"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2453
msgid "target on which reset was observed"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2447
msgid ""
"Utility function used by low-level drivers to report that they have observed "
"a device reset on the device being handled."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2451
msgid "Lock status: Host lock must be held"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2588
msgid ""
"get information field from sense data (either fixed or descriptor format)"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2594
#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:179
msgid "``const u8 *sense_buffer``"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2589
msgid "byte array of sense data"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2591
#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:178
#: ../drivers/scsi/scsi_common.c:239
msgid "``int sb_len``"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2590
#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:177
#: ../drivers/scsi/scsi_common.c:238
msgid "number of valid bytes in sense_buffer"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2592
msgid "``u64 *info_out``"
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2591
msgid ""
"pointer to 64 integer where 8 or 4 byte information field will be placed if "
"found."
msgstr ""

#: ../../../driver-api/scsi:119: ../drivers/scsi/scsi_error.c:2594
msgid "true if information field found, false if not found."
msgstr ""

#: ../../../driver-api/scsi.rst:123
msgid "drivers/scsi/scsi_devinfo.c"
msgstr ""

#: ../../../driver-api/scsi.rst:125
msgid ""
"Manage scsi_dev_info_list, which tracks blacklisted and whitelisted devices."
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:330
msgid "add one dev_info list entry."
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:336
msgid "``int compatible``"
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:331
msgid "if true, null terminate short strings.  Otherwise space pad."
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:333
msgid "``char *vendor``"
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:332
msgid "vendor string"
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:334
msgid "``char *model``"
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:333
msgid "model (product) string"
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:335
msgid "``char *strflags``"
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:334
msgid "integer string"
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:336
msgid "``blist_flags_t flags``"
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:335
msgid "if strflags NULL, use this flag value"
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:337
#: ../drivers/scsi/scsi_devinfo.c:562 ../drivers/scsi/scsi_devinfo.c:752
#: ../drivers/scsi/scsi_devinfo.c:784
msgid "``enum scsi_devinfo_key key``"
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:336
msgid "specify list to use"
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:338
msgid ""
"Create and add one dev_info entry for **vendor**, **model**, **strflags** or "
"**flag** in list specified by **key**. If **compatible**, add to the tail of "
"the list, do not space pad, and set devinfo->compatible. The "
"scsi_static_device_list entries are added with **compatible** 1 and "
"**clfags** NULL."
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:345
msgid "0 OK, -error on failure."
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:557
msgid "get device specific flags from the dynamic device list"
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:558
msgid ":c:type:`scsi_device` to get flags for"
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:560
msgid "``const unsigned char *vendor``"
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:559
msgid "vendor name"
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:561
msgid "``const unsigned char *model``"
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:560
msgid "model name"
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:561
msgid "list to look up"
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:563
msgid ""
"Search the scsi_dev_info_list specified by **key** for an entry matching "
"**vendor** and **model**, if found, return the matching flags value, else "
"return the host or global default settings. Called during scan time."
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:746
msgid "add a new devinfo list"
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:747
msgid "key of the list to add"
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:749
msgid "``const char *name``"
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:748
msgid "Name of the list to add (for /proc/scsi/device_info)"
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:749
msgid ""
"Adds the requested list, returns zero on success, -EEXIST if the key is "
"already registered to a list, or other error on failure."
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:778
msgid "destroy an added devinfo list"
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:779
msgid "key of the list to destroy"
msgstr ""

#: ../../../driver-api/scsi:128: ../drivers/scsi/scsi_devinfo.c:780
msgid ""
"Iterates over the entire list first, freeing all the values, then frees the "
"list itself.  Returns 0 on success or -EINVAL if the key can't be found."
msgstr ""

#: ../../../driver-api/scsi.rst:132
msgid "drivers/scsi/scsi_ioctl.c"
msgstr ""

#: ../../../driver-api/scsi.rst:134
msgid "Handle ioctl() calls for SCSI devices."
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:127
msgid "send command to allow or prevent medium removal"
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:128
#: ../drivers/scsi/scsi_ioctl.c:964
msgid "target scsi device"
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:130
msgid "``char state``"
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:129
msgid "removal state to set (prevent or allow)"
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:131
msgid "``0`` if **sdev** is not removable or not lockable or successful."
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:132
msgid "non-``0`` is a SCSI result code if > 0 or kernel error code if < 0."
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:133
msgid "Sets **sdev->locked** to the new state on success."
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:258
msgid "Check if the given command is allowed."
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:264
msgid "``unsigned char *cmd``"
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:259
msgid "SCSI command to check"
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:261
#: ../drivers/scsi/scsi_ioctl.c:872
msgid "``bool open_for_write``"
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:260
#: ../drivers/scsi/scsi_ioctl.c:871
msgid "is the file / block device opened for writing?"
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:261
msgid ""
"Only a subset of commands are allowed for unprivileged users. Commands used "
"to format the media, update the firmware, etc. are not permitted."
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:265
msgid "``true`` if the cmd is allowed, otherwise **false**."
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:869
msgid "Dispatch ioctl to scsi device"
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:870
msgid "scsi device receiving ioctl"
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:873
#: ../drivers/scsi/scsi_ioctl.c:966
msgid "``int cmd``"
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:872
#: ../drivers/scsi/scsi_ioctl.c:965
msgid "which ioctl is it"
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:874
msgid "``void __user *arg``"
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:873
msgid "data associated with ioctl"
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:875
msgid ""
"The scsi_ioctl() function differs from most ioctls in that it does not take "
"a major/minor number as the dev field.  Rather, it takes a pointer to a :c:"
"type:`struct scsi_device <scsi_device>`."
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:879
msgid "varies depending on the **cmd**"
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:963
msgid "prevent commands from being queued"
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:967
msgid "``bool ndelay``"
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:966
msgid "no delay (non-blocking)"
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:967
msgid "We can process a reset even when a device isn't fully operable."
msgstr ""

#: ../../../driver-api/scsi:136: ../drivers/scsi/scsi_ioctl.c:970
msgid "``0`` on success, <0 error code."
msgstr ""

#: ../../../driver-api/scsi.rst:140
msgid "drivers/scsi/scsi_lib.c"
msgstr ""

#: ../../../driver-api/scsi.rst:142
msgid "SCSI queuing library."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:188
msgid "reset all failures to zero"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:194
msgid "``struct scsi_failures *failures``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:189
msgid ""
":c:type:`struct scsi_failures <scsi_failures>` with specific failure modes "
"set"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:281
msgid "insert request and wait for the result"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:282
msgid "scsi_device"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:284
msgid "``const unsigned char *cmd``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:283
#: ../../../driver-api/scsi:153: ../drivers/scsi/scsi_lib_dma.c:18
#: ../drivers/scsi/scsi_lib_dma.c:41
msgid "scsi command"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:285
#: ../drivers/scsi/scsi_lib.c:1234
msgid "``blk_opf_t opf``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:284
msgid "block layer request cmd_flags"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:286
msgid "``void *buffer``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:285
msgid "data buffer"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:287
msgid "``unsigned int bufflen``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:286
msgid "len of buffer"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:288
#: ../drivers/scsi/scsi_lib.c:2247 ../drivers/scsi/scsi_lib.c:2330
#: ../drivers/scsi/scsi_lib.c:2459
msgid "``int timeout``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:287
msgid "request timeout in HZ"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:289
msgid "``int ml_retries``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:288
msgid "number of times SCSI midlayer will retry request"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:290
msgid "``const struct scsi_exec_args *args``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:289
msgid "Optional args. See struct definition for field descriptions"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:290
msgid ""
"Returns the scsi_cmnd result field if a command was executed, or a negative "
"Linux error code if we didn't get that far."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:1110
msgid "Allocate and initialize data and integrity scatterlists"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:1116
#: ../../../driver-api/scsi:153: ../drivers/scsi/scsi_lib_dma.c:23
#: ../drivers/scsi/scsi_lib_dma.c:46 ../../../driver-api/scsi:249:
#: ../drivers/scsi/scsi_transport_iscsi.c:1847 ../../../driver-api/scsi:291:
#: ../drivers/scsi/scsi_transport_spi.c:1225
msgid "``struct scsi_cmnd *cmd``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:1111
msgid "SCSI command data structure to initialize."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:1112
msgid ""
"Initializes **cmd->sdb** and also **cmd->prot_sdb** if data integrity is "
"enabled for **cmd**."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:1116
msgid "BLK_STS_OK       - on success"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:1117
msgid "BLK_STS_RESOURCE - if the failure is retryable"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:1118
msgid "BLK_STS_IOERR    - if the failure is fatal"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:1230
msgid ""
"allocate a block request and partially initialize its :c:type:`scsi_cmnd`"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:1236
#: ../drivers/scsi/scsi_lib.c:2182
msgid "``struct request_queue *q``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:1232
msgid "the device's request queue"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:1233
msgid "the request operation code"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:1235
#: ../drivers/scsi/scsi_lib.c:2142
msgid "``blk_mq_req_flags_t flags``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:1234
msgid "block layer allocation flags"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:1236
msgid ""
":c:type:`struct request <request>` pointer on success or ``NULL`` on failure"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2138
msgid "Allocate an internal SCSI command."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2139
msgid "SCSI device from which to allocate the command"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2141
msgid "``enum dma_data_direction data_direction``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2140
msgid "Data direction for the allocated command"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2141
msgid ""
"request allocation flags, e.g. BLK_MQ_REQ_RESERVED or BLK_MQ_REQ_NOWAIT."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2143
msgid "Allocates a SCSI command for internal LLDD use."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2166
msgid "Free an internal SCSI command."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2167
msgid "SCSI command to be freed"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2176
msgid "return sdev associated with a request_queue"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2177
msgid "The request queue to return the sdev from"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2178
msgid ""
"Return the sdev associated with a request queue or NULL if the request_queue "
"does not reference a SCSI device."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2204
msgid ""
"Utility function used by low-level drivers to prevent further commands from "
"being queued to the device."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2206
#: ../drivers/scsi/scsi_lib.c:2220
msgid "host in question"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2207
msgid ""
"There is no timer nor any other means by which the requests get unblocked "
"other than the low-level driver calling scsi_unblock_requests()."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2218
msgid ""
"Utility function used by low-level drivers to allow further commands to be "
"queued to the device."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2221
msgid ""
"There is no timer nor any other means by which the requests get unblocked "
"other than the low-level driver calling scsi_unblock_requests(). This is "
"done as an API function so that changes to the internals of the scsi mid-"
"layer won't require wholesale changes to drivers that use this feature."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2240
msgid "issue a mode select"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2241
#: ../drivers/scsi/scsi_lib.c:2323
msgid "SCSI device to be queried"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2243
msgid "``int pf``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2242
msgid "Page format bit (1 == standard, 0 == vendor specific)"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2244
msgid "``int sp``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2243
msgid "Save page bit (0 == don't save, 1 == save)"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2244
#: ../drivers/scsi/scsi_lib.c:2327
msgid "request buffer (may not be smaller than eight bytes)"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2246
#: ../drivers/scsi/scsi_lib.c:2329 ../../../driver-api/scsi:194:
#: ../drivers/scsi/scsi_scan.c:611
msgid "``int len``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2245
#: ../drivers/scsi/scsi_lib.c:2328
msgid "length of request buffer."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2246
#: ../drivers/scsi/scsi_lib.c:2329 ../drivers/scsi/scsi_lib.c:2458
msgid "command timeout"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2248
#: ../drivers/scsi/scsi_lib.c:2331 ../drivers/scsi/scsi_lib.c:2460
msgid "``int retries``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2247
#: ../drivers/scsi/scsi_lib.c:2330 ../drivers/scsi/scsi_lib.c:2459
msgid "number of retries before failing"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2249
#: ../drivers/scsi/scsi_lib.c:2332
msgid "``struct scsi_mode_data *data``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2248
#: ../drivers/scsi/scsi_lib.c:2331
msgid "returns a structure abstracting the mode header data"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2250
#: ../drivers/scsi/scsi_lib.c:2333 ../drivers/scsi/scsi_lib.c:2461
#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:179
msgid "``struct scsi_sense_hdr *sshdr``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2249
#: ../drivers/scsi/scsi_lib.c:2332
msgid ""
"place to put sense data (or NULL if no sense to be collected). must be "
"SCSI_SENSE_BUFFERSIZE big."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2251
msgid ""
"Returns zero if successful; negative error number or scsi status on error"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2322
msgid "issue a mode sense, falling back from 10 to six bytes if necessary."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2325
msgid "``int dbd``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2324
msgid "set to prevent mode sense from returning block descriptors"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2326
msgid "``int modepage``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2325
msgid "mode page being requested"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2327
msgid "``int subpage``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2326
msgid "sub-page of the mode page being requested"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2334
msgid "Returns zero if successful, or a negative error number on failure"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2456
msgid "test if unit is ready"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2457
#: ../drivers/scsi/scsi_lib.c:2493
msgid "scsi device to change the state of."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2460
msgid "outpout pointer for decoded sense information."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2461
msgid ""
"Returns zero if successful or an error if TUR failed.  For removable media, "
"UNIT_ATTENTION sets ->changed flag."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2492
msgid "Take the given device through the device state model."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2495
msgid "``enum scsi_device_state state``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2494
msgid "state to change to."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2495
msgid ""
"Returns zero if successful or an error if the requested transition is "
"illegal."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2708
#: ../drivers/scsi/scsi_lib.c:2772
msgid "send asserted event to uevent thread"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2709
#: ../drivers/scsi/scsi_lib.c:2773
msgid "scsi_device event occurred on"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2711
msgid "``struct scsi_event *evt``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2710
msgid "event to send"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2711
msgid "Assert scsi device event asynchronously."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2736
msgid "allocate a new scsi event"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2742
#: ../drivers/scsi/scsi_lib.c:2775
msgid "``enum scsi_device_event evt_type``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2737
msgid "type of event to allocate"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2739
#: ../drivers/scsi/scsi_lib.c:2776
msgid "``gfp_t gfpflags``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2738
#: ../drivers/scsi/scsi_lib.c:2775
msgid "GFP flags for allocation"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2739
msgid "Allocates and returns a new scsi_event."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2774
msgid "type of event to send"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2776
msgid "Assert scsi device event asynchronously, given an event type."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2794
msgid "Block all commands except power management."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2795
msgid "scsi device to quiesce."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2796
msgid ""
"This works by trying to transition to the SDEV_QUIESCE state (which must be "
"a legal transition).  When the device is in this state, only power "
"management requests will be accepted, all others will be deferred."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2801
#: ../drivers/scsi/scsi_lib.c:2853
msgid "Must be called with user context, may sleep."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2803
msgid "Returns zero if successful or an error if not."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2848
msgid "Restart user issued commands to a quiesced device."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2849
msgid "scsi device to resume."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2850
msgid "Moves the device from quiesced back to running and restarts the queues."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2926
msgid "try to transition to the SDEV_BLOCK state"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2927
#: ../drivers/scsi/scsi_lib.c:3129
msgid "device to block"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2928
msgid "Pause SCSI command processing on the specified device. Does not sleep."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2930
#: ../drivers/scsi/scsi_lib.c:2998 ../drivers/scsi/scsi_lib.c:3133
msgid "Returns zero if successful or a negative error code upon failure."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2933
msgid ""
"This routine transitions the device to the SDEV_BLOCK state (which must be a "
"legal transition). When the device is in this state, command processing is "
"paused until the device leaves the SDEV_BLOCK state. See also "
"scsi_internal_device_unblock_nowait()."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2992
msgid "resume a device after a block request"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2993
msgid "device to resume"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2995
msgid "``enum scsi_device_state new_state``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2994
msgid "state to set the device to after unblocking"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:2995
msgid ""
"Restart the device queue for a previously suspended SCSI device. Does not "
"sleep."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3001
msgid ""
"This routine transitions the device to the SDEV_RUNNING state or to one of "
"the offline states (which must be a legal transition) allowing the midlayer "
"to goose the queue for this device."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3081
msgid "transition all SCSI child devices to SDEV_BLOCK state"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3083
msgid "the Scsi_Host to which this device belongs"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3085
#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:272
#: ../../../driver-api/scsi:208: ../drivers/scsi/scsi_sysfs.c:1527
#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:210
#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:301
msgid "``struct device *dev``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3082
msgid "a parent device of one or more scsi_target devices"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3084
msgid ""
"Iterate over all children of **dev**, which should be scsi_target devices, "
"and switch all subordinate scsi devices to SDEV_BLOCK state. Wait for "
"ongoing scsi_queue_rq() calls to finish. May sleep."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3089
msgid "**dev** must not itself be a scsi_target device."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3128
msgid "Try to transition all logical units to the SDEV_BLOCK state"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3130
msgid ""
"Pause SCSI command processing for all logical units associated with the SCSI "
"host and wait until pending scsi_queue_rq() calls have finished."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3181
msgid "find and atomically map an sg-elemnt"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3187
msgid "``struct scatterlist *sgl``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3182
msgid "scatter-gather list"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3184
msgid "``int sg_count``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3183
msgid "number of segments in sg"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3185
msgid "``size_t *offset``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3184
msgid "offset in bytes into sg, on return offset into the mapped area"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3186
msgid "``size_t *len``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3185
msgid "bytes to map, on return number of bytes mapped"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3186
msgid "Returns virtual address of the start of the mapped page"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3230
msgid ""
"atomically unmap a virtual address, previously mapped with "
"scsi_kmap_atomic_sg"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3236
msgid "``void *virt``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3231
msgid "virtual address to be unmapped"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3326
msgid "return a unique device identification"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3327
#: ../drivers/scsi/scsi_lib.c:3456 ../../../driver-api/scsi:276:
#: ../drivers/scsi/scsi_transport_sas.c:423
msgid "SCSI device"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3329
msgid "``char *id``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3328
msgid "buffer for the identification"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3330
msgid "``size_t id_len``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3329
msgid "length of the buffer"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3330
msgid ""
"Copies a unique device identification into **id** based on the information "
"in the VPD page 0x83 of the device. The string will be formatted as a SCSI "
"name string."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3334
msgid ""
"Returns the length of the identification or error on failure. If the "
"identifier is longer than the supplied buffer the actual identifier length "
"is returned and the buffer is not zero-padded."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3455
msgid "return a target port group identifier"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3458
msgid "``int *rel_id``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3457
msgid "pointer to return relative target port in if not ``NULL``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3458
msgid ""
"Returns the Target Port Group identifier from the information from VPD page "
"0x83 of the device. Optionally sets **rel_id** to the relative target port "
"on success."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3463
msgid "the identifier or error on failure."
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3504
msgid "build sense data for a command"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3505
msgid "scsi command for which the sense should be formatted"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3507
#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:281
msgid "``int desc``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3506
#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:276
msgid "Sense format (non-zero == descriptor format, 0 == fixed format)"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3509
#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:280
msgid "``u8 key``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3508
#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:279
msgid "Sense key"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3510
#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:281
msgid "``u8 asc``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3509
#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:280
msgid "Additional sense code"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3511
#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:282
msgid "``u8 ascq``"
msgstr ""

#: ../../../driver-api/scsi:144: ../drivers/scsi/scsi_lib.c:3510
#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:281
msgid "Additional sense code qualifier"
msgstr ""

#: ../../../driver-api/scsi.rst:148
msgid "drivers/scsi/scsi_lib_dma.c"
msgstr ""

#: ../../../driver-api/scsi.rst:150
msgid ""
"SCSI library functions depending on DMA (map and unmap scatter-gather lists)."
msgstr ""

#: ../../../driver-api/scsi:153: ../drivers/scsi/scsi_lib_dma.c:17
msgid "perform DMA mapping against command's sg lists"
msgstr ""

#: ../../../driver-api/scsi:153: ../drivers/scsi/scsi_lib_dma.c:19
msgid ""
"Returns the number of sg lists actually used, zero if the sg lists is NULL, "
"or -ENOMEM if the mapping failed."
msgstr ""

#: ../../../driver-api/scsi:153: ../drivers/scsi/scsi_lib_dma.c:40
msgid "unmap command's sg lists mapped by scsi_dma_map"
msgstr ""

#: ../../../driver-api/scsi.rst:157
msgid "drivers/scsi/scsi_proc.c"
msgstr ""

#: ../../../driver-api/scsi.rst:159
msgid ""
"The functions in this file provide an interface between the PROC file system "
"and the SCSI device drivers It is mainly used for debugging, statistics and "
"to pass information directly to the lowlevel driver. I.E. plumbing to "
"manage /proc/scsi/\\*"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:51
msgid "(host template, SCSI proc dir) association"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:52
msgid "``entry``"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:53
msgid "entry in scsi_proc_list."
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:53
msgid "``sht``"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:54
msgid "SCSI host template associated with the procfs directory."
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:54
msgid "``proc_dir``"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:55
msgid "procfs directory associated with the SCSI host template."
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:55
msgid "``present``"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:56
msgid "Number of SCSI hosts instantiated for **sht**."
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:128
msgid "returns the procfs dir for a SCSI host template"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:134
#: ../drivers/scsi/scsi_proc.c:155 ../drivers/scsi/scsi_proc.c:199
#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:400
msgid "``const struct scsi_host_template *sht``"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:129
msgid "SCSI host template pointer."
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:149
msgid "Create directory in /proc for a scsi host"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:150
msgid "owner of this directory"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:151
msgid "Sets sht->proc_dir to the new directory."
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:193
msgid "remove directory in /proc for a scsi host"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:194
msgid "owner of directory"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:215
msgid "Add entry for this host to appropriate /proc dir"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:216
msgid "host to add"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:246
msgid "remove this host's entry from /proc"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:247
msgid "which host"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:266
msgid "return data about this host"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:267
msgid "A scsi device"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:268
msgid ":c:type:`struct seq_file <seq_file>` to output to."
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:270
msgid "prints Host, Channel, Id, Lun, Vendor, Model, Rev, Type, and revision."
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:324
msgid "Respond to user request to probe for/add device"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:330
#: ../drivers/scsi/scsi_proc.c:363
msgid "``uint host``"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:325
#: ../drivers/scsi/scsi_proc.c:326 ../drivers/scsi/scsi_proc.c:327
#: ../drivers/scsi/scsi_proc.c:328 ../drivers/scsi/scsi_proc.c:358
#: ../drivers/scsi/scsi_proc.c:359 ../drivers/scsi/scsi_proc.c:360
#: ../drivers/scsi/scsi_proc.c:361
msgid "user-supplied decimal integer"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:329
#: ../drivers/scsi/scsi_proc.c:362
msgid "``uint lun``"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:330
msgid "called by writing \"scsi add-single-device\" to /proc/scsi/scsi."
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:332
msgid ""
"does scsi_host_lookup() and either user_scan() if that transport type "
"supports it, or else scsi_scan_host_selected()"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:335
msgid "this seems to be aimed exclusively at SCSI parallel busses."
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:357
msgid "Respond to user request to remove a device"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:363
msgid ""
"called by writing \"scsi remove-single-device\" to /proc/scsi/scsi.  Does a "
"scsi_device_lookup() and scsi_remove_device()"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:387
msgid "handle writes to /proc/scsi/scsi"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:393
#: ../drivers/scsi/scsi_proc.c:526
msgid "``struct file *file``"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:388
#: ../drivers/scsi/scsi_proc.c:391 ../drivers/scsi/scsi_proc.c:524
msgid "not used"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:390
msgid "``const char __user *buf``"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:389
msgid "buffer to write"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:391
msgid "``size_t length``"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:390
msgid "length of buf, at most PAGE_SIZE"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:392
msgid "``loff_t *ppos``"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:393
msgid ""
"this provides a legacy mechanism to add or remove devices by Host, Channel, "
"ID, and Lun.  To use, \"echo 'scsi add-single-device 0 1 2 3' > /proc/scsi/"
"scsi\" or \"echo 'scsi remove-single-device 0 1 2 3' > /proc/scsi/scsi\" "
"with \"0 1 2 3\" replaced by the Host, Channel, Id, and Lun."
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:399
msgid ""
"this seems to be aimed at parallel SCSI. Most modern busses (USB, SATA, "
"Firewire, Fibre Channel, etc) dynamically assign these values to provide a "
"unique identifier and nothing more."
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:523
msgid "glue function"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:529
msgid "``struct inode *inode``"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:525
msgid "passed to single_open()"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:526
msgid "Associates proc_scsi_show with this file"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:547
msgid "create scsi and scsi/scsi in procfs"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:553
#: ../drivers/scsi/scsi_proc.c:576 ../../../driver-api/scsi:175:
#: ../drivers/scsi/scsi_netlink.c:113 ../drivers/scsi/scsi_netlink.c:138
#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:506
msgid "``void``"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:1
#: ../../../driver-api/scsi:175: ../drivers/scsi/scsi_netlink.c:1
#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:1
msgid "no arguments"
msgstr ""

#: ../../../driver-api/scsi:164: ../drivers/scsi/scsi_proc.c:570
msgid "Remove scsi/scsi and scsi from procfs"
msgstr ""

#: ../../../driver-api/scsi.rst:167
msgid "drivers/scsi/scsi_netlink.c"
msgstr ""

#: ../../../driver-api/scsi.rst:169
msgid ""
"Infrastructure to provide async events from transports to userspace via "
"netlink, using a single NETLINK_SCSITRANSPORT protocol for all transports. "
"See `the original patch submission <https://lore.kernel.org/linux-"
"scsi/1155070439.6275.5.camel@localhost.localdomain/>`__ for more details."
msgstr ""

#: ../../../driver-api/scsi:175: ../drivers/scsi/scsi_netlink.c:23
msgid "Receive message handler."
msgstr ""

#: ../../../driver-api/scsi:175: ../drivers/scsi/scsi_netlink.c:29
msgid "``struct sk_buff *skb``"
msgstr ""

#: ../../../driver-api/scsi:175: ../drivers/scsi/scsi_netlink.c:24
msgid "socket receive buffer"
msgstr ""

#: ../../../driver-api/scsi:175: ../drivers/scsi/scsi_netlink.c:26
msgid "Extracts message from a receive buffer."
msgstr ""

#: ../../../driver-api/scsi:175: ../drivers/scsi/scsi_netlink.c:27
msgid ""
"Validates message header and calls appropriate transport message handler"
msgstr ""

#: ../../../driver-api/scsi:175: ../drivers/scsi/scsi_netlink.c:107
msgid ""
"Called by SCSI subsystem to initialize the SCSI transport netlink interface"
msgstr ""

#: ../../../driver-api/scsi:175: ../drivers/scsi/scsi_netlink.c:132
msgid ""
"Called by SCSI subsystem to disable the SCSI transport netlink interface"
msgstr ""

#: ../../../driver-api/scsi.rst:179
msgid "drivers/scsi/scsi_scan.c"
msgstr ""

#: ../../../driver-api/scsi.rst:181
msgid ""
"Scan a host to determine which (if any) devices are attached. The general "
"scanning/probing algorithm is as follows, exceptions are made to it "
"depending on device specific flags, compilation options, and global variable "
"(boot or module load time) settings. A specific LUN is scanned via an "
"INQUIRY command; if the LUN has a device attached, a scsi_device is "
"allocated and setup for it. For every id of every channel on the given host, "
"start by scanning LUN 0. Skip hosts that don't respond at all to a scan of "
"LUN 0. Otherwise, if LUN 0 has a device attached, allocate and setup a "
"scsi_device for it. If target is SCSI-3 or up, issue a REPORT LUN, and scan "
"all of the LUNs returned by the REPORT LUN; else, sequentially scan LUNs up "
"until some maximum is reached, or a LUN is seen that cannot have a device "
"attached to it."
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:607
msgid "remove non-graphical chars from an INQUIRY result string"
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:613
msgid "``unsigned char *s``"
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:609
msgid "INQUIRY result string to sanitize"
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:610
msgid "length of the string"
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:612
msgid ""
"The SCSI spec says that INQUIRY vendor, product, and revision strings must "
"consist entirely of graphic ASCII characters, padded on the right with "
"spaces.  Since not all devices obey this rule, we will replace non-graphic "
"or non-ASCII characters with spaces.  Exception: a NUL character is "
"interpreted as a string terminator, so all the following characters are set "
"to spaces."
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:1654
msgid "creates a new SCSI (LU) instance"
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:1660
msgid "``struct Scsi_Host *host``"
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:1655
msgid "the :c:type:`Scsi_Host` instance where the device is located"
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:1656
msgid "target channel number (rarely other than ``0``)"
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:1658
msgid "``uint target``"
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:1657
msgid "target id number"
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:1658
msgid "LUN of target device"
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:1659
msgid "Probe for a specific LUN and add it if found."
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:1662
msgid ""
"This call is usually performed internally during a SCSI bus scan when an HBA "
"is added (i.e. scsi_scan_host()). So it should only be called if the HBA "
"becomes aware of a new SCSI device (LU) after scsi_scan_host() has "
"completed. If successful this call can lead to sdev_init() and "
"sdev_configure() callbacks into the LLD."
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:1669
msgid "``0`` on success or negative error code on failure"
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:1812
msgid "scan a target id, possibly including all LUNs on the target."
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:1818
#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:705
#: ../drivers/scsi/scsi_transport_sas.c:900
#: ../drivers/scsi/scsi_transport_sas.c:945
msgid "``struct device *parent``"
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:1813
msgid "host to scan"
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:1815
msgid "``unsigned int channel``"
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:1814
msgid "channel to scan"
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:1816
msgid "``unsigned int id``"
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:1815
msgid "target id to scan"
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:1816
msgid "Specific LUN to scan or SCAN_WILD_CARD"
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:1818
msgid "``enum scsi_scan_mode rescan``"
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:1817
msgid ""
"passed to LUN scanning routines; SCSI_SCAN_INITIAL for no rescan, "
"SCSI_SCAN_RESCAN to rescan existing LUNs, and SCSI_SCAN_MANUAL to force "
"scanning even if 'scan=manual' is set."
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:1822
msgid ""
"Scan the target id on **parent**, **channel**, and **id**. Scan at least LUN "
"0, and possibly all LUNs on the target id."
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:1825
msgid ""
"First try a REPORT LUN scan, if that does not scan the target, do a "
"sequential scan of LUNs on the target id."
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:2060
msgid "scan the given adapter"
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:2061
msgid "adapter to scan"
msgstr ""

#: ../../../driver-api/scsi:194: ../drivers/scsi/scsi_scan.c:2063
msgid "Should be called after scsi_add_host()"
msgstr ""

#: ../../../driver-api/scsi.rst:198
msgid "drivers/scsi/scsi_sysctl.c"
msgstr ""

#: ../../../driver-api/scsi.rst:200
msgid ""
"Set up the sysctl entry: \"/dev/scsi/"
"logging_level\" (DEV_SCSI_LOGGING_LEVEL) which sets/returns "
"scsi_logging_level."
msgstr ""

#: ../../../driver-api/scsi.rst:204
msgid "drivers/scsi/scsi_sysfs.c"
msgstr ""

#: ../../../driver-api/scsi.rst:206
msgid "SCSI sysfs interface routines."
msgstr ""

#: ../../../driver-api/scsi:208: ../drivers/scsi/scsi_sysfs.c:1476
msgid "unregister a device from the scsi bus"
msgstr ""

#: ../../../driver-api/scsi:208: ../drivers/scsi/scsi_sysfs.c:1477
msgid "scsi_device to unregister"
msgstr ""

#: ../../../driver-api/scsi:208: ../drivers/scsi/scsi_sysfs.c:1521
msgid "try to remove a target and all its devices"
msgstr ""

#: ../../../driver-api/scsi:208: ../drivers/scsi/scsi_sysfs.c:1522
msgid "generic starget or parent of generic stargets to be removed"
msgstr ""

#: ../../../driver-api/scsi:208: ../drivers/scsi/scsi_sysfs.c:1524
msgid ""
"This is slightly racy.  It is possible that if the user requests the "
"addition of another device then the target won't be removed."
msgstr ""

#: ../../../driver-api/scsi.rst:212
msgid "drivers/scsi/hosts.c"
msgstr ""

#: ../../../driver-api/scsi.rst:214
msgid "mid to lowlevel SCSI driver interface"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:162
msgid "remove a scsi host"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:163
msgid "a pointer to a scsi host to remove"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:207
msgid "add a scsi host with dma device"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:208
msgid "scsi host pointer to add"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:209
msgid "a struct device of type scsi class"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:211
msgid "``struct device *dma_dev``"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:210
msgid "dma device for the host"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:212
msgid ""
"You rarely need to worry about this unless you're in a virtualised host "
"environments, so use the simpler scsi_add_host() function instead."
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:217
msgid "0 on success / != 0 for error"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:394
msgid "register a scsi host adapter instance."
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:395
msgid "pointer to scsi host template"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:397
msgid "``int privsize``"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:396
msgid "extra bytes to allocate for driver"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:398
msgid ""
"Allocate a new Scsi_Host and perform basic initialization. The host is not "
"published to the scsi midlayer until scsi_add_host is called."
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:403
msgid "Pointer to a new Scsi_Host"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:572
msgid "get a reference to a Scsi_Host by host no"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:578
msgid "``unsigned int hostnum``"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:573
msgid "host number to locate"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:575
msgid "A pointer to located Scsi_Host or NULL."
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:577
msgid ""
"The caller must do a scsi_host_put() to drop the reference that "
"scsi_host_get() took. The put_device() below dropped the reference from "
"class_find_device()."
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:598
msgid "inc a Scsi_Host ref count"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:599
msgid "Pointer to Scsi_Host to inc."
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:622
msgid "Return the count of in-flight commands"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:623
msgid "Pointer to Scsi_Host"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:637
msgid "dec a Scsi_Host ref count"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:638
msgid "Pointer to Scsi_Host to dec."
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:664
msgid "Queue work to the Scsi_Host workqueue."
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:665
#: ../drivers/scsi/hosts.c:690 ../drivers/scsi/hosts.c:751
msgid "Pointer to Scsi_Host."
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:667
msgid "``struct work_struct *work``"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:666
msgid "Work to queue for execution."
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:668
msgid ""
"1 - work queued for execution 0 - work is already queued -EINVAL - work "
"queue doesn't exist"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:689
msgid "Flush a Scsi_Host's workqueue."
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:719
msgid "Terminate all running commands"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:720
msgid "Scsi Host on which commands should be terminated"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:722
msgid "``enum scsi_host_status status``"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:721
msgid "Status to be set for the terminated commands"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:722
msgid ""
"There is no protection against modification of the number of outstanding "
"commands. It is the responsibility of the caller to ensure that concurrent I/"
"O submission and/or completion is stopped when calling this function."
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:750
msgid "Iterate over all busy commands"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:753
msgid "``bool (*fn)(struct scsi_cmnd *, void *)``"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:752
msgid "Function to call on each busy command"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:754
msgid "``void *priv``"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:753
msgid "Data pointer passed to **fn**"
msgstr ""

#: ../../../driver-api/scsi:216: ../drivers/scsi/hosts.c:754
msgid ""
"If locking against concurrent command completions is required ithas to be "
"provided by the caller"
msgstr ""

#: ../../../driver-api/scsi.rst:220
msgid "drivers/scsi/scsi_common.c"
msgstr ""

#: ../../../driver-api/scsi.rst:222
msgid "general support functions"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:53
msgid "Return 17-char string indicating device type."
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:59
msgid "``unsigned type``"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:54
msgid "type number to look up"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:111
msgid "convert a scsi_lun to an int"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:117
#: ../drivers/scsi/scsi_common.c:147
msgid "``struct scsi_lun *scsilun``"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:112
msgid "struct scsi_lun to be converted."
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:114
msgid ""
"Convert **scsilun** from a struct scsi_lun to a four-byte host byte-ordered "
"integer, and return the result. The caller must check for truncation before "
"using this function."
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:119
msgid ""
"For a description of the LUN format, post SCSI-3 see the SCSI Architecture "
"Model, for SCSI-3 see the SCSI Controller Commands."
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:122
msgid ""
"Given a struct scsi_lun of: d2 04 0b 03 00 00 00 00, this function returns "
"the integer: 0x0b03d204"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:125
msgid ""
"This encoding will return a standard integer LUN for LUNs smaller than 256, "
"which typically use a single level LUN structure with addressing method 0."
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:144
msgid "reverts an int into a scsi_lun"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:145
msgid "integer to be reverted"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:146
msgid "struct scsi_lun to be set."
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:148
msgid ""
"Reverts the functionality of the scsilun_to_int, which packed an 8-byte lun "
"value into an int. This routine unpacks the int back into the lun value."
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:153
msgid ""
"Given an integer : 0x0b03d204, this function returns a struct scsi_lun of: "
"d2 04 0b 03 00 00 00 00"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:173
msgid ""
"normalize main elements from either fixed or descriptor sense data format "
"into a common format."
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:176
msgid "byte array containing sense data returned by device"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:178
msgid "pointer to instance of structure that common elements are written to."
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:181
msgid ""
"The \"main elements\" from sense data are: response_code, sense_key, asc, "
"ascq and additional_length (only for descriptor format)."
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:184
msgid ""
"Typically this function can be called after a device has responded to a SCSI "
"command with the CHECK_CONDITION status."
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:188
msgid "true if valid sense data information found, else false;"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:236
msgid "search for a given descriptor type in descriptor sense data format."
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:242
msgid "``const u8 * sense_buffer``"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:237
msgid "byte array of descriptor format sense data"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:240
msgid "``int desc_type``"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:239
msgid "value of descriptor type to find (e.g. 0 -> information)"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:242
msgid "only valid when sense data is in descriptor format"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:245
msgid "pointer to start of (first) descriptor if found else NULL"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:275
msgid "build sense data in a buffer"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:279
#: ../drivers/scsi/scsi_common.c:309 ../drivers/scsi/scsi_common.c:357
msgid "``u8 *buf``"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:278
#: ../drivers/scsi/scsi_common.c:305 ../drivers/scsi/scsi_common.c:353
msgid "Where to build sense data"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:303
msgid "set the information field in a formatted sense data buffer"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:306
#: ../drivers/scsi/scsi_common.c:354
msgid "buffer length"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:308
msgid "``u64 info``"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:307
msgid "64-bit information value to be set"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:309
#: ../drivers/scsi/scsi_common.c:359
msgid "0 on success or -EINVAL for invalid sense buffer length"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:351
msgid ""
"set the field pointer sense key specific information in a formatted sense "
"data buffer"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:356
msgid "``u16 fp``"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:355
msgid "field pointer to be set"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:357
msgid "``u8 bp``"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:356
msgid "bit pointer to be set"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:358
msgid "``bool cd``"
msgstr ""

#: ../../../driver-api/scsi:224: ../drivers/scsi/scsi_common.c:357
msgid "command/data bit"
msgstr ""

#: ../../../driver-api/scsi.rst:228
msgid "Transport classes"
msgstr ""

#: ../../../driver-api/scsi.rst:230
msgid ""
"Transport classes are service libraries for drivers in the SCSI lower layer, "
"which expose transport attributes in sysfs."
msgstr ""

#: ../../../driver-api/scsi.rst:234
msgid "Fibre Channel transport"
msgstr ""

#: ../../../driver-api/scsi.rst:236
msgid ""
"The file drivers/scsi/scsi_transport_fc.c defines transport attributes for "
"Fibre Channel."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:500
msgid "Obtain the next sequential FC event number"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:502
msgid ""
"We could have inlined this, but it would have required fc_event_seq to be "
"exposed. For now, live with the subroutine call. Atomic used to avoid lock/"
"unlock..."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:515
msgid "routine to do the work of posting an event on an fc_host."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:517
#: ../drivers/scsi/scsi_transport_fc.c:594
#: ../drivers/scsi/scsi_transport_fc.c:615
msgid "host the event occurred on"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:519
#: ../drivers/scsi/scsi_transport_fc.c:596
#: ../drivers/scsi/scsi_transport_fc.c:617
msgid "``u32 event_number``"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:518
#: ../drivers/scsi/scsi_transport_fc.c:595
#: ../drivers/scsi/scsi_transport_fc.c:616
msgid "fc event number obtained from get_fc_event_number()"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:520
#: ../drivers/scsi/scsi_transport_fc.c:597
msgid "``enum fc_host_event_code event_code``"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:519
#: ../drivers/scsi/scsi_transport_fc.c:596
msgid "fc_host event being posted"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:521
#: ../drivers/scsi/scsi_transport_fc.c:618
msgid "``u32 data_len``"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:520
msgid "amount, in bytes, of event data"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:522
msgid "``char *data_buf``"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:521
msgid "pointer to event data"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:523
#: ../drivers/scsi/scsi_transport_fc.c:620
msgid "``u64 vendor_id``"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:522
msgid "value for Vendor id"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:524
#: ../drivers/scsi/scsi_transport_fc.c:599
#: ../drivers/scsi/scsi_transport_fc.c:621
#: ../drivers/scsi/scsi_transport_fc.c:638
#: ../drivers/scsi/scsi_transport_fc.c:888
#: ../drivers/scsi/scsi_transport_fc.c:2522
#: ../drivers/scsi/scsi_transport_fc.c:2866
#: ../drivers/scsi/scsi_transport_fc.c:3181
#: ../drivers/scsi/scsi_transport_fc.c:3416
#: ../drivers/scsi/scsi_transport_fc.c:3492
#: ../drivers/scsi/scsi_transport_fc.c:3956
#: ../drivers/scsi/scsi_transport_fc.c:3979
msgid "This routine assumes no locks are held on entry."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:593
msgid "called to post an even on an fc_host."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:598
msgid "``u32 event_data``"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:597
msgid "32bits of data for the event being posted"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:613
msgid "called to post a vendor unique event on an fc_host"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:617
msgid "amount, in bytes, of vendor unique data"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:619
msgid "``char * data_buf``"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:618
msgid "pointer to vendor unique data"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:619
msgid "Vendor id"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:634
msgid "find the fc_rport pointer for a given wwpn"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:635
msgid "host the fc_rport is associated with"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:637
msgid "``u64 wwpn``"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:636
msgid "wwpn of the fc_rport device"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:883
msgid "routine to process a received FPIN."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:884
msgid "host the FPIN was received on"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:886
msgid "``u32 fpin_len``"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:885
msgid "length of FPIN payload, in bytes"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:887
msgid "``char *fpin_buf``"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:886
msgid "pointer to FPIN payload"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:888
msgid "``u8 event_acknowledge``"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:887
msgid "1, if LLDD handles this event."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:2504
msgid "FC Transport I/O timeout intercept handler"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:2505
msgid "The SCSI command which timed out"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:2506
msgid ""
"This routine protects against error handlers getting invoked while a rport "
"is in a blocked state, typically due to a temporarily loss of connectivity. "
"If the error handlers are allowed to proceed, requests to abort i/o, reset "
"the target, etc will likely fail as there is no way to communicate with the "
"device to perform the requested function. These failures may result in the "
"midlayer taking the device offline, requiring manual intervention to restore "
"operation."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:2514
msgid ""
"This routine, called whenever an i/o times out, validates the state of the "
"underlying rport. If the rport is blocked, it returns EH_RESET_TIMER, which "
"will continue to reschedule the timeout. Eventually, either the device will "
"return, or devloss_tmo will fire, and when the timeout then fires, it will "
"be handled normally. If the rport is not blocked, normal error handling "
"continues."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:2855
msgid "called to terminate any fc_transport-related elements for a scsi host."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:2856
msgid "Which :c:type:`Scsi_Host`"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:2857
msgid ""
"This routine is expected to be called immediately preceding the a driver's "
"call to scsi_remove_host()."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:2860
msgid "WARNING: A driver utilizing the fc_transport, which fails to call"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:2861
msgid ""
"this routine prior to scsi_remove_host(), will leave dangling objects in /"
"sys/class/fc_remote_ports. Access to any of these objects can result in a "
"system crash !!!"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3147
msgid "notify fc transport of the existence of a remote FC port."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3148
#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:690
msgid "scsi host the remote port is connected to."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3149
msgid "Channel on shost port connected to."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3151
msgid "``struct fc_rport_identifiers *ids``"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3150
msgid ""
"The world wide names, fc address, and FC4 port roles for the remote port."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3152
msgid ""
"The LLDD calls this routine to notify the transport of the existence of a "
"remote port. The LLDD provides the unique identifiers (wwpn,wwn) of the "
"port, it's FC address (port_id), and the FC4 roles that are active for the "
"port."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3157
msgid ""
"For ports that are FCP targets (aka scsi targets), the FC transport "
"maintains consistent target id bindings on behalf of the LLDD. A consistent "
"target id binding is an assignment of a target id to a remote port "
"identifier, which persists while the scsi host is attached. The remote port "
"can disappear, then later reappear, and it's target id assignment remains "
"the same. This allows for shifts in FC addressing (if binding by wwpn or "
"wwnn) with no apparent changes to the scsi subsystem which is based on scsi "
"host number and target id values.  Bindings are only valid during the "
"attachment of the scsi host. If the host detaches, then later re-attaches, "
"target id bindings may change."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3169
msgid ""
"This routine is responsible for returning a remote port structure. The "
"routine will search the list of remote ports it maintains internally on "
"behalf of consistent target id mappings. If found, the remote port structure "
"will be reused. Otherwise, a new remote port structure will be allocated."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3175
msgid ""
"Whenever a remote port is allocated, a new fc_remote_port class device is "
"created."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3178
#: ../drivers/scsi/scsi_transport_fc.c:3490
msgid "Should not be called from interrupt context."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3368
msgid "notifies the fc transport that a remote port is no longer in existence."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3374
#: ../drivers/scsi/scsi_transport_fc.c:3482
#: ../drivers/scsi/scsi_transport_fc.c:3745
msgid "``struct fc_rport *rport``"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3369
msgid "The remote port that no longer exists"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3370
msgid ""
"The LLDD calls this routine to notify the transport that a remote port is no "
"longer part of the topology. Note: Although a port may no longer be part of "
"the topology, it may persist in the remote ports displayed by the fc_host. "
"We do this under 2 conditions:"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3375
msgid ""
"If the port was a scsi target, we delay its deletion by \"blocking\" it. "
"This allows the port to temporarily disappear, then reappear without "
"disrupting the SCSI device tree attached to it. During the \"blocked\" "
"period the port will still exist."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3380
msgid ""
"If the port was a scsi target and disappears for longer than we expect, "
"we'll delete the port and the tear down the SCSI device tree attached to it. "
"However, we want to semi-persist the target id assigned to that port if it "
"eventually does exist. The port structure will remain (although with minimal "
"information) so that the target id bindings also remain."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3387
msgid ""
"If the remote port is not an FCP Target, it will be fully torn down and "
"deallocated, including the fc_remote_port class device."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3390
msgid ""
"If the remote port is an FCP Target, the port will be placed in a temporary "
"blocked state. From the LLDD's perspective, the rport no longer exists. From "
"the SCSI midlayer's perspective, the SCSI target exists, but all sdevs on it "
"are blocked from further I/O. The following is then expected."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3396
msgid ""
"If the remote port does not return (signaled by a LLDD call to "
"fc_remote_port_add()) within the dev_loss_tmo timeout, then the scsi target "
"is removed - killing all outstanding i/o and removing the scsi devices "
"attached to it. The port structure will be marked Not Present and be "
"partially cleared, leaving only enough information to recognize the remote "
"port relative to the scsi target id binding if it later appears.  The port "
"will remain as long as there is a valid binding (e.g. until the user changes "
"the binding type or unloads the scsi host with the binding)."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3406
msgid ""
"If the remote port returns within the dev_loss_tmo value (and matches "
"according to the target id binding type), the port structure will be reused. "
"If it is no longer a SCSI target, the target will be torn down. If it "
"continues to be a SCSI target, then the target will be unblocked (allowing i/"
"o to be resumed), and a scan will be activated to ensure that all luns are "
"detected."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3413
msgid ""
"Called from normal process context only - cannot be called from interrupt."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3476
msgid "notifies the fc transport that the roles on a remote may have changed."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3477
msgid "The remote port that changed."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3479
msgid "``u32 roles``"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3478
msgid "New roles for this port."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3480
msgid ""
"The LLDD calls this routine to notify the transport that the roles on a "
"remote port may have changed. The largest effect of this is if a port now "
"becomes a FCP Target, it must be allocated a scsi target id.  If the port is "
"no longer a FCP target, any scsi target id value assigned to it will persist "
"in case the role changes back to include FCP Target. No changes in the scsi "
"midlayer will be invoked if the role changes (in the expectation that the "
"role will be resumed. If it doesn't normal error processing will take place)."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3739
msgid "Block SCSI eh thread for blocked fc_rport."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3740
msgid "Remote port that scsi_eh is trying to recover."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3741
#: ../drivers/scsi/scsi_transport_fc.c:3776
msgid ""
"This routine can be called from a FC LLD scsi_eh callback. It blocks the "
"scsi_eh thread until the fc_rport leaves the FC_PORTSTATE_BLOCKED, or the "
"fast_io_fail_tmo fires. This is necessary to avoid the scsi_eh failing "
"recovery actions for blocked rports which would lead to offlined SCSI "
"devices."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3748
#: ../drivers/scsi/scsi_transport_fc.c:3783
msgid ""
"0 if the fc_rport left the state FC_PORTSTATE_BLOCKED. FAST_IO_FAIL if the "
"fast_io_fail_tmo fired, this should be passed back to scsi_eh."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3774
msgid "Block SCSI eh thread for blocked fc_rport"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3780
msgid "``struct scsi_cmnd *cmnd``"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3775
msgid "SCSI command that scsi_eh is trying to recover"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3950
msgid "Admin App or LLDD requests creation of a vport"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3951
msgid "scsi host the virtual port is connected to."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3952
msgid "channel on shost port connected to."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3954
msgid "``struct fc_vport_identifiers *ids``"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3953
msgid "The world wide names, FC4 port roles, etc for the virtual port."
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3973
msgid "Admin App or LLDD requests termination of a vport"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3979
msgid "``struct fc_vport *vport``"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3974
msgid "fc_vport to be terminated"
msgstr ""

#: ../../../driver-api/scsi:239: ../drivers/scsi/scsi_transport_fc.c:3975
msgid ""
"Calls the LLDD vport_delete() function, then deallocates and removes the "
"vport from the shost and object tree."
msgstr ""

#: ../../../driver-api/scsi.rst:243
msgid "iSCSI transport class"
msgstr ""

#: ../../../driver-api/scsi.rst:245
msgid ""
"The file drivers/scsi/scsi_transport_iscsi.c defines transport attributes "
"for the iSCSI class, which sends SCSI packets over TCP/IP connections."
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:274
msgid "get ep from handle"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:280
msgid "``u64 handle``"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:275
msgid "endpoint handle"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:276
msgid "Caller must do a iscsi_put_endpoint."
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1221
msgid "Add flashnode session entry in sysfs"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1222
#: ../drivers/scsi/scsi_transport_iscsi.c:1270
#: ../drivers/scsi/scsi_transport_iscsi.c:1380
#: ../drivers/scsi/scsi_transport_iscsi.c:1458
msgid "pointer to host data"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1224
msgid "``int index``"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1223
msgid "index of flashnode to add in sysfs"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1225
#: ../drivers/scsi/scsi_transport_iscsi.c:1273
msgid "``struct iscsi_transport *transport``"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1224
#: ../drivers/scsi/scsi_transport_iscsi.c:1272
msgid "pointer to transport data"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1226
#: ../drivers/scsi/scsi_transport_iscsi.c:1274
#: ../drivers/scsi/scsi_transport_iscsi.c:2405
msgid "``int dd_size``"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1225
#: ../drivers/scsi/scsi_transport_iscsi.c:1273
msgid "total size to allocate"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1226
msgid "Adds a sysfs entry for the flashnode session attributes"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1229
msgid "pointer to allocated flashnode sess on success ``NULL`` on failure"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1269
msgid "Add flashnode conn entry in sysfs"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1272
#: ../drivers/scsi/scsi_transport_iscsi.c:1406
#: ../drivers/scsi/scsi_transport_iscsi.c:1433
msgid "``struct iscsi_bus_flash_session *fnode_sess``"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1271
msgid "pointer to the parent flashnode session entry"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1274
msgid "Adds a sysfs entry for the flashnode connection attributes"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1277
msgid "pointer to allocated flashnode conn on success ``NULL`` on failure"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1379
msgid "finds flashnode session entry"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1382
msgid "``const void *data``"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1381
msgid "pointer to data containing value to use for comparison"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1383
msgid "``device_match_t fn``"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1382
msgid "function pointer that does actual comparison"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1383
msgid ""
"Finds the flashnode session object comparing the data passed using logic "
"defined in passed function pointer"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1387
msgid ""
"pointer to found flashnode session device object on success ``NULL`` on "
"failure"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1400
msgid "finds flashnode connection entry"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1401
msgid "pointer to parent flashnode session entry"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1402
msgid ""
"Finds the flashnode connection object comparing the data passed using logic "
"defined in passed function pointer"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1406
msgid ""
"pointer to found flashnode connection device object on success ``NULL`` on "
"failure"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1427
msgid "destroy flashnode session entry"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1428
msgid "pointer to flashnode session entry to be destroyed"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1429
msgid ""
"Deletes the flashnode session entry and all children flashnode connection "
"entries from sysfs"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1457
msgid "destroy all flashnode session entries"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1459
msgid ""
"Destroys all the flashnode session entries and all corresponding children "
"flashnode connection entries from sysfs"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1841
msgid "block scsi eh until session state has transistioned"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1842
msgid "scsi cmd passed to scsi eh handler"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1843
msgid ""
"If the session is down this function will wait for the recovery timer to "
"fire or for the session to be logged back in. If the recovery timer fires "
"then FAST_IO_FAIL is returned. The caller should pass this error value to "
"the scsi eh."
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1922
msgid "set a session as logged in and start IO."
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1928
#: ../drivers/scsi/scsi_transport_iscsi.c:2369
#: ../drivers/scsi/scsi_transport_iscsi.c:2408
#: ../drivers/scsi/scsi_transport_iscsi.c:2860
msgid "``struct iscsi_cls_session *session``"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1923
msgid "iscsi session"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:1924
msgid "Mark a session as ready to accept IO."
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:2363
msgid "destroy a session from the kernel"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:2364
msgid "session to destroy"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:2365
msgid ""
"Force the destruction of a session from the kernel. This should only be used "
"when userspace is no longer running during system shutdown."
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:2402
msgid "alloc iscsi class connection"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:2403
msgid "iscsi cls session"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:2404
msgid "private driver data size"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:2406
msgid "``uint32_t cid``"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:2405
msgid "connection id"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:2445
msgid "add iscsi class connection"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:2451
#: ../drivers/scsi/scsi_transport_iscsi.c:2486
msgid "``struct iscsi_cls_conn *conn``"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:2446
#: ../drivers/scsi/scsi_transport_iscsi.c:2481
msgid "iscsi cls connection"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:2447
msgid ""
"This will expose iscsi_cls_conn to sysfs so make sure the related resources "
"for sysfs attributes are initialized before calling this."
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:2480
msgid "remove iscsi class connection from sysfs"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:2482
msgid ""
"Remove iscsi_cls_conn from sysfs, and wait for previous read/write of "
"iscsi_cls_conn's attributes in sysfs to finish."
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:2854
msgid "send session destr. completion event"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:2855
msgid "iscsi class session"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:2857
msgid "``enum iscsi_uevent_e event``"
msgstr ""

#: ../../../driver-api/scsi:249: ../drivers/scsi/scsi_transport_iscsi.c:2856
msgid "type of event"
msgstr ""

#: ../../../driver-api/scsi.rst:253
msgid "Serial Attached SCSI (SAS) transport class"
msgstr ""

#: ../../../driver-api/scsi.rst:255
msgid ""
"The file drivers/scsi/scsi_transport_sas.c defines transport attributes for "
"Serial Attached SCSI, a variant of SATA aimed at large high-end systems."
msgstr ""

#: ../../../driver-api/scsi.rst:259
msgid ""
"The SAS transport class contains common code to deal with SAS HBAs, an "
"approximated representation of SAS topologies in the driver model, and "
"various sysfs attributes to expose these topologies and management "
"interfaces to userspace."
msgstr ""

#: ../../../driver-api/scsi.rst:264
msgid ""
"In addition to the basic SCSI core objects this transport class introduces "
"two additional intermediate objects: The SAS PHY as represented by struct "
"sas_phy defines an \"outgoing\" PHY on a SAS HBA or Expander, and the SAS "
"remote PHY represented by struct sas_rphy defines an \"incoming\" PHY on a "
"SAS Expander or end device. Note that this is purely a software concept, the "
"underlying hardware for a PHY and a remote PHY is the exactly the same."
msgstr ""

#: ../../../driver-api/scsi.rst:272
msgid ""
"There is no concept of a SAS port in this code, users can see what PHYs form "
"a wide port based on the port_identifier attribute, which is the same for "
"all PHYs in a port."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:295
msgid "tear down a devices SAS data structures"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:296
msgid "device belonging to the sas object"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:297
msgid "Removes all SAS PHYs and remote PHYs for a given object"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:308
msgid "tear down a Scsi_Host's SAS data structures"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:309
#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:774
msgid "Scsi Host that is torn down"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:310
msgid ""
"Removes all SAS PHYs and remote PHYs for a given Scsi_Host and remove the "
"Scsi_Host as well."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:314
msgid ""
"Do not call scsi_remove_host() on the Scsi_Host any more, as it is already "
"removed."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:325
msgid "return the SAS address of the device"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:326
msgid "scsi device"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:327
msgid "Returns the SAS address of the scsi device"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:339
msgid "checking TLR bit in vpd 0x90"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:340
#: ../drivers/scsi/scsi_transport_sas.c:378
#: ../drivers/scsi/scsi_transport_sas.c:394
msgid "scsi device struct"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:341
msgid ""
"Check Transport Layer Retries are supported or not. If vpd page 0x90 is "
"present, TRL is supported."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:377
#: ../drivers/scsi/scsi_transport_sas.c:393
msgid "setting TLR flags"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:379
msgid "Seting tlr_enabled flag to 0."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:395
msgid "Seting tlr_enabled flag 1."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:422
msgid "Check for ATA NCQ command priority support"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:424
msgid ""
"Check if an ATA device supports NCQ priority using VPD page 89h (ATA "
"Information). Since this VPD page is implemented only for ATA devices, this "
"function always returns false for SCSI devices."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:699
msgid "allocates and initialize a SAS PHY structure"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:700
msgid "Parent device"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:702
msgid "``int number``"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:701
msgid "Phy index"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:702
msgid ""
"Allocates an SAS PHY structure.  It will be added in the device tree below "
"the device specified by **parent**, which has to be either a Scsi_Host or "
"sas_rphy."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:707
#: ../drivers/scsi/scsi_transport_sas.c:1462
#: ../drivers/scsi/scsi_transport_sas.c:1501
msgid "SAS PHY allocated or ``NULL`` if the allocation failed."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:740
msgid "add a SAS PHY to the device hierarchy"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:746
#: ../drivers/scsi/scsi_transport_sas.c:771
#: ../drivers/scsi/scsi_transport_sas.c:788
#: ../drivers/scsi/scsi_transport_sas.c:1092
#: ../drivers/scsi/scsi_transport_sas.c:1130
msgid "``struct sas_phy *phy``"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:741
msgid "The PHY to be added"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:742
msgid "Publishes a SAS PHY to the rest of the system."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:765
msgid "free a SAS PHY"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:766
msgid "SAS PHY to free"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:767
msgid "Frees the specified SAS PHY."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:770
msgid ""
"This function must only be called on a PHY that has not successfully been "
"added using sas_phy_add()."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:782
msgid "remove SAS PHY"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:783
msgid "SAS PHY to remove"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:784
msgid ""
"Removes the specified SAS PHY.  If the SAS PHY has an associated remote PHY "
"it is removed before."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:804
msgid "check if a struct device represents a SAS PHY"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:810
#: ../drivers/scsi/scsi_transport_sas.c:1059
#: ../drivers/scsi/scsi_transport_sas.c:1681
msgid "``const struct device *dev``"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:805
#: ../drivers/scsi/scsi_transport_sas.c:1054
#: ../drivers/scsi/scsi_transport_sas.c:1676
msgid "device to check"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:807
msgid "``1`` if the device represents a SAS PHY, ``0`` else"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:894
#: ../drivers/scsi/scsi_transport_sas.c:939
msgid "allocate and initialize a SAS port structure"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:896
#: ../drivers/scsi/scsi_transport_sas.c:941
msgid "parent device"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:898
msgid "``int port_id``"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:897
msgid "port number"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:898
msgid ""
"Allocates a SAS port structure.  It will be added to the device tree below "
"the device specified by **parent** which must be either a Scsi_Host or a "
"sas_expander_device."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:903
#: ../drivers/scsi/scsi_transport_sas.c:949
msgid "``NULL`` on error"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:942
msgid ""
"Allocates a SAS port structure and a number to go with it.  This interface "
"is really for adapters where the port number has no meansing, so the sas "
"class should manage them.  It will be added to the device tree below the "
"device specified by **parent** which must be either a Scsi_Host or a "
"sas_expander_device."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:972
msgid "add a SAS port to the device hierarchy"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:978
#: ../drivers/scsi/scsi_transport_sas.c:1003
#: ../drivers/scsi/scsi_transport_sas.c:1020
#: ../drivers/scsi/scsi_transport_sas.c:1072
#: ../drivers/scsi/scsi_transport_sas.c:1095
#: ../drivers/scsi/scsi_transport_sas.c:1133
msgid "``struct sas_port *port``"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:973
msgid "port to be added"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:974
msgid "publishes a port to the rest of the system"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:997
msgid "free a SAS PORT"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:998
msgid "SAS PORT to free"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:999
msgid "Frees the specified SAS PORT."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1002
msgid ""
"This function must only be called on a PORT that has not successfully been "
"added using sas_port_add()."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1014
msgid "remove SAS PORT"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1015
msgid "SAS PORT to remove"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1016
msgid ""
"Removes the specified SAS PORT.  If the SAS PORT has an associated phys, "
"unlink them from the port as well."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1053
msgid "check if a struct device represents a SAS port"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1056
msgid "``1`` if the device represents a SAS Port, ``0`` else"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1066
msgid "try to take a reference on a port member"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1067
msgid "port to check"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1089
msgid "add another phy to a port to form a wide port"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1090
msgid "port to add the phy to"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1091
msgid "phy to add"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1092
msgid ""
"When a port is initially created, it is empty (has no phys).  All ports must "
"have at least one phy to operated, and all wide ports must have at least "
"two.  The current code makes no difference between ports and wide ports, but "
"the only object that can be connected to a remote device is a port, so ports "
"must be formed on all devices with phys if they're connected to anything."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1127
msgid "remove a phy from a port or wide port"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1128
msgid "port to remove the phy from"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1129
msgid "phy to remove"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1130
msgid ""
"This operation is used for tearing down ports again.  It must be done to "
"every port or wide port before calling sas_port_delete."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1457
#: ../drivers/scsi/scsi_transport_sas.c:1495
msgid "allocate an rphy for an end device"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1463
#: ../drivers/scsi/scsi_transport_sas.c:1501
msgid "``struct sas_port *parent``"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1458
#: ../drivers/scsi/scsi_transport_sas.c:1496
msgid "which port"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1459
#: ../drivers/scsi/scsi_transport_sas.c:1498
msgid "Allocates an SAS remote PHY structure, connected to **parent**."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1498
msgid "``enum sas_device_type type``"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1497
msgid "SAS_EDGE_EXPANDER_DEVICE or SAS_FANOUT_EXPANDER_DEVICE"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1536
msgid "add a SAS remote PHY to the device hierarchy"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1542
#: ../drivers/scsi/scsi_transport_sas.c:1596
#: ../drivers/scsi/scsi_transport_sas.c:1623
#: ../drivers/scsi/scsi_transport_sas.c:1637
#: ../drivers/scsi/scsi_transport_sas.c:1651
msgid "``struct sas_rphy *rphy``"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1537
msgid "The remote PHY to be added"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1538
msgid "Publishes a SAS remote PHY to the rest of the system."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1590
msgid "free a SAS remote PHY"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1591
msgid "SAS remote PHY to free"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1592
msgid "Frees the specified SAS remote PHY."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1595
msgid ""
"This function must only be called on a remote PHY that has not successfully "
"been added using sas_rphy_add() (or has been sas_rphy_remove()'d)"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1617
msgid "remove and free SAS remote PHY"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1618
msgid "SAS remote PHY to remove and free"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1619
msgid "Removes the specified SAS remote PHY and frees it."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1631
msgid "unlink SAS remote PHY"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1632
msgid "SAS remote phy to unlink from its parent port"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1633
msgid "Removes port reference to an rphy"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1645
msgid "remove SAS remote PHY"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1646
msgid "SAS remote phy to remove"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1647
msgid "Removes the specified SAS remote PHY."
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1675
msgid "check if a struct device represents a SAS remote PHY"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1678
msgid "``1`` if the device represents a SAS remote PHY, ``0`` else"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1809
msgid "instantiate SAS transport template"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1815
msgid "``struct sas_function_template *ft``"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1810
msgid "SAS transport class function template"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1918
msgid "release SAS transport template instance"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1924
#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:864
msgid "``struct scsi_transport_template *t``"
msgstr ""

#: ../../../driver-api/scsi:276: ../drivers/scsi/scsi_transport_sas.c:1919
#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:859
msgid "transport template instance"
msgstr ""

#: ../../../driver-api/scsi.rst:280
msgid "SATA transport class"
msgstr ""

#: ../../../driver-api/scsi.rst:282
msgid ""
"The SATA transport is handled by libata, which has its own book of "
"documentation in this directory."
msgstr ""

#: ../../../driver-api/scsi.rst:286
msgid "Parallel SCSI (SPI) transport class"
msgstr ""

#: ../../../driver-api/scsi.rst:288
msgid ""
"The file drivers/scsi/scsi_transport_spi.c defines transport attributes for "
"traditional (fast/wide/ultra) SCSI buses."
msgstr ""

#: ../../../driver-api/scsi:291: ../drivers/scsi/scsi_transport_spi.c:989
msgid "Do Domain Validation on the device"
msgstr ""

#: ../../../driver-api/scsi:291: ../drivers/scsi/scsi_transport_spi.c:990
msgid "scsi device to validate"
msgstr ""

#: ../../../driver-api/scsi:291: ../drivers/scsi/scsi_transport_spi.c:991
msgid ""
"Performs the domain validation on the given device in the current execution "
"thread.  Since DV operations may sleep, the current thread must have user "
"context.  Also no SCSI related locks that would deadlock I/O issued by the "
"DV may be held."
msgstr ""

#: ../../../driver-api/scsi:291: ../drivers/scsi/scsi_transport_spi.c:1087
msgid "schedule domain validation to occur on the device"
msgstr ""

#: ../../../driver-api/scsi:291: ../drivers/scsi/scsi_transport_spi.c:1088
msgid "The device to validate"
msgstr ""

#: ../../../driver-api/scsi:291: ../drivers/scsi/scsi_transport_spi.c:1089
msgid ""
"Identical to spi_dv_device() above, except that the DV will be scheduled to "
"occur in a workqueue later.  All memory allocations are atomic, so may be "
"called from any context including those holding SCSI locks."
msgstr ""

#: ../../../driver-api/scsi:291: ../drivers/scsi/scsi_transport_spi.c:1124
msgid "Print the current target transfer agreement"
msgstr ""

#: ../../../driver-api/scsi:291: ../drivers/scsi/scsi_transport_spi.c:1125
msgid "The target for which to display the agreement"
msgstr ""

#: ../../../driver-api/scsi:291: ../drivers/scsi/scsi_transport_spi.c:1126
msgid ""
"Each SPI port is required to maintain a transfer agreement for each other "
"port on the bus.  This function prints a one-line summary of the current "
"agreement; more detailed information is available in sysfs."
msgstr ""

#: ../../../driver-api/scsi:291: ../drivers/scsi/scsi_transport_spi.c:1222
msgid "place a tag message in a buffer"
msgstr ""

#: ../../../driver-api/scsi:291: ../drivers/scsi/scsi_transport_spi.c:1228
msgid "``unsigned char *msg``"
msgstr ""

#: ../../../driver-api/scsi:291: ../drivers/scsi/scsi_transport_spi.c:1223
msgid "pointer to the area to place the tag"
msgstr ""

#: ../../../driver-api/scsi:291: ../drivers/scsi/scsi_transport_spi.c:1224
msgid "pointer to the scsi command for the tag"
msgstr ""

#: ../../../driver-api/scsi:291: ../drivers/scsi/scsi_transport_spi.c:1226
msgid ""
"designed to create the correct type of tag message for the particular "
"request.  Returns the size of the tag message. May return 0 if TCQ is "
"disabled for this device."
msgstr ""

#: ../../../driver-api/scsi.rst:295
msgid "SCSI RDMA (SRP) transport class"
msgstr ""

#: ../../../driver-api/scsi.rst:297
msgid ""
"The file drivers/scsi/scsi_transport_srp.c defines transport attributes for "
"SCSI over Remote Direct Memory Access."
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:72
msgid "check timeout combination validity"
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:78
msgid "``int reconnect_delay``"
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:73
msgid "Reconnect delay in seconds."
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:75
msgid "``int fast_io_fail_tmo``"
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:74
msgid "Fast I/O fail timeout in seconds."
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:76
msgid "``long dev_loss_tmo``"
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:75
msgid "Device loss timeout in seconds."
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:76
msgid ""
"The combination of the timeout parameters must be such that SCSI commands "
"are finished in a reasonable time. Hence do not allow the fast I/O fail "
"timeout to exceed SCSI_DEVICE_BLOCK_MAX_TIMEOUT nor allow dev_loss_tmo to "
"exceed that limit if failing I/O fast has been disabled. Furthermore, these "
"parameters must be such that multipath can detect failed paths timely. Hence "
"do not allow all three parameters to be disabled simultaneously."
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:496
msgid "start the transport layer failure timers"
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:502
#: ../drivers/scsi/scsi_transport_srp.c:517
#: ../drivers/scsi/scsi_transport_srp.c:675
#: ../drivers/scsi/scsi_transport_srp.c:685
#: ../drivers/scsi/scsi_transport_srp.c:754
#: ../drivers/scsi/scsi_transport_srp.c:792
msgid "``struct srp_rport *rport``"
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:497
#: ../drivers/scsi/scsi_transport_srp.c:512
#: ../drivers/scsi/scsi_transport_srp.c:670
#: ../drivers/scsi/scsi_transport_srp.c:680
msgid "SRP target port."
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:498
msgid ""
"Start the transport layer fast I/O failure and device loss timers. Do not "
"modify a timer that was already started."
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:511
msgid "reconnect to an SRP target port"
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:513
msgid ""
"Blocks SCSI command queueing before invoking reconnect() such that "
"queuecommand() won't be invoked concurrently with reconnect() from outside "
"the SCSI EH. This is important since a reconnect() implementation may "
"reallocate resources needed by queuecommand()."
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:519
msgid ""
"This function neither waits until outstanding requests have finished nor "
"tries to abort these. It is the responsibility of the reconnect() function "
"to finish outstanding commands before reconnecting to the target port."
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:523
msgid ""
"It is the responsibility of the caller to ensure that the resources "
"reallocated by the reconnect() function won't be used while this function is "
"in progress. One possible strategy is to invoke this function from the "
"context of the SCSI EH thread only. Another possible strategy is to lock the "
"rport mutex inside each SCSI LLD callback that can be invoked by the SCSI EH "
"(the scsi_host_template.eh_*() functions and also the scsi_host_template."
"queuecommand() function)."
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:593
msgid "SRP transport intercept of the SCSI timeout EH"
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:594
msgid "SCSI command."
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:595
msgid ""
"If a timeout occurs while an rport is in the blocked state, ask the SCSI EH "
"to continue waiting (SCSI_EH_RESET_TIMER). Otherwise let the SCSI core "
"handle the timeout (SCSI_EH_NOT_HANDLED)."
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:600
msgid ""
"This function is called from soft-IRQ context and with the request queue "
"lock held."
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:669
msgid "increment rport reference count"
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:679
msgid "decrement rport reference count"
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:689
msgid "add a SRP remote port to the device hierarchy"
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:692
msgid "``struct srp_rport_identifiers *ids``"
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:691
msgid "The port id for the remote port."
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:692
msgid "Publishes a port to the rest of the system."
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:748
msgid "remove a SRP remote port"
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:749
msgid "SRP remote port to remove"
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:750
msgid "Removes the specified SRP remote port."
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:773
msgid "tear down a Scsi_Host's SRP data structures"
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:775
msgid ""
"Removes all SRP remote ports for a given Scsi_Host. Must be called just "
"before scsi_remove_host for SRP HBAs."
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:786
msgid "stop the transport layer recovery timers"
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:787
msgid "SRP remote port for which to stop the timers."
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:788
msgid ""
"Must be called after srp_remove_host() and scsi_remove_host(). The caller "
"must hold a reference on the rport (rport->dev) and on the SCSI host (rport-"
">dev.parent)."
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:808
msgid "instantiate SRP transport template"
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:814
msgid "``struct srp_function_template *ft``"
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:809
msgid "SRP transport class function template"
msgstr ""

#: ../../../driver-api/scsi:300: ../drivers/scsi/scsi_transport_srp.c:858
msgid "release SRP transport template instance"
msgstr ""

#: ../../../driver-api/scsi.rst:304
msgid "SCSI lower layer"
msgstr ""

#: ../../../driver-api/scsi.rst:307
msgid "Host Bus Adapter transport types"
msgstr ""

#: ../../../driver-api/scsi.rst:309
msgid ""
"Many modern device controllers use the SCSI command set as a protocol to "
"communicate with their devices through many different types of physical "
"connections."
msgstr ""

#: ../../../driver-api/scsi.rst:313
msgid ""
"In SCSI language a bus capable of carrying SCSI commands is called a "
"\"transport\", and a controller connecting to such a bus is called a \"host "
"bus adapter\" (HBA)."
msgstr ""

#: ../../../driver-api/scsi.rst:318
msgid "Debug transport"
msgstr ""

#: ../../../driver-api/scsi.rst:320
msgid ""
"The file drivers/scsi/scsi_debug.c simulates a host adapter with a variable "
"number of disks (or disk like devices) attached, sharing a common amount of "
"RAM. Does a lot of checking to make sure that we are not getting blocks "
"mixed up, and panics the kernel if anything out of the ordinary is seen."
msgstr ""

#: ../../../driver-api/scsi.rst:326
msgid ""
"To be more realistic, the simulated devices have the transport attributes of "
"SAS disks."
msgstr ""

#: ../../../driver-api/scsi.rst:329
msgid "For documentation see http://sg.danny.cz/sg/scsi_debug.html"
msgstr ""

#: ../../../driver-api/scsi.rst:332
msgid "todo"
msgstr ""

#: ../../../driver-api/scsi.rst:334
msgid ""
"Parallel (fast/wide/ultra) SCSI, USB, SATA, SAS, Fibre Channel, FireWire, "
"ATAPI devices, Infiniband, Parallel ports, netlink..."
msgstr ""
