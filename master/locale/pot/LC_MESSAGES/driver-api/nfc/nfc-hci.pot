# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/nfc/nfc-hci.rst:3
msgid "HCI backend for NFC Core"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:5
msgid "Author: Eric Lapuyade, Samuel Ortiz"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:6
msgid "Contact: eric.lapuyade@intel.com, samuel.ortiz@intel.com"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:9
msgid "General"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:11
msgid ""
"The HCI layer implements much of the ETSI TS 102 622 V10.2.0 specification. "
"It enables easy writing of HCI-based NFC drivers. The HCI layer runs as an "
"NFC Core backend, implementing an abstract nfc device and translating NFC "
"Core API to HCI commands and events."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:17
msgid "HCI"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:19
msgid ""
"HCI registers as an nfc device with NFC Core. Requests coming from userspace "
"are routed through netlink sockets to NFC Core and then to HCI. From this "
"point, they are translated in a sequence of HCI commands sent to the HCI "
"layer in the host controller (the chip). Commands can be executed "
"synchronously (the sending context blocks waiting for response) or "
"asynchronously (the response is returned from HCI Rx context). HCI events "
"can also be received from the host controller. They will be handled and a "
"translation will be forwarded to NFC Core as needed. There are hooks to let "
"the HCI driver handle proprietary events or override standard behavior. HCI "
"uses 2 execution contexts:"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:30
msgid ""
"one for executing commands : nfc_hci_msg_tx_work(). Only one command can be "
"executing at any given moment."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:32
msgid ""
"one for dispatching received events and commands : nfc_hci_msg_rx_work()."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:35
msgid "HCI Session initialization"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:37
msgid ""
"The Session initialization is an HCI standard which must unfortunately "
"support proprietary gates. This is the reason why the driver will pass a "
"list of proprietary gates that must be part of the session. HCI will ensure "
"all those gates have pipes connected when the hci device is set up. In case "
"the chip supports pre-opened gates and pseudo-static pipes, the driver can "
"pass that information to HCI core."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:45
msgid "HCI Gates and Pipes"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:47
msgid ""
"A gate defines the 'port' where some service can be found. In order to "
"access a service, one must create a pipe to that gate and open it. In this "
"implementation, pipes are totally hidden. The public API only knows gates. "
"This is consistent with the driver need to send commands to proprietary "
"gates without knowing the pipe connected to it."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:54
msgid "Driver interface"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:56
msgid ""
"A driver is generally written in two parts : the physical link management "
"and the HCI management. This makes it easier to maintain a driver for a chip "
"that can be connected using various phy (i2c, spi, ...)"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:61
msgid "HCI Management"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:63
msgid ""
"A driver would normally register itself with HCI and provide the following "
"entry points::"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:90
msgid "open() and close() shall turn the hardware on and off."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:91
msgid ""
"hci_ready() is an optional entry point that is called right after the hci "
"session has been set up. The driver can use it to do additional "
"initialization that must be performed using HCI commands."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:94
msgid "xmit() shall simply write a frame to the physical link."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:95
msgid ""
"start_poll() is an optional entrypoint that shall set the hardware in "
"polling mode. This must be implemented only if the hardware uses proprietary "
"gates or a mechanism slightly different from the HCI standard."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:98
msgid ""
"dep_link_up() is called after a p2p target has been detected, to finish the "
"p2p connection setup with hardware parameters that need to be passed back to "
"nfc core."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:101
msgid "dep_link_down() is called to bring the p2p link down."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:102
msgid ""
"target_from_gate() is an optional entrypoint to return the nfc protocols "
"corresponding to a proprietary gate."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:104
msgid ""
"complete_target_discovered() is an optional entry point to let the driver "
"perform additional proprietary processing necessary to auto activate the "
"discovered target."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:107
msgid ""
"im_transceive() must be implemented by the driver if proprietary HCI "
"commands are required to send data to the tag. Some tag types will require "
"custom commands, others can be written to using the standard HCI commands. "
"The driver can check the tag type and either do proprietary processing, or "
"return 1 to ask for standard processing. The data exchange command itself "
"must be sent asynchronously."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:113
msgid "tm_send() is called to send data in the case of a p2p connection"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:114
msgid ""
"check_presence() is an optional entry point that will be called regularly by "
"the core to check that an activated tag is still in the field. If this is "
"not implemented, the core will not be able to push tag_lost events to the "
"user space"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:118
msgid ""
"event_received() is called to handle an event coming from the chip. Driver "
"can handle the event or return 1 to let HCI attempt standard processing."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:121
msgid ""
"On the rx path, the driver is responsible to push incoming HCP frames to HCI "
"using nfc_hci_recv_frame(). HCI will take care of re-aggregation and "
"handling This must be done from a context that can sleep."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:126
msgid "PHY Management"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:128
msgid ""
"The physical link (i2c, ...) management is defined by the following "
"structure::"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:136
msgid "enable():"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:137
msgid "turn the phy on (power on), make it ready to transfer data"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:138
msgid "disable():"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:139
msgid "turn the phy off"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:140
msgid "write():"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:141
msgid ""
"Send a data frame to the chip. Note that to enable higher layers such as an "
"llc to store the frame for re-emission, this function must not alter the "
"skb. It must also not return a positive result (return 0 for success, "
"negative for failure)."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:146
msgid ""
"Data coming from the chip shall be sent directly to nfc_hci_recv_frame()."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:149
msgid "LLC"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:151
msgid ""
"Communication between the CPU and the chip often requires some link layer "
"protocol. Those are isolated as modules managed by the HCI layer. There are "
"currently two modules : nop (raw transfer) and shdlc. A new llc must "
"implement the following functions::"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:168
msgid "init():"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:169
msgid "allocate and init your private storage"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:170
msgid "deinit():"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:171
msgid "cleanup"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:172
msgid "start():"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:173
msgid "establish the logical connection"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:174
msgid "stop ():"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:175
msgid "terminate the logical connection"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:176
msgid "rcv_from_drv():"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:177
msgid "handle data coming from the chip, going to HCI"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:178
msgid "xmit_from_hci():"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:179
msgid "handle data sent by HCI, going to the chip"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:181
msgid ""
"The llc must be registered with nfc before it can be used. Do that by "
"calling::"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:186
msgid ""
"Again, note that the llc does not handle the physical link. It is thus very "
"easy to mix any physical link with any llc for a given chip driver."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:190
msgid "Included Drivers"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:192
msgid ""
"An HCI based driver for an NXP PN544, connected through I2C bus, and using "
"shdlc is included."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:196
msgid "Execution Contexts"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:198
msgid ""
"The execution contexts are the following: - IRQ handler (IRQH): fast, cannot "
"sleep. sends incoming frames to HCI where they are passed to the current "
"llc. In case of shdlc, the frame is queued in shdlc rx queue."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:203
msgid "SHDLC State Machine worker (SMW)"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:205
msgid "Only when llc_shdlc is used: handles shdlc rx & tx queues."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:207
msgid "Dispatches HCI cmd responses."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:209
msgid "HCI Tx Cmd worker (MSGTXWQ)"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:211
msgid "Serializes execution of HCI commands."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:213
msgid "Completes execution in case of response timeout."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:215
msgid "HCI Rx worker (MSGRXWQ)"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:217
msgid "Dispatches incoming HCI commands or events."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:219
msgid "Syscall context from a userspace call (SYSCALL)"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:221
msgid "Any entrypoint in HCI called from NFC Core"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:224
msgid "Workflow executing an HCI command (using shdlc)"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:226
msgid ""
"Executing an HCI command can easily be performed synchronously using the "
"following API::"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:232
msgid ""
"The API must be invoked from a context that can sleep. Most of the time, "
"this will be the syscall context. skb will return the result that was "
"received in the response."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:236
msgid ""
"Internally, execution is asynchronous. So all this API does is to enqueue "
"the HCI command, setup a local wait queue on stack, and wait_event() for "
"completion. The wait is not interruptible because it is guaranteed that the "
"command will complete after some short timeout anyway."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:241
msgid ""
"MSGTXWQ context will then be scheduled and invoke nfc_hci_msg_tx_work(). "
"This function will dequeue the next pending command and send its HCP "
"fragments to the lower layer which happens to be shdlc. It will then start a "
"timer to be able to complete the command with a timeout error if no response "
"arrive."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:246
msgid ""
"SMW context gets scheduled and invokes nfc_shdlc_sm_work(). This function "
"handles shdlc framing in and out. It uses the driver xmit to send frames and "
"receives incoming frames in an skb queue filled from the driver IRQ handler. "
"SHDLC I(nformation) frames payload are HCP fragments. They are aggregated to "
"form complete HCI frames, which can be a response, command, or event."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:252
msgid ""
"HCI Responses are dispatched immediately from this context to unblock "
"waiting command execution. Response processing involves invoking the "
"completion callback that was provided by nfc_hci_msg_tx_work() when it sent "
"the command. The completion callback will then wake the syscall context."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:257
msgid ""
"It is also possible to execute the command asynchronously using this API::"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:263
msgid ""
"The workflow is the same, except that the API call returns immediately, and "
"the callback will be called with the result from the SMW context."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:267
msgid "Workflow receiving an HCI event or command"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:269
msgid ""
"HCI commands or events are not dispatched from SMW context. Instead, they "
"are queued to HCI rx_queue and will be dispatched from HCI rx worker context "
"(MSGRXWQ). This is done this way to allow a cmd or event handler to also "
"execute other commands (for example, handling the "
"NFC_HCI_EVT_TARGET_DISCOVERED event from PN544 requires to issue an "
"ANY_GET_PARAMETER to the reader A gate to get information on the target that "
"was discovered)."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:277
msgid ""
"Typically, such an event will be propagated to NFC Core from MSGRXWQ context."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:280
msgid "Error management"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:282
msgid ""
"Errors that occur synchronously with the execution of an NFC Core request "
"are simply returned as the execution result of the request. These are easy."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:285
msgid ""
"Errors that occur asynchronously (e.g. in a background protocol handling "
"thread) must be reported such that upper layers don't stay ignorant that "
"something went wrong below and know that expected events will probably never "
"happen. Handling of these errors is done as follows:"
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:290
msgid ""
"driver (pn544) fails to deliver an incoming frame: it stores the error such "
"that any subsequent call to the driver will result in this error. Then it "
"calls the standard nfc_shdlc_recv_frame() with a NULL argument to report the "
"problem above. shdlc stores a EREMOTEIO sticky status, which will trigger "
"SMW to report above in turn."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:296
msgid ""
"SMW is basically a background thread to handle incoming and outgoing shdlc "
"frames. This thread will also check the shdlc sticky status and report to "
"HCI when it discovers it is not able to run anymore because of an "
"unrecoverable error that happened within shdlc or below. If the problem "
"occurs during shdlc connection, the error is reported through the connect "
"completion."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:302
msgid ""
"HCI: if an internal HCI error happens (frame is lost), or HCI is reported an "
"error from a lower layer, HCI will either complete the currently executing "
"command with that error, or notify NFC Core directly if no command is "
"executing."
msgstr ""

#: ../../../driver-api/nfc/nfc-hci.rst:307
msgid ""
"NFC Core: when NFC Core is notified of an error from below and polling is "
"active, it will send a tag discovered event with an empty tag list to the "
"user space to let it know that the poll operation will never be able to "
"detect a tag. If polling is not active and the error was sticky, lower "
"levels will return it at next invocation."
msgstr ""
