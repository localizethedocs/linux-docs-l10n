# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-09 08:48+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/infrastructure.rst:2
msgid "Device drivers infrastructure"
msgstr ""

#: ../../../driver-api/infrastructure.rst:5
msgid "The Basic Device Driver-Model Structures"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:51
msgid "interfaces to device functions"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:28
#: ../include/linux/uio_driver.h:63 ../include/linux/uio_driver.h:94
#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:29
#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:30
#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:56
#: ../../../driver-api/infrastructure:44: ../include/linux/device/faux.h:24
#: ../include/linux/device/faux.h:39 ../../../driver-api/infrastructure:50:
#: ../drivers/base/node.c:78 ../drivers/base/node.c:294
#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:55
#: ../include/linux/device.h:104 ../include/linux/device.h:118
#: ../include/linux/device.h:371 ../include/linux/device.h:385
#: ../include/linux/device.h:444 ../include/linux/device.h:466
#: ../include/linux/device.h:679
msgid "**Definition**::"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:42
#: ../include/linux/uio_driver.h:73 ../include/linux/uio_driver.h:112
#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:55
#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:47
#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:83
#: ../../../driver-api/infrastructure:44: ../include/linux/device/faux.h:30
#: ../include/linux/device/faux.h:46 ../../../driver-api/infrastructure:50:
#: ../drivers/base/node.c:89 ../drivers/base/node.c:302
#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:65
#: ../include/linux/device.h:112 ../include/linux/device.h:125
#: ../include/linux/device.h:380 ../include/linux/device.h:394
#: ../include/linux/device.h:454 ../include/linux/device.h:548
#: ../include/linux/device.h:695
msgid "**Members**"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:25
#: ../include/linux/uio_driver.h:60 ../include/linux/uio_driver.h:92
#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:27
#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:27
#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:53
#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:52
msgid "``name``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:53
msgid "name of the device function"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:53
msgid "``subsys``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:54
msgid "subsystem of the devices to attach to"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:292
#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:54
msgid "``node``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:55
msgid "the list of functions registered at the subsystem"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:55
msgid "``add_dev``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:56
#: ../include/linux/device.h:57
msgid "device hookup to device function handler"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:56
msgid "``remove_dev``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:133
#: ../include/linux/uio_driver.h:153 ../../../driver-api/infrastructure:11:
#: ../include/linux/device/bus.h:71 ../include/linux/device/bus.h:287
#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:46
#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:45
#: ../include/linux/device/driver.h:93 ../../../driver-api/infrastructure:23:
#: ../drivers/base/init.c:3 ../../../driver-api/infrastructure:26:
#: ../include/linux/device/driver.h:263 ../include/linux/device/driver.h:290
#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:43
#: ../drivers/base/driver.c:115 ../drivers/base/driver.c:143
#: ../drivers/base/driver.c:221 ../drivers/base/driver.c:268
#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3
#: ../drivers/base/core.c:677 ../drivers/base/core.c:954
#: ../drivers/base/core.c:972 ../drivers/base/core.c:2393
#: ../drivers/base/core.c:2866 ../drivers/base/core.c:3080
#: ../drivers/base/core.c:3140 ../drivers/base/core.c:3548
#: ../drivers/base/core.c:3754 ../drivers/base/core.c:3779
#: ../drivers/base/core.c:3823 ../drivers/base/core.c:3909
#: ../drivers/base/core.c:4000 ../drivers/base/core.c:4030
#: ../drivers/base/core.c:4061 ../drivers/base/core.c:4095
#: ../drivers/base/core.c:4259 ../drivers/base/core.c:4320
#: ../drivers/base/core.c:4463 ../drivers/base/core.c:4483
#: ../drivers/base/core.c:4719 ../drivers/base/core.c:5037
#: ../drivers/base/core.c:5085 ../drivers/base/core.c:5136
#: ../drivers/base/core.c:5181 ../drivers/base/core.c:5263
#: ../drivers/base/core.c:5287 ../../../driver-api/infrastructure:35:
#: ../drivers/base/syscore.c:3 ../../../driver-api/infrastructure:41:
#: ../drivers/base/class.c:258 ../drivers/base/class.c:296
#: ../drivers/base/class.c:315 ../drivers/base/class.c:345
#: ../drivers/base/class.c:376 ../drivers/base/class.c:393
#: ../drivers/base/class.c:440 ../drivers/base/class.c:569
#: ../drivers/base/class.c:628 ../../../driver-api/infrastructure:44:
#: ../include/linux/device/faux.h:25 ../include/linux/device/faux.h:45
#: ../../../driver-api/infrastructure:47: ../drivers/base/faux.c:113
#: ../drivers/base/faux.c:193 ../drivers/base/faux.c:218
#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:714
#: ../drivers/base/node.c:914 ../../../driver-api/infrastructure:53:
#: ../drivers/base/transport_class.c:42 ../drivers/base/transport_class.c:62
#: ../drivers/base/transport_class.c:84 ../drivers/base/transport_class.c:110
#: ../drivers/base/transport_class.c:137 ../drivers/base/transport_class.c:189
#: ../drivers/base/transport_class.c:220 ../drivers/base/transport_class.c:259
#: ../drivers/base/transport_class.c:288 ../../../driver-api/infrastructure:56:
#: ../drivers/base/dd.c:3 ../drivers/base/dd.c:285 ../drivers/base/dd.c:388
#: ../drivers/base/dd.c:485 ../drivers/base/dd.c:1064 ../drivers/base/dd.c:1130
#: ../drivers/base/dd.c:1237 ../drivers/base/dd.c:1316
#: ../../../driver-api/infrastructure:59:
#: ../include/linux/platform_device.h:153
#: ../include/linux/platform_device.h:181
#: ../include/linux/platform_device.h:212
#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:175
#: ../drivers/base/platform.c:264 ../drivers/base/platform.c:289
#: ../drivers/base/platform.c:371 ../drivers/base/platform.c:505
#: ../drivers/base/platform.c:526 ../drivers/base/platform.c:587
#: ../drivers/base/platform.c:615 ../drivers/base/platform.c:642
#: ../drivers/base/platform.c:670 ../drivers/base/platform.c:695
#: ../drivers/base/platform.c:783 ../drivers/base/platform.c:828
#: ../drivers/base/platform.c:845 ../drivers/base/platform.c:940
#: ../drivers/base/platform.c:1012 ../drivers/base/platform.c:1065
#: ../drivers/base/platform.c:1106 ../../../driver-api/infrastructure:68:
#: ../drivers/base/bus.c:357 ../drivers/base/bus.c:397
#: ../drivers/base/bus.c:474 ../drivers/base/bus.c:817
#: ../drivers/base/bus.c:831 ../drivers/base/bus.c:889
#: ../drivers/base/bus.c:977 ../drivers/base/bus.c:1305
#: ../drivers/base/bus.c:1330 ../drivers/base/bus.c:1354
#: ../drivers/base/bus.c:1403 ../../../driver-api/infrastructure:74:
#: ../kernel/dma/mapping.c:67 ../kernel/dma/mapping.c:87
#: ../kernel/dma/mapping.c:270 ../kernel/dma/mapping.c:298
#: ../kernel/dma/mapping.c:456 ../kernel/dma/mapping.c:545
#: ../kernel/dma/mapping.c:569 ../kernel/dma/mapping.c:954
#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:60
#: ../include/linux/device.h:145 ../include/linux/device.h:167
#: ../include/linux/device.h:177 ../include/linux/device.h:187
#: ../include/linux/device.h:196 ../include/linux/device.h:205
#: ../include/linux/device.h:214 ../include/linux/device.h:225
#: ../include/linux/device.h:238 ../include/linux/device.h:250
#: ../include/linux/device.h:262 ../include/linux/device.h:486
#: ../include/linux/device.h:735 ../include/linux/device.h:984
#: ../include/linux/device.h:999 ../include/linux/device.h:1031
#: ../include/linux/device.h:1052 ../../../driver-api/infrastructure:80:
#: ../drivers/pnp/core.c:45 ../../../driver-api/infrastructure:89:
#: ../drivers/pnp/manager.c:335 ../drivers/pnp/manager.c:359
#: ../drivers/pnp/manager.c:381 ../drivers/pnp/manager.c:407
#: ../../../driver-api/infrastructure:98: ../drivers/uio/uio.c:977
#: ../drivers/uio/uio.c:1073
msgid "**Description**"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:57
msgid ""
"Simple interfaces attached to a subsystem. Multiple interfaces can attach to "
"a subsystem and its devices. Unlike drivers, they do not exclusively claim "
"or control devices. Interfaces usually represent a specific functionality of "
"a subsystem/class of devices."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:100
msgid "Interface for exporting device attributes."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:101
#: ../include/linux/device.h:115
msgid "``attr``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:102
msgid "sysfs attribute definition."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:102
msgid "``show``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:103
msgid "Show handler."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:103
msgid "``store``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:104
msgid "Store handler."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:114
msgid "Exported device attribute with extra context."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:116
msgid "Exported device attribute."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:116
msgid "``var``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:117
msgid "Pointer to context."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:141
msgid "``DEVICE_ATTR (_name, _mode, _show, _store)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:139
msgid "Define a device attribute."
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:133
#: ../include/linux/uio_driver.h:153 ../../../driver-api/infrastructure:23:
#: ../drivers/base/init.c:20 ../../../driver-api/infrastructure:26:
#: ../include/linux/device/driver.h:176 ../include/linux/device/driver.h:188
#: ../include/linux/device/driver.h:201 ../include/linux/device/driver.h:214
#: ../include/linux/device/driver.h:233 ../include/linux/device/driver.h:257
#: ../include/linux/device/driver.h:283 ../../../driver-api/infrastructure:29:
#: ../drivers/base/driver.c:38 ../drivers/base/driver.c:113
#: ../drivers/base/driver.c:141 ../drivers/base/driver.c:179
#: ../drivers/base/driver.c:197 ../drivers/base/driver.c:222
#: ../drivers/base/driver.c:269 ../../../driver-api/infrastructure:32:
#: ../drivers/base/core.c:545 ../drivers/base/core.c:673
#: ../drivers/base/core.c:955 ../drivers/base/core.c:972
#: ../drivers/base/core.c:2394 ../drivers/base/core.c:2866
#: ../drivers/base/core.c:3043 ../drivers/base/core.c:3067
#: ../drivers/base/core.c:3080 ../drivers/base/core.c:3097
#: ../drivers/base/core.c:3112 ../drivers/base/core.c:3141
#: ../drivers/base/core.c:3486 ../drivers/base/core.c:3549
#: ../drivers/base/core.c:3755 ../drivers/base/core.c:3780
#: ../drivers/base/core.c:3794 ../drivers/base/core.c:3824
#: ../drivers/base/core.c:3910 ../drivers/base/core.c:3999
#: ../drivers/base/core.c:4029 ../drivers/base/core.c:4059
#: ../drivers/base/core.c:4094 ../drivers/base/core.c:4259
#: ../drivers/base/core.c:4321 ../drivers/base/core.c:4387
#: ../drivers/base/core.c:4422 ../drivers/base/core.c:4463
#: ../drivers/base/core.c:4483 ../drivers/base/core.c:4583
#: ../drivers/base/core.c:4718 ../drivers/base/core.c:5035
#: ../drivers/base/core.c:5083 ../drivers/base/core.c:5136
#: ../drivers/base/core.c:5181 ../drivers/base/core.c:5202
#: ../drivers/base/core.c:5226 ../drivers/base/core.c:5263
#: ../drivers/base/core.c:5286 ../../../driver-api/infrastructure:35:
#: ../drivers/base/syscore.c:22 ../drivers/base/syscore.c:34
#: ../drivers/base/syscore.c:47 ../drivers/base/syscore.c:93
#: ../../../driver-api/infrastructure:38: ../include/linux/device/class.h:103
#: ../include/linux/device/class.h:115 ../include/linux/device/class.h:127
#: ../include/linux/device/class.h:139 ../include/linux/device/class.h:153
#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:259
#: ../drivers/base/class.c:297 ../drivers/base/class.c:313
#: ../drivers/base/class.c:346 ../drivers/base/class.c:377
#: ../drivers/base/class.c:391 ../drivers/base/class.c:438
#: ../drivers/base/class.c:570 ../drivers/base/class.c:593
#: ../drivers/base/class.c:604 ../drivers/base/class.c:616
#: ../drivers/base/class.c:628 ../../../driver-api/infrastructure:47:
#: ../drivers/base/faux.c:104 ../drivers/base/faux.c:188
#: ../drivers/base/faux.c:219 ../../../driver-api/infrastructure:50:
#: ../drivers/base/node.c:368 ../drivers/base/node.c:712
#: ../drivers/base/node.c:871 ../drivers/base/node.c:915
#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:42
#: ../drivers/base/transport_class.c:62 ../drivers/base/transport_class.c:84
#: ../drivers/base/transport_class.c:110 ../drivers/base/transport_class.c:138
#: ../drivers/base/transport_class.c:189 ../drivers/base/transport_class.c:220
#: ../drivers/base/transport_class.c:259 ../drivers/base/transport_class.c:288
#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:281
#: ../drivers/base/dd.c:389 ../drivers/base/dd.c:486 ../drivers/base/dd.c:772
#: ../drivers/base/dd.c:1065 ../drivers/base/dd.c:1130
#: ../drivers/base/dd.c:1238 ../drivers/base/dd.c:1317
#: ../../../driver-api/infrastructure:59:
#: ../include/linux/platform_device.h:146
#: ../include/linux/platform_device.h:179
#: ../include/linux/platform_device.h:209
#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:52
#: ../drivers/base/platform.c:91 ../drivers/base/platform.c:116
#: ../drivers/base/platform.c:134 ../drivers/base/platform.c:174
#: ../drivers/base/platform.c:264 ../drivers/base/platform.c:289
#: ../drivers/base/platform.c:319 ../drivers/base/platform.c:367
#: ../drivers/base/platform.c:460 ../drivers/base/platform.c:505
#: ../drivers/base/platform.c:526 ../drivers/base/platform.c:543
#: ../drivers/base/platform.c:588 ../drivers/base/platform.c:615
#: ../drivers/base/platform.c:641 ../drivers/base/platform.c:669
#: ../drivers/base/platform.c:696 ../drivers/base/platform.c:784
#: ../drivers/base/platform.c:813 ../drivers/base/platform.c:829
#: ../drivers/base/platform.c:844 ../drivers/base/platform.c:902
#: ../drivers/base/platform.c:917 ../drivers/base/platform.c:939
#: ../drivers/base/platform.c:1007 ../drivers/base/platform.c:1064
#: ../drivers/base/platform.c:1106 ../drivers/base/platform.c:1540
#: ../../../driver-api/infrastructure:65: ../include/linux/device/bus.h:161
#: ../include/linux/device/bus.h:175 ../include/linux/device/bus.h:187
#: ../include/linux/device/bus.h:199 ../include/linux/device/bus.h:211
#: ../include/linux/device/bus.h:226 ../../../driver-api/infrastructure:68:
#: ../drivers/base/bus.c:355 ../drivers/base/bus.c:395
#: ../drivers/base/bus.c:472 ../drivers/base/bus.c:818
#: ../drivers/base/bus.c:832 ../drivers/base/bus.c:890
#: ../drivers/base/bus.c:978 ../drivers/base/bus.c:1305
#: ../drivers/base/bus.c:1330 ../drivers/base/bus.c:1354
#: ../drivers/base/bus.c:1404 ../../../driver-api/infrastructure:74:
#: ../kernel/dma/mapping.c:65 ../kernel/dma/mapping.c:84
#: ../kernel/dma/mapping.c:267 ../kernel/dma/mapping.c:296
#: ../kernel/dma/mapping.c:457 ../kernel/dma/mapping.c:546
#: ../kernel/dma/mapping.c:565 ../kernel/dma/mapping.c:955
#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:143
#: ../include/linux/device.h:165 ../include/linux/device.h:178
#: ../include/linux/device.h:188 ../include/linux/device.h:197
#: ../include/linux/device.h:206 ../include/linux/device.h:215
#: ../include/linux/device.h:224 ../include/linux/device.h:237
#: ../include/linux/device.h:249 ../include/linux/device.h:261
#: ../include/linux/device.h:709 ../include/linux/device.h:722
#: ../include/linux/device.h:736 ../include/linux/device.h:984
#: ../include/linux/device.h:1000 ../include/linux/device.h:1030
#: ../include/linux/device.h:1053 ../../../driver-api/infrastructure:80:
#: ../drivers/pnp/core.c:46 ../../../driver-api/infrastructure:83:
#: ../drivers/pnp/card.c:295 ../drivers/pnp/card.c:347
#: ../drivers/pnp/card.c:385 ../drivers/pnp/card.c:419
#: ../../../driver-api/infrastructure:86: ../drivers/pnp/driver.c:314
#: ../../../driver-api/infrastructure:89: ../drivers/pnp/manager.c:336
#: ../drivers/pnp/manager.c:360 ../drivers/pnp/manager.c:382
#: ../drivers/pnp/manager.c:408 ../../../driver-api/infrastructure:92:
#: ../drivers/pnp/support.c:20 ../../../driver-api/infrastructure:98:
#: ../drivers/uio/uio.c:431 ../drivers/uio/uio.c:976 ../drivers/uio/uio.c:1072
#: ../drivers/uio/uio.c:1105
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:145
#: ../include/linux/device.h:167 ../include/linux/device.h:180
#: ../include/linux/device.h:190 ../include/linux/device.h:199
#: ../include/linux/device.h:208 ../include/linux/device.h:217
#: ../include/linux/device.h:226 ../include/linux/device.h:239
#: ../include/linux/device.h:251 ../include/linux/device.h:263
msgid "``_name``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:140
#: ../include/linux/device.h:162 ../include/linux/device.h:175
#: ../include/linux/device.h:185 ../include/linux/device.h:194
#: ../include/linux/device.h:203 ../include/linux/device.h:212
#: ../include/linux/device.h:221 ../include/linux/device.h:234
#: ../include/linux/device.h:246 ../include/linux/device.h:258
msgid "Attribute name."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:142
#: ../include/linux/device.h:164 ../include/linux/device.h:223
#: ../include/linux/device.h:236 ../include/linux/device.h:248
#: ../include/linux/device.h:260
msgid "``_mode``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:141
#: ../include/linux/device.h:163 ../include/linux/device.h:222
#: ../include/linux/device.h:235 ../include/linux/device.h:247
#: ../include/linux/device.h:259
msgid "File mode."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:143
#: ../include/linux/device.h:165
msgid "``_show``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:142
#: ../include/linux/device.h:164
msgid "Show handler. Optional, but mandatory if attribute is readable."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:144
#: ../include/linux/device.h:166
msgid "``_store``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:143
#: ../include/linux/device.h:165
msgid "Store handler. Optional, but mandatory if attribute is writable."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:144
msgid "Convenience macro for defining a struct device_attribute."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:146
msgid ""
"For example, ``DEVICE_ATTR(foo, 0644, foo_show, foo_store);`` expands to:"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:163
msgid "``DEVICE_ATTR_PREALLOC (_name, _mode, _show, _store)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:161
msgid "Define a preallocated device attribute."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:166
msgid "Like DEVICE_ATTR(), but ``SYSFS_PREALLOC`` is set on **_mode**."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:176
msgid "``DEVICE_ATTR_RW (_name)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:174
msgid "Define a read-write device attribute."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:176
msgid ""
"Like DEVICE_ATTR(), but **_mode** is 0644, **_show** is <_name>_show, and "
"**_store** is <_name>_store."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:186
msgid "``DEVICE_ATTR_ADMIN_RW (_name)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:184
msgid "Define an admin-only read-write device attribute."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:186
msgid "Like DEVICE_ATTR_RW(), but **_mode** is 0600."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:195
msgid "``DEVICE_ATTR_RO (_name)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:193
msgid "Define a readable device attribute."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:195
msgid ""
"Like DEVICE_ATTR(), but **_mode** is 0444 and **_show** is <_name>_show."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:204
msgid "``DEVICE_ATTR_ADMIN_RO (_name)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:202
msgid "Define an admin-only readable device attribute."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:204
msgid "Like DEVICE_ATTR_RO(), but **_mode** is 0400."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:213
msgid "``DEVICE_ATTR_WO (_name)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:211
msgid "Define an admin-only writable device attribute."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:213
msgid ""
"Like DEVICE_ATTR(), but **_mode** is 0200 and **_store** is <_name>_store."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:222
msgid "``DEVICE_ULONG_ATTR (_name, _mode, _var)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:220
msgid "Define a device attribute backed by an unsigned long."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:224
#: ../include/linux/device.h:237 ../include/linux/device.h:249
#: ../include/linux/device.h:261
msgid "``_var``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:223
msgid "Identifier of unsigned long."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:224
msgid ""
"Like DEVICE_ATTR(), but **_show** and **_store** are automatically provided "
"such that reads and writes to the attribute from userspace affect **_var**."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:235
msgid "``DEVICE_INT_ATTR (_name, _mode, _var)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:233
msgid "Define a device attribute backed by an int."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:236
msgid "Identifier of int."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:237
msgid "Like DEVICE_ULONG_ATTR(), but **_var** is an int."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:247
msgid "``DEVICE_BOOL_ATTR (_name, _mode, _var)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:245
msgid "Define a device attribute backed by a bool."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:248
msgid "Identifier of bool."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:249
msgid "Like DEVICE_ULONG_ATTR(), but **_var** is a bool."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:259
msgid "``DEVICE_STRING_ATTR_RO (_name, _mode, _var)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:257
msgid "Define a device attribute backed by a r/o string."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:260
msgid "Identifier of string."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:261
msgid ""
"Like DEVICE_ULONG_ATTR(), but **_var** is a string. Because the length of "
"the string allocation is unknown, the attribute must be read-only."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:337
msgid "Device driver presence tracking information."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:261
#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:28
#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:341
#: ../include/linux/device.h:355 ../include/linux/device.h:397
#: ../include/linux/device.h:418 ../include/linux/device.h:431
msgid "**Constants**"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:343
msgid "``DL_DEV_NO_DRIVER``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:344
msgid "There is no driver attached to the device."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:346
msgid "``DL_DEV_PROBING``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:347
msgid "A driver is probing."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:349
msgid "``DL_DEV_DRIVER_BOUND``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:350
msgid "The driver has been bound to the device."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:352
msgid "``DL_DEV_UNBINDING``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:353
msgid "The driver is unbinding from the device."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:351
msgid ""
"Whether the device is removable. The criteria for a device to be classified "
"as removable is determined by its subsystem or bus."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:357
msgid "``DEVICE_REMOVABLE_NOT_SUPPORTED``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:358
msgid "This attribute is not supported for this device (default)."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:361
msgid "``DEVICE_REMOVABLE_UNKNOWN``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:362
msgid "Device location is Unknown."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:364
msgid "``DEVICE_FIXED``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:365
msgid "Device is not removable by the user."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:367
msgid "``DEVICE_REMOVABLE``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:368
msgid "Device is removable by the user."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:367
msgid "Device data related to device links."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:368
msgid "``suppliers``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:369
msgid "List of links to supplier devices."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:369
msgid "``consumers``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:370
msgid "List of links to consumer devices."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:370
msgid "``defer_sync``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:371
msgid "Hook to global list of devices that have deferred sync_state."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:371
#: ../include/linux/device.h:681
msgid "``status``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:372
msgid "Driver status information."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:381
msgid "Device data related to MSI"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:382
msgid "``domain``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:383
msgid "The MSI interrupt domain associated to the device"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:383
msgid "``data``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:384
msgid "Pointer to MSI device data"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:393
msgid ""
"Describes which panel surface of the system's housing the device connection "
"point resides on."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:399
msgid "``DEVICE_PANEL_TOP``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:400
msgid "Device connection point is on the top panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:402
msgid "``DEVICE_PANEL_BOTTOM``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:403
msgid "Device connection point is on the bottom panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:405
msgid "``DEVICE_PANEL_LEFT``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:406
msgid "Device connection point is on the left panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:408
msgid "``DEVICE_PANEL_RIGHT``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:409
msgid "Device connection point is on the right panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:411
msgid "``DEVICE_PANEL_FRONT``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:412
msgid "Device connection point is on the front panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:414
msgid "``DEVICE_PANEL_BACK``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:415
msgid "Device connection point is on the back panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:417
msgid "``DEVICE_PANEL_UNKNOWN``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:418
msgid "The panel with device connection point is unknown."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:414
msgid ""
"Describes vertical position of the device connection point on the panel "
"surface."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:420
msgid "``DEVICE_VERT_POS_UPPER``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:421
msgid "Device connection point is at upper part of panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:423
msgid "``DEVICE_VERT_POS_CENTER``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:424
#: ../include/linux/device.h:437
msgid "Device connection point is at center part of panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:426
msgid "``DEVICE_VERT_POS_LOWER``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:427
msgid "Device connection point is at lower part of panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:427
msgid ""
"Describes horizontal position of the device connection point on the panel "
"surface."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:433
msgid "``DEVICE_HORI_POS_LEFT``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:434
msgid "Device connection point is at left part of panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:436
msgid "``DEVICE_HORI_POS_CENTER``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:439
msgid "``DEVICE_HORI_POS_RIGHT``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:440
msgid "Device connection point is at right part of panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:440
msgid ""
"Device data related to physical location of the device connection point."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:442
msgid "``panel``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:443
msgid ""
"Panel surface of the system's housing that the device connection point "
"resides on."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:444
msgid "``vertical_position``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:445
msgid "Vertical position of the device connection point within the panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:446
msgid "``horizontal_position``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:447
msgid "Horizontal position of the device connection point within the panel."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:448
msgid "``dock``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:449
msgid ""
"Set if the device connection point resides in a docking station or port "
"replicator."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:450
msgid "``lid``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:451
msgid ""
"Set if this device connection point resides on the lid of laptop system."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:462
msgid "The basic device structure"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:469
msgid "``kobj``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:470
msgid "A top-level, abstract class from which other classes are derived."
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:135
#: ../include/linux/uio_driver.h:155 ../../../driver-api/infrastructure:7:
#: ../include/linux/device.h:463
msgid "``parent``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:464
msgid ""
"The device's \"parent\" device, the device to which it is attached. In most "
"cases, a parent device is some sort of bus or host controller. If parent is "
"NULL, the device, is a top-level device, which is not usually what you want."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:86
#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:467
msgid "``p``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:468
msgid ""
"Holds the private data of the driver core portions of the device. See the "
"comment of the struct device_private for detail."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:470
msgid "``init_name``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:471
msgid "Initial name of the device."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:471
msgid "``type``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:472
msgid ""
"The type of device. This identifies the device type and carries type-"
"specific information."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:54
#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:475
msgid "``bus``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:476
msgid "Type of bus device is on."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:476
msgid "``driver``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:477
msgid "Which driver has allocated this"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:477
msgid "``platform_data``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:478
msgid "Platform data specific to the device."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:485
msgid "``driver_data``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:486
msgid "Private pointer for driver specific info."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:474
msgid "``mutex``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:475
msgid "Mutex to synchronize calls to its driver."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:486
msgid "``links``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:487
msgid "Links to suppliers and consumers of this device."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:487
msgid "``power``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:488
msgid ""
"For device power management. See Documentation/driver-api/pm/devices.rst for "
"details."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:489
msgid "``pm_domain``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:490
msgid ""
"Provide callbacks that are executed during system suspend, hibernation, "
"system resume and during runtime PM transitions along with subsystem-level "
"and driver-level callbacks."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:492
msgid "``em_pd``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:493
msgid "device's energy model performance domain"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:493
msgid "``pins``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:494
msgid ""
"For device pin management. See Documentation/driver-api/pin-control.rst for "
"details."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:495
msgid "``msi``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:496
msgid "MSI related data"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:497
msgid "``dma_ops``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:498
msgid "DMA mapping operations for this device."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:498
msgid "``dma_mask``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:499
msgid "Dma mask (if dma'ble device)."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:499
msgid "``coherent_dma_mask``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:500
msgid ""
"Like dma_mask, but for alloc_coherent mapping as not all hardware supports "
"64-bit addresses for consistent allocations such descriptors."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:502
msgid "``bus_dma_limit``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:503
msgid ""
"Limit of an upstream bridge or bus which imposes a smaller DMA limit than "
"the device itself supports."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:504
msgid "``dma_range_map``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:505
msgid "map for DMA memory ranges relative to that of RAM"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:505
msgid "``dma_parms``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:506
msgid ""
"A low level driver may set these to teach IOMMU code about segment "
"limitations."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:507
msgid "``dma_pools``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:508
msgid "Dma pools (if dma'ble device)."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:508
msgid "``dma_mem``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:509
msgid "Internal for coherent mem override."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:509
msgid "``cma_area``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:510
msgid "Contiguous memory area for dma allocations"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:510
msgid "``dma_io_tlb_mem``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:511
msgid "Software IO TLB allocator.  Not for driver use."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:511
msgid "``dma_io_tlb_pools``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:512
msgid "List of transient swiotlb memory pools."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:512
msgid "``dma_io_tlb_lock``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:513
msgid "Protects changes to the list of active pools."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:513
msgid "``dma_uses_io_tlb``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:514
msgid "``true`` if device has used the software IO TLB."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:514
msgid "``archdata``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:515
msgid "For arch-specific additions."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:515
msgid "``of_node``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:516
msgid "Associated device tree node."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:516
msgid "``fwnode``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:517
msgid "Associated device node supplied by platform firmware."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:496
msgid "``numa_node``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:497
msgid "NUMA node this device is close to."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:517
msgid "``devt``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:518
msgid "For creating the sysfs \"dev\"."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:518
msgid "``id``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:519
msgid "device instance"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:519
msgid "``devres_lock``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:520
msgid "Spinlock to protect the resource of the device."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:520
msgid "``devres_head``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:521
msgid "The resources list of the device."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:521
msgid "``class``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:522
msgid "The class of the device."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:77
#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:522
msgid "``groups``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:523
msgid "Optional attribute groups."
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:102
#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:523
msgid "``release``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:524
msgid ""
"Callback to free the device after all references have gone away. This should "
"be set by the allocator of the device (i.e. the bus driver that discovered "
"the device)."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:526
msgid "``iommu_group``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:527
msgid "IOMMU group the device belongs to."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:527
msgid "``iommu``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:528
msgid "Per device generic IOMMU runtime data"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:528
msgid "``physical_location``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:529
msgid ""
"Describes physical location of the device connection point in the system "
"housing."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:530
msgid "``removable``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:531
msgid ""
"Whether the device can be removed from the system. This should be set by the "
"subsystem / bus driver that discovered the device."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:534
msgid "``offline_disabled``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:535
msgid "If set, the device is permanently online."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:54
#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:535
msgid "``offline``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:536
msgid "Set after successful invocation of bus type's .offline()."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:536
msgid "``of_node_reused``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:537
msgid "Set if the device-tree node is shared with an ancestor device."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:538
msgid "``state_synced``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:539
msgid ""
"The hardware state of this device has been synced to match the software "
"state of this device by calling the driver/bus sync_state() callback."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:541
msgid "``can_match``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:542
msgid ""
"The device has matched with a driver at least once or it is in a bus (like "
"AMBA) which can't check for matching drivers until other devices probe "
"successfully."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:544
msgid "``dma_coherent``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:545
msgid ""
"this particular device is dma coherent, even if the architecture supports "
"non-coherent devices."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:546
msgid "``dma_ops_bypass``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:547
msgid ""
"If set to ``true`` then the dma_ops are bypassed for the streaming DMA "
"operations (->map_* / ->unmap_* / ->sync_*), and optionall (if the coherent "
"mask is large enough) also for dma allocations.  This flag is managed by the "
"dma ops instance from ->dma_supported."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:551
msgid "``dma_skip_sync``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:552
msgid "DMA sync operations can be skipped for coherent buffers."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:552
msgid "``dma_iommu``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:553
msgid ""
"Device is using default IOMMU implementation for DMA and doesn't rely on "
"dma_ops structure."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:557
msgid "**Example**"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:478
msgid "For devices on custom boards, as typical of embedded"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:479
msgid ""
"and SOC based hardware, Linux often uses platform_data to point to board-"
"specific structures describing devices and how they are wired.  That can "
"include what ports are available, chip variants, which GPIO pins act in what "
"additional roles, and so on.  This shrinks the \"Board Support "
"Packages\" (BSPs) and minimizes board-specific #ifdefs in drivers."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:554
msgid ""
"At the lowest level, every device in a Linux system is represented by an "
"instance of struct device. The device structure contains the information "
"that the device model core needs to model the system. Most subsystems, "
"however, track additional information about the devices they host. As a "
"result, it is rare for devices to be represented by bare device structures; "
"instead, that structure, like kobject structures, is usually embedded within "
"a higher-level representation of the device."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:675
msgid "Device link representation."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:676
msgid "``supplier``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:677
msgid "The device on the supplier end of the link."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:677
msgid "``s_node``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:678
msgid "Hook to the supplier device's list of links to consumers."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:678
msgid "``consumer``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:679
msgid "The device on the consumer end of the link."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:679
msgid "``c_node``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:680
msgid "Hook to the consumer device's list of links to suppliers."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:680
msgid "``link_dev``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:681
msgid "device used to expose link details in sysfs"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:682
msgid "The state of the link (with respect to the presence of drivers)."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:682
msgid "``flags``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:672
#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:683
msgid "Link flags."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:683
msgid "``rpm_active``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:684
msgid "Whether or not the consumer device is runtime-PM-active."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:684
msgid "``kref``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:685
msgid "Count repeated addition of the same link."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:685
msgid "``rm_work``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:686
msgid "Work structure used for removing the link."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:686
msgid "``supplier_preactivated``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:687
msgid "Supplier has been made active before consumer probe."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:705
msgid "Returns true when the device DMA is translated by an IOMMU"
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:40
#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:2868
#: ../drivers/base/core.c:3045 ../drivers/base/core.c:3069
#: ../drivers/base/core.c:3082 ../drivers/base/core.c:3099
#: ../drivers/base/core.c:3114 ../drivers/base/core.c:3143
#: ../drivers/base/core.c:3488 ../drivers/base/core.c:3551
#: ../drivers/base/core.c:3757 ../drivers/base/core.c:3782
#: ../drivers/base/core.c:3796 ../drivers/base/core.c:3826
#: ../drivers/base/core.c:3912 ../drivers/base/core.c:4323
#: ../drivers/base/core.c:4485 ../drivers/base/core.c:4585
#: ../drivers/base/core.c:4720 ../drivers/base/core.c:5138
#: ../drivers/base/core.c:5183 ../drivers/base/core.c:5204
#: ../drivers/base/core.c:5228 ../drivers/base/core.c:5265
#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:604
#: ../drivers/base/class.c:616 ../../../driver-api/infrastructure:53:
#: ../drivers/base/transport_class.c:140 ../drivers/base/transport_class.c:191
#: ../drivers/base/transport_class.c:222 ../drivers/base/transport_class.c:261
#: ../drivers/base/transport_class.c:290 ../../../driver-api/infrastructure:56:
#: ../drivers/base/dd.c:283 ../drivers/base/dd.c:391 ../drivers/base/dd.c:488
#: ../drivers/base/dd.c:1067 ../drivers/base/dd.c:1129
#: ../drivers/base/dd.c:1319 ../../../driver-api/infrastructure:68:
#: ../drivers/base/bus.c:834 ../../../driver-api/infrastructure:74:
#: ../kernel/dma/mapping.c:67 ../kernel/dma/mapping.c:86
#: ../kernel/dma/mapping.c:269 ../kernel/dma/mapping.c:298
#: ../kernel/dma/mapping.c:459 ../kernel/dma/mapping.c:548
#: ../kernel/dma/mapping.c:567 ../kernel/dma/mapping.c:957
#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:711
msgid "``struct device *dev``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:707
msgid "Device to perform the check on"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:718
msgid "Return a device's name."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:2396
#: ../drivers/base/core.c:5037 ../drivers/base/core.c:5085
#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:724
#: ../include/linux/device.h:738
msgid "``const struct device *dev``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:719
msgid "Device with name to get."
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:45
#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:674
#: ../drivers/base/core.c:5226 ../../../driver-api/infrastructure:47:
#: ../drivers/base/faux.c:123 ../drivers/base/faux.c:201
#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:870
#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:280
#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:53
#: ../drivers/base/platform.c:95 ../drivers/base/platform.c:119
#: ../drivers/base/platform.c:138 ../drivers/base/platform.c:179
#: ../drivers/base/platform.c:275 ../drivers/base/platform.c:298
#: ../drivers/base/platform.c:318 ../drivers/base/platform.c:373
#: ../drivers/base/platform.c:506 ../drivers/base/platform.c:528
#: ../drivers/base/platform.c:543 ../drivers/base/platform.c:1069
#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:89
#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:721
msgid "**Return**"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:720
msgid "The kobject name of the device, or its initial name if unavailable."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:732
msgid "Return a device's bus/class name, if at all possible"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:733
msgid "struct device to get the bus/class name of"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:734
msgid ""
"Will return the name of the bus/class the device is attached to.  If it is "
"not attached to a bus/class, an empty string will be returned."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:980
msgid "device iterator for locating a child device."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4001
#: ../drivers/base/core.c:4031 ../drivers/base/core.c:4061
#: ../drivers/base/core.c:4096 ../drivers/base/core.c:4386
#: ../drivers/base/core.c:4421 ../../../driver-api/infrastructure:47:
#: ../drivers/base/faux.c:106 ../drivers/base/faux.c:188
#: ../../../driver-api/infrastructure:59:
#: ../include/linux/platform_device.h:148
#: ../include/linux/platform_device.h:211 ../../../driver-api/infrastructure:7:
#: ../include/linux/device.h:986 ../include/linux/device.h:1002
#: ../../../driver-api/infrastructure:98: ../drivers/uio/uio.c:975
#: ../drivers/uio/uio.c:1071
msgid "``struct device *parent``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4091
#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:981
#: ../include/linux/device.h:997
msgid "parent struct device"
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:176
#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4261
#: ../../../driver-api/infrastructure:38: ../include/linux/device/class.h:103
#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:261
#: ../drivers/base/class.c:572 ../../../driver-api/infrastructure:47:
#: ../drivers/base/faux.c:106 ../drivers/base/faux.c:190
#: ../../../driver-api/infrastructure:59:
#: ../include/linux/platform_device.h:147
#: ../include/linux/platform_device.h:181
#: ../include/linux/platform_device.h:208
#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:137
#: ../drivers/base/platform.c:460 ../drivers/base/platform.c:504
#: ../drivers/base/platform.c:525 ../drivers/base/platform.c:617
#: ../../../driver-api/infrastructure:65: ../include/linux/device/bus.h:162
#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:1356
#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:983
msgid "``const char *name``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:982
msgid "name of the child device"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:983
msgid ""
"This is similar to the device_find_child() function above, but it returns a "
"reference to a device that has the name **name**."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3152
#: ../drivers/base/core.c:3561 ../drivers/base/core.c:3763
#: ../drivers/base/core.c:3828 ../drivers/base/core.c:4103
#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:812
#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:363
#: ../drivers/base/bus.c:479 ../../../driver-api/infrastructure:7:
#: ../include/linux/device.h:986 ../include/linux/device.h:1001
msgid "**NOTE**"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4104
#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:987
#: ../include/linux/device.h:1002
msgid "you will need to drop the reference with put_device() after use."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:996
msgid "device iterator for locating a child device, if any."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:998
msgid ""
"This is similar to the device_find_child() function above, but it returns a "
"reference to a child device, if any."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:1028
msgid "``device_lock_set_class (dev, key)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:1026
msgid "Specify a temporary lock class while a device is attached to a driver"
msgstr ""

#: ../../../driver-api/infrastructure:44: ../include/linux/device/faux.h:21
#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:76
#: ../drivers/base/node.c:291 ../../../driver-api/infrastructure:7:
#: ../include/linux/device.h:1032 ../include/linux/device.h:1055
msgid "``dev``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:1028
#: ../include/linux/device.h:1050
msgid "device to modify"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:1030
msgid "``key``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:1029
msgid "lock class key data"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:1030
msgid ""
"This must be called with the device_lock() already held, for example from "
"driver ->probe(). Take care to only override the default lockdep_no_validate "
"class."
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:1051
msgid "``device_lock_reset_class (dev)``"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:1049
msgid "Return a device to the default lockdep novalidate state"
msgstr ""

#: ../../../driver-api/infrastructure:7: ../include/linux/device.h:1051
msgid ""
"This must be called with the device_lock() already held, for example from "
"driver ->remove()."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:25
msgid "The bus type of the device"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:28
msgid "The name of the bus."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:28
msgid "``dev_name``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:29
msgid "Used for subsystems to enumerate devices like (\"foo``u``\", dev->id)."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:29
msgid "``bus_groups``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:30
msgid "Default attributes of the bus."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:30
#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:29
#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:79
msgid "``dev_groups``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:31
msgid "Default attributes of the devices on the bus."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:31
msgid "``drv_groups``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:32
msgid "Default attributes of the device drivers on the bus."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:32
msgid "``match``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:33
msgid ""
"Called, perhaps multiple times, whenever a new device or driver is added for "
"this bus. It should return a positive value if the given device can be "
"handled by the given driver and zero otherwise. It may also return error "
"code if determining that the driver supports the device is not possible. In "
"case of -EPROBE_DEFER it will queue the device for deferred probing."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:38
msgid "``uevent``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:39
msgid ""
"Called when a device is added, removed, or a few other things that generate "
"uevents to add the environment variables."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:40
#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:61
#: ../../../driver-api/infrastructure:44: ../include/linux/device/faux.h:36
msgid "``probe``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:41
msgid ""
"Called when a new device or driver add to this bus, and callback the "
"specific driver's probe to initial the matched device."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:42
#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:64
msgid "``sync_state``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:43
#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:65
msgid ""
"Called to sync device state to software state after all the state tracking "
"consumers linked to this device (present at the time of late_initcall) have "
"successfully bound to a driver. If the device has no consumers, this "
"function will be called at late_initcall_sync level. If the device has "
"consumers that are never bound to a driver, this function will never get "
"called until they do."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:49
#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:71
#: ../../../driver-api/infrastructure:44: ../include/linux/device/faux.h:41
msgid "``remove``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:50
msgid "Called when a device removed from this bus."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:50
#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:73
msgid "``shutdown``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:51
#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:74
msgid "Called at shut-down time to quiesce the device."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:51
msgid "``irq_get_affinity``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:52
msgid "Get IRQ affinity mask for the device on this bus."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:53
msgid "``online``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:54
msgid "Called to put the device back online (after offlining it)."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:55
msgid "Called to put the device offline for hot-removal. May fail."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:56
#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:74
msgid "``suspend``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:57
msgid "Called when a device on this bus wants to go to sleep mode."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:57
#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:76
msgid "``resume``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:58
msgid "Called to bring a device on this bus out of sleep mode."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:58
msgid "``num_vf``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:59
msgid ""
"Called to find out how many virtual functions a device on this bus supports."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:60
msgid "``dma_configure``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:61
msgid "Called to setup DMA configuration on a device on this bus."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:62
msgid "``dma_cleanup``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:63
msgid "Called to cleanup DMA configuration on a device on this bus."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:64
#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:42
#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:81
msgid "``pm``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:65
msgid ""
"Power management operations of this bus, callback the specific device "
"driver's pm-ops."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:66
msgid "``need_parent_lock``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:67
msgid ""
"When probing or removing a device on this bus, the device core should lock "
"the device's parent."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:68
msgid ""
"A bus is a channel between the processor and one or more devices. For the "
"purposes of the device model, all devices are connected via a bus, even if "
"it is an internal, virtual, \"platform\" bus. Buses can plug into each "
"other. A USB controller is usually a PCI device, for example. The device "
"model represents the actual connections between buses and the devices they "
"control. A bus is represented by the bus_type structure. It contains the "
"name, the default attributes, the bus' methods, PM operations, and the "
"driver core's private data."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:257
msgid "Bus Notifier events that have happened"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:263
msgid "``BUS_NOTIFY_ADD_DEVICE``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:264
msgid "device is added to this bus"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:266
msgid "``BUS_NOTIFY_DEL_DEVICE``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:267
msgid "device is about to be removed from this bus"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:269
msgid "``BUS_NOTIFY_REMOVED_DEVICE``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:270
msgid "device is successfully removed from this bus"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:272
msgid "``BUS_NOTIFY_BIND_DRIVER``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:273
msgid "a driver is about to be bound to this device on this bus"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:275
msgid "``BUS_NOTIFY_BOUND_DRIVER``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:276
msgid "a driver is successfully bound to this device on this bus"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:278
msgid "``BUS_NOTIFY_UNBIND_DRIVER``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:279
msgid "a driver is about to be unbound from this device on this bus"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:281
msgid "``BUS_NOTIFY_UNBOUND_DRIVER``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:282
msgid "a driver is successfully unbound from this device on this bus"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:284
msgid "``BUS_NOTIFY_DRIVER_NOT_BOUND``"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:285
msgid "a driver failed to be bound to this device on this bus"
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:266
msgid ""
"These are the value passed to a bus notifier when a specific event happens."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:268
msgid ""
"Note that bus notifiers are likely to be called with the device lock already "
"held by the driver core, so be careful in any notifier callback as to what "
"you do with the device structure."
msgstr ""

#: ../../../driver-api/infrastructure:11: ../include/linux/device/bus.h:272
msgid ""
"All bus notifiers are called with the target struct device * as an argument."
msgstr ""

#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:26
msgid "device classes"
msgstr ""

#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:28
msgid "Name of the class."
msgstr ""

#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:28
msgid "``class_groups``"
msgstr ""

#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:29
msgid "Default attributes of this class."
msgstr ""

#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:30
msgid "Default attributes of the devices that belong to the class."
msgstr ""

#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:30
msgid "``dev_uevent``"
msgstr ""

#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:31
msgid ""
"Called when a device is added, removed from this class, or a few other "
"things that generate uevents to add the environment variables."
msgstr ""

#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:33
msgid "``devnode``"
msgstr ""

#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:34
msgid "Callback to provide the devtmpfs."
msgstr ""

#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:34
msgid "``class_release``"
msgstr ""

#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:35
msgid "Called to release this class."
msgstr ""

#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:35
msgid "``dev_release``"
msgstr ""

#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:36
msgid "Called to release the device."
msgstr ""

#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:36
msgid "``shutdown_pre``"
msgstr ""

#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:37
msgid "Called at shut-down time before driver shutdown."
msgstr ""

#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:37
msgid "``ns_type``"
msgstr ""

#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:38
msgid "Callbacks so sysfs can detemine namespaces."
msgstr ""

#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:38
msgid "``namespace``"
msgstr ""

#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:39
msgid "Namespace of the device belongs to this class."
msgstr ""

#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:39
msgid "``get_ownership``"
msgstr ""

#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:40
msgid ""
"Allows class to specify uid/gid of the sysfs directories for the devices "
"belonging to the class. Usually tied to device's namespace."
msgstr ""

#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:43
msgid "The default device power management operations of this class."
msgstr ""

#: ../../../driver-api/infrastructure:14: ../include/linux/device/class.h:43
msgid ""
"A class is a higher-level view of a device that abstracts out low-level "
"implementation details. Drivers may see a SCSI disk or an ATA disk, but, at "
"the class level, they are all simply disks. Classes allow user space to work "
"with devices based on what they do, rather than how they are connected or "
"how they work."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:24
msgid ""
"device driver probe type to try Device drivers may opt in for special "
"handling of their respective probe routines. This tells the core what to "
"expect and prefer."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:30
msgid "``PROBE_DEFAULT_STRATEGY``"
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:31
msgid ""
"Used by drivers that work equally well whether probed synchronously or "
"asynchronously."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:34
msgid "``PROBE_PREFER_ASYNCHRONOUS``"
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:35
msgid ""
"Drivers for \"slow\" devices which probing order is not essential for "
"booting the system may opt into executing their probes asynchronously."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:39
msgid "``PROBE_FORCE_SYNCHRONOUS``"
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:40
msgid ""
"Use this to annotate drivers that need their probe routines to run "
"synchronously with driver and device registration (with the exception of -"
"EPROBE_DEFER handling - re-probing always ends up being done asynchronously)."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:38
msgid ""
"Note that the end goal is to switch the kernel to use asynchronous probing "
"by default, so annotating drivers with ``PROBE_PREFER_ASYNCHRONOUS`` is a "
"temporary measure that allows us to speed up boot process while we are "
"validating the rest of the drivers."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:52
msgid "The basic device driver structure"
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:54
msgid "Name of the device driver."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:55
msgid "The bus which the device of this driver belongs to."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:55
msgid "``owner``"
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:56
msgid "The module owner."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:56
msgid "``mod_name``"
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:57
msgid "Used for built-in modules."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:57
msgid "``suppress_bind_attrs``"
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:58
msgid "Disables bind/unbind via sysfs."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:58
msgid "``probe_type``"
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:59
msgid "Type of the probe (synchronous or asynchronous) to use."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:59
msgid "``of_match_table``"
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:60
msgid "The open firmware table."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:60
msgid "``acpi_match_table``"
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:61
msgid "The ACPI match table."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:62
msgid ""
"Called to query the existence of a specific device, whether this driver can "
"work with it, and bind the driver to a specific device."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:72
msgid ""
"Called when the device is removed from the system to unbind a device from "
"this driver."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:75
msgid "Called to put the device to sleep mode. Usually to a low power state."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:77
msgid "Called to bring a device from sleep mode."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:78
msgid "Default attributes that get created by the driver core automatically."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:80
msgid ""
"Additional attributes attached to device instance once it is bound to the "
"driver."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:82
msgid "Power management operations of the device which matched this driver."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:83
msgid "``coredump``"
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:84
msgid ""
"Called when sysfs entry is written to. The device driver is expected to call "
"the dev_coredump API resulting in a uevent."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:87
msgid ""
"Driver core's private data, no one other than the driver core can touch this."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:88
msgid "``p_cb``"
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:89
msgid ""
"Callbacks private to the driver core; no one other than the driver core is "
"allowed to touch this."
msgstr ""

#: ../../../driver-api/infrastructure:17: ../include/linux/device/driver.h:90
msgid ""
"The device driver-model tracks all of the drivers known to the system. The "
"main reason for this tracking is to enable the driver core to match up "
"drivers with new devices. Once drivers are known objects within the system, "
"however, a number of other things become possible. Device drivers can export "
"information and configuration variables that are independent of any specific "
"device."
msgstr ""

#: ../../../driver-api/infrastructure.rst:21
msgid "Device Drivers Base"
msgstr ""

#: ../../../driver-api/infrastructure:23: ../drivers/base/init.c:16
msgid "initialize driver model."
msgstr ""

#: ../../../driver-api/infrastructure:23: ../drivers/base/init.c:22
#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:547
#: ../../../driver-api/infrastructure:35: ../drivers/base/syscore.c:49
#: ../drivers/base/syscore.c:95 ../../../driver-api/infrastructure:56:
#: ../drivers/base/dd.c:774
msgid "``void``"
msgstr ""

#: ../../../driver-api/infrastructure:23: ../drivers/base/init.c:1
#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:1
#: ../../../driver-api/infrastructure:35: ../drivers/base/syscore.c:1
#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:1
msgid "no arguments"
msgstr ""

#: ../../../driver-api/infrastructure:23: ../drivers/base/init.c:17
msgid ""
"Call the driver model init functions to initialize their subsystems. Called "
"early from init/main.c."
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:172
#: ../../../driver-api/infrastructure:38: ../include/linux/device/class.h:99
#: ../../../driver-api/infrastructure:65: ../include/linux/device/bus.h:157
msgid "device iterator for locating a particular device of a specific name."
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:178
#: ../include/linux/device/driver.h:190 ../include/linux/device/driver.h:216
#: ../include/linux/device/driver.h:235 ../../../driver-api/infrastructure:29:
#: ../drivers/base/driver.c:143 ../drivers/base/driver.c:181
#: ../drivers/base/driver.c:199 ../../../driver-api/infrastructure:56:
#: ../drivers/base/dd.c:1132 ../drivers/base/dd.c:1240
#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:1540
msgid "``const struct device_driver *drv``"
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:174
#: ../include/linux/device/driver.h:186 ../include/linux/device/driver.h:199
#: ../include/linux/device/driver.h:212 ../include/linux/device/driver.h:231
msgid "the driver we're iterating"
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:175
#: ../../../driver-api/infrastructure:38: ../include/linux/device/class.h:102
#: ../../../driver-api/infrastructure:65: ../include/linux/device/bus.h:161
msgid "name of the device to match"
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:184
msgid "device iterator for locating a particular device by of_node pointer."
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:188
#: ../../../driver-api/infrastructure:38: ../include/linux/device/class.h:115
#: ../../../driver-api/infrastructure:65: ../include/linux/device/bus.h:175
msgid "``const struct device_node *np``"
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:187
msgid "of_node pointer to match."
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:197
msgid "device iterator for locating a particular device by fwnode pointer."
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:203
#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:115
#: ../drivers/base/driver.c:224 ../drivers/base/driver.c:271
msgid "``struct device_driver *drv``"
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:201
#: ../../../driver-api/infrastructure:38: ../include/linux/device/class.h:127
#: ../../../driver-api/infrastructure:65: ../include/linux/device/bus.h:187
msgid "``const struct fwnode_handle *fwnode``"
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:200
msgid "fwnode pointer to match."
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:210
msgid "device iterator for locating a particular device by devt."
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:214
#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4387
#: ../drivers/base/core.c:4422 ../drivers/base/core.c:4462
#: ../../../driver-api/infrastructure:38: ../include/linux/device/class.h:139
#: ../../../driver-api/infrastructure:65: ../include/linux/device/bus.h:199
msgid "``dev_t devt``"
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:213
msgid "devt pointer to match."
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:229
#: ../../../driver-api/infrastructure:38: ../include/linux/device/class.h:149
msgid ""
"device iterator for locating a particular device matching the ACPI_COMPANION "
"device."
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:233
#: ../../../driver-api/infrastructure:38: ../include/linux/device/class.h:153
#: ../../../driver-api/infrastructure:65: ../include/linux/device/bus.h:226
msgid "``const struct acpi_device *adev``"
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:232
#: ../../../driver-api/infrastructure:38: ../include/linux/device/class.h:152
msgid "ACPI_COMPANION device to match."
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:255
msgid "``module_driver (__driver, __register, __unregister, ...)``"
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:253
msgid ""
"Helper macro for drivers that don't do anything special in module init/exit. "
"This eliminates a lot of boilerplate. Each module may only use this macro "
"once, and calling it replaces module_init() and module_exit()."
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:259
#: ../include/linux/device/driver.h:285
msgid "``__driver``"
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:258
#: ../include/linux/device/driver.h:286
msgid "driver name"
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:260
#: ../include/linux/device/driver.h:288
msgid "``__register``"
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:259
#: ../include/linux/device/driver.h:287
msgid "register function for this driver type"
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:261
msgid "``__unregister``"
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:260
msgid "unregister function for this driver type"
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:262
#: ../include/linux/device/driver.h:289 ../../../driver-api/infrastructure:32:
#: ../drivers/base/core.c:3486 ../drivers/base/core.c:4390
#: ../drivers/base/core.c:4426 ../drivers/base/core.c:5036
#: ../drivers/base/core.c:5084
msgid "``...``"
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:261
msgid "Additional arguments to be passed to __register and __unregister."
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:262
#: ../include/linux/device/driver.h:289
msgid ""
"Use this macro to construct bus specific macros for registering drivers, and "
"do not use it on its own."
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:281
msgid "``builtin_driver (__driver, __register, ...)``"
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:279
msgid ""
"Helper macro for drivers that don't do anything special in init and have no "
"exit. This eliminates some boilerplate. Each driver may only use this macro "
"once, and calling it replaces device_initcall (or in some cases, the legacy "
"__initcall). This is meant to be a direct parallel of module_driver() above "
"but without the __exit stuff that is not used for builtin cases."
msgstr ""

#: ../../../driver-api/infrastructure:26: ../include/linux/device/driver.h:288
msgid "Additional arguments to be passed to __register"
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:34
msgid "Helper to set or clear driver override."
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:35
msgid "Device to change"
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:37
msgid "``const char **override``"
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:36
msgid ""
"Address of string to change (e.g. :c:type:`device->driver_override "
"<device>`); The contents will be freed and hold newly allocated override."
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:39
msgid "``const char *s``"
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:38
msgid ""
"NUL-terminated string, new driver name to force a match, pass empty string "
"to clear it (\"\" or \"\\n\", where the latter is only for sysfs interface)."
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:42
msgid "``size_t len``"
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:41
msgid "length of **s**"
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:42
msgid ""
"Helper to set or clear driver override in a device, intended for the cases "
"when the driver_override field is allocated by driver/bus code."
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:46
#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:1070
msgid "0 on success or a negative error code on failure."
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:109
msgid "Iterator for devices bound to a driver."
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:110
msgid "Driver we're iterating."
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:112
#: ../drivers/base/driver.c:140 ../../../driver-api/infrastructure:62:
#: ../drivers/base/platform.c:1542 ../../../driver-api/infrastructure:65:
#: ../include/linux/device/bus.h:161 ../../../driver-api/infrastructure:68:
#: ../drivers/base/bus.c:354 ../drivers/base/bus.c:394
msgid "``struct device *start``"
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:111
#: ../drivers/base/driver.c:139 ../../../driver-api/infrastructure:41:
#: ../drivers/base/class.c:436 ../../../driver-api/infrastructure:65:
#: ../include/linux/device/bus.h:160 ../../../driver-api/infrastructure:68:
#: ../drivers/base/bus.c:393
msgid "Device to begin with"
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:113
#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3998
#: ../drivers/base/core.c:4028 ../drivers/base/core.c:4059
#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:391
#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:355
#: ../drivers/base/bus.c:472
msgid "``void *data``"
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:112
msgid "Data to pass to the callback."
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:114
#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3999
#: ../drivers/base/core.c:4029 ../drivers/base/core.c:4060
#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:392
#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:356
msgid "``device_iter_t fn``"
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:113
msgid "Function to call for each device."
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:114
msgid "Iterate over the **drv**'s list of devices calling **fn** for each one."
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:137
#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4090
#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:391
msgid "device iterator for locating a particular device."
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:138
msgid "The device's driver"
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:141
#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4093
#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:438
#: ../../../driver-api/infrastructure:59:
#: ../include/linux/platform_device.h:151
#: ../include/linux/platform_device.h:210
#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:668
#: ../drivers/base/platform.c:1009 ../../../driver-api/infrastructure:68:
#: ../drivers/base/bus.c:395
msgid "``const void *data``"
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:140
#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4092
#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:394
msgid "Data to pass to match function"
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:142
#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4094
#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:439
#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:396
msgid "``device_match_t match``"
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:141
#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4093
#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:395
msgid "Callback function to check device"
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:142
msgid ""
"This is similar to the driver_for_each_device() function above, but it "
"returns a reference to a device that is 'found' for later use, as determined "
"by the **match** callback."
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:146
#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:443
#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:400
msgid ""
"The callback should return 0 if the device doesn't match and non-zero if it "
"does.  If the callback returns non-zero, this function will return to the "
"caller and not iterate over any more devices."
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:175
msgid "create sysfs file for driver."
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:176
#: ../drivers/base/driver.c:194 ../drivers/base/driver.c:266
#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:1235
msgid "driver."
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:178
#: ../drivers/base/driver.c:196
msgid "``const struct driver_attribute *attr``"
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:177
#: ../drivers/base/driver.c:195
msgid "driver attribute descriptor."
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:193
msgid "remove sysfs file for driver."
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:218
msgid "register driver with bus"
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:219
msgid "driver to register"
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:220
msgid ""
"We pass off most of the work to the bus_add_driver() call, since most of the "
"things we have to do deal with the bus structures."
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:265
msgid "remove driver from system."
msgstr ""

#: ../../../driver-api/infrastructure:29: ../drivers/base/driver.c:267
msgid "Again, we pass off most of the work to the bus-level call."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:541
msgid "Wait for ongoing devlink removal jobs to terminate"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:669
msgid "Create a link between two devices."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:675
msgid "``struct device *consumer``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:670
#: ../drivers/base/core.c:969
msgid "Consumer end of the link."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:672
#: ../drivers/base/core.c:971
msgid "``struct device *supplier``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:671
#: ../drivers/base/core.c:970
msgid "Supplier end of the link."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:673
msgid "``u32 flags``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:674
msgid ""
"On success, a device_link struct will be returned. On error or invalid flag "
"settings, NULL will be returned."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:676
msgid ""
"The caller is responsible for the proper synchronization of the link "
"creation with runtime PM.  First, setting the DL_FLAG_PM_RUNTIME flag will "
"cause the runtime PM framework to take the link into account.  Second, if "
"the DL_FLAG_RPM_ACTIVE flag is set in addition to it, the supplier devices "
"will be forced into the active meta state and reference-counted upon the "
"creation of the link.  If DL_FLAG_PM_RUNTIME is not set, DL_FLAG_RPM_ACTIVE "
"will be ignored."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:684
msgid ""
"If DL_FLAG_STATELESS is set in **flags**, the caller of this function is "
"expected to release the link returned by it directly with the help of either "
"device_link_del() or device_link_remove()."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:688
msgid ""
"If that flag is not set, however, the caller of this function is handing the "
"management of the link over to the driver core entirely and its return value "
"can only be used to check whether or not the link is present.  In that case, "
"the DL_FLAG_AUTOREMOVE_CONSUMER and DL_FLAG_AUTOREMOVE_SUPPLIER device link "
"flags can be used to indicate to the driver core when the link can be safely "
"deleted.  Namely, setting one of them in **flags** indicates to the driver "
"core that the link is not going to be used (by the given caller of this "
"function) after unbinding the consumer or supplier driver, respectively, "
"from its device, so the link can be deleted at that point.  If none of them "
"is set, the link will be maintained until one of the devices pointed to by "
"it (either the consumer or the supplier) is unregistered."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:700
msgid ""
"Also, if DL_FLAG_STATELESS, DL_FLAG_AUTOREMOVE_CONSUMER and "
"DL_FLAG_AUTOREMOVE_SUPPLIER are not set in **flags** (that is, a persistent "
"managed device link is being added), the DL_FLAG_AUTOPROBE_CONSUMER flag can "
"be used to request the driver core to automatically probe for a consumer "
"driver after successfully binding a driver to the supplier device."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:706
msgid ""
"The combination of DL_FLAG_STATELESS and one of DL_FLAG_AUTOREMOVE_CONSUMER, "
"DL_FLAG_AUTOREMOVE_SUPPLIER, or DL_FLAG_AUTOPROBE_CONSUMER set in **flags** "
"at the same time is invalid and will cause NULL to be returned upfront. "
"However, if a device link between the given **consumer** and **supplier** "
"pair exists already when this function is called for them, the existing link "
"will be returned regardless of its current type and status (the link's flags "
"may be modified then).  The caller of this function is then expected to "
"treat the link as though it has just been created, so (in particular) if "
"DL_FLAG_STATELESS was passed in **flags**, the link needs to be released "
"explicitly when not needed any more (as stated above)."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:717
msgid ""
"A side effect of the link creation is re-ordering of dpm_list and the "
"devices_kset list by moving the consumer device and all devices depending on "
"it to the ends of these lists (that does not happen to devices that have not "
"been registered when this function is called)."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:722
msgid ""
"The supplier device is required to be registered when this function is "
"called and NULL will be returned if that is not the case.  The consumer "
"device need not be registered, however."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:951
#: ../drivers/base/core.c:968
msgid "Delete a stateless link between two devices."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:957
msgid "``struct device_link *link``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:952
msgid "Device link to delete."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:953
msgid ""
"The caller must ensure proper synchronization of this function with runtime "
"PM.  If the link was added multiple times, it needs to be deleted as often. "
"Care is required for hotplugged devices:  Their links are purged on removal "
"and calling device_link_del() is then no longer allowed."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:974
msgid "``void *consumer``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:971
msgid ""
"The caller must ensure proper synchronization of this function with runtime "
"PM."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:2390
msgid "Return a device's driver name, if at all possible"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:2391
msgid "struct device to get the name of"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:2392
msgid ""
"Will return the device's driver's name if it is bound to a device.  If the "
"device is not bound to a driver, it will return the name of the bus it is "
"attached to.  If it is not attached to a bus either, an empty string will be "
"returned."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:2862
msgid "given a device, create a managed attribute group"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:2863
msgid "The device to create the group for"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:2865
msgid "``const struct attribute_group *grp``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:2864
msgid "The attribute group to create"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:2865
msgid ""
"This function creates a group for the first time.  It will explicitly warn "
"and error if any of the attribute files being created already exist."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:2868
#: ../drivers/base/core.c:4722
msgid "Returns 0 on success or error code on failure."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3039
msgid "create sysfs attribute file for device."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3040
#: ../drivers/base/core.c:3064 ../drivers/base/core.c:3077
#: ../drivers/base/core.c:3094 ../drivers/base/core.c:3109
#: ../drivers/base/core.c:3138 ../drivers/base/core.c:3546
#: ../drivers/base/core.c:3777 ../drivers/base/core.c:3821
#: ../drivers/base/core.c:4715 ../../../driver-api/infrastructure:56:
#: ../drivers/base/dd.c:483 ../drivers/base/dd.c:1062 ../drivers/base/dd.c:1314
msgid "device."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3042
#: ../drivers/base/core.c:3066 ../drivers/base/core.c:3079
msgid "``const struct device_attribute *attr``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3041
#: ../drivers/base/core.c:3065 ../drivers/base/core.c:3078
msgid "device attribute descriptor."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3063
msgid "remove sysfs attribute file."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3076
msgid "remove sysfs attribute file from its own method."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3079
msgid "See kernfs_remove_self() for details."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3093
msgid "create sysfs binary attribute file for device."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3096
#: ../drivers/base/core.c:3111
msgid "``const struct bin_attribute *attr``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3095
#: ../drivers/base/core.c:3110
msgid "device binary attribute descriptor."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3108
msgid "remove sysfs binary attribute file"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3137
msgid "init device structure."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3139
msgid ""
"This prepares the device for use by other layers by initializing its fields. "
"It is the first half of device_register(), if called by that function, "
"though it can also be called separately, so one may use **dev**'s fields. In "
"particular, get_device()/put_device() may be used for reference counting of "
"**dev** after calling this function."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3147
msgid ""
"All fields in **dev** must be initialized by the caller to 0, except for "
"those explicitly set to some other value.  The simplest approach is to use "
"kzalloc() to allocate the structure containing **dev**."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3153
msgid ""
"Use put_device() to give up your reference instead of freeing **dev** "
"directly once you have called this function."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3482
msgid "set a device name"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3483
msgid "device"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3485
#: ../drivers/base/core.c:4389 ../drivers/base/core.c:4425
#: ../drivers/base/core.c:5035 ../drivers/base/core.c:5083
msgid "``const char *fmt``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3484
msgid "format string for the device's name"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:1
msgid "variable arguments"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3545
msgid "add device to device hierarchy."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3547
msgid ""
"This is part 2 of device_register(), though may be called separately _iff_ "
"device_initialize() has been called separately."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3550
msgid ""
"This adds **dev** to the kobject hierarchy via kobject_add(), adds it to the "
"global and sibling lists for the device, then adds it to the other relevant "
"subsystems of the driver model."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3554
msgid ""
"Do not call this routine or device_register() more than once for any device "
"structure.  The driver model core is not designed to work with devices that "
"get unregistered and then spring back to life. (Among other things, it's "
"very hard to guarantee that all references to the previous incarnation of "
"**dev** have been dropped.)  Allocate and register a fresh new struct device "
"instead."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3562
msgid ""
"_Never_ directly free **dev** after calling this function, even if it "
"returned an error! Always use put_device() to give up your reference instead."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3566
msgid ""
"Rule of thumb is: if device_add() succeeds, you should call device_del() "
"when you want to get rid of it. If device_add() has *not* succeeded, use "
"*only* put_device() to drop the reference count."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3751
msgid "register a device with the system."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3752
msgid "pointer to the device structure"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3753
msgid ""
"This happens in two clean steps - initialize the device and add it to the "
"system. The two steps can be called separately, but this is the easiest and "
"most common. I.e. you should only call the two helpers separately if have a "
"clearly defined need to use and refcount the device before it is added to "
"the hierarchy."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3760
msgid ""
"For more information, see the kerneldoc for device_initialize() and "
"device_add()."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3764
msgid ""
"_Never_ directly free **dev** after calling this function, even if it "
"returned an error! Always use put_device() to give up the reference "
"initialized in this function instead."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3776
msgid "increment reference count for device."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3778
msgid ""
"This simply forwards the call to kobject_get(), though we do take care to "
"provide for the case that we get a NULL pointer passed in."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3790
msgid "decrement reference count."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3791
msgid "device in question."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3820
msgid "delete device from system."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3822
msgid ""
"This is the first part of the device unregistration sequence. This removes "
"the device from the lists we control from here, has it removed from the "
"other driver model subsystems it was added to in device_add(), and removes "
"it from the kobject hierarchy."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3829
msgid ""
"this should be called manually _iff_ device_add() was also called manually."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3906
msgid "unregister device from system."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3907
msgid "device going away."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3908
msgid ""
"We do this in two parts, like we do device_register(). First, we remove it "
"from all the subsystems with device_del(), then we decrement the reference "
"count via put_device(). If that is the final reference count, the device "
"will be cleaned up via device_release() above. Otherwise, the structure will "
"stick around until the final reference to the device is dropped."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3995
msgid "device child iterator."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3996
#: ../drivers/base/core.c:4026 ../drivers/base/core.c:4056
msgid "parent struct device."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3997
#: ../drivers/base/core.c:4027 ../drivers/base/core.c:4058
#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:354
msgid "data for the callback."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3998
#: ../drivers/base/core.c:4028 ../drivers/base/core.c:4059
#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:355
msgid "function to be called for each device."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:3999
#: ../drivers/base/core.c:4029
msgid ""
"Iterate over **parent**'s child devices, and call **fn** for each, passing "
"it **data**."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4002
#: ../drivers/base/core.c:4032 ../../../driver-api/infrastructure:41:
#: ../drivers/base/class.c:397 ../../../driver-api/infrastructure:68:
#: ../drivers/base/bus.c:360
msgid ""
"We check the return of **fn** each time. If it returns anything other than "
"0, we break out and return that value."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4025
#: ../drivers/base/core.c:4055
msgid "device child iterator in reversed order."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4058
msgid "``struct device *from``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4057
msgid "optional starting point in child list"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4060
msgid ""
"Iterate over **parent**'s child devices, starting at **from**, and call "
"**fn** for each, passing it **data**. This helper is identical to "
"device_for_each_child_reverse() when **from** is NULL."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4064
msgid ""
"**fn** is checked each iteration. If it returns anything other than 0, "
"iteration stop and that value is returned to the caller of "
"device_for_each_child_reverse_from();"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4094
msgid ""
"This is similar to the device_for_each_child() function above, but it "
"returns a reference to a device that is 'found' for later use, as determined "
"by the **match** callback."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4098
msgid ""
"The callback should return 0 if the device doesn't match and non-zero if it "
"does.  If the callback returns non-zero and a reference to the current "
"device can be obtained, this function will return to the caller and not "
"iterate over any more devices."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4255
msgid "allocate and register a root device"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4256
msgid "root device name"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4258
#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:901
#: ../drivers/base/platform.c:1064 ../../../driver-api/infrastructure:98:
#: ../drivers/uio/uio.c:978 ../drivers/uio/uio.c:1074
msgid "``struct module *owner``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4257
msgid "owner module of the root device, usually THIS_MODULE"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4258
msgid ""
"This function allocates a root device and registers it using "
"device_register(). In order to free the returned device, use "
"root_device_unregister()."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4262
msgid ""
"Root devices are dummy devices which allow other devices to be grouped "
"under /sys/devices. Use this function to allocate a root device and then use "
"it as the parent of any device which should appear under /sys/devices/{name}"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4267
msgid ""
"The /sys/devices/{name} directory will also contain a 'module' symlink which "
"points to the **owner** directory in sysfs."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4271
#: ../drivers/base/core.c:4400 ../drivers/base/core.c:4438
msgid ""
"Returns :c:type:`struct device <device>` pointer on success, or ERR_PTR() on "
"error."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4273
#: ../drivers/base/core.c:4487
msgid "**Note**"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4274
msgid "You probably want to use root_device_register()."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4317
msgid "unregister and free a root device"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4318
msgid "device going away"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4319
msgid ""
"This function unregisters and cleans up a device that was created by "
"root_device_register()."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4383
#: ../drivers/base/core.c:4418
msgid "creates a device and registers it with sysfs"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4389
#: ../drivers/base/core.c:4424 ../drivers/base/core.c:4465
#: ../../../driver-api/infrastructure:38: ../include/linux/device/class.h:105
#: ../include/linux/device/class.h:117 ../include/linux/device/class.h:129
#: ../include/linux/device/class.h:141 ../include/linux/device/class.h:155
#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:312
#: ../drivers/base/class.c:393 ../drivers/base/class.c:440
#: ../drivers/base/class.c:630
msgid "``const struct class *class``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4384
#: ../drivers/base/core.c:4419
msgid "pointer to the struct class that this device should be registered to"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4385
#: ../drivers/base/core.c:4420
msgid "pointer to the parent struct device of this new device, if any"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4386
#: ../drivers/base/core.c:4421
msgid "the dev_t for the char device to be added"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4388
#: ../drivers/base/core.c:4423
msgid "``void *drvdata``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4387
#: ../drivers/base/core.c:4422
msgid "the data to be added to the device for callbacks"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4388
#: ../drivers/base/core.c:4424
msgid "string for the device's name"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4389
msgid ""
"This function can be used by char device classes.  A struct device will be "
"created in sysfs, registered to the specified class."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4392
#: ../drivers/base/core.c:4430
msgid ""
"A \"dev\" file will be created, showing the dev_t for the device, if the "
"dev_t is not 0,0. If a pointer to a parent struct device is passed in, the "
"newly created struct device will be a child of that device in sysfs. The "
"pointer to the struct device will be returned from the call. Any further "
"sysfs files that might be required can be created using this pointer."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4424
#: ../../../driver-api/infrastructure:47: ../drivers/base/faux.c:111
#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:1304
#: ../drivers/base/bus.c:1329
msgid "``const struct attribute_group **groups``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4423
msgid "NULL-terminated list of attribute groups to be created"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4425
msgid ""
"This function can be used by char device classes.  A struct device will be "
"created in sysfs, registered to the specified class. Additional attributes "
"specified in the groups parameter will also be created automatically."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4459
msgid "removes a device that was created with device_create()"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4460
msgid "pointer to the struct class that this device was registered with"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4461
msgid "the dev_t of the device that was previously registered"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4462
msgid ""
"This call unregisters and cleans up a device that was created with a call to "
"device_create()."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4479
msgid "renames a device"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4480
msgid "the pointer to the struct device to be renamed"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4482
msgid "``const char *new_name``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4481
msgid "the new name of the device"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4482
msgid ""
"It is the responsibility of the caller to provide mutual exclusion between "
"two different calls of device_rename on the same device to ensure that "
"new_name is valid and won't conflict with other devices."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4488
msgid ""
"given that some subsystems (networking and infiniband) use this function, "
"with no immediate plans for this to change, we cannot assume or require that "
"this function not be called at all."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4492
msgid ""
"However, if you're writing new code, do not call this function. The "
"following text from Kay Sievers offers some insight:"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4495
msgid ""
"Renaming devices is racy at many levels, symlinks and other stuff are not "
"replaced atomically, and you get a \"move\" uevent, but it's not easy to "
"connect the event to the old and new device. Device nodes are not renamed at "
"all, there isn't even support for that in the kernel now."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4500
msgid ""
"In the meantime, during renaming, your target name might be taken by another "
"driver, creating conflicts. Or the old name is taken directly after you "
"renamed it -- then you get events for the same DEVPATH, before you even see "
"the \"move\" event. It's just a mess, and nothing new should ever rely on "
"kernel device renaming. Besides that, it's not even implemented now for "
"other things than (driver-core wise very simple) network devices."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4507
msgid ""
"Make up a \"real\" name in the driver before you register anything, or add "
"some other attributes for userspace to find the device, or use udev to add "
"symlinks -- but never rename kernel devices later, it's a complete mess. We "
"don't even want to get into that and try to implement the missing pieces in "
"the core. We really have other pieces to fix in the driver core mess. :)"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4579
msgid "moves a device to a new parent"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4580
msgid "the pointer to the struct device to be moved"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4582
msgid "``struct device *new_parent``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4581
msgid "the new parent of the device (can be NULL)"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4583
msgid "``enum dpm_order dpm_order``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4582
msgid "how to reorder the dpm_list"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4714
msgid "change the owner of an existing device."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4717
msgid "``kuid_t kuid``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4716
msgid "new owner's kuid"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4718
msgid "``kgid_t kgid``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4717
msgid "new owner's kgid"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:4718
msgid ""
"This changes the owner of **dev** and its corresponding sysfs entries to "
"**kuid**/**kgid**. This function closely mirrors how **dev** was added via "
"driver core."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5031
#: ../drivers/base/core.c:5079
msgid "probe error check and log helper"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5032
#: ../drivers/base/core.c:5080
msgid "the pointer to the struct device"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5034
#: ../drivers/base/core.c:5082
msgid "``int err``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5033
#: ../drivers/base/core.c:5081
msgid "error value to test"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5034
#: ../drivers/base/core.c:5082
msgid "printf-style format string"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5035
#: ../drivers/base/core.c:5083
msgid "arguments as specified in the format string"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5036
msgid ""
"This helper implements common pattern present in probe functions for error "
"checking: print debug or error message depending if the error value is -"
"EPROBE_DEFER and propagate error upwards. In case of -EPROBE_DEFER it sets "
"also defer probe reason, which can be checked later by reading "
"devices_deferred debugfs attribute. It replaces the following code sequence::"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5049
#: ../drivers/base/core.c:5097
msgid "with::"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5053
msgid ""
"Using this helper in your probe function is totally fine even if **err** is "
"known to never be -EPROBE_DEFER. The benefit compared to a normal dev_err() "
"is the standardized format of the error code, which is emitted symbolically "
"(i.e. you get \"EAGAIN\" instead of \"-35\"), and having the error code "
"returned allows more compact error paths."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5060
#: ../drivers/base/core.c:5108
msgid "Returns **err**."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5084
msgid ""
"This helper implements common pattern present in probe functions for error "
"checking: print debug or warning message depending if the error value is -"
"EPROBE_DEFER and propagate error upwards. In case of -EPROBE_DEFER it sets "
"also defer probe reason, which can be checked later by reading "
"devices_deferred debugfs attribute. It replaces the following code sequence::"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5101
msgid ""
"Using this helper in your probe function is totally fine even if **err** is "
"known to never be -EPROBE_DEFER. The benefit compared to a normal dev_warn() "
"is the standardized format of the error code, which is emitted symbolically "
"(i.e. you get \"EAGAIN\" instead of \"-35\"), and having the error code "
"returned allows more compact error paths."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5132
msgid "Change the primary firmware node of a given device."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5133
#: ../drivers/base/core.c:5178
msgid "Device to handle."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5135
#: ../drivers/base/core.c:5180 ../drivers/base/core.c:5288
msgid "``struct fwnode_handle *fwnode``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5134
msgid "New primary firmware node of the device."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5135
msgid ""
"Set the device's firmware node pointer to **fwnode**, but if a secondary "
"firmware node of the device is present, preserve it."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5138
msgid "Valid fwnode cases are:"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5139
msgid "primary --> secondary --> -ENODEV"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5140
msgid "primary --> NULL"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5141
msgid "secondary --> -ENODEV"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5142
msgid "NULL"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5177
msgid "Change the secondary firmware node of a given device."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5179
msgid "New secondary firmware node of the device."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5180
msgid ""
"If a primary firmware node of the device is present, set its secondary "
"pointer to **fwnode**.  Otherwise, set the device's firmware node pointer to "
"**fwnode**."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5198
msgid "Remove an of_node from a device"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5199
msgid "device whose device tree node is being removed"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5222
msgid "Add an of_node to an existing device"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5223
msgid "device whose device tree node is being added"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5225
msgid "``struct device_node *of_node``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5224
msgid "of_node to add"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5226
msgid "0 on success or error code on failure."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5259
msgid "reuse device-tree node of another device"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5260
msgid "device whose device-tree node is being set"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5262
msgid "``const struct device *dev2``"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5261
msgid "device whose device-tree node is being reused"
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5262
msgid ""
"Takes another reference to the new device-tree node after first dropping any "
"reference held to the old node."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5282
msgid ""
"Obtain a reference count of the struct device the struct fwnode_handle is "
"associated with."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5284
msgid ""
"The pointer to the struct fwnode_handle to obtain the struct device "
"reference count of."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5286
msgid ""
"This function obtains a reference count of the device the device pointer "
"embedded in the struct fwnode_handle points to."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5289
msgid ""
"Note that the struct device pointer embedded in struct fwnode_handle does "
"*not* have a reference count of the struct device itself."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5292
msgid ""
"Hence, it is a UAF (and thus a bug) to call this function if the caller "
"can't guarantee that the last reference count of the corresponding struct "
"device is not dropped concurrently."
msgstr ""

#: ../../../driver-api/infrastructure:32: ../drivers/base/core.c:5296
msgid ""
"This is possible since struct fwnode_handle has its own reference count and "
"hence can out-live the struct device it is associated with."
msgstr ""

#: ../../../driver-api/infrastructure:35: ../drivers/base/syscore.c:18
msgid "Register a set of system core operations."
msgstr ""

#: ../../../driver-api/infrastructure:35: ../drivers/base/syscore.c:24
#: ../drivers/base/syscore.c:36
msgid "``struct syscore *syscore``"
msgstr ""

#: ../../../driver-api/infrastructure:35: ../drivers/base/syscore.c:19
msgid "System core operations to register."
msgstr ""

#: ../../../driver-api/infrastructure:35: ../drivers/base/syscore.c:30
msgid "Unregister a set of system core operations."
msgstr ""

#: ../../../driver-api/infrastructure:35: ../drivers/base/syscore.c:31
msgid "System core operations to unregister."
msgstr ""

#: ../../../driver-api/infrastructure:35: ../drivers/base/syscore.c:43
msgid "Execute all the registered system core suspend callbacks."
msgstr ""

#: ../../../driver-api/infrastructure:35: ../drivers/base/syscore.c:44
#: ../drivers/base/syscore.c:90
msgid "This function is executed with one CPU on-line and disabled interrupts."
msgstr ""

#: ../../../driver-api/infrastructure:35: ../drivers/base/syscore.c:89
msgid "Execute all the registered system core resume callbacks."
msgstr ""

#: ../../../driver-api/infrastructure:38: ../include/linux/device/class.h:101
#: ../include/linux/device/class.h:113 ../include/linux/device/class.h:125
#: ../include/linux/device/class.h:137 ../include/linux/device/class.h:151
msgid "class type"
msgstr ""

#: ../../../driver-api/infrastructure:38: ../include/linux/device/class.h:111
#: ../../../driver-api/infrastructure:65: ../include/linux/device/bus.h:171
msgid "device iterator for locating a particular device matching the of_node."
msgstr ""

#: ../../../driver-api/infrastructure:38: ../include/linux/device/class.h:114
#: ../../../driver-api/infrastructure:65: ../include/linux/device/bus.h:174
msgid "of_node of the device to match."
msgstr ""

#: ../../../driver-api/infrastructure:38: ../include/linux/device/class.h:123
#: ../../../driver-api/infrastructure:65: ../include/linux/device/bus.h:183
msgid "device iterator for locating a particular device matching the fwnode."
msgstr ""

#: ../../../driver-api/infrastructure:38: ../include/linux/device/class.h:126
#: ../../../driver-api/infrastructure:65: ../include/linux/device/bus.h:186
msgid "fwnode of the device to match."
msgstr ""

#: ../../../driver-api/infrastructure:38: ../include/linux/device/class.h:135
#: ../../../driver-api/infrastructure:65: ../include/linux/device/bus.h:195
msgid ""
"device iterator for locating a particular device matching the device type."
msgstr ""

#: ../../../driver-api/infrastructure:38: ../include/linux/device/class.h:138
#: ../../../driver-api/infrastructure:65: ../include/linux/device/bus.h:198
msgid "device type of the device to match."
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:255
msgid "create a struct class structure"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:256
msgid "pointer to a string for the name of this class."
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:257
msgid ""
"This is used to create a struct class pointer that can then be used in calls "
"to device_create()."
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:260
msgid ""
"Returns :c:type:`struct class <class>` pointer on success, or ERR_PTR() on "
"error."
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:262
msgid ""
"Note, the pointer created here is to be destroyed when finished by making a "
"call to class_destroy()."
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:293
msgid "destroys a struct class structure"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:299
msgid "``const struct class *cls``"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:294
msgid "pointer to the struct class that is to be destroyed"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:295
msgid ""
"Note, the pointer to be destroyed must have been created with a call to "
"class_create()."
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:309
msgid "initialize class device iterator"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:315
#: ../drivers/base/class.c:348 ../drivers/base/class.c:379
msgid "``struct class_dev_iter *iter``"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:310
msgid "class iterator to initialize"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:311
msgid "the class we wanna iterate over"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:313
#: ../drivers/base/class.c:390 ../drivers/base/class.c:437
msgid "``const struct device *start``"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:312
msgid "the device to start iterating from, if any"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:314
msgid "``const struct device_type *type``"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:313
msgid "device_type of the devices to iterate over, NULL for all"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:314
msgid ""
"Initialize class iterator **iter** such that it iterates over devices of "
"**class**.  If **start** is set, the list iteration will start there, "
"otherwise if it is NULL, the iteration starts at the beginning of the list."
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:342
msgid "iterate to the next device"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:343
msgid "class iterator to proceed"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:344
msgid ""
"Proceed **iter** to the next device and return it.  Returns NULL if "
"iteration is complete."
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:347
msgid ""
"The returned device is referenced and won't be released till iterator is "
"proceed to the next device or exited.  The caller is free to do whatever it "
"wants to do with the device including calling back into class code."
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:373
msgid "finish iteration"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:374
msgid "class iterator to finish"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:375
msgid ""
"Finish an iteration.  Always call this function after iteration is complete "
"whether the iteration ran till the end or not."
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:387
msgid "device iterator"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:388
#: ../drivers/base/class.c:435
msgid "the class we're iterating"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:389
msgid "the device to start with in the list, if any."
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:390
msgid "data for the callback"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:391
msgid "function to be called for each device"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:392
msgid ""
"Iterate over **class**'s list of devices, and call **fn** for each, passing "
"it **data**.  If **start** is set, the list iteration will start there, "
"otherwise if it is NULL, the iteration starts at the beginning of the list."
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:400
msgid ""
"**fn** is allowed to do anything including calling back into class code.  "
"There's no locking restriction."
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:434
msgid "device iterator for locating a particular device"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:437
msgid "data for the match function"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:438
msgid "function to check device"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:439
msgid ""
"This is similar to the class_for_each_dev() function above, but it returns a "
"reference to a device that is 'found' for later use, as determined by the "
"**match** callback."
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:447
msgid "Note, you will need to drop the reference with put_device() after use."
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:449
msgid ""
"**match** is allowed to do anything including calling back into class code.  "
"There's no locking restriction."
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:566
msgid "register a compatibility class"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:567
msgid "the name of the class"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:568
msgid ""
"Compatibility class are meant as a temporary user-space compatibility "
"workaround when converting a family of class devices to a bus devices."
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:589
msgid "unregister a compatibility class"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:595
#: ../drivers/base/class.c:606 ../drivers/base/class.c:618
msgid "``struct class_compat *cls``"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:590
msgid "the class to unregister"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:600
msgid "create a compatibility class device link to a bus device"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:602
#: ../drivers/base/class.c:614
msgid "the compatibility class"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:603
#: ../drivers/base/class.c:615
msgid "the target bus device"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:612
msgid "remove a compatibility class device link to a bus device"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:624
msgid ""
"determine if at this moment in time, a class is registered in the driver "
"core or not."
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:626
msgid "the class to check"
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:627
msgid ""
"Returns a boolean to state if the class is registered in the driver core or "
"not.  Note that the value could switch right after this call is made, so "
"only use this in places where you \"know\" it is safe to do so (usually to "
"determine if the specific class has been registered yet or not)."
msgstr ""

#: ../../../driver-api/infrastructure:41: ../drivers/base/class.c:632
msgid "Be careful in using this."
msgstr ""

#: ../../../driver-api/infrastructure:44: ../include/linux/device/faux.h:20
msgid "a \"faux\" device"
msgstr ""

#: ../../../driver-api/infrastructure:44: ../include/linux/device/faux.h:22
msgid "internal struct device of the object"
msgstr ""

#: ../../../driver-api/infrastructure:44: ../include/linux/device/faux.h:22
msgid ""
"A simple faux device that can be created/destroyed.  To be used when a "
"driver only needs to have a device to \"hang\" something off.  This can be "
"used for downloading firmware or other basic tasks.  Use this instead of a "
"struct platform_device if the device has no resources assigned to it at all."
msgstr ""

#: ../../../driver-api/infrastructure:44: ../include/linux/device/faux.h:35
msgid "a set of callbacks for a struct faux_device"
msgstr ""

#: ../../../driver-api/infrastructure:44: ../include/linux/device/faux.h:37
msgid ""
"called when a faux device is probed by the driver core before the device is "
"fully bound to the internal faux bus code.  If probe succeeds, return 0, "
"otherwise return a negative error number to stop the probe sequence from "
"succeeding."
msgstr ""

#: ../../../driver-api/infrastructure:44: ../include/linux/device/faux.h:42
msgid "called when a faux device is removed from the system"
msgstr ""

#: ../../../driver-api/infrastructure:44: ../include/linux/device/faux.h:42
msgid "Both **probe** and **remove** are optional, if not needed, set to NULL."
msgstr ""

#: ../../../driver-api/infrastructure:47: ../drivers/base/faux.c:100
msgid ""
"Create and register with the driver core a faux device and populate the "
"device with an initial set of sysfs attributes."
msgstr ""

#: ../../../driver-api/infrastructure:47: ../drivers/base/faux.c:103
#: ../drivers/base/faux.c:185
msgid ""
"The name of the device we are adding, must be unique for all faux devices."
msgstr ""

#: ../../../driver-api/infrastructure:47: ../drivers/base/faux.c:105
#: ../drivers/base/faux.c:187
msgid ""
"Pointer to a potential parent struct device.  If set to NULL, the device "
"will be created in the \"root\" of the faux device tree in sysfs."
msgstr ""

#: ../../../driver-api/infrastructure:47: ../drivers/base/faux.c:109
#: ../drivers/base/faux.c:191
msgid "``const struct faux_device_ops *faux_ops``"
msgstr ""

#: ../../../driver-api/infrastructure:47: ../drivers/base/faux.c:108
#: ../drivers/base/faux.c:190
msgid ""
"struct faux_device_ops that the new device will call back into, can be NULL."
msgstr ""

#: ../../../driver-api/infrastructure:47: ../drivers/base/faux.c:110
msgid ""
"The set of sysfs attributes that will be created for this device when it is "
"registered with the driver core."
msgstr ""

#: ../../../driver-api/infrastructure:47: ../drivers/base/faux.c:112
#: ../drivers/base/faux.c:192
msgid ""
"Create a new faux device and register it in the driver core properly. If "
"present, callbacks in **faux_ops** will be called with the device that for "
"the caller to do something with at the proper time given the device's "
"lifecycle."
msgstr ""

#: ../../../driver-api/infrastructure:47: ../drivers/base/faux.c:117
msgid ""
"Note, when this function is called, the functions specified in struct "
"faux_ops can be called before the function returns, so be prepared for "
"everything to be properly initialized before that point in time.  If the "
"probe callback (if one is present) does NOT succeed, the creation of the "
"device will fail and NULL will be returned."
msgstr ""

#: ../../../driver-api/infrastructure:47: ../drivers/base/faux.c:124
#: ../drivers/base/faux.c:202
msgid "NULL if an error happened with creating the device"
msgstr ""

#: ../../../driver-api/infrastructure:47: ../drivers/base/faux.c:125
#: ../drivers/base/faux.c:203
msgid "pointer to a valid struct faux_device that is registered with sysfs"
msgstr ""

#: ../../../driver-api/infrastructure:47: ../drivers/base/faux.c:184
msgid "create and register with the driver core a faux device"
msgstr ""

#: ../../../driver-api/infrastructure:47: ../drivers/base/faux.c:197
msgid ""
"Note, when this function is called, the functions specified in struct "
"faux_ops can be called before the function returns, so be prepared for "
"everything to be properly initialized before that point in time."
msgstr ""

#: ../../../driver-api/infrastructure:47: ../drivers/base/faux.c:215
msgid "destroy a faux device"
msgstr ""

#: ../../../driver-api/infrastructure:47: ../drivers/base/faux.c:221
msgid "``struct faux_device *faux_dev``"
msgstr ""

#: ../../../driver-api/infrastructure:47: ../drivers/base/faux.c:216
msgid "faux device to destroy"
msgstr ""

#: ../../../driver-api/infrastructure:47: ../drivers/base/faux.c:217
msgid ""
"Unregisters and cleans up a device that was created with a call to "
"faux_device_create()"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:74
msgid "Access class device to hold user visible relationships to other nodes."
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:77
msgid "Device for this memory access class"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:77
msgid "``list_node``"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:78
msgid "List element in the node's access list"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:78
msgid "``access``"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:79
msgid "The access class rank"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:79
msgid "``coord``"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:80
msgid "Heterogeneous memory performance coordinates"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:290
msgid "Internal tracking for memory node caches"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:292
msgid "Device represeting the cache level"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:293
msgid "List element for tracking in the node"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:293
msgid "``cache_attrs``"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:294
msgid "Attributes for this cache level"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:364
msgid "add cache attribute to a memory node"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:370
msgid "``unsigned int nid``"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:365
msgid "Node identifier that has new cache attributes"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:367
msgid "``struct node_cache_attrs *cache_attrs``"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:366
msgid "Attributes for the cache being added"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:708
msgid "link memory node to its compute node for a given access class."
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:714
msgid "``unsigned int mem_nid``"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:710
msgid "Memory node number"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:712
msgid "``unsigned int cpu_nid``"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:711
msgid "Cpu  node number"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:713
msgid "``enum access_coordinate_class access``"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:712
msgid "Access class to register"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:714
msgid ""
"For use with platforms that may have separate memory and compute nodes. This "
"function will export node relationships linking which memory initiator nodes "
"can access memory targets at a given ranked access class."
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:867
msgid "Initialize and register the node device."
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:873
#: ../drivers/base/node.c:917
msgid "``int nid``"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:868
msgid "Node number to use when creating the device."
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:870
msgid "0 on success, -errno otherwise"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:911
msgid "unregister a node device"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:912
msgid "nid of the node going away"
msgstr ""

#: ../../../driver-api/infrastructure:50: ../drivers/base/node.c:913
msgid ""
"Unregisters the node device at node id **nid**. All the devices on the node "
"must be unregistered before calling this function."
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:38
msgid "register an initial transport class"
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:44
#: ../drivers/base/transport_class.c:64
msgid "``struct transport_class *tclass``"
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:40
msgid "a pointer to the transport class structure to be initialised"
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:41
msgid ""
"The transport class contains an embedded class which is used to identify "
"it.  The caller should initialise this structure with zeros and then generic "
"class must have been initialised with the actual transport class unique "
"name.  There's a macro DECLARE_TRANSPORT_CLASS() to do this (declared "
"classes still must be registered)."
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:48
msgid "Returns 0 on success or error on failure."
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:58
msgid "unregister a previously registered class"
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:60
msgid "The transport class to unregister"
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:61
msgid ""
"Must be called prior to deallocating the memory for the transport class."
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:80
msgid "register an anonymous class"
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:86
#: ../drivers/base/transport_class.c:112
msgid "``struct anon_transport_class *atc``"
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:82
msgid "The anon transport class to register"
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:83
msgid ""
"The anonymous transport class contains both a transport class and a "
"container.  The idea of an anonymous class is that it never actually has any "
"device attributes associated with it (and thus saves on container storage).  "
"So it can only be used for triggering events.  Use prezero and then use "
"DECLARE_ANON_TRANSPORT_CLASS() to initialise the anon transport class "
"storage."
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:106
msgid "unregister an anon class"
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:108
msgid "Pointer to the anon transport class to unregister"
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:109
msgid ""
"Must be called prior to deallocating the memory for the anon transport class."
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:134
msgid ""
"declare a new dev for transport class association but don't make it visible "
"yet."
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:135
#: ../drivers/base/transport_class.c:187
msgid "the generic device representing the entity being added"
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:136
msgid ""
"Usually, dev represents some component in the HBA system (either the HBA "
"itself or a device remote across the HBA bus).  This routine is simply a "
"trigger point to see if any set of transport classes wishes to associate "
"with the added device.  This allocates storage for the class device and "
"initialises it, but does not yet add it to the system or add attributes to "
"it (you do this with transport_add_device).  If you have no need for a "
"separate setup and add operations, use transport_register_device (see "
"transport_class.h)."
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:185
msgid "declare a new dev for transport class association"
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:188
msgid ""
"Usually, dev represents some component in the HBA system (either the HBA "
"itself or a device remote across the HBA bus).  This routine is simply a "
"trigger point used to add the device to the system and register attributes "
"for it."
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:216
msgid "configure an already set up device"
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:218
msgid "generic device representing device to be configured"
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:219
msgid ""
"The idea of configure is simply to provide a point within the setup process "
"to allow the transport class to extract information from a device after it "
"has been setup.  This is used in SCSI because we have to have a setup device "
"to begin using the HBA, but after we send the initial inquiry, we use "
"configure to extract the device parameters.  The device need not have been "
"added to be configured."
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:255
msgid "remove the visibility of a device"
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:257
msgid "generic device to remove"
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:258
msgid ""
"This call removes the visibility of the device (to the user from sysfs), but "
"does not destroy it.  To eliminate a device entirely you must also call "
"transport_destroy_device.  If you don't need to do remove and destroy as "
"separate operations, use transport_unregister_device() (see transport_class."
"h) which will perform both calls for you."
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:284
msgid "destroy a removed device"
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:286
msgid "device to eliminate from the transport class."
msgstr ""

#: ../../../driver-api/infrastructure:53: ../drivers/base/transport_class.c:287
msgid ""
"This call triggers the elimination of storage associated with the transport "
"classdev.  Note: all it really does is relinquish a reference to the "
"classdev.  The memory will not be freed until the last reference goes to "
"zero.  Note also that the classdev retains a reference count on dev, so dev "
"too will remain for as long as the transport class device remains around."
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:277
msgid "Check deferred probe state"
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:278
#: ../drivers/base/dd.c:386 ../../../driver-api/infrastructure:74:
#: ../kernel/dma/mapping.c:454 ../kernel/dma/mapping.c:543
#: ../kernel/dma/mapping.c:952
msgid "device to check"
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:280
msgid "-ENODEV if initcalls have completed and modules are disabled."
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:281
msgid ""
"-ETIMEDOUT if the deferred probe timeout was set and has expired and modules "
"are enabled."
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:283
msgid "-EPROBE_DEFER in other cases."
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:285
msgid ""
"Drivers or subsystems can opt-in to calling this function instead of "
"directly returning -EPROBE_DEFER."
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:385
msgid "Check if device is bound to a driver"
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:387
msgid ""
"Returns true if passed device has already finished probing successfully "
"against a driver."
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:390
#: ../drivers/base/dd.c:491
msgid "This function must be called with the device lock held."
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:482
msgid "bind a driver to one device."
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:484
msgid ""
"Allow manual attachment of a driver to a device. Caller must have already "
"set **dev->driver**."
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:487
msgid ""
"Note that this does not modify the bus reference count. Please verify that "
"is accounted for before calling this. (It is ok to call with no other effort "
"from a driver's probe() method.)"
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:493
msgid "Callers should prefer to use device_driver_attach() instead."
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:769
msgid "Wait for device probing to be completed."
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:1061
msgid "try to attach device to a driver."
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:1063
msgid ""
"Walk the list of drivers that the bus has and call driver_probe_device() for "
"each pair. If a compatible pair is found, break out and return."
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:1067
msgid ""
"Returns 1 if the device was bound to a driver; 0 if no matching driver was "
"found; -ENODEV if the device is not registered."
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:1071
msgid "When called for a USB interface, **dev->parent** lock must be held."
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:1126
msgid "attach a specific driver to a specific device"
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:1127
msgid "Driver to attach"
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:1128
msgid "Device to attach it to"
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:1129
msgid ""
"Manually attach driver to a device. Will acquire both **dev** lock and **dev-"
">parent** lock if needed. Returns 0 on success, -ERR on failure."
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:1234
msgid "try to bind driver to devices."
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:1236
msgid ""
"Walk the list of devices that the bus has on it and try to match the driver "
"with each one.  If driver_probe_device() returns 0 and the **dev->driver** "
"is set, we've found a compatible pair."
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:1313
msgid "manually detach device from driver."
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:1315
msgid ""
"Manually detach device from driver. When called for a USB interface, **dev-"
">parent** lock must be held."
msgstr ""

#: ../../../driver-api/infrastructure:56: ../drivers/base/dd.c:1318
msgid ""
"If this function is to be called with **dev->parent** lock held, ensure that "
"the device's consumers are unbound in advance or that their locks can be "
"acquired under the **dev->parent** lock."
msgstr ""

#: ../../../driver-api/infrastructure:59:
#: ../include/linux/platform_device.h:142
#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:840
msgid "add a platform-level device with resources and platform-specific data"
msgstr ""

#: ../../../driver-api/infrastructure:59:
#: ../include/linux/platform_device.h:145
#: ../include/linux/platform_device.h:206
msgid "parent device for the device we're adding"
msgstr ""

#: ../../../driver-api/infrastructure:59:
#: ../include/linux/platform_device.h:146
#: ../include/linux/platform_device.h:176
#: ../include/linux/platform_device.h:207
#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:612
msgid "base name of the device we're adding"
msgstr ""

#: ../../../driver-api/infrastructure:59:
#: ../include/linux/platform_device.h:148
#: ../include/linux/platform_device.h:178
#: ../include/linux/platform_device.h:209
#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:614
msgid "``int id``"
msgstr ""

#: ../../../driver-api/infrastructure:59:
#: ../include/linux/platform_device.h:147
#: ../include/linux/platform_device.h:177
#: ../include/linux/platform_device.h:208
#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:613
msgid "instance id"
msgstr ""

#: ../../../driver-api/infrastructure:59:
#: ../include/linux/platform_device.h:149
#: ../include/linux/platform_device.h:179
#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:640
msgid "``const struct resource *res``"
msgstr ""

#: ../../../driver-api/infrastructure:59:
#: ../include/linux/platform_device.h:148
#: ../include/linux/platform_device.h:178
#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:639
#: ../drivers/base/platform.c:1006
msgid "set of resources that needs to be allocated for the device"
msgstr ""

#: ../../../driver-api/infrastructure:59:
#: ../include/linux/platform_device.h:150
#: ../include/linux/platform_device.h:180
#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:52
#: ../drivers/base/platform.c:173 ../drivers/base/platform.c:263
#: ../drivers/base/platform.c:288 ../drivers/base/platform.c:641
msgid "``unsigned int num``"
msgstr ""

#: ../../../driver-api/infrastructure:59:
#: ../include/linux/platform_device.h:149
#: ../include/linux/platform_device.h:179
#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:640
#: ../drivers/base/platform.c:1007
msgid "number of resources"
msgstr ""

#: ../../../driver-api/infrastructure:59:
#: ../include/linux/platform_device.h:150
#: ../include/linux/platform_device.h:209
#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:667
#: ../drivers/base/platform.c:1008
msgid "platform specific data for this platform device"
msgstr ""

#: ../../../driver-api/infrastructure:59:
#: ../include/linux/platform_device.h:152
#: ../include/linux/platform_device.h:211
#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:669
#: ../drivers/base/platform.c:1010 ../../../driver-api/infrastructure:74:
#: ../kernel/dma/mapping.c:64 ../kernel/dma/mapping.c:83
#: ../kernel/dma/mapping.c:567
msgid "``size_t size``"
msgstr ""

#: ../../../driver-api/infrastructure:59:
#: ../include/linux/platform_device.h:151
#: ../include/linux/platform_device.h:210
#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:668
#: ../drivers/base/platform.c:1009
msgid "size of platform specific data"
msgstr ""

#: ../../../driver-api/infrastructure:59:
#: ../include/linux/platform_device.h:152
#: ../include/linux/platform_device.h:193
#: ../include/linux/platform_device.h:217
#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:844
#: ../drivers/base/platform.c:1014
msgid ""
"Returns :c:type:`struct platform_device <platform_device>` pointer on "
"success, or ERR_PTR() on error."
msgstr ""

#: ../../../driver-api/infrastructure:59:
#: ../include/linux/platform_device.h:175
msgid "add a platform-level device and its resources"
msgstr ""

#: ../../../driver-api/infrastructure:59:
#: ../include/linux/platform_device.h:180
#: ../include/linux/platform_device.h:211
msgid ""
"This function creates a simple platform device that requires minimal "
"resource and memory management. Canned release function freeing memory "
"allocated for the device allows drivers using such devices to be unloaded "
"without waiting for the last reference to the device to be dropped."
msgstr ""

#: ../../../driver-api/infrastructure:59:
#: ../include/linux/platform_device.h:186
msgid ""
"This interface is primarily intended for use with legacy drivers which probe "
"hardware directly.  Because such drivers create sysfs device nodes "
"themselves, rather than letting system infrastructure handle such device "
"enumeration tasks, they don't fully conform to the Linux driver model. In "
"particular, when such drivers are built as modules, they can't be "
"\"hotplugged\"."
msgstr ""

#: ../../../driver-api/infrastructure:59:
#: ../include/linux/platform_device.h:205
msgid "add a platform-level device with platform-specific data"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:48
msgid "get a resource for a device"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:54
#: ../drivers/base/platform.c:176 ../drivers/base/platform.c:266
#: ../drivers/base/platform.c:291 ../drivers/base/platform.c:321
#: ../drivers/base/platform.c:369 ../drivers/base/platform.c:462
#: ../drivers/base/platform.c:507 ../drivers/base/platform.c:528
msgid "``struct platform_device *dev``"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:49
#: ../drivers/base/platform.c:171 ../drivers/base/platform.c:261
#: ../drivers/base/platform.c:286 ../drivers/base/platform.c:316
#: ../drivers/base/platform.c:457 ../drivers/base/platform.c:502
#: ../drivers/base/platform.c:523
msgid "platform device"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:51
#: ../drivers/base/platform.c:459
msgid "``unsigned int type``"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:50
#: ../drivers/base/platform.c:458
msgid "resource type"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:51
#: ../drivers/base/platform.c:92 ../drivers/base/platform.c:117
msgid "resource index"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:53
msgid "a pointer to the resource or NULL on failure."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:87
msgid "call devm_ioremap_resource() for a platform device and get resource"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:93
#: ../drivers/base/platform.c:118 ../drivers/base/platform.c:136
#: ../drivers/base/platform.c:590 ../drivers/base/platform.c:643
#: ../drivers/base/platform.c:671 ../drivers/base/platform.c:698
#: ../drivers/base/platform.c:786 ../drivers/base/platform.c:815
#: ../drivers/base/platform.c:831
msgid "``struct platform_device *pdev``"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:90
#: ../drivers/base/platform.c:115 ../drivers/base/platform.c:134
msgid ""
"platform device to use both for memory resource lookup as well as resource "
"management"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:93
#: ../drivers/base/platform.c:118
msgid "``unsigned int index``"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:94
msgid "``struct resource **res``"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:93
msgid "optional output parameter to store a pointer to the obtained resource."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:95
#: ../drivers/base/platform.c:119 ../drivers/base/platform.c:138
msgid ""
"a pointer to the remapped memory or an ERR_PTR() encoded error code on "
"failure."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:112
msgid "call devm_ioremap_resource() for a platform device"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:130
msgid ""
"call devm_ioremap_resource for a platform device, retrieve the resource by "
"name"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:136
msgid "name of the resource"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:170
msgid "get an optional IRQ and its affinity for a device"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:172
#: ../drivers/base/platform.c:262
msgid "interrupt number index"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:174
msgid "``const struct cpumask **affinity``"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:173
msgid "optional cpumask pointer to get the affinity of a per-cpu interrupt"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:174
msgid ""
"Gets an interupt for a platform device. Device drivers should check the "
"return value for errors so as to not pass a negative integer value to the "
"request_irq() APIs. Optional affinity information is provided in the "
"affinity pointer if available, and NULL otherwise."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:180
#: ../drivers/base/platform.c:276
msgid "non-zero interrupt number on success, negative error number on failure."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:260
msgid "get an optional interrupt for a device"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:263
msgid ""
"Gets an interrupt for a platform device. Device drivers should check the "
"return value for errors so as to not pass a negative integer value to the "
"request_irq() APIs. This is the same as platform_get_irq(), except that it "
"does not print an error message if an interrupt can not be obtained."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:269
#: ../drivers/base/platform.c:292
msgid "For example::"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:285
msgid "get an IRQ for a device"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:287
msgid "IRQ number index"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:288
msgid ""
"Gets an IRQ for a platform device and prints an error message if finding the "
"IRQ fails. Device drivers should check the return value for errors so as to "
"not pass a negative integer value to the request_irq() APIs."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:299
#: ../drivers/base/platform.c:507 ../drivers/base/platform.c:529
msgid "non-zero IRQ number on success, negative error number on failure."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:315
msgid "Count the number of IRQs a platform device uses"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:318
msgid "Number of IRQs a platform device uses or EPROBE_DEFER"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:363
msgid ""
"devm method to get a set of IRQs for a device using an interrupt affinity "
"descriptor"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:365
msgid "platform device pointer"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:367
msgid "``struct irq_affinity *affd``"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:366
msgid "affinity descriptor"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:368
msgid "``unsigned int minvec``"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:367
msgid "minimum count of interrupt vectors"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:369
msgid "``unsigned int maxvec``"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:368
msgid "maximum count of interrupt vectors"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:370
msgid "``int **irqs``"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:369
msgid "pointer holder for IRQ numbers"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:370
msgid ""
"Gets a set of IRQs for a platform device, and updates IRQ afffinty according "
"to the passed affinity descriptor"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:374
msgid "Number of vectors on success, negative error number on failure."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:456
msgid "get a resource for a device by name"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:459
msgid "resource name"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:501
msgid "get an IRQ for a device by name"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:503
#: ../drivers/base/platform.c:524
msgid "IRQ name"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:504
msgid ""
"Get an IRQ like platform_get_irq(), but then by name rather then by index."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:522
msgid "get an optional IRQ for a device by name"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:525
msgid ""
"Get an optional IRQ by name like platform_get_irq_byname(). Except that it "
"does not print an error message if an IRQ can not be obtained."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:539
msgid "add a numbers of platform devices"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:545
msgid "``struct platform_device **devs``"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:540
msgid "array of platform devices to add"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:542
msgid "``int num``"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:541
msgid "number of platform devices in array"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:543
msgid "0 on success, negative error number on failure."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:584
msgid "destroy a platform device"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:585
msgid "platform device to free"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:586
msgid ""
"Free all memory associated with a platform device.  This function must "
"_only_ be externally called in error cases.  All other usage is a bug."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:611
msgid "create a platform device"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:614
msgid ""
"Create a platform device object which can have other objects attached to it, "
"and which will have attached objects freed when it is released."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:637
msgid "add resources to a platform device"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:638
#: ../drivers/base/platform.c:666
msgid "platform device allocated by platform_device_alloc to add resources to"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:641
msgid ""
"Add a copy of the resources to the platform device.  The memory associated "
"with the resources will be freed when the platform device is released."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:665
msgid "add platform-specific data to a platform device"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:669
msgid ""
"Add a copy of platform specific data to the platform device's platform_data "
"pointer.  The memory associated with the platform data will be freed when "
"the platform device is released."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:692
msgid "add a platform device to device hierarchy"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:693
#: ../drivers/base/platform.c:810
msgid "platform device we're adding"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:694
msgid ""
"This is part 2 of platform_device_register(), though may be called "
"separately _iff_ pdev was allocated by platform_device_alloc()."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:780
msgid "remove a platform-level device"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:781
msgid "platform device we're removing"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:782
msgid ""
"Note that this function will also release all memory- and port-based "
"resources owned by the device (**dev->resource**).  This function must "
"_only_ be externally called in error cases.  All other usage is a bug."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:809
msgid "add a platform-level device"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:812
msgid ""
"_Never_ directly free **pdev** after calling this function, even if it "
"returned an error! Always use platform_device_put() to give up the reference "
"initialised in this function instead."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:825
msgid "unregister a platform-level device"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:826
msgid "platform device we're unregistering"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:827
msgid ""
"Unregistration is done in 2 steps. First we release all resources and remove "
"it from the subsystem, then we drop reference count by calling "
"platform_device_put()."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:846
msgid "``const struct platform_device_info *pdevinfo``"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:843
msgid "data used to create device"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:898
msgid "register a driver for platform-level devices"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:904
#: ../drivers/base/platform.c:919 ../drivers/base/platform.c:941
msgid "``struct platform_driver *drv``"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:899
#: ../drivers/base/platform.c:914 ../drivers/base/platform.c:936
#: ../drivers/base/platform.c:1004
msgid "platform driver structure"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:900
msgid "owning module/driver"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:913
msgid "unregister a driver for platform-level devices"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:935
msgid "register driver for non-hotpluggable device"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:938
#: ../drivers/base/platform.c:1006
msgid "``int (*probe)(struct platform_device *)``"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:937
#: ../drivers/base/platform.c:1005
msgid "the driver probe routine, probably from an __init section"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:939
#: ../drivers/base/platform.c:1011
msgid "``struct module *module``"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:938
#: ../drivers/base/platform.c:1010
msgid "module which will be the owner of the driver"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:939
msgid ""
"Use this instead of platform_driver_register() when you know the device is "
"not hotpluggable and has already been registered, and you want to remove its "
"run-once probe() infrastructure from memory after the driver has bound to "
"the device."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:944
msgid ""
"One typical use for this would be with drivers for controllers integrated "
"into system-on-chip processors, where the controller devices have been "
"configured as part of board setup."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:948
msgid "Note that this is incompatible with deferred probing."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:950
msgid ""
"Returns zero if the driver registered and bound to a device, else returns a "
"negative error code and with the driver not registered."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:1003
msgid "register driver and create corresponding device"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:1009
msgid "``struct platform_driver *driver``"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:1007
msgid "``struct resource *res``"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:1008
msgid "``unsigned int n_res``"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:1011
msgid ""
"Use this in legacy-style modules that probe hardware directly and register a "
"single platform device and corresponding platform driver."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:1060
msgid "register an array of platform drivers"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:1066
#: ../drivers/base/platform.c:1108
msgid "``struct platform_driver * const *drivers``"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:1061
msgid "an array of drivers to register"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:1063
#: ../drivers/base/platform.c:1105
msgid "``unsigned int count``"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:1062
msgid "the number of drivers to register"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:1063
msgid "module owning the drivers"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:1064
msgid ""
"Registers platform drivers specified by an array. On failure to register a "
"driver, all previously registered drivers will be unregistered. Callers of "
"this API should use platform_unregister_drivers() to unregister drivers in "
"the reverse order."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:1102
msgid "unregister an array of platform drivers"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:1103
msgid "an array of drivers to unregister"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:1104
msgid "the number of drivers to unregister"
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:1105
msgid ""
"Unregisters platform drivers specified by an array. This is typically used "
"to complement an earlier call to platform_register_drivers(). Drivers are "
"unregistered in the reverse order in which they were registered."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:1536
msgid "Find a platform device with a given driver."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:1538
msgid "The device to start the search from."
msgstr ""

#: ../../../driver-api/infrastructure:62: ../drivers/base/platform.c:1539
msgid "The device driver to look for."
msgstr ""

#: ../../../driver-api/infrastructure:65: ../include/linux/device/bus.h:163
#: ../include/linux/device/bus.h:177 ../include/linux/device/bus.h:189
#: ../include/linux/device/bus.h:201 ../include/linux/device/bus.h:213
#: ../include/linux/device/bus.h:228 ../../../driver-api/infrastructure:68:
#: ../drivers/base/bus.c:357 ../drivers/base/bus.c:397
#: ../drivers/base/bus.c:474 ../drivers/base/bus.c:820
#: ../drivers/base/bus.c:892 ../drivers/base/bus.c:980
#: ../drivers/base/bus.c:1353 ../drivers/base/bus.c:1406
msgid "``const struct bus_type *bus``"
msgstr ""

#: ../../../driver-api/infrastructure:65: ../include/linux/device/bus.h:159
#: ../include/linux/device/bus.h:173 ../include/linux/device/bus.h:185
#: ../include/linux/device/bus.h:197 ../include/linux/device/bus.h:209
#: ../include/linux/device/bus.h:224 ../../../driver-api/infrastructure:68:
#: ../drivers/base/bus.c:392
msgid "bus type"
msgstr ""

#: ../../../driver-api/infrastructure:65: ../include/linux/device/bus.h:207
msgid "Find the next device after a given device in a given bus."
msgstr ""

#: ../../../driver-api/infrastructure:65: ../include/linux/device/bus.h:211
msgid "``struct device *cur``"
msgstr ""

#: ../../../driver-api/infrastructure:65: ../include/linux/device/bus.h:210
msgid "device to begin the search with."
msgstr ""

#: ../../../driver-api/infrastructure:65: ../include/linux/device/bus.h:222
msgid ""
"device iterator for locating a particular device matching the ACPI COMPANION "
"device."
msgstr ""

#: ../../../driver-api/infrastructure:65: ../include/linux/device/bus.h:225
msgid "ACPI COMPANION device to match."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:351
msgid "device iterator."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:352
msgid "bus type."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:353
msgid "device to start iterating from."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:356
msgid ""
"Iterate over **bus**'s list of devices, and call **fn** for each, passing it "
"**data**. If **start** is not NULL, we use that device to begin iterating "
"from."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:364
msgid ""
"The device that returns a non-zero value is not retained in any way, nor is "
"its refcount incremented. If the caller needs to retain this data, it should "
"do so, and increment the reference count in the supplied callback."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:396
msgid ""
"This is similar to the bus_for_each_dev() function above, but it returns a "
"reference to a device that is 'found' for later use, as determined by the "
"**match** callback."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:468
msgid "driver iterator"
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:469
msgid "bus we're dealing with."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:471
msgid "``struct device_driver *start``"
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:470
msgid "driver to start iterating on."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:471
msgid "data to pass to the callback."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:473
msgid "``int (*fn)(struct device_driver *, void *)``"
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:472
msgid "function to call for each driver."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:473
msgid ""
"This is nearly identical to the device iterator above. We iterate over each "
"driver that belongs to **bus**, and call **fn** for each. If **fn** returns "
"anything but 0, we break out and return it. If **start** is not NULL, we use "
"it as the head of the list."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:480
msgid ""
"we don't return the driver that returns a non-zero value, nor do we leave "
"the reference count incremented for that driver. If the caller needs to know "
"that info, it must set it in the callback. It must also be sure to increment "
"the refcount so it doesn't disappear before returning to the caller."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:814
msgid "rescan devices on the bus for possible drivers"
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:815
msgid "the bus to scan."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:816
msgid ""
"This function will look for devices on the bus with no driver attached and "
"rescan it against existing drivers to see if it matches any by calling "
"device_attach() for the unbound devices."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:828
msgid "remove driver for a device and probe for a new driver"
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:829
msgid "the device to reprobe"
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:830
msgid ""
"This function detaches the attached driver (if any) for the given device and "
"restarts the driver probing process.  It is intended to use if probing "
"criteria changed during a devices lifetime and driver attachment should "
"change accordingly."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:886
msgid "register a driver-core subsystem"
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:887
msgid "bus to register"
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:888
msgid ""
"Once we have that, we register the bus with the kobject infrastructure, then "
"register the children subsystems it has: the devices and drivers that belong "
"to the subsystem."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:974
msgid "remove a bus from the system"
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:975
msgid "bus."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:976
msgid ""
"Unregister the child subsystems and the bus itself. Finally, we call "
"bus_put() to release the refcount"
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:1301
msgid "register a subsystem at /sys/devices/system/"
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:1307
#: ../drivers/base/bus.c:1332
msgid "``const struct bus_type *subsys``"
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:1302
msgid "system subsystem"
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:1303
#: ../drivers/base/bus.c:1328
msgid "default attributes for the root device"
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:1304
msgid ""
"All 'system' subsystems have a /sys/devices/system/<name> root device with "
"the name of the subsystem. The root device can carry subsystem- wide "
"attributes. All registered devices are below this single root device and are "
"named after the subsystem with a simple enumeration number appended. The "
"registered devices are not explicitly named; only 'id' in the device needs "
"to be set."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:1311
msgid ""
"Do not use this interface for anything new, it exists for compatibility with "
"bad ideas only. New subsystems should use plain subsystems; and add the "
"subsystem-wide attributes should be added to the subsystem directory itself "
"and not some create fake root-device placed in /sys/devices/system/<name>."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:1326
msgid "register a subsystem at /sys/devices/virtual/"
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:1327
msgid "virtual subsystem"
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:1329
msgid ""
"All 'virtual' subsystems have a /sys/devices/system/<name> root device with "
"the name of the subsystem.  The root device can carry subsystem-wide "
"attributes.  All registered devices are below this single root device. "
"There's no restriction on device naming.  This is for kernel software "
"constructs which need sysfs interface."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:1350
msgid "locate driver on a bus by its name."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:1351
msgid "name of the driver."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:1352
msgid "bus to scan for the driver."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:1353
msgid ""
"Call kset_find_obj() to iterate over list of drivers on a bus to find driver "
"by name. Return driver if found."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:1356
msgid ""
"This routine provides no locking to prevent the driver it returns from being "
"unregistered or unloaded while the caller is using it. The caller is "
"responsible for preventing this."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:1400
msgid "return a pointer to the \"device root\" of a bus"
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:1401
msgid "bus to return the device root of."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:1402
msgid ""
"If a bus has a \"device root\" structure, return it, WITH THE REFERENCE "
"COUNT INCREMENTED."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:1405
msgid ""
"Note, when finished with the device, a call to put_device() is required."
msgstr ""

#: ../../../driver-api/infrastructure:68: ../drivers/base/bus.c:1407
msgid ""
"If the device root is not present (or bus is not a valid pointer), NULL will "
"be returned."
msgstr ""

#: ../../../driver-api/infrastructure.rst:72
msgid "Device Drivers DMA Management"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:61
msgid "Managed dma_free_coherent()"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:62
msgid "Device to free coherent memory for"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:63
#: ../kernel/dma/mapping.c:82
msgid "Size of allocation"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:65
msgid "``void *vaddr``"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:64
msgid "Virtual address of the memory to free"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:66
msgid "``dma_addr_t dma_handle``"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:65
msgid "DMA handle of the memory to free"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:66
msgid "Managed dma_free_coherent()."
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:80
msgid "Managed dma_alloc_attrs()"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:81
msgid "Device to allocate non_coherent memory for"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:84
msgid "``dma_addr_t *dma_handle``"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:83
msgid "Out argument for allocated DMA handle"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:85
msgid "``gfp_t gfp``"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:84
msgid "Allocation flags"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:86
#: ../kernel/dma/mapping.c:269 ../kernel/dma/mapping.c:297
#: ../kernel/dma/mapping.c:568
msgid "``unsigned long attrs``"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:85
msgid "Flags in the DMA_ATTR_* namespace."
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:86
msgid ""
"Managed dma_alloc_attrs().  Memory allocated using this function will be "
"automatically released on driver detach."
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:90
msgid "Pointer to allocated memory on success, NULL on failure."
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:263
#: ../kernel/dma/mapping.c:292
msgid "Map the given buffer for DMA"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:264
#: ../kernel/dma/mapping.c:293
msgid "The device for which to perform the DMA operation"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:266
msgid "``struct scatterlist *sg``"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:265
#: ../kernel/dma/mapping.c:294
msgid "The sg_table object describing the buffer"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:267
msgid "``int nents``"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:266
msgid "Number of entries to map"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:268
#: ../kernel/dma/mapping.c:296
msgid "``enum dma_data_direction dir``"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:267
#: ../kernel/dma/mapping.c:295
msgid "DMA direction"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:268
#: ../kernel/dma/mapping.c:296
msgid "Optional DMA attributes for the map operation"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:269
msgid ""
"Maps a buffer described by a scatterlist passed in the sg argument with "
"nents segments for the **dir** DMA operation by the **dev** device."
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:272
msgid ""
"Returns the number of mapped entries (which can be less than nents) on "
"success. Zero is returned for any error."
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:275
msgid ""
"dma_unmap_sg_attrs() should be used to unmap the buffer with the original sg "
"and original nents (not the value returned by this funciton)."
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:295
msgid "``struct sg_table *sgt``"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:297
msgid ""
"Maps a buffer described by a scatterlist stored in the given sg_table object "
"for the **dir** DMA operation by the **dev** device. After success, the "
"ownership for the buffer is transferred to the DMA domain.  One has to call "
"dma_sync_sgtable_for_cpu() or dma_unmap_sgtable() to move the ownership of "
"the buffer back to the CPU domain before touching the buffer by the CPU."
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:304
msgid ""
"Returns 0 on success or a negative error code on error. The following error "
"codes are supported with the given meaning:"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:307
msgid ""
"An invalid argument, unaligned access or other error in usage. Will not "
"succeed if retried."
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:309
msgid ""
"Insufficient resources (like memory or IOVA space) to complete the mapping. "
"Should succeed if retried later."
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:311
msgid ""
"Legacy error code with an unknown meaning. eg. this is returned if a lower "
"level call returned DMA_MAPPING_ERROR."
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:314
msgid ""
"The DMA device cannot access P2PDMA memory specified in the sg_table. This "
"will not succeed if retried."
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:453
msgid "does this device need dma_unmap_* operations"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:455
msgid ""
"If this function returns ``false``, drivers can skip calling dma_unmap_* "
"after finishing an I/O.  This function must be called after all mappings "
"that might need to be unmapped have been performed."
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:542
msgid "check if a given device supports dma_mmap_*"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:544
msgid ""
"Returns ``true`` if **dev** supports dma_mmap_coherent() and "
"dma_mmap_attrs() to map DMA allocations to userspace."
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:561
msgid "map a coherent DMA allocation into user space"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:562
msgid "valid struct device pointer, or NULL for ISA and EISA-like devices"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:564
msgid "``struct vm_area_struct *vma``"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:563
msgid "vm_area_struct describing requested user mapping"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:565
msgid "``void *cpu_addr``"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:564
msgid "kernel CPU-view address returned from dma_alloc_attrs"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:566
msgid "``dma_addr_t dma_addr``"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:565
msgid "device-view address returned from dma_alloc_attrs"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:566
msgid "size of memory originally requested in dma_alloc_attrs"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:567
msgid "attributes of mapping properties requested in dma_alloc_attrs"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:568
msgid ""
"Map a coherent DMA buffer previously allocated by dma_alloc_attrs into user "
"space.  The coherent DMA buffer must not be freed by the driver until the "
"user space mapping has been released."
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:951
msgid "return if the device is addressing limited"
msgstr ""

#: ../../../driver-api/infrastructure:74: ../kernel/dma/mapping.c:953
msgid ""
"Return ``true`` if the devices DMA mask is too small to address all memory "
"in the system, else ``false``.  Lack of addressing bits is the prime reason "
"for bounce buffering, but might not be the only one."
msgstr ""

#: ../../../driver-api/infrastructure.rst:78
msgid "Device drivers PnP support"
msgstr ""

#: ../../../driver-api/infrastructure:80: ../drivers/pnp/core.c:42
msgid "adds a pnp protocol to the pnp layer"
msgstr ""

#: ../../../driver-api/infrastructure:80: ../drivers/pnp/core.c:48
msgid "``struct pnp_protocol *protocol``"
msgstr ""

#: ../../../driver-api/infrastructure:80: ../drivers/pnp/core.c:43
msgid "pointer to the corresponding pnp_protocol structure"
msgstr ""

#: ../../../driver-api/infrastructure:80: ../drivers/pnp/core.c:44
msgid "Ex protocols: ISAPNP, PNPBIOS, etc"
msgstr ""

#: ../../../driver-api/infrastructure:83: ../drivers/pnp/card.c:291
msgid "Searches for a PnP device under the specified card"
msgstr ""

#: ../../../driver-api/infrastructure:83: ../drivers/pnp/card.c:297
msgid "``struct pnp_card_link *clink``"
msgstr ""

#: ../../../driver-api/infrastructure:83: ../drivers/pnp/card.c:292
msgid "pointer to the card link, cannot be NULL"
msgstr ""

#: ../../../driver-api/infrastructure:83: ../drivers/pnp/card.c:294
#: ../../../driver-api/infrastructure:86: ../drivers/pnp/driver.c:313
msgid "``const char *id``"
msgstr ""

#: ../../../driver-api/infrastructure:83: ../drivers/pnp/card.c:293
msgid ""
"pointer to a PnP ID structure that explains the rules for finding the device"
msgstr ""

#: ../../../driver-api/infrastructure:83: ../drivers/pnp/card.c:295
msgid "``struct pnp_dev *from``"
msgstr ""

#: ../../../driver-api/infrastructure:83: ../drivers/pnp/card.c:294
msgid ""
"Starting place to search from. If NULL it will start from the beginning."
msgstr ""

#: ../../../driver-api/infrastructure:83: ../drivers/pnp/card.c:343
msgid "call this when the driver no longer needs the device"
msgstr ""

#: ../../../driver-api/infrastructure:83: ../drivers/pnp/card.c:349
#: ../../../driver-api/infrastructure:86: ../drivers/pnp/driver.c:316
#: ../../../driver-api/infrastructure:89: ../drivers/pnp/manager.c:338
#: ../drivers/pnp/manager.c:362 ../drivers/pnp/manager.c:384
#: ../drivers/pnp/manager.c:410 ../../../driver-api/infrastructure:92:
#: ../drivers/pnp/support.c:22
msgid "``struct pnp_dev *dev``"
msgstr ""

#: ../../../driver-api/infrastructure:83: ../drivers/pnp/card.c:344
msgid "pointer to the PnP device structure"
msgstr ""

#: ../../../driver-api/infrastructure:83: ../drivers/pnp/card.c:381
msgid "registers a PnP card driver with the PnP Layer"
msgstr ""

#: ../../../driver-api/infrastructure:83: ../drivers/pnp/card.c:387
#: ../drivers/pnp/card.c:421
msgid "``struct pnp_card_driver *drv``"
msgstr ""

#: ../../../driver-api/infrastructure:83: ../drivers/pnp/card.c:382
msgid "pointer to the driver to register"
msgstr ""

#: ../../../driver-api/infrastructure:83: ../drivers/pnp/card.c:415
msgid "unregisters a PnP card driver from the PnP Layer"
msgstr ""

#: ../../../driver-api/infrastructure:83: ../drivers/pnp/card.c:416
msgid "pointer to the driver to unregister"
msgstr ""

#: ../../../driver-api/infrastructure:86: ../drivers/pnp/driver.c:310
msgid "adds an EISA id to the specified device"
msgstr ""

#: ../../../driver-api/infrastructure:86: ../drivers/pnp/driver.c:311
#: ../../../driver-api/infrastructure:89: ../drivers/pnp/manager.c:333
#: ../drivers/pnp/manager.c:357 ../drivers/pnp/manager.c:379
#: ../drivers/pnp/manager.c:405
msgid "pointer to the desired device"
msgstr ""

#: ../../../driver-api/infrastructure:86: ../drivers/pnp/driver.c:312
msgid "pointer to an EISA id string"
msgstr ""

#: ../../../driver-api/infrastructure:89: ../drivers/pnp/manager.c:332
msgid "low-level start of the PnP device"
msgstr ""

#: ../../../driver-api/infrastructure:89: ../drivers/pnp/manager.c:334
msgid "assumes that resources have already been allocated"
msgstr ""

#: ../../../driver-api/infrastructure:89: ../drivers/pnp/manager.c:356
msgid "low-level disable of the PnP device"
msgstr ""

#: ../../../driver-api/infrastructure:89: ../drivers/pnp/manager.c:358
msgid "does not free resources"
msgstr ""

#: ../../../driver-api/infrastructure:89: ../drivers/pnp/manager.c:378
msgid "activates a PnP device for use"
msgstr ""

#: ../../../driver-api/infrastructure:89: ../drivers/pnp/manager.c:380
msgid "does not validate or set resources so be careful."
msgstr ""

#: ../../../driver-api/infrastructure:89: ../drivers/pnp/manager.c:404
msgid "disables device"
msgstr ""

#: ../../../driver-api/infrastructure:89: ../drivers/pnp/manager.c:406
msgid ""
"inform the correct pnp protocol so that resources can be used by other "
"devices"
msgstr ""

#: ../../../driver-api/infrastructure:92: ../drivers/pnp/support.c:16
msgid "Determines if a device is active based on its current resources"
msgstr ""

#: ../../../driver-api/infrastructure:92: ../drivers/pnp/support.c:18
msgid "pointer to the desired PnP device"
msgstr ""

#: ../../../driver-api/infrastructure.rst:96
msgid "Userspace IO devices"
msgstr ""

#: ../../../driver-api/infrastructure:98: ../drivers/uio/uio.c:427
msgid "trigger an interrupt event"
msgstr ""

#: ../../../driver-api/infrastructure:98: ../drivers/uio/uio.c:433
#: ../drivers/uio/uio.c:976 ../drivers/uio/uio.c:1072 ../drivers/uio/uio.c:1107
msgid "``struct uio_info *info``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:90
#: ../include/linux/uio_driver.h:131 ../include/linux/uio_driver.h:151
#: ../../../driver-api/infrastructure:98: ../drivers/uio/uio.c:428
#: ../drivers/uio/uio.c:975 ../drivers/uio/uio.c:1071 ../drivers/uio/uio.c:1102
msgid "UIO device capabilities"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:129
#: ../../../driver-api/infrastructure:98: ../drivers/uio/uio.c:972
msgid "register a new userspace IO device"
msgstr ""

#: ../../../driver-api/infrastructure:98: ../drivers/uio/uio.c:973
#: ../drivers/uio/uio.c:1069
msgid "module that creates the new device"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:130
#: ../include/linux/uio_driver.h:150 ../../../driver-api/infrastructure:98:
#: ../drivers/uio/uio.c:974 ../drivers/uio/uio.c:1070
msgid "parent device"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:132
#: ../include/linux/uio_driver.h:152 ../../../driver-api/infrastructure:98:
#: ../drivers/uio/uio.c:976 ../drivers/uio/uio.c:1072
msgid "returns zero on success or a negative error code."
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:149
#: ../../../driver-api/infrastructure:98: ../drivers/uio/uio.c:1068
msgid "Resource managed uio_register_device()"
msgstr ""

#: ../../../driver-api/infrastructure:98: ../drivers/uio/uio.c:1101
msgid "unregister a industrial IO device"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:24
msgid "description of a UIO memory region"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:26
msgid "name of the memory region for identification"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:26
msgid "``addr``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:27
msgid ""
"address of the device's memory rounded to page size (phys_addr is used since "
"addr can be logical, virtual, or physical & phys_addr_t should always be "
"large enough to handle any of the address types)"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:31
msgid "``dma_addr``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:32
msgid ""
"DMA handle set by dma_alloc_coherent, used with UIO_MEM_DMA_COHERENT only "
"(**addr** should be the void * returned from the same dma_alloc_coherent "
"call)"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:34
msgid "``offs``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:35
msgid "offset of device memory within the page"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:35
#: ../include/linux/uio_driver.h:62
msgid "``size``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:36
msgid "size of IO (multiple of page size)"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:36
msgid "``memtype``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:37
msgid "type of memory addr points to"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:37
msgid "``internal_addr``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:38
msgid "ioremap-ped version of addr, for driver internal use"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:38
msgid "``dma_device``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:39
msgid ""
"device struct that was passed to dma_alloc_coherent, used with "
"UIO_MEM_DMA_COHERENT only"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:40
msgid "``map``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:41
#: ../include/linux/uio_driver.h:65
msgid "for use by the UIO core only."
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:59
msgid "description of a UIO port region"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:61
msgid "name of the port region for identification"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:61
msgid "``start``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:62
msgid "start of port region"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:63
msgid "size of port region"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:63
msgid "``porttype``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:64
msgid "type of port (see UIO_PORT_* below)"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:64
msgid "``portio``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:91
msgid "``uio_dev``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:92
msgid "the UIO device this info belongs to"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:93
msgid "device name"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:93
msgid "``version``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:94
msgid "device driver version"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:94
msgid "``mem``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:95
msgid "list of mappable memory regions, size==0 for end of list"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:95
msgid "``port``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:96
msgid "list of port regions, size==0 for end of list"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:96
msgid "``irq``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:97
msgid "interrupt number or UIO_IRQ_CUSTOM"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:97
msgid "``irq_flags``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:98
msgid "flags for request_irq()"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:98
msgid "``priv``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:99
msgid "optional private data"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:99
msgid "``handler``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:100
msgid "the device's irq handler"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:100
msgid "``mmap``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:101
msgid "mmap operation for this uio device"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:101
msgid "``open``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:102
msgid "open operation for this uio device"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:103
msgid "release operation for this uio device"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:103
msgid "``irqcontrol``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:104
msgid "disable/enable irqs when 0/1 is written to /dev/uioX"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:131
msgid "``uio_register_device (parent, info)``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:132
#: ../include/linux/uio_driver.h:152
msgid "``info``"
msgstr ""

#: ../../../driver-api/infrastructure:101: ../include/linux/uio_driver.h:151
msgid "``devm_uio_register_device (parent, info)``"
msgstr ""
