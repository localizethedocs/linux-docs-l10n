# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 08:27+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../mm/zsmalloc.rst:3
msgid "zsmalloc"
msgstr ""

#: ../../../mm/zsmalloc.rst:5
msgid ""
"This allocator is designed for use with zram. Thus, the allocator is "
"supposed to work well under low memory conditions. In particular, it never "
"attempts higher order page allocation which is very likely to fail under "
"memory pressure. On the other hand, if we just use single (0-order) pages, "
"it would suffer from very high fragmentation -- any object of size "
"PAGE_SIZE/2 or larger would occupy an entire page. This was one of the major "
"issues with its predecessor (xvmalloc)."
msgstr ""

#: ../../../mm/zsmalloc.rst:13
msgid ""
"To overcome these issues, zsmalloc allocates a bunch of 0-order pages and "
"links them together using various 'struct page' fields. These linked pages "
"act as a single higher-order page i.e. an object can span 0-order page "
"boundaries. The code refers to these linked pages as a single entity called "
"zspage."
msgstr ""

#: ../../../mm/zsmalloc.rst:19
msgid ""
"For simplicity, zsmalloc can only allocate objects of size up to PAGE_SIZE "
"since this satisfies the requirements of all its current users (in the worst "
"case, page is incompressible and is thus stored \"as-is\" i.e. in "
"uncompressed form). For allocation requests larger than this size, failure "
"is returned (see zs_malloc)."
msgstr ""

#: ../../../mm/zsmalloc.rst:25
msgid ""
"Additionally, zs_malloc() does not return a dereferenceable pointer. "
"Instead, it returns an opaque handle (unsigned long) which encodes actual "
"location of the allocated object. The reason for this indirection is that "
"zsmalloc does not keep zspages permanently mapped since that would cause "
"issues on 32-bit systems where the VA region for kernel space mappings is "
"very small. So, using the allocated memory should be done through the proper "
"handle-based APIs."
msgstr ""

#: ../../../mm/zsmalloc.rst:34
msgid "stat"
msgstr ""

#: ../../../mm/zsmalloc.rst:36
msgid ""
"With CONFIG_ZSMALLOC_STAT, we could see zsmalloc internal information via ``/"
"sys/kernel/debug/zsmalloc/<user name>``. Here is a sample of stat output::"
msgstr ""

#: ../../../mm/zsmalloc.rst:51
msgid "class"
msgstr ""

#: ../../../mm/zsmalloc.rst:52
msgid "index"
msgstr ""

#: ../../../mm/zsmalloc.rst:53
msgid "size"
msgstr ""

#: ../../../mm/zsmalloc.rst:54
msgid "object size zspage stores"
msgstr ""

#: ../../../mm/zsmalloc.rst:55
msgid "10%"
msgstr ""

#: ../../../mm/zsmalloc.rst:56
msgid "the number of zspages with usage ratio less than 10% (see below)"
msgstr ""

#: ../../../mm/zsmalloc.rst:57
msgid "20%"
msgstr ""

#: ../../../mm/zsmalloc.rst:58
msgid "the number of zspages with usage ratio between 10% and 20%"
msgstr ""

#: ../../../mm/zsmalloc.rst:59
msgid "30%"
msgstr ""

#: ../../../mm/zsmalloc.rst:60
msgid "the number of zspages with usage ratio between 20% and 30%"
msgstr ""

#: ../../../mm/zsmalloc.rst:61
msgid "40%"
msgstr ""

#: ../../../mm/zsmalloc.rst:62
msgid "the number of zspages with usage ratio between 30% and 40%"
msgstr ""

#: ../../../mm/zsmalloc.rst:63
msgid "50%"
msgstr ""

#: ../../../mm/zsmalloc.rst:64
msgid "the number of zspages with usage ratio between 40% and 50%"
msgstr ""

#: ../../../mm/zsmalloc.rst:65
msgid "60%"
msgstr ""

#: ../../../mm/zsmalloc.rst:66
msgid "the number of zspages with usage ratio between 50% and 60%"
msgstr ""

#: ../../../mm/zsmalloc.rst:67
msgid "70%"
msgstr ""

#: ../../../mm/zsmalloc.rst:68
msgid "the number of zspages with usage ratio between 60% and 70%"
msgstr ""

#: ../../../mm/zsmalloc.rst:69
msgid "80%"
msgstr ""

#: ../../../mm/zsmalloc.rst:70
msgid "the number of zspages with usage ratio between 70% and 80%"
msgstr ""

#: ../../../mm/zsmalloc.rst:71
msgid "90%"
msgstr ""

#: ../../../mm/zsmalloc.rst:72
msgid "the number of zspages with usage ratio between 80% and 90%"
msgstr ""

#: ../../../mm/zsmalloc.rst:73
msgid "99%"
msgstr ""

#: ../../../mm/zsmalloc.rst:74
msgid "the number of zspages with usage ratio between 90% and 99%"
msgstr ""

#: ../../../mm/zsmalloc.rst:75
msgid "100%"
msgstr ""

#: ../../../mm/zsmalloc.rst:76
msgid "the number of zspages with usage ratio 100%"
msgstr ""

#: ../../../mm/zsmalloc.rst:77
msgid "obj_allocated"
msgstr ""

#: ../../../mm/zsmalloc.rst:78
msgid "the number of objects allocated"
msgstr ""

#: ../../../mm/zsmalloc.rst:79
msgid "obj_used"
msgstr ""

#: ../../../mm/zsmalloc.rst:80
msgid "the number of objects allocated to the user"
msgstr ""

#: ../../../mm/zsmalloc.rst:81
msgid "pages_used"
msgstr ""

#: ../../../mm/zsmalloc.rst:82
msgid "the number of pages allocated for the class"
msgstr ""

#: ../../../mm/zsmalloc.rst:83
msgid "pages_per_zspage"
msgstr ""

#: ../../../mm/zsmalloc.rst:84
msgid "the number of 0-order pages to make a zspage"
msgstr ""

#: ../../../mm/zsmalloc.rst:85
msgid "freeable"
msgstr ""

#: ../../../mm/zsmalloc.rst:86
msgid "the approximate number of pages class compaction can free"
msgstr ""

#: ../../../mm/zsmalloc.rst:88
msgid ""
"Each zspage maintains inuse counter which keeps track of the number of "
"objects stored in the zspage.  The inuse counter determines the zspage's "
"\"fullness group\" which is calculated as the ratio of the \"inuse\" objects "
"to the total number of objects the zspage can hold (objs_per_zspage). The "
"closer the inuse counter is to objs_per_zspage, the better."
msgstr ""

#: ../../../mm/zsmalloc.rst:95
msgid "Internals"
msgstr ""

#: ../../../mm/zsmalloc.rst:97
msgid ""
"zsmalloc has 255 size classes, each of which can hold a number of zspages. "
"Each zspage can contain up to ZSMALLOC_CHAIN_SIZE physical (0-order) pages. "
"The optimal zspage chain size for each size class is calculated during the "
"creation of the zsmalloc pool (see calculate_zspage_chain_size())."
msgstr ""

#: ../../../mm/zsmalloc.rst:102
msgid ""
"As an optimization, zsmalloc merges size classes that have similar "
"characteristics in terms of the number of pages per zspage and the number of "
"objects that each zspage can store."
msgstr ""

#: ../../../mm/zsmalloc.rst:106
msgid "For instance, consider the following size classes:::"
msgstr ""

#: ../../../mm/zsmalloc.rst:115
msgid ""
"Size classes #95-99 are merged with size class #100. This means that when we "
"need to store an object of size, say, 1568 bytes, we end up using size class "
"#100 instead of size class #96. Size class #100 is meant for objects of size "
"1632 bytes, so each object of size 1568 bytes wastes 1632-1568=64 bytes."
msgstr ""

#: ../../../mm/zsmalloc.rst:120
msgid ""
"Size class #100 consists of zspages with 2 physical pages each, which can "
"hold a total of 5 objects. If we need to store 13 objects of size 1568, we "
"end up allocating three zspages, or 6 physical pages."
msgstr ""

#: ../../../mm/zsmalloc.rst:124
msgid ""
"However, if we take a closer look at size class #96 (which is meant for "
"objects of size 1568 bytes) and trace `calculate_zspage_chain_size()`, we "
"find that the most optimal zspage configuration for this class is a chain of "
"5 physical pages:::"
msgstr ""

#: ../../../mm/zsmalloc.rst:136
msgid ""
"This means that a class #96 configuration with 5 physical pages can store 13 "
"objects of size 1568 in a single zspage, using a total of 5 physical pages. "
"This is more efficient than the class #100 configuration, which would use 6 "
"physical pages to store the same number of objects."
msgstr ""

#: ../../../mm/zsmalloc.rst:141
msgid ""
"As the zspage chain size for class #96 increases, its key characteristics "
"such as pages per-zspage and objects per-zspage also change. This leads to "
"dewer class mergers, resulting in a more compact grouping of classes, which "
"reduces memory wastage."
msgstr ""

#: ../../../mm/zsmalloc.rst:146
msgid ""
"Let's take a closer look at the bottom of `/sys/kernel/debug/zsmalloc/zramX/"
"classes`:::"
msgstr ""

#: ../../../mm/zsmalloc.rst:155
msgid ""
"Size class #202 stores objects of size 3264 bytes and has a maximum of 4 "
"pages per zspage. Any object larger than 3264 bytes is considered huge and "
"belongs to size class #254, which stores each object in its own physical "
"page (objects in huge classes do not share pages)."
msgstr ""

#: ../../../mm/zsmalloc.rst:160
msgid ""
"Increasing the size of the chain of zspages also results in a higher "
"watermark for the huge size class and fewer huge classes overall. This "
"allows for more efficient storage of large objects."
msgstr ""

#: ../../../mm/zsmalloc.rst:164
msgid "For zspage chain size of 8, huge class watermark becomes 3632 bytes:::"
msgstr ""

#: ../../../mm/zsmalloc.rst:177
msgid "For zspage chain size of 16, huge class watermark becomes 3840 bytes:::"
msgstr ""

#: ../../../mm/zsmalloc.rst:204
msgid ""
"Overall the combined zspage chain size effect on zsmalloc pool "
"configuration:::"
msgstr ""

#: ../../../mm/zsmalloc.rst:223
msgid "A synthetic test"
msgstr ""

#: ../../../mm/zsmalloc.rst:225
msgid "zram as a build artifacts storage (Linux kernel compilation)."
msgstr ""

#: ../../../mm/zsmalloc.rst:227
msgid "`CONFIG_ZSMALLOC_CHAIN_SIZE=4`"
msgstr ""

#: ../../../mm/zsmalloc.rst:229 ../../../mm/zsmalloc.rst:243
msgid "zsmalloc classes stats:::"
msgstr ""

#: ../../../mm/zsmalloc.rst:236 ../../../mm/zsmalloc.rst:250
msgid "zram mm_stat:::"
msgstr ""

#: ../../../mm/zsmalloc.rst:241
msgid "`CONFIG_ZSMALLOC_CHAIN_SIZE=8`"
msgstr ""

#: ../../../mm/zsmalloc.rst:254
msgid ""
"Using larger zspage chains may result in using fewer physical pages, as seen "
"in the example where the number of physical pages used decreased from 159955 "
"to 156666, at the same time maximum zsmalloc pool memory usage went down "
"from 655175680 to 641703936 bytes."
msgstr ""

#: ../../../mm/zsmalloc.rst:259
msgid ""
"However, this advantage may be offset by the potential for increased system "
"memory pressure (as some zspages have larger chain sizes) in cases where "
"there is heavy internal fragmentation and zspool compaction is unable to "
"relocate objects and release zspages. In these cases, it is recommended to "
"decrease the limit on the size of the zspage chains (as specified by the "
"CONFIG_ZSMALLOC_CHAIN_SIZE option)."
msgstr ""

#: ../../../mm/zsmalloc.rst:267
msgid "Functions"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:746
msgid "get (<zpdesc>, <obj_idx>) from encoded object value"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:750 mm/zsmalloc.c:768
#: mm/zsmalloc.c:1045 mm/zsmalloc.c:1197 mm/zsmalloc.c:1258 mm/zsmalloc.c:2021
msgid "**Parameters**"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:752
msgid "``unsigned long obj``"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:747
msgid "the encoded object value"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:749
msgid "``struct zpdesc **zpdesc``"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:748 mm/zsmalloc.c:765
msgid "zpdesc object resides in zspage"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:750
msgid "``unsigned int *obj_idx``"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:749 mm/zsmalloc.c:766
msgid "object index"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:764
msgid "get obj value encoded from (<zpdesc>, <obj_idx>)"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:770
msgid "``struct zpdesc *zpdesc``"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:767
msgid "``unsigned int obj_idx``"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:1041
msgid ""
"Returns index of the zsmalloc :c:type:`size_class` that hold objects of the "
"provided size."
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:1047 mm/zsmalloc.c:1199
#: mm/zsmalloc.c:1260
msgid "``struct zs_pool *pool``"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:1043 mm/zsmalloc.c:1195
msgid "zsmalloc pool to use"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:1045
msgid "``unsigned int size``"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:1044
msgid "object size"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:1046 mm/zsmalloc.c:1200
msgid "**Context**"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:1046 mm/zsmalloc.c:1201
msgid "Any context."
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:1048 mm/zsmalloc.c:1203
msgid "**Return**"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:1048
msgid ""
"the index of the zsmalloc :c:type:`size_class` that hold objects of the "
"provided size."
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:1193
msgid ""
"Returns the size (in bytes) of the first huge zsmalloc :c:type:`size_class`."
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:1197 mm/zsmalloc.c:1260
#: mm/zsmalloc.c:2020
msgid "**Description**"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:1196
msgid ""
"The function returns the size of the first huge class - any object of equal "
"or bigger size will be stored in zspage consisting of a single physical page."
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:1203
msgid "the size (in bytes) of the first huge zsmalloc :c:type:`size_class`."
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:1254
msgid "Allocate block of given size from pool."
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:1255
msgid "pool to allocate from"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:1257
msgid "``size_t size``"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:1256
msgid "size of block to allocate"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:1258
msgid "``gfp_t gfp``"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:1257
msgid "gfp flags when allocating object"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:1259
msgid "``const int nid``"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:1258
msgid "The preferred node id to allocate new zspage (if needed)"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:1259
msgid ""
"On success, handle to the allocated object is returned, otherwise an "
"ERR_PTR(). Allocation requests with size > ZS_MAX_ALLOC_SIZE will fail."
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:2017
msgid "Creates an allocation pool to work from."
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:2023
msgid "``const char *name``"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:2018
msgid "pool name to be created"
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:2019
msgid ""
"This function must be called before anything when using the zsmalloc "
"allocator."
msgstr ""

#: ../../../mm/zsmalloc:269: mm/zsmalloc.c:2022
msgid ""
"On success, a pointer to the newly created pool is returned, otherwise NULL."
msgstr ""
