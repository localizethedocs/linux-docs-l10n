# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-16 08:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/powerpc/papr_hcalls.rst:5
msgid "Hypercall Op-codes (hcalls)"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:8
msgid "Overview"
msgstr "概覽"

#: ../../../arch/powerpc/papr_hcalls.rst:10
msgid ""
"Virtualization on 64-bit Power Book3S Platforms is based on the PAPR "
"specification [1]_ which describes the run-time environment for a guest "
"operating system and how it should interact with the hypervisor for "
"privileged operations. Currently there are two PAPR compliant hypervisors:"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:15
msgid ""
"**IBM PowerVM (PHYP)**: IBM's proprietary hypervisor that supports AIX, IBM-"
"i and  Linux as supported guests (termed as Logical Partitions or LPARS). It "
"supports the full PAPR specification."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:19
msgid ""
"**Qemu/KVM**: Supports PPC64 linux guests running on a PPC64 linux host. "
"Though it only implements a subset of PAPR specification called LoPAPR [2]_."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:22
msgid ""
"On PPC64 arch a guest kernel running on top of a PAPR hypervisor is called a "
"*pSeries guest*. A pseries guest runs in a supervisor mode (HV=0) and must "
"issue hypercalls to the hypervisor whenever it needs to perform an action "
"that is hypervisor privileged [3]_ or for other services managed by the "
"hypervisor."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:28
msgid ""
"Hence a Hypercall (hcall) is essentially a request by the pseries guest "
"asking hypervisor to perform a privileged operation on behalf of the guest. "
"The guest issues a with necessary input operands. The hypervisor after "
"performing the privilege operation returns a status code and output operands "
"back to the guest."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:35
msgid "HCALL ABI"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:36
msgid ""
"The ABI specification for a hcall between a pseries guest and PAPR "
"hypervisor is covered in section 14.5.3 of ref [2]_. Switch to the  "
"Hypervisor context is done via the instruction **HVCS** that expects the "
"Opcode for hcall is set in *r3* and any in-arguments for the hcall are "
"provided in registers *r4-r12*. If values have to be passed through a memory "
"buffer, the data stored in that buffer should be in Big-endian byte order."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:43
msgid ""
"Once control returns back to the guest after hypervisor has serviced the "
"'HVCS' instruction the return value of the hcall is available in *r3* and "
"any out values are returned in registers *r4-r12*. Again like in case of in-"
"arguments, any out values stored in a memory buffer will be in Big-endian "
"byte order."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:48
msgid ""
"Powerpc arch code provides convenient wrappers named **plpar_hcall_xxx** "
"defined in a arch specific header [4]_ to issue hcalls from the linux kernel "
"running as pseries guest."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:53
msgid "Register Conventions"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:55
msgid ""
"Any hcall should follow same register convention as described in section "
"2.2.1.1 of \"64-Bit ELF V2 ABI Specification: Power Architecture\"[5]_. "
"Table below summarizes these conventions:"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:60
msgid "Register Range"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:60
msgid "Volatile (Y/N)"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:60
msgid "Purpose"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:63
msgid "r0"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:63
#: ../../../arch/powerpc/papr_hcalls.rst:69
#: ../../../arch/powerpc/papr_hcalls.rst:71
#: ../../../arch/powerpc/papr_hcalls.rst:73
#: ../../../arch/powerpc/papr_hcalls.rst:75
#: ../../../arch/powerpc/papr_hcalls.rst:82
#: ../../../arch/powerpc/papr_hcalls.rst:84
#: ../../../arch/powerpc/papr_hcalls.rst:86
#: ../../../arch/powerpc/papr_hcalls.rst:88
#: ../../../arch/powerpc/papr_hcalls.rst:92
msgid "Y"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:63
msgid "Optional-usage"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:65
msgid "r1"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:65
#: ../../../arch/powerpc/papr_hcalls.rst:67
#: ../../../arch/powerpc/papr_hcalls.rst:78
#: ../../../arch/powerpc/papr_hcalls.rst:80
#: ../../../arch/powerpc/papr_hcalls.rst:90
#: ../../../arch/powerpc/papr_hcalls.rst:94
msgid "N"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:65
msgid "Stack Pointer"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:67
msgid "r2"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:67
msgid "TOC"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:69
msgid "r3"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:69
msgid "hcall opcode/return value"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:71
msgid "r4-r10"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:71
msgid "in and out values"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:73
msgid "r11"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:73
msgid "Optional-usage/Environmental pointer"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:75
msgid "r12"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:75
msgid "Optional-usage/Function entry address at global entry point"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:78
msgid "r13"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:78
msgid "Thread-Pointer"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:80
msgid "r14-r31"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:80
msgid "Local Variables"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:82
msgid "LR"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:82
msgid "Link Register"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:84
msgid "CTR"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:84
msgid "Loop Counter"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:86
msgid "XER"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:86
msgid "Fixed-point exception register."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:88
msgid "CR0-1"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:88
#: ../../../arch/powerpc/papr_hcalls.rst:90
#: ../../../arch/powerpc/papr_hcalls.rst:92
msgid "Condition register fields."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:90
msgid "CR2-4"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:92
msgid "CR5-7"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:94
msgid "Others"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:98
msgid "DRC & DRC Indexes"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:111
msgid ""
"PAPR hypervisor terms shared hardware resources like PCI devices, NVDIMMs "
"etc available for use by LPARs as Dynamic Resource (DR). When a DR is "
"allocated to an LPAR, PHYP creates a data-structure called Dynamic Resource "
"Connector (DRC) to manage LPAR access. An LPAR refers to a DRC via an opaque "
"32-bit number called DRC-Index. The DRC-index value is provided to the LPAR "
"via device-tree where its present as an attribute in the device tree node "
"associated with the DR."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:120
msgid "HCALL Return-values"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:122
msgid ""
"After servicing the hcall, hypervisor sets the return-value in *r3* "
"indicating success or failure of the hcall. In case of a failure an error "
"code indicates the cause for error. These codes are defined and documented "
"in arch specific header [4]_."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:127
msgid ""
"In some cases a hcall can potentially take a long time and need to be issued "
"multiple times in order to be completely serviced. These hcalls will usually "
"accept an opaque value *continue-token* within there argument list and a "
"return value of *H_CONTINUE* indicates that hypervisor hasn't still finished "
"servicing the hcall yet."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:133
msgid ""
"To make such hcalls the guest need to set *continue-token == 0* for the "
"initial call and use the hypervisor returned value of *continue-token* for "
"each subsequent hcall until hypervisor returns a non *H_CONTINUE* return "
"value."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:139
msgid "HCALL Op-codes"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:141
msgid ""
"Below is a partial list of HCALLs that are supported by PHYP. For the "
"corresponding opcode values please look into the arch specific header [4]_:"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:144
msgid "**H_SCM_READ_METADATA**"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:146
msgid "Input: *drcIndex, offset, buffer-address, numBytesToRead*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:147
msgid "Out: *numBytesRead*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:148
msgid "Return Value: *H_Success, H_Parameter, H_P2, H_P3, H_Hardware*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:150
msgid ""
"Given a DRC Index of an NVDIMM, read N-bytes from the metadata area "
"associated with it, at a specified offset and copy it to provided buffer. "
"The metadata area stores configuration information such as label "
"information, bad-blocks etc. The metadata area is located out-of-band of "
"NVDIMM storage area hence a separate access semantics is provided."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:156
msgid "**H_SCM_WRITE_METADATA**"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:158
msgid "Input: *drcIndex, offset, data, numBytesToWrite*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:159
#: ../../../arch/powerpc/papr_hcalls.rst:212
msgid "Out: *None*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:160
msgid "Return Value: *H_Success, H_Parameter, H_P2, H_P4, H_Hardware*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:162
msgid ""
"Given a DRC Index of an NVDIMM, write N-bytes to the metadata area "
"associated with it, at the specified offset and from the provided buffer."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:165
msgid "**H_SCM_BIND_MEM**"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:167
msgid "Input: *drcIndex, startingScmBlockIndex, numScmBlocksToBind,*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:168
msgid "*targetLogicalMemoryAddress, continue-token*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:169
msgid "Out: *continue-token, targetLogicalMemoryAddress, numScmBlocksToBound*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:170
msgid "Return Value: *H_Success, H_Parameter, H_P2, H_P3, H_P4, H_Overlap,*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:171
msgid "*H_Too_Big, H_P5, H_Busy*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:173
msgid ""
"Given a DRC-Index of an NVDIMM, map a continuous SCM blocks range "
"*(startingScmBlockIndex, startingScmBlockIndex+numScmBlocksToBind)* to the "
"guest at *targetLogicalMemoryAddress* within guest physical address space. "
"In case *targetLogicalMemoryAddress == 0xFFFFFFFF_FFFFFFFF* then hypervisor "
"assigns a target address to the guest. The HCALL can fail if the Guest has "
"an active PTE entry to the SCM block being bound."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:180
msgid ""
"**H_SCM_UNBIND_MEM** | Input: drcIndex, startingScmLogicalMemoryAddress, "
"numScmBlocksToUnbind | Out: numScmBlocksUnbound | Return Value: *H_Success, "
"H_Parameter, H_P2, H_P3, H_In_Use, H_Overlap,* | *H_Busy, "
"H_LongBusyOrder1mSec, H_LongBusyOrder10mSec*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:186
msgid ""
"Given a DRC-Index of an NVDimm, unmap *numScmBlocksToUnbind* SCM blocks "
"starting at *startingScmLogicalMemoryAddress* from guest physical address "
"space. The HCALL can fail if the Guest has an active PTE entry to the SCM "
"block being unbound."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:191
msgid "**H_SCM_QUERY_BLOCK_MEM_BINDING**"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:193
msgid "Input: *drcIndex, scmBlockIndex*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:194
msgid "Out: *Guest-Physical-Address*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:195
#: ../../../arch/powerpc/papr_hcalls.rst:204
msgid "Return Value: *H_Success, H_Parameter, H_P2, H_NotFound*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:197
msgid ""
"Given a DRC-Index and an SCM Block index return the guest physical address "
"to which the SCM block is mapped to."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:200
msgid "**H_SCM_QUERY_LOGICAL_MEM_BINDING**"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:202
msgid "Input: *Guest-Physical-Address*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:203
msgid "Out: *drcIndex, scmBlockIndex*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:206
msgid ""
"Given a guest physical address return which DRC Index and SCM block is "
"mapped to that address."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:209
msgid "**H_SCM_UNBIND_ALL**"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:211
msgid "Input: *scmTargetScope, drcIndex*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:213
msgid "Return Value: *H_Success, H_Parameter, H_P2, H_P3, H_In_Use, H_Busy,*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:214
msgid "*H_LongBusyOrder1mSec, H_LongBusyOrder10mSec*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:216
msgid ""
"Depending on the Target scope unmap all SCM blocks belonging to all NVDIMMs "
"or all SCM blocks belonging to a single NVDIMM identified by its drcIndex "
"from the LPAR memory."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:220
msgid "**H_SCM_HEALTH**"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:222
msgid "Input: drcIndex"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:223
msgid "Out: *health-bitmap (r4), health-bit-valid-bitmap (r5)*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:224
msgid "Return Value: *H_Success, H_Parameter, H_Hardware*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:226
msgid ""
"Given a DRC Index return the info on predictive failure and overall health "
"of the PMEM device. The asserted bits in the health-bitmap indicate one or "
"more states (described in table below) of the PMEM device and health-bit-"
"valid-bitmap indicate which bits in health-bitmap are valid. The bits are "
"reported in reverse bit ordering for example a value of 0xC400000000000000 "
"indicates bits 0, 1, and 5 are valid."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:233
msgid "Health Bitmap Flags:"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:236
msgid "Bit"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:236
msgid "Definition"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:238
msgid "00"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:238
msgid ""
"PMEM device is unable to persist memory contents. If the system is powered "
"down, nothing will be saved."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:241
msgid "01"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:241
msgid ""
"PMEM device failed to persist memory contents. Either contents were not "
"saved successfully on power down or were not restored properly on power up."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:245
msgid "02"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:245
msgid ""
"PMEM device contents are persisted from previous IPL. The data from the last "
"boot were successfully restored."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:248
msgid "03"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:248
msgid ""
"PMEM device contents are not persisted from previous IPL. There was no data "
"to restore from the last boot."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:251
msgid "04"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:251
msgid "PMEM device memory life remaining is critically low"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:253
msgid "05"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:253
msgid "PMEM device will be garded off next IPL due to failure"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:255
msgid "06"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:255
msgid ""
"PMEM device contents cannot persist due to current platform health status. A "
"hardware failure may prevent data from being saved or restored."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:259
msgid "07"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:259
msgid "PMEM device is unable to persist memory contents in certain conditions"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:261
msgid "08"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:261
msgid "PMEM device is encrypted"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:263
msgid "09"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:263
msgid ""
"PMEM device has successfully completed a requested erase or secure erase "
"procedure."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:266
msgid "10:63"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:266
msgid "Reserved / Unused"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:269
msgid "**H_SCM_PERFORMANCE_STATS**"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:271
msgid "Input: drcIndex, resultBuffer Addr"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:272
msgid "Out: None"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:273
msgid ""
"Return Value:  *H_Success, H_Parameter, H_Unsupported, H_Hardware, "
"H_Authority, H_Privilege*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:275
msgid ""
"Given a DRC Index collect the performance statistics for NVDIMM and copy "
"them to the resultBuffer."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:278
msgid "**H_SCM_FLUSH**"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:280
msgid "Input: *drcIndex, continue-token*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:281
msgid "Out: *continue-token*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:282
msgid "Return Value: *H_SUCCESS, H_Parameter, H_P2, H_BUSY*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:284
msgid "Given a DRC Index Flush the data to backend NVDIMM device."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:286
msgid ""
"The hcall returns H_BUSY when the flush takes longer time and the hcall "
"needs to be issued multiple times in order to be completely serviced. The "
"*continue-token* from the output to be passed in the argument list of "
"subsequent hcalls to the hypervisor until the hcall is completely serviced "
"at which point H_SUCCESS or other error is returned by the hypervisor."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:292
msgid "**H_HTM**"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:294
msgid "Input: flags, target, operation (op), op-param1, op-param2, op-param3"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:295
msgid "Out: *dumphtmbufferdata*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:297
msgid ""
"Return Value: *H_Success,H_Busy,H_LongBusyOrder,H_Partial,H_Parameter, H_P2,"
"H_P3,H_P4,H_P5,H_P6,H_State,H_Not_Available,H_Authority*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:299
msgid ""
"H_HTM supports setup, configuration, control and dumping of Hardware Trace "
"Macro (HTM) function and its data. HTM buffer stores tracing data for "
"functions like core instruction, core LLAT and nest."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:303
msgid "**H_PKS_GEN_KEY**"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:305
msgid "Input: authorization, objectlabel, objectlabellen, policy, out, outlen"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:306
msgid ""
"Out: *Hypervisor Generated Key, or None when the wrapping key policy is set*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:309
msgid ""
"Return Value: *H_SUCCESS, H_Function, H_State, H_R_State, H_Parameter, H_P2, "
"H_P3, H_P4, H_P5, H_P6, H_Authority, H_Nomem, H_Busy, H_Resource, H_Aborted*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:311
msgid ""
"H_PKS_GEN_KEY is used to have the hypervisor generate a new random key. This "
"key is stored as an object in the Power LPAR Platform KeyStore with the "
"provided object label. With the wrapping key policy set the key is only "
"visible to the hypervisor, while the key's label would still be visible to "
"the user. Generation of wrapping keys is supported only for a key size of 32 "
"bytes."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:318
msgid "**H_PKS_WRAP_OBJECT**"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:320
msgid ""
"Input: authorization, wrapkeylabel, wrapkeylabellen, objectwrapflags, in,"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:321
msgid "inlen, out, outlen, continue-token"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:322
msgid "Out: *continue-token, byte size of wrapped object, wrapped object*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:325
msgid ""
"Return Value: *H_SUCCESS, H_Function, H_State, H_R_State, H_Parameter, H_P2, "
"H_P3, H_P4, H_P5, H_P6, H_P7, H_P8, H_P9, H_Authority, H_Invalid_Key, "
"H_NOT_FOUND, H_Busy, H_LongBusy, H_Aborted*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:327
msgid ""
"H_PKS_WRAP_OBJECT is used to wrap an object using a wrapping key stored in "
"the Power LPAR Platform KeyStore and return the wrapped object to the "
"caller. The caller provides a label to a wrapping key with the 'wrapping "
"key' policy set, which must have been previously created with H_PKS_GEN_KEY. "
"The provided object is then encrypted with the wrapping key and additional "
"metadata and the result is returned to the caller."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:335
msgid "**H_PKS_UNWRAP_OBJECT**"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:337
msgid ""
"Input: authorization, objectwrapflags, in, inlen, out, outlen, continue-token"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:338
msgid "Out: *continue-token, byte size of unwrapped object, unwrapped object*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:341
msgid ""
"Return Value: *H_SUCCESS, H_Function, H_State, H_R_State, H_Parameter, H_P2, "
"H_P3, H_P4, H_P5, H_P6, H_P7, H_Authority, H_Unsupported, H_Bad_Data, "
"H_NOT_FOUND, H_Invalid_Key, H_Busy, H_LongBusy, H_Aborted*"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:343
msgid ""
"H_PKS_UNWRAP_OBJECT is used to unwrap an object that was previously warapped "
"with H_PKS_WRAP_OBJECT."
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:347
msgid "References"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:348
msgid ""
"\"Power Architecture Platform Reference\" https://en.wikipedia.org/wiki/"
"Power_Architecture_Platform_Reference"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:350
msgid ""
"\"Linux on Power Architecture Platform Reference\" https://members."
"openpowerfoundation.org/document/dl/469"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:352
msgid ""
"\"Definitions and Notation\" Book III-Section 14.5.3 https://"
"openpowerfoundation.org/?resource_lib=power-isa-version-3-0"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:354
msgid "arch/powerpc/include/asm/hvcall.h"
msgstr ""

#: ../../../arch/powerpc/papr_hcalls.rst:355
msgid ""
"\"64-Bit ELF V2 ABI Specification: Power Architecture\" https://"
"openpowerfoundation.org/?resource_lib=64-bit-elf-v2-abi-specification-power-"
"architecture"
msgstr ""
