# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../crypto/async-tx-api.rst:5
msgid "Asynchronous Transfers/Transforms API"
msgstr ""

#: ../../../crypto/async-tx-api.rst:29
msgid "1. Introduction"
msgstr ""

#: ../../../crypto/async-tx-api.rst:31
msgid ""
"The async_tx API provides methods for describing a chain of asynchronous "
"bulk memory transfers/transforms with support for inter-transactional "
"dependencies.  It is implemented as a dmaengine client that smooths over the "
"details of different hardware offload engine implementations.  Code that is "
"written to the API can optimize for asynchronous operation and the API will "
"fit the chain of operations to the available offload resources."
msgstr ""

#: ../../../crypto/async-tx-api.rst:40
msgid "2.Genealogy"
msgstr ""

#: ../../../crypto/async-tx-api.rst:42
msgid ""
"The API was initially designed to offload the memory copy and xor-parity-"
"calculations of the md-raid5 driver using the offload engines present in the "
"Intel(R) Xscale series of I/O processors.  It also built on the 'dmaengine' "
"layer developed for offloading memory copies in the network stack using "
"Intel(R) I/OAT engines.  The following design features surfaced as a result:"
msgstr ""

#: ../../../crypto/async-tx-api.rst:49
msgid ""
"implicit synchronous path: users of the API do not need to know if the "
"platform they are running on has offload capabilities.  The operation will "
"be offloaded when an engine is available and carried out in software "
"otherwise."
msgstr ""

#: ../../../crypto/async-tx-api.rst:53
msgid ""
"cross channel dependency chains: the API allows a chain of dependent "
"operations to be submitted, like xor->copy->xor in the raid5 case.  The API "
"automatically handles cases where the transition from one operation to "
"another implies a hardware channel switch."
msgstr ""

#: ../../../crypto/async-tx-api.rst:57
msgid ""
"dmaengine extensions to support multiple clients and operation types beyond "
"'memcpy'"
msgstr ""

#: ../../../crypto/async-tx-api.rst:61
msgid "3. Usage"
msgstr ""

#: ../../../crypto/async-tx-api.rst:64
msgid "3.1 General format of the API"
msgstr ""

#: ../../../crypto/async-tx-api.rst:72
msgid "3.2 Supported operations"
msgstr ""

#: ../../../crypto/async-tx-api.rst:75
msgid "memcpy"
msgstr ""

#: ../../../crypto/async-tx-api.rst:75
msgid "memory copy between a source and a destination buffer"
msgstr ""

#: ../../../crypto/async-tx-api.rst:76
msgid "memset"
msgstr ""

#: ../../../crypto/async-tx-api.rst:76
msgid "fill a destination buffer with a byte value"
msgstr ""

#: ../../../crypto/async-tx-api.rst:77
msgid "xor"
msgstr ""

#: ../../../crypto/async-tx-api.rst:77
msgid ""
"xor a series of source buffers and write the result to a destination buffer"
msgstr ""

#: ../../../crypto/async-tx-api.rst:79
msgid "xor_val"
msgstr ""

#: ../../../crypto/async-tx-api.rst:79
msgid ""
"xor a series of source buffers and set a flag if the result is zero.  The "
"implementation attempts to prevent writes to memory"
msgstr ""

#: ../../../crypto/async-tx-api.rst:82
msgid "pq"
msgstr ""

#: ../../../crypto/async-tx-api.rst:82
msgid "generate the p+q (raid6 syndrome) from a series of source buffers"
msgstr ""

#: ../../../crypto/async-tx-api.rst:83
msgid "pq_val"
msgstr ""

#: ../../../crypto/async-tx-api.rst:83
msgid ""
"validate that a p and or q buffer are in sync with a given series of sources"
msgstr ""

#: ../../../crypto/async-tx-api.rst:85
msgid "datap"
msgstr ""

#: ../../../crypto/async-tx-api.rst:85
msgid ""
"(raid6_datap_recov) recover a raid6 data block and the p block from the "
"given sources"
msgstr ""

#: ../../../crypto/async-tx-api.rst:87
msgid "2data"
msgstr ""

#: ../../../crypto/async-tx-api.rst:87
msgid "(raid6_2data_recov) recover 2 raid6 data blocks from the given sources"
msgstr ""

#: ../../../crypto/async-tx-api.rst:92
msgid "3.3 Descriptor management"
msgstr ""

#: ../../../crypto/async-tx-api.rst:94
msgid ""
"The return value is non-NULL and points to a 'descriptor' when the operation "
"has been queued to execute asynchronously.  Descriptors are recycled "
"resources, under control of the offload engine driver, to be reused as "
"operations complete.  When an application needs to submit a chain of "
"operations it must guarantee that the descriptor is not automatically "
"recycled before the dependency is submitted.  This requires that all "
"descriptors be acknowledged by the application before the offload engine "
"driver is allowed to recycle (or free) the descriptor.  A descriptor can be "
"acked by one of the following methods:"
msgstr ""

#: ../../../crypto/async-tx-api.rst:104
msgid ""
"setting the ASYNC_TX_ACK flag if no child operations are to be submitted"
msgstr ""

#: ../../../crypto/async-tx-api.rst:105
msgid ""
"submitting an unacknowledged descriptor as a dependency to another async_tx "
"call will implicitly set the acknowledged state."
msgstr ""

#: ../../../crypto/async-tx-api.rst:107
msgid "calling async_tx_ack() on the descriptor."
msgstr ""

#: ../../../crypto/async-tx-api.rst:110
msgid "3.4 When does the operation execute?"
msgstr ""

#: ../../../crypto/async-tx-api.rst:112
msgid ""
"Operations do not immediately issue after return from the async_<operation> "
"call.  Offload engine drivers batch operations to improve performance by "
"reducing the number of mmio cycles needed to manage the channel.  Once a "
"driver-specific threshold is met the driver automatically issues pending "
"operations.  An application can force this event by calling "
"async_tx_issue_pending_all().  This operates on all channels since the "
"application has no knowledge of channel to operation mapping."
msgstr ""

#: ../../../crypto/async-tx-api.rst:122
msgid "3.5 When does the operation complete?"
msgstr ""

#: ../../../crypto/async-tx-api.rst:124
msgid ""
"There are two methods for an application to learn about the completion of an "
"operation."
msgstr ""

#: ../../../crypto/async-tx-api.rst:127
msgid ""
"Call dma_wait_for_async_tx().  This call causes the CPU to spin while it "
"polls for the completion of the operation.  It handles dependency chains and "
"issuing pending operations."
msgstr ""

#: ../../../crypto/async-tx-api.rst:130
msgid ""
"Specify a completion callback.  The callback routine runs in tasklet context "
"if the offload engine driver supports interrupts, or it is called in "
"application context if the operation is carried out synchronously in "
"software.  The callback can be set in the call to async_<operation>, or when "
"the application needs to submit a chain of unknown length it can use the "
"async_trigger_callback() routine to set a completion interrupt/callback at "
"the end of the chain."
msgstr ""

#: ../../../crypto/async-tx-api.rst:139
msgid "3.6 Constraints"
msgstr ""

#: ../../../crypto/async-tx-api.rst:141
msgid ""
"Calls to async_<operation> are not permitted in IRQ context.  Other contexts "
"are permitted provided constraint #2 is not violated."
msgstr ""

#: ../../../crypto/async-tx-api.rst:143
msgid ""
"Completion callback routines cannot submit new operations.  This results in "
"recursion in the synchronous case and spin_locks being acquired twice in the "
"asynchronous case."
msgstr ""

#: ../../../crypto/async-tx-api.rst:148
msgid "3.7 Example"
msgstr ""

#: ../../../crypto/async-tx-api.rst:150
msgid ""
"Perform a xor->copy->xor operation where each operation depends on the "
"result from the previous operation::"
msgstr ""

#: ../../../crypto/async-tx-api.rst:191
msgid ""
"See include/linux/async_tx.h for more information on the flags.  See the "
"ops_run_* and ops_complete_* routines in drivers/md/raid5.c for more "
"implementation examples."
msgstr ""

#: ../../../crypto/async-tx-api.rst:196
msgid "4. Driver Development Notes"
msgstr ""

#: ../../../crypto/async-tx-api.rst:199
msgid "4.1 Conformance points"
msgstr ""

#: ../../../crypto/async-tx-api.rst:201
msgid ""
"There are a few conformance points required in dmaengine drivers to "
"accommodate assumptions made by applications using the async_tx API:"
msgstr ""

#: ../../../crypto/async-tx-api.rst:204
msgid "Completion callbacks are expected to happen in tasklet context"
msgstr ""

#: ../../../crypto/async-tx-api.rst:205
msgid "dma_async_tx_descriptor fields are never manipulated in IRQ context"
msgstr ""

#: ../../../crypto/async-tx-api.rst:206
msgid ""
"Use async_tx_run_dependencies() in the descriptor clean up path to handle "
"submission of dependent operations"
msgstr ""

#: ../../../crypto/async-tx-api.rst:210
msgid "4.2 \"My application needs exclusive control of hardware channels\""
msgstr ""

#: ../../../crypto/async-tx-api.rst:212
msgid ""
"Primarily this requirement arises from cases where a DMA engine driver is "
"being used to support device-to-memory operations.  A channel that is "
"performing these operations cannot, for many platform specific reasons, be "
"shared.  For these cases the dma_request_channel() interface is provided."
msgstr ""

#: ../../../crypto/async-tx-api.rst:218
msgid "The interface is::"
msgstr ""

#: ../../../crypto/async-tx-api.rst:224
msgid "Where dma_filter_fn is defined as::"
msgstr ""

#: ../../../crypto/async-tx-api.rst:228
msgid ""
"When the optional 'filter_fn' parameter is set to NULL dma_request_channel "
"simply returns the first channel that satisfies the capability mask.  "
"Otherwise, when the mask parameter is insufficient for specifying the "
"necessary channel, the filter_fn routine can be used to disposition the "
"available channels in the system. The filter_fn routine is called once for "
"each free channel in the system.  Upon seeing a suitable channel filter_fn "
"returns DMA_ACK which flags that channel to be the return value from "
"dma_request_channel.  A channel allocated via this interface is exclusive to "
"the caller, until dma_release_channel() is called."
msgstr ""

#: ../../../crypto/async-tx-api.rst:239
msgid ""
"The DMA_PRIVATE capability flag is used to tag dma devices that should not "
"be used by the general-purpose allocator.  It can be set at initialization "
"time if it is known that a channel will always be private.  Alternatively, "
"it is set when dma_request_channel() finds an unused \"public\" channel."
msgstr ""

#: ../../../crypto/async-tx-api.rst:245
msgid "A couple caveats to note when implementing a driver and consumer:"
msgstr ""

#: ../../../crypto/async-tx-api.rst:247
msgid ""
"Once a channel has been privately allocated it will no longer be considered "
"by the general-purpose allocator even after a call to dma_release_channel()."
msgstr ""

#: ../../../crypto/async-tx-api.rst:250
msgid ""
"Since capabilities are specified at the device level a dma_device with "
"multiple channels will either have all channels public, or all channels "
"private."
msgstr ""

#: ../../../crypto/async-tx-api.rst:255
msgid "5. Source"
msgstr ""

#: ../../../crypto/async-tx-api.rst:257
msgid "include/linux/dmaengine.h:"
msgstr ""

#: ../../../crypto/async-tx-api.rst:258
msgid "core header file for DMA drivers and api users"
msgstr ""

#: ../../../crypto/async-tx-api.rst:259
msgid "drivers/dma/dmaengine.c:"
msgstr ""

#: ../../../crypto/async-tx-api.rst:260
msgid "offload engine channel management routines"
msgstr ""

#: ../../../crypto/async-tx-api.rst:261
msgid "drivers/dma/:"
msgstr ""

#: ../../../crypto/async-tx-api.rst:262
msgid "location for offload engine drivers"
msgstr ""

#: ../../../crypto/async-tx-api.rst:263
msgid "include/linux/async_tx.h:"
msgstr ""

#: ../../../crypto/async-tx-api.rst:264
msgid "core header file for the async_tx api"
msgstr ""

#: ../../../crypto/async-tx-api.rst:265
msgid "crypto/async_tx/async_tx.c:"
msgstr ""

#: ../../../crypto/async-tx-api.rst:266
msgid "async_tx interface to dmaengine and common code"
msgstr ""

#: ../../../crypto/async-tx-api.rst:267
msgid "crypto/async_tx/async_memcpy.c:"
msgstr ""

#: ../../../crypto/async-tx-api.rst:268
msgid "copy offload"
msgstr ""

#: ../../../crypto/async-tx-api.rst:269
msgid "crypto/async_tx/async_xor.c:"
msgstr ""

#: ../../../crypto/async-tx-api.rst:270
msgid "xor and xor zero sum offload"
msgstr ""
