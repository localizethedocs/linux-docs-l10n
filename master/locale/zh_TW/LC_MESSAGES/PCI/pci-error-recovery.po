# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../PCI/pci-error-recovery.rst:5
msgid "PCI Error Recovery"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:0
msgid "Authors"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:8
msgid "Linas Vepstas <linasvepstas@gmail.com>"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:9
msgid "Richard Lary <rlary@us.ibm.com>"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:10
msgid "Mike Mason <mmlnx@us.ibm.com>"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:13
msgid ""
"Many PCI bus controllers are able to detect a variety of hardware PCI errors "
"on the bus, such as parity errors on the data and address buses, as well as "
"SERR and PERR errors.  Some of the more advanced chipsets are able to deal "
"with these errors; these include PCI-E chipsets, and the PCI-host bridges "
"found on IBM Power4, Power5 and Power6-based pSeries boxes. A typical action "
"taken is to disconnect the affected device, halting all I/O to it.  The goal "
"of a disconnection is to avoid system corruption; for example, to halt "
"system memory corruption due to DMAs to \"wild\" addresses. Typically, a "
"reconnection mechanism is also offered, so that the affected PCI device(s) "
"are reset and put back into working condition. The reset phase requires "
"coordination between the affected device drivers and the PCI controller "
"chip. This document describes a generic API for notifying device drivers of "
"a bus disconnection, and then performing error recovery. This API is "
"currently implemented in the 2.6.16 and later kernels."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:29
msgid ""
"Reporting and recovery is performed in several steps. First, when a PCI "
"hardware error has resulted in a bus disconnect, that event is reported as "
"soon as possible to all affected device drivers, including multiple "
"instances of a device driver on multi-function cards. This allows device "
"drivers to avoid deadlocking in spinloops, waiting for some i/o-space "
"register to change, when it never will. It also gives the drivers a chance "
"to defer incoming I/O as needed."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:38
msgid ""
"Next, recovery is performed in several stages. Most of the complexity is "
"forced by the need to handle multi-function devices, that is, devices that "
"have multiple device drivers associated with them. In the first stage, each "
"driver is allowed to indicate what type of reset it desires, the choices "
"being a simple re-enabling of I/O or requesting a slot reset."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:45
msgid "If any driver requests a slot reset, that is what will be done."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:47
msgid ""
"After a reset and/or a re-enabling of I/O, all drivers are again notified, "
"so that they may then perform any device setup/config that may be required.  "
"After these have all completed, a final \"resume normal operations\" event "
"is sent out."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:52
msgid ""
"The biggest reason for choosing a kernel-based implementation rather than a "
"user-space implementation was the need to deal with bus disconnects of PCI "
"devices attached to storage media, and, in particular, disconnects from "
"devices holding the root file system.  If the root file system is "
"disconnected, a user-space mechanism would have to go through a large number "
"of contortions to complete recovery. Almost all of the current Linux file "
"systems are not tolerant of disconnection from/reconnection to their "
"underlying block device. By contrast, bus errors are easy to manage in the "
"device driver. Indeed, most device drivers already handle very similar "
"recovery procedures; for example, the SCSI-generic layer already provides "
"significant mechanisms for dealing with SCSI bus errors and SCSI bus resets."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:67
msgid "Detailed Design"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:69
msgid ""
"Design and implementation details below, based on a chain of public email "
"discussions with Ben Herrenschmidt, circa 5 April 2005."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:72
msgid ""
"The error recovery API support is exposed to the driver in the form of a "
"structure of function pointers pointed to by a new field in struct "
"pci_driver. A driver that fails to provide the structure is \"non-aware\", "
"and the actual recovery steps taken are platform dependent.  The arch/"
"powerpc implementation will simulate a PCI hotplug remove/add."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:78
msgid "This structure has the form::"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:89
msgid "The possible channel states are::"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:97
msgid "Possible return values are::"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:107
msgid ""
"A driver does not have to implement all of these callbacks; however, if it "
"implements any, it must implement error_detected(). If a callback is not "
"implemented, the corresponding feature is considered unsupported. For "
"example, if mmio_enabled() and resume() aren't there, then it is assumed "
"that the driver is not doing any direct recovery and requires a slot reset.  "
"Typically a driver will want to know about a slot_reset()."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:115
msgid ""
"The actual steps taken by a platform to recover from a PCI error event will "
"be platform-dependent, but will follow the general sequence described below."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:120
msgid "STEP 0: Error Event"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:121
msgid ""
"A PCI bus error is detected by the PCI hardware.  On powerpc, the slot is "
"isolated, in that all I/O is blocked: all reads return 0xffffffff, all "
"writes are ignored."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:127
msgid "STEP 1: Notification"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:128
msgid ""
"Platform calls the error_detected() callback on every instance of every "
"driver affected by the error."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:131
msgid ""
"At this point, the device might not be accessible anymore, depending on the "
"platform (the slot will be isolated on powerpc). The driver may already have "
"\"noticed\" the error because of a failing I/O, but this is the proper "
"\"synchronization point\", that is, it gives the driver a chance to cleanup, "
"waiting for pending stuff (timers, whatever, etc...) to complete; it can "
"take semaphores, schedule, etc... everything but touch the device. Within "
"this function and after it returns, the driver shouldn't do any new IOs. "
"Called in task context. This is sort of a \"quiesce\" point. See note about "
"interrupts at the end of this doc."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:141
msgid ""
"All drivers participating in this system must implement this call. The "
"driver must return one of the following result codes:"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:144
msgid "PCI_ERS_RESULT_CAN_RECOVER"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:145
msgid ""
"Driver returns this if it thinks it might be able to recover the HW by just "
"banging IOs or if it wants to be given a chance to extract some diagnostic "
"information (see mmio_enable, below)."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:149
#: ../../../PCI/pci-error-recovery.rst:226
msgid "PCI_ERS_RESULT_NEED_RESET"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:150
msgid "Driver returns this if it can't recover without a slot reset."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:152
#: ../../../PCI/pci-error-recovery.rst:231
msgid "PCI_ERS_RESULT_DISCONNECT"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:153
msgid "Driver returns this if it doesn't want to recover at all."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:155
msgid ""
"The next step taken will depend on the result codes returned by the drivers."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:158
msgid ""
"If all drivers on the segment/slot return PCI_ERS_RESULT_CAN_RECOVER, then "
"the platform should re-enable IOs on the slot (or do nothing in particular, "
"if the platform doesn't isolate slots), and recovery proceeds to STEP 2 "
"(MMIO Enable)."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:163
msgid ""
"If any driver requested a slot reset (by returning "
"PCI_ERS_RESULT_NEED_RESET), then recovery proceeds to STEP 4 (Slot Reset)."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:166
msgid ""
"If the platform is unable to recover the slot, the next step is STEP 6 "
"(Permanent Failure)."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:171
msgid ""
"The current powerpc implementation assumes that a device driver will *not* "
"schedule or semaphore in this routine; the current powerpc implementation "
"uses one kernel thread to notify all devices; thus, if one device sleeps/"
"schedules, all devices are affected. Doing better requires complex multi-"
"threaded logic in the error recovery implementation (e.g. waiting for all "
"notification threads to \"join\" before proceeding with recovery.)  This "
"seems excessively complex and not worth implementing."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:180
msgid ""
"The current powerpc implementation doesn't much care if the device attempts "
"I/O at this point, or not.  I/Os will fail, returning a value of 0xff on "
"read, and writes will be dropped. If more than EEH_MAX_FAILS I/Os are "
"attempted to a frozen adapter, EEH assumes that the device driver has gone "
"into an infinite loop and prints an error to syslog.  A reboot is then "
"required to get the device working again."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:189
msgid "STEP 2: MMIO Enabled"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:190
msgid ""
"The platform re-enables MMIO to the device (but typically not the DMA), and "
"then calls the mmio_enabled() callback on all affected device drivers."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:194
msgid ""
"This is the \"early recovery\" call. IOs are allowed again, but DMA is not, "
"with some restrictions. This is NOT a callback for the driver to start "
"operations again, only to peek/poke at the device, extract diagnostic "
"information, if any, and eventually do things like trigger a device local "
"reset or some such, but not restart operations. This callback is made if all "
"drivers on a segment agree that they can try to recover and if no automatic "
"link reset was performed by the HW. If the platform can't just re-enable IOs "
"without a slot reset or a link reset, it will not call this callback, and "
"instead will have gone directly to STEP 3 (Link Reset) or STEP 4 (Slot Reset)"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:206
msgid ""
"The following is proposed; no platform implements this yet: Proposal: All I/"
"Os should be done _synchronously_ from within this callback, errors "
"triggered by them will be returned via the normal pci_check_whatever() API, "
"no new error_detected() callback will be issued due to an error happening "
"here. However, such an error might cause IOs to be re-blocked for the whole "
"segment, and thus invalidate the recovery that other devices on the same "
"segment might have done, forcing the whole segment into one of the next "
"states, that is, link reset or slot reset."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:216
msgid "The driver should return one of the following result codes:"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:217
msgid "PCI_ERS_RESULT_RECOVERED"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:218
msgid ""
"Driver returns this if it thinks the device is fully functional and thinks "
"it is ready to start normal driver operations again. There is no guarantee "
"that the driver will actually be allowed to proceed, as another driver on "
"the same segment might have failed and thus triggered a slot reset on "
"platforms that support it."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:227
msgid ""
"Driver returns this if it thinks the device is not recoverable in its "
"current state and it needs a slot reset to proceed."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:232
msgid ""
"Same as above. Total failure, no recovery even after reset driver dead. (To "
"be defined more precisely)"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:235
msgid ""
"The next step taken depends on the results returned by the drivers. If all "
"drivers returned PCI_ERS_RESULT_RECOVERED, then the platform proceeds to "
"either STEP3 (Link Reset) or to STEP 5 (Resume Operations)."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:239
msgid ""
"If any driver returned PCI_ERS_RESULT_NEED_RESET, then the platform proceeds "
"to STEP 4 (Slot Reset)"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:243
msgid "STEP 3: Link Reset"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:244
msgid ""
"The platform resets the link.  This is a PCI-Express specific step and is "
"done whenever a fatal error has been detected that can be \"solved\" by "
"resetting the link."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:249
msgid "STEP 4: Slot Reset"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:251
msgid ""
"In response to a return value of PCI_ERS_RESULT_NEED_RESET, the platform "
"will perform a slot reset on the requesting PCI device(s). The actual steps "
"taken by a platform to perform a slot reset will be platform-dependent. Upon "
"completion of slot reset, the platform will call the device slot_reset() "
"callback."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:257
msgid ""
"Powerpc platforms implement two levels of slot reset: soft reset(default) "
"and fundamental(optional) reset."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:260
msgid ""
"Powerpc soft reset consists of asserting the adapter #RST line and then "
"restoring the PCI BARs and PCI configuration header to a state that is "
"equivalent to what it would be after a fresh system power-on followed by "
"power-on BIOS/system firmware initialization. Soft reset is also known as "
"hot-reset."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:266
msgid ""
"Powerpc fundamental reset is supported by PCI Express cards only and results "
"in device's state machines, hardware logic, port states and configuration "
"registers to initialize to their default conditions."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:270
msgid ""
"For most PCI devices, a soft reset will be sufficient for recovery. Optional "
"fundamental reset is provided to support a limited number of PCI Express "
"devices for which a soft reset is not sufficient for recovery."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:275
msgid ""
"If the platform supports PCI hotplug, then the reset might be performed by "
"toggling the slot electrical power off/on."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:278
msgid ""
"It is important for the platform to restore the PCI config space to the "
"\"fresh poweron\" state, rather than the \"last state\". After a slot reset, "
"the device driver will almost always use its standard device initialization "
"routines, and an unusual config space setup may result in hung devices, "
"kernel panics, or silent data corruption."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:284
msgid ""
"This call gives drivers the chance to re-initialize the hardware (re-"
"download firmware, etc.).  At this point, the driver may assume that the "
"card is in a fresh state and is fully functional. The slot is unfrozen and "
"the driver has full access to PCI config space, memory mapped I/O space and "
"DMA. Interrupts (Legacy, MSI, or MSI-X) will also be available."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:291
msgid ""
"Drivers should not restart normal I/O processing operations at this point.  "
"If all device drivers report success on this callback, the platform will "
"call resume() to complete the sequence, and let the driver restart normal I/"
"O processing."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:296
msgid ""
"A driver can still return a critical failure for this function if it can't "
"get the device operational after reset.  If the platform previously tried a "
"soft reset, it might now try a hard reset (power cycle) and then call "
"slot_reset() again.  If the device still can't be recovered, there is "
"nothing more that can be done;  the platform will typically report a "
"\"permanent failure\" in such a case.  The device will be considered "
"\"dead\" in this case."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:304
msgid ""
"Drivers for multi-function cards will need to coordinate among themselves as "
"to which driver instance will perform any \"one-shot\" or global device "
"initialization. For example, the Symbios sym53cxx2 driver performs device "
"init only from PCI function 0::"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:312
msgid "Result codes:"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:313
msgid "PCI_ERS_RESULT_DISCONNECT Same as above."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:316
msgid ""
"Drivers for PCI Express cards that require a fundamental reset must set the "
"needs_freset bit in the pci_dev structure in their probe function. For "
"example, the QLogic qla2xxx driver sets the needs_freset bit for certain PCI "
"card types::"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:326
msgid ""
"Platform proceeds either to STEP 5 (Resume Operations) or STEP 6 (Permanent "
"Failure)."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:331
msgid ""
"The current powerpc implementation does not try a power-cycle reset if the "
"driver returned PCI_ERS_RESULT_DISCONNECT. However, it probably should."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:337
msgid "STEP 5: Resume Operations"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:338
msgid ""
"The platform will call the resume() callback on all affected device drivers "
"if all drivers on the segment have returned PCI_ERS_RESULT_RECOVERED from "
"one of the 3 previous callbacks. The goal of this callback is to tell the "
"driver to restart activity, that everything is back and running. This "
"callback does not return a result code."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:345
msgid ""
"At this point, if a new error happens, the platform will restart a new error "
"recovery sequence."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:349
msgid "STEP 6: Permanent Failure"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:350
msgid ""
"A \"permanent failure\" has occurred, and the platform cannot recover the "
"device.  The platform will call error_detected() with a pci_channel_state_t "
"value of pci_channel_io_perm_failure."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:354
msgid ""
"The device driver should, at this point, assume the worst. It should cancel "
"all pending I/O, refuse all new I/O, returning -EIO to higher layers. The "
"device driver should then clean up all of its memory and remove itself from "
"kernel operations, much as it would during system shutdown."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:360
msgid ""
"The platform will typically notify the system operator of the permanent "
"failure in some way.  If the device is hotplug-capable, the operator will "
"probably want to remove and replace the device. Note, however, not all "
"failures are truly \"permanent\". Some are caused by over-heating, some by a "
"poorly seated card. Many PCI error events are caused by software bugs, e.g. "
"DMAs to wild addresses or bogus split transactions due to programming "
"errors. See the discussion in Documentation/arch/powerpc/eeh-pci-error-"
"recovery.rst for additional detail on real-life experience of the causes of "
"software errors."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:373
msgid "Conclusion; General Remarks"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:374
msgid ""
"The way the callbacks are called is platform policy. A platform with no slot "
"reset capability may want to just \"ignore\" drivers that can't recover "
"(disconnect them) and try to let other cards on the same segment recover. "
"Keep in mind that in most real life cases, though, there will be only one "
"driver per segment."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:380
msgid ""
"Now, a note about interrupts. If you get an interrupt and your device is "
"dead or has been isolated, there is a problem :) The current policy is to "
"turn this into a platform policy. That is, the recovery API only requires "
"that:"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:385
msgid ""
"There is no guarantee that interrupt delivery can proceed from any device on "
"the segment starting from the error detection and until the slot_reset "
"callback is called, at which point interrupts are expected to be fully "
"operational."
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:390
msgid ""
"There is no guarantee that interrupt delivery is stopped, that is, a driver "
"that gets an interrupt after detecting an error, or that detects an error "
"within the interrupt handler such that it prevents proper ack'ing of the "
"interrupt (and thus removal of the source) should just return "
"IRQ_NOTHANDLED. It's up to the platform to deal with that condition, "
"typically by masking the IRQ source during the duration of the error "
"handling. It is expected that the platform \"knows\" which interrupts are "
"routed to error-management capable slots and can deal with temporarily "
"disabling that IRQ number during error processing (this isn't terribly "
"complex). That means some IRQ latency for other devices sharing the "
"interrupt, but there is simply no other way. High end platforms aren't "
"supposed to share interrupts between many devices anyway :)"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:406
msgid ""
"Implementation details for the powerpc platform are discussed in the file "
"Documentation/arch/powerpc/eeh-pci-error-recovery.rst"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:409
msgid ""
"As of this writing, there is a growing list of device drivers with patches "
"implementing error recovery. Not all of these patches are in mainline yet. "
"These may be used as \"examples\":"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:413
msgid "drivers/scsi/ipr"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:414
msgid "drivers/scsi/sym53c8xx_2"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:415
msgid "drivers/scsi/qla2xxx"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:416
msgid "drivers/scsi/lpfc"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:417
msgid "drivers/next/bnx2.c"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:418
msgid "drivers/next/e100.c"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:419
msgid "drivers/net/e1000"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:420
msgid "drivers/net/e1000e"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:421
msgid "drivers/net/ixgbe"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:422
msgid "drivers/net/cxgb3"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:423
msgid "drivers/net/s2io.c"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:425
msgid ""
"The cor_error_detected() callback is invoked in handle_error_source() when "
"the error severity is \"correctable\". The callback is optional and allows "
"additional logging to be done if desired. See example:"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:429
msgid "drivers/cxl/pci.c"
msgstr ""

#: ../../../PCI/pci-error-recovery.rst:432
msgid "The End"
msgstr ""
