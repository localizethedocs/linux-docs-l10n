# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-10 08:33+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../dev-tools/kcsan.rst:5
msgid "Kernel Concurrency Sanitizer (KCSAN)"
msgstr ""

#: ../../../dev-tools/kcsan.rst:7
msgid ""
"The Kernel Concurrency Sanitizer (KCSAN) is a dynamic race detector, which "
"relies on compile-time instrumentation, and uses a watchpoint-based sampling "
"approach to detect races. KCSAN's primary purpose is to detect `data races`_."
msgstr ""

#: ../../../dev-tools/kcsan.rst:12
msgid "Usage"
msgstr ""

#: ../../../dev-tools/kcsan.rst:14
msgid ""
"KCSAN is supported by both GCC and Clang. With GCC we require version 11 or "
"later, and with Clang also require version 11 or later."
msgstr ""

#: ../../../dev-tools/kcsan.rst:17
msgid "To enable KCSAN configure the kernel with::"
msgstr ""

#: ../../../dev-tools/kcsan.rst:21
msgid ""
"KCSAN provides several other configuration options to customize behaviour "
"(see the respective help text in ``lib/Kconfig.kcsan`` for more info)."
msgstr ""

#: ../../../dev-tools/kcsan.rst:25
msgid "Error reports"
msgstr ""

#: ../../../dev-tools/kcsan.rst:27
msgid "A typical data race report looks like this::"
msgstr ""

#: ../../../dev-tools/kcsan.rst:51
msgid ""
"The header of the report provides a short summary of the functions involved "
"in the race. It is followed by the access types and stack traces of the 2 "
"threads involved in the data race. If KCSAN also observed a value change, "
"the observed old value and new value are shown on the \"value changed\" line "
"respectively."
msgstr ""

#: ../../../dev-tools/kcsan.rst:56
msgid "The other less common type of data race report looks like this::"
msgstr ""

#: ../../../dev-tools/kcsan.rst:74
msgid ""
"This report is generated where it was not possible to determine the other "
"racing thread, but a race was inferred due to the data value of the watched "
"memory location having changed. These reports always show a \"value "
"changed\" line. A common reason for reports of this type are missing "
"instrumentation in the racing thread, but could also occur due to e.g. DMA "
"accesses. Such reports are shown only if "
"``CONFIG_KCSAN_REPORT_RACE_UNKNOWN_ORIGIN=y``, which is enabled by default."
msgstr ""

#: ../../../dev-tools/kcsan.rst:83
msgid "Selective analysis"
msgstr ""

#: ../../../dev-tools/kcsan.rst:85
msgid ""
"It may be desirable to disable data race detection for specific accesses, "
"functions, compilation units, or entire subsystems.  For static "
"blacklisting, the below options are available:"
msgstr ""

#: ../../../dev-tools/kcsan.rst:89
msgid ""
"KCSAN understands the ``data_race(expr)`` annotation, which tells KCSAN that "
"any data races due to accesses in ``expr`` should be ignored and resulting "
"behaviour when encountering a data race is deemed safe.  Please see "
"`\"Marking Shared-Memory Accesses\" in the LKMM`_ for more information."
msgstr ""

#: ../../../dev-tools/kcsan.rst:94
msgid ""
"Similar to ``data_race(...)``, the type qualifier ``__data_racy`` can be "
"used to document that all data races due to accesses to a variable are "
"intended and should be ignored by KCSAN::"
msgstr ""

#: ../../../dev-tools/kcsan.rst:104
msgid ""
"Disabling data race detection for entire functions can be accomplished by "
"using the function attribute ``__no_kcsan``::"
msgstr ""

#: ../../../dev-tools/kcsan.rst:111
msgid ""
"To dynamically limit for which functions to generate reports, see the "
"`DebugFS interface`_ blacklist/whitelist feature."
msgstr ""

#: ../../../dev-tools/kcsan.rst:114
msgid ""
"To disable data race detection for a particular compilation unit, add to the "
"``Makefile``::"
msgstr ""

#: ../../../dev-tools/kcsan.rst:119
msgid ""
"To disable data race detection for all compilation units listed in a "
"``Makefile``, add to the respective ``Makefile``::"
msgstr ""

#: ../../../dev-tools/kcsan.rst:126
msgid ""
"Furthermore, it is possible to tell KCSAN to show or hide entire classes of "
"data races, depending on preferences. These can be changed via the following "
"Kconfig options:"
msgstr ""

#: ../../../dev-tools/kcsan.rst:130
msgid ""
"``CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY``: If enabled and a conflicting "
"write is observed via a watchpoint, but the data value of the memory "
"location was observed to remain unchanged, do not report the data race."
msgstr ""

#: ../../../dev-tools/kcsan.rst:134
msgid ""
"``CONFIG_KCSAN_ASSUME_PLAIN_WRITES_ATOMIC``: Assume that plain aligned "
"writes up to word size are atomic by default. Assumes that such writes are "
"not subject to unsafe compiler optimizations resulting in data races. The "
"option causes KCSAN to not report data races due to conflicts where the only "
"plain accesses are aligned writes up to word size."
msgstr ""

#: ../../../dev-tools/kcsan.rst:140
msgid ""
"``CONFIG_KCSAN_PERMISSIVE``: Enable additional permissive rules to ignore "
"certain classes of common data races. Unlike the above, the rules are more "
"complex involving value-change patterns, access type, and address. This "
"option depends on ``CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY=y``. For details "
"please see the ``kernel/kcsan/permissive.h``. Testers and maintainers that "
"only focus on reports from specific subsystems and not the whole kernel are "
"recommended to disable this option."
msgstr ""

#: ../../../dev-tools/kcsan.rst:148
msgid ""
"To use the strictest possible rules, select ``CONFIG_KCSAN_STRICT=y``, which "
"configures KCSAN to follow the Linux-kernel memory consistency model (LKMM) "
"as closely as possible."
msgstr ""

#: ../../../dev-tools/kcsan.rst:153
msgid "DebugFS interface"
msgstr ""

#: ../../../dev-tools/kcsan.rst:155
msgid "The file ``/sys/kernel/debug/kcsan`` provides the following interface:"
msgstr ""

#: ../../../dev-tools/kcsan.rst:157
msgid "Reading ``/sys/kernel/debug/kcsan`` returns various runtime statistics."
msgstr ""

#: ../../../dev-tools/kcsan.rst:159
msgid ""
"Writing ``on`` or ``off`` to ``/sys/kernel/debug/kcsan`` allows turning "
"KCSAN on or off, respectively."
msgstr ""

#: ../../../dev-tools/kcsan.rst:162
msgid ""
"Writing ``!some_func_name`` to ``/sys/kernel/debug/kcsan`` adds "
"``some_func_name`` to the report filter list, which (by default) blacklists "
"reporting data races where either one of the top stackframes are a function "
"in the list."
msgstr ""

#: ../../../dev-tools/kcsan.rst:167
msgid ""
"Writing either ``blacklist`` or ``whitelist`` to ``/sys/kernel/debug/kcsan`` "
"changes the report filtering behaviour. For example, the blacklist feature "
"can be used to silence frequently occurring data races; the whitelist "
"feature can help with reproduction and testing of fixes."
msgstr ""

#: ../../../dev-tools/kcsan.rst:173
msgid "Tuning performance"
msgstr ""

#: ../../../dev-tools/kcsan.rst:175
msgid ""
"Core parameters that affect KCSAN's overall performance and bug detection "
"ability are exposed as kernel command-line arguments whose defaults can also "
"be changed via the corresponding Kconfig options."
msgstr ""

#: ../../../dev-tools/kcsan.rst:179
msgid ""
"``kcsan.skip_watch`` (``CONFIG_KCSAN_SKIP_WATCH``): Number of per-CPU memory "
"operations to skip, before another watchpoint is set up. Setting up "
"watchpoints more frequently will result in the likelihood of races to be "
"observed to increase. This parameter has the most significant impact on "
"overall system performance and race detection ability."
msgstr ""

#: ../../../dev-tools/kcsan.rst:185
msgid ""
"``kcsan.udelay_task`` (``CONFIG_KCSAN_UDELAY_TASK``): For tasks, the "
"microsecond delay to stall execution after a watchpoint has been set up. "
"Larger values result in the window in which we may observe a race to "
"increase."
msgstr ""

#: ../../../dev-tools/kcsan.rst:190
msgid ""
"``kcsan.udelay_interrupt`` (``CONFIG_KCSAN_UDELAY_INTERRUPT``): For "
"interrupts, the microsecond delay to stall execution after a watchpoint has "
"been set up. Interrupts have tighter latency requirements, and their delay "
"should generally be smaller than the one chosen for tasks."
msgstr ""

#: ../../../dev-tools/kcsan.rst:195
msgid "They may be tweaked at runtime via ``/sys/module/kcsan/parameters/``."
msgstr ""

#: ../../../dev-tools/kcsan.rst:198
msgid "Data Races"
msgstr ""

#: ../../../dev-tools/kcsan.rst:200
msgid ""
"In an execution, two memory accesses form a *data race* if they *conflict*, "
"they happen concurrently in different threads, and at least one of them is a "
"*plain access*; they *conflict* if both access the same memory location, and "
"at least one is a write. For a more thorough discussion and definition, see "
"`\"Plain Accesses and Data Races\" in the LKMM`_."
msgstr ""

#: ../../../dev-tools/kcsan.rst:209
msgid "Relationship with the Linux-Kernel Memory Consistency Model (LKMM)"
msgstr ""

#: ../../../dev-tools/kcsan.rst:211
msgid ""
"The LKMM defines the propagation and ordering rules of various memory "
"operations, which gives developers the ability to reason about concurrent "
"code. Ultimately this allows to determine the possible executions of "
"concurrent code, and if that code is free from data races."
msgstr ""

#: ../../../dev-tools/kcsan.rst:216
msgid ""
"KCSAN is aware of *marked atomic operations* (``READ_ONCE``, ``WRITE_ONCE``, "
"``atomic_*``, etc.), and a subset of ordering guarantees implied by memory "
"barriers. With ``CONFIG_KCSAN_WEAK_MEMORY=y``, KCSAN models load or store "
"buffering, and can detect missing ``smp_mb()``, ``smp_wmb()``, "
"``smp_rmb()``, ``smp_store_release()``, and all ``atomic_*`` operations with "
"equivalent implied barriers."
msgstr ""

#: ../../../dev-tools/kcsan.rst:223
msgid ""
"Note, KCSAN will not report all data races due to missing memory ordering, "
"specifically where a memory barrier would be required to prohibit subsequent "
"memory operation from reordering before the barrier. Developers should "
"therefore carefully consider the required memory ordering requirements that "
"remain unchecked."
msgstr ""

#: ../../../dev-tools/kcsan.rst:230
msgid "Race Detection Beyond Data Races"
msgstr ""

#: ../../../dev-tools/kcsan.rst:232
msgid ""
"For code with complex concurrency design, race-condition bugs may not always "
"manifest as data races. Race conditions occur if concurrently executing "
"operations result in unexpected system behaviour. On the other hand, data "
"races are defined at the C-language level. The following macros can be used "
"to check properties of concurrent code where bugs would not manifest as data "
"races."
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:342
msgid "``ASSERT_EXCLUSIVE_WRITER (var)``"
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:340
msgid "assert no concurrent writes to **var**"
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:344
#: include/linux/kcsan-checks.h:392 include/linux/kcsan-checks.h:427
#: include/linux/kcsan-checks.h:459 include/linux/kcsan-checks.h:475
msgid "**Parameters**"
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:346
#: include/linux/kcsan-checks.h:394 include/linux/kcsan-checks.h:429
#: include/linux/kcsan-checks.h:461 include/linux/kcsan-checks.h:477
msgid "``var``"
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:368
#: include/linux/kcsan-checks.h:417 include/linux/kcsan-checks.h:449
#: include/linux/kcsan-checks.h:465 include/linux/kcsan-checks.h:522
msgid "variable to assert on"
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:370
#: include/linux/kcsan-checks.h:419 include/linux/kcsan-checks.h:451
#: include/linux/kcsan-checks.h:467 include/linux/kcsan-checks.h:525
msgid "**Description**"
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:341
msgid ""
"Assert that there are no concurrent writes to **var**; other readers are "
"allowed. This assertion can be used to specify properties of concurrent "
"code, where violation cannot be detected as a normal data race."
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:345
msgid ""
"For example, if we only have a single writer, but multiple concurrent "
"readers, to avoid data races, all these accesses must be marked; even "
"concurrent marked writes racing with the single writer are bugs. "
"Unfortunately, due to being marked, they are no longer data races. For cases "
"like these, we can use the macro as follows:"
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:364
#: include/linux/kcsan-checks.h:440 include/linux/kcsan-checks.h:493
msgid "**Note**"
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:365
msgid ""
"ASSERT_EXCLUSIVE_WRITER_SCOPED(), if applicable, performs more thorough "
"checking if a clear scope where no concurrent writes are expected exists."
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:390
msgid "``ASSERT_EXCLUSIVE_WRITER_SCOPED (var)``"
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:388
msgid "assert no concurrent writes to **var** in scope"
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:389
msgid "Scoped variant of ASSERT_EXCLUSIVE_WRITER()."
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:391
msgid ""
"Assert that there are no concurrent writes to **var** for the duration of "
"the scope in which it is introduced. This provides a better way to fully "
"cover the enclosing scope, compared to multiple ASSERT_EXCLUSIVE_WRITER(), "
"and increases the likelihood for KCSAN to detect racing accesses."
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:396
msgid ""
"For example, it allows finding race-condition bugs that only occur due to "
"state changes within the scope itself:"
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:425
msgid "``ASSERT_EXCLUSIVE_ACCESS (var)``"
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:423
msgid "assert no concurrent accesses to **var**"
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:424
msgid ""
"Assert that there are no concurrent accesses to **var** (no readers nor "
"writers). This assertion can be used to specify properties of concurrent "
"code, where violation cannot be detected as a normal data race."
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:428
msgid ""
"For example, where exclusive access is expected after determining no other "
"users of an object are left, but the object is not actually freed. We can "
"check that this property actually holds as follows:"
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:441
msgid ""
"ASSERT_EXCLUSIVE_ACCESS_SCOPED(), if applicable, performs more thorough "
"checking if a clear scope where no concurrent accesses are expected exists."
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:444
msgid ""
"For cases where the object is freed, `KASAN <kasan.html>`_ is a better fit "
"to detect use-after-free bugs."
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:457
msgid "``ASSERT_EXCLUSIVE_ACCESS_SCOPED (var)``"
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:455
msgid "assert no concurrent accesses to **var** in scope"
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:456
msgid "Scoped variant of ASSERT_EXCLUSIVE_ACCESS()."
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:458
msgid ""
"Assert that there are no concurrent accesses to **var** (no readers nor "
"writers) for the entire duration of the scope in which it is introduced. "
"This provides a better way to fully cover the enclosing scope, compared to "
"multiple ASSERT_EXCLUSIVE_ACCESS(), and increases the likelihood for KCSAN "
"to detect racing accesses."
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:473
msgid "``ASSERT_EXCLUSIVE_BITS (var, mask)``"
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:471
msgid "assert no concurrent writes to subset of bits in **var**"
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:524
msgid "``mask``"
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:523
msgid "only check for modifications to bits set in **mask**"
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:472
msgid "Bit-granular variant of ASSERT_EXCLUSIVE_WRITER()."
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:474
msgid ""
"Assert that there are no concurrent writes to a subset of bits in **var**; "
"concurrent readers are permitted. This assertion captures more detailed bit-"
"level properties, compared to the other (word granularity) assertions. Only "
"the bits set in **mask** are checked for concurrent modifications, while "
"ignoring the remaining bits, i.e. concurrent writes (or reads) to ~mask bits "
"are ignored."
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:481
msgid ""
"Use this for variables, where some bits must not be modified concurrently, "
"yet other bits are expected to be modified concurrently."
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:484
msgid ""
"For example, variables where, after initialization, some bits are read-only, "
"but other bits may still be modified concurrently. A reader may wish to "
"assert that this is true as follows:"
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:494
msgid ""
"The access that immediately follows ASSERT_EXCLUSIVE_BITS() is assumed to "
"access the masked bits only, and KCSAN optimistically assumes it is "
"therefore safe, even in the presence of data races, and marking it with "
"READ_ONCE() is optional from KCSAN's point-of-view. We caution, however, "
"that it may still be advisable to do so, since we cannot reason about all "
"compiler optimizations when it comes to bit manipulations (on the reader and "
"writer side). If you are sure nothing can go wrong, we can write the above "
"simply as:"
msgstr ""

#: ../../../dev-tools/kcsan:238: include/linux/kcsan-checks.h:508
msgid ""
"Another example, where this may be used, is when certain bits of **var** may "
"only be modified when holding the appropriate lock, but other bits may still "
"be modified concurrently. Writers, where other bits may change concurrently, "
"could use the assertion as follows:"
msgstr ""

#: ../../../dev-tools/kcsan.rst:244
msgid "Implementation Details"
msgstr ""

#: ../../../dev-tools/kcsan.rst:246
msgid ""
"KCSAN relies on observing that two accesses happen concurrently. Crucially, "
"we want to (a) increase the chances of observing races (especially for races "
"that manifest rarely), and (b) be able to actually observe them. We can "
"accomplish (a) by injecting various delays, and (b) by using address "
"watchpoints (or breakpoints)."
msgstr ""

#: ../../../dev-tools/kcsan.rst:252
msgid ""
"If we deliberately stall a memory access, while we have a watchpoint for its "
"address set up, and then observe the watchpoint to fire, two accesses to the "
"same address just raced. Using hardware watchpoints, this is the approach "
"taken in `DataCollider <http://usenix.org/legacy/events/osdi10/tech/"
"full_papers/Erickson.pdf>`_. Unlike DataCollider, KCSAN does not use "
"hardware watchpoints, but instead relies on compiler instrumentation and "
"\"soft watchpoints\"."
msgstr ""

#: ../../../dev-tools/kcsan.rst:260
msgid ""
"In KCSAN, watchpoints are implemented using an efficient encoding that "
"stores access type, size, and address in a long; the benefits of using "
"\"soft watchpoints\" are portability and greater flexibility. KCSAN then "
"relies on the compiler instrumenting plain accesses. For each instrumented "
"plain access:"
msgstr ""

#: ../../../dev-tools/kcsan.rst:265
msgid ""
"Check if a matching watchpoint exists; if yes, and at least one access is a "
"write, then we encountered a racing access."
msgstr ""

#: ../../../dev-tools/kcsan.rst:268
msgid ""
"Periodically, if no matching watchpoint exists, set up a watchpoint and "
"stall for a small randomized delay."
msgstr ""

#: ../../../dev-tools/kcsan.rst:271
msgid ""
"Also check the data value before the delay, and re-check the data value "
"after delay; if the values mismatch, we infer a race of unknown origin."
msgstr ""

#: ../../../dev-tools/kcsan.rst:274
msgid ""
"To detect data races between plain and marked accesses, KCSAN also annotates "
"marked accesses, but only to check if a watchpoint exists; i.e. KCSAN never "
"sets up a watchpoint on marked accesses. By never setting up watchpoints for "
"marked operations, if all accesses to a variable that is accessed "
"concurrently are properly marked, KCSAN will never trigger a watchpoint and "
"therefore never report the accesses."
msgstr ""

#: ../../../dev-tools/kcsan.rst:282
msgid "Modeling Weak Memory"
msgstr ""

#: ../../../dev-tools/kcsan.rst:284
msgid ""
"KCSAN's approach to detecting data races due to missing memory barriers is "
"based on modeling access reordering (with ``CONFIG_KCSAN_WEAK_MEMORY=y``). "
"Each plain memory access for which a watchpoint is set up, is also selected "
"for simulated reordering within the scope of its function (at most 1 in-"
"flight access)."
msgstr ""

#: ../../../dev-tools/kcsan.rst:290
msgid ""
"Once an access has been selected for reordering, it is checked along every "
"other access until the end of the function scope. If an appropriate memory "
"barrier is encountered, the access will no longer be considered for "
"simulated reordering."
msgstr ""

#: ../../../dev-tools/kcsan.rst:295
msgid ""
"When the result of a memory operation should be ordered by a barrier, KCSAN "
"can then detect data races where the conflict only occurs as a result of a "
"missing barrier. Consider the example::"
msgstr ""

#: ../../../dev-tools/kcsan.rst:311
msgid ""
"When weak memory modeling is enabled, KCSAN can consider ``x`` in ``T1`` for "
"simulated reordering. After the write of ``flag``, ``x`` is again checked "
"for concurrent accesses: because ``T2`` is able to proceed after the write "
"of ``flag``, a data race is detected. With the correct barriers in place, "
"``x`` would not be considered for reordering after the proper release of "
"``flag``, and no data race would be detected."
msgstr ""

#: ../../../dev-tools/kcsan.rst:318
msgid ""
"Deliberate trade-offs in complexity but also practical limitations mean only "
"a subset of data races due to missing memory barriers can be detected. With "
"currently available compiler support, the implementation is limited to "
"modeling the effects of \"buffering\" (delaying accesses), since the runtime "
"cannot \"prefetch\" accesses. Also recall that watchpoints are only set up "
"for plain accesses, and the only access type for which KCSAN simulates "
"reordering. This means reordering of marked accesses is not modeled."
msgstr ""

#: ../../../dev-tools/kcsan.rst:326
msgid ""
"A consequence of the above is that acquire operations do not require barrier "
"instrumentation (no prefetching). Furthermore, marked accesses introducing "
"address or control dependencies do not require special handling (the marked "
"access cannot be reordered, later dependent accesses cannot be prefetched)."
msgstr ""

#: ../../../dev-tools/kcsan.rst:332
msgid "Key Properties"
msgstr ""

#: ../../../dev-tools/kcsan.rst:334
msgid ""
"**Memory Overhead:**  The overall memory overhead is only a few MiB "
"depending on configuration. The current implementation uses a small array of "
"longs to encode watchpoint information, which is negligible."
msgstr ""

#: ../../../dev-tools/kcsan.rst:338
msgid ""
"**Performance Overhead:** KCSAN's runtime aims to be minimal, using an "
"efficient watchpoint encoding that does not require acquiring any shared "
"locks in the fast-path. For kernel boot on a system with 8 CPUs:"
msgstr ""

#: ../../../dev-tools/kcsan.rst:342
msgid "5.0x slow-down with the default KCSAN config;"
msgstr ""

#: ../../../dev-tools/kcsan.rst:343
msgid ""
"2.8x slow-down from runtime fast-path overhead only (set very large "
"``KCSAN_SKIP_WATCH`` and unset ``KCSAN_SKIP_WATCH_RANDOMIZE``)."
msgstr ""

#: ../../../dev-tools/kcsan.rst:346
msgid ""
"**Annotation Overheads:** Minimal annotations are required outside the KCSAN "
"runtime. As a result, maintenance overheads are minimal as the kernel "
"evolves."
msgstr ""

#: ../../../dev-tools/kcsan.rst:350
msgid ""
"**Detects Racy Writes from Devices:** Due to checking data values upon "
"setting up watchpoints, racy writes from devices can also be detected."
msgstr ""

#: ../../../dev-tools/kcsan.rst:353
msgid ""
"**Memory Ordering:** KCSAN is aware of only a subset of LKMM ordering rules; "
"this may result in missed data races (false negatives)."
msgstr ""

#: ../../../dev-tools/kcsan.rst:356
msgid ""
"**Analysis Accuracy:** For observed executions, due to using a sampling "
"strategy, the analysis is *unsound* (false negatives possible), but aims to "
"be complete (no false positives)."
msgstr ""

#: ../../../dev-tools/kcsan.rst:361
msgid "Alternatives Considered"
msgstr ""

#: ../../../dev-tools/kcsan.rst:363
msgid ""
"An alternative data race detection approach for the kernel can be found in "
"the `Kernel Thread Sanitizer (KTSAN) <https://github.com/google/kernel-"
"sanitizers/blob/master/KTSAN.md>`_. KTSAN is a happens-before data race "
"detector, which explicitly establishes the happens-before order between "
"memory operations, which can then be used to determine data races as defined "
"in `Data Races`_."
msgstr ""

#: ../../../dev-tools/kcsan.rst:370
msgid ""
"To build a correct happens-before relation, KTSAN must be aware of all "
"ordering rules of the LKMM and synchronization primitives. Unfortunately, "
"any omission leads to large numbers of false positives, which is especially "
"detrimental in the context of the kernel which includes numerous custom "
"synchronization mechanisms. To track the happens-before relation, KTSAN's "
"implementation requires metadata for each memory location (shadow memory), "
"which for each page corresponds to 4 pages of shadow memory, and can "
"translate into overhead of tens of GiB on a large system."
msgstr ""
