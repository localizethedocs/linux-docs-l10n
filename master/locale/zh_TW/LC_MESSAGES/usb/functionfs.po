# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usb/functionfs.rst:3
msgid "How FunctionFS works"
msgstr ""

#: ../../../usb/functionfs.rst:6
msgid "Overview"
msgstr "概覽"

#: ../../../usb/functionfs.rst:8
msgid ""
"From kernel point of view it is just a composite function with some unique "
"behaviour.  It may be added to an USB configuration only after the user "
"space driver has registered by writing descriptors and strings (the user "
"space program has to provide the same information that kernel level "
"composite functions provide when they are added to the configuration)."
msgstr ""

#: ../../../usb/functionfs.rst:15
msgid ""
"This in particular means that the composite initialisation functions may not "
"be in init section (ie. may not use the __init tag)."
msgstr ""

#: ../../../usb/functionfs.rst:18
msgid ""
"From user space point of view it is a file system which when mounted "
"provides an \"ep0\" file.  User space driver need to write descriptors and "
"strings to that file.  It does not need to worry about endpoints, interfaces "
"or strings numbers but simply provide descriptors such as if the function "
"was the only one (endpoints and strings numbers starting from one and "
"interface numbers starting from zero).  The FunctionFS changes them as "
"needed also handling situation when numbers differ in different "
"configurations."
msgstr ""

#: ../../../usb/functionfs.rst:28
msgid ""
"For more information about FunctionFS descriptors see :doc:`functionfs-desc`"
msgstr ""

#: ../../../usb/functionfs.rst:30
msgid ""
"When descriptors and strings are written \"ep#\" files appear (one for each "
"declared endpoint) which handle communication on a single endpoint.  Again, "
"FunctionFS takes care of the real numbers and changing of the configuration "
"(which means that \"ep1\" file may be really mapped to (say) endpoint 3 (and "
"when configuration changes to (say) endpoint 2)).  \"ep0\" is used for "
"receiving events and handling setup requests."
msgstr ""

#: ../../../usb/functionfs.rst:38
msgid "When all files are closed the function disables itself."
msgstr ""

#: ../../../usb/functionfs.rst:40
msgid ""
"What I also want to mention is that the FunctionFS is designed in such a way "
"that it is possible to mount it several times so in the end a gadget could "
"use several FunctionFS functions. The idea is that each FunctionFS instance "
"is identified by the device name used when mounting."
msgstr ""

#: ../../../usb/functionfs.rst:46
msgid ""
"One can imagine a gadget that has an Ethernet, MTP and HID interfaces where "
"the last two are implemented via FunctionFS.  On user space level it would "
"look like this::"
msgstr ""

#: ../../../usb/functionfs.rst:56
msgid ""
"On kernel level the gadget checks ffs_data->dev_name to identify whether its "
"FunctionFS is designed for MTP (\"mtp\") or HID (\"hid\")."
msgstr ""

#: ../../../usb/functionfs.rst:59
msgid ""
"If no \"functions\" module parameters is supplied, the driver accepts just "
"one function with any name."
msgstr ""

#: ../../../usb/functionfs.rst:62
msgid ""
"When \"functions\" module parameter is supplied, only functions with listed "
"names are accepted. In particular, if the \"functions\" parameter's value is "
"just a one-element list, then the behaviour is similar to when there is no "
"\"functions\" at all; however, only a function with the specified name is "
"accepted."
msgstr ""

#: ../../../usb/functionfs.rst:68
msgid ""
"The gadget is registered only after all the declared function filesystems "
"have been mounted and USB descriptors of all functions have been written to "
"their ep0's."
msgstr ""

#: ../../../usb/functionfs.rst:72
msgid ""
"Conversely, the gadget is unregistered after the first USB function closes "
"its endpoints."
msgstr ""

#: ../../../usb/functionfs.rst:76
msgid "DMABUF interface"
msgstr ""

#: ../../../usb/functionfs.rst:78
msgid ""
"FunctionFS additionally supports a DMABUF based interface, where the "
"userspace can attach DMABUF objects (externally created) to an endpoint, and "
"subsequently use them for data transfers."
msgstr ""

#: ../../../usb/functionfs.rst:82
msgid ""
"A userspace application can then use this interface to share DMABUF objects "
"between several interfaces, allowing it to transfer data in a zero-copy "
"fashion, for instance between IIO and the USB stack."
msgstr ""

#: ../../../usb/functionfs.rst:86
msgid ""
"As part of this interface, three new IOCTLs have been added. These three "
"IOCTLs have to be performed on a data endpoint (ie. not ep0). They are:"
msgstr ""

#: ../../../usb/functionfs.rst:89
msgid "``FUNCTIONFS_DMABUF_ATTACH(int)``"
msgstr ""

#: ../../../usb/functionfs.rst:90
msgid ""
"Attach the DMABUF object, identified by its file descriptor, to the data "
"endpoint. Returns zero on success, and a negative errno value on error."
msgstr ""

#: ../../../usb/functionfs.rst:94
msgid "``FUNCTIONFS_DMABUF_DETACH(int)``"
msgstr ""

#: ../../../usb/functionfs.rst:95
msgid ""
"Detach the given DMABUF object, identified by its file descriptor, from the "
"data endpoint. Returns zero on success, and a negative errno value on error. "
"Note that closing the endpoint's file descriptor will automatically detach "
"all attached DMABUFs."
msgstr ""

#: ../../../usb/functionfs.rst:100
msgid "``FUNCTIONFS_DMABUF_TRANSFER(struct usb_ffs_dmabuf_transfer_req *)``"
msgstr ""

#: ../../../usb/functionfs.rst:101
msgid ""
"Enqueue the previously attached DMABUF to the transfer queue. The argument "
"is a structure that packs the DMABUF's file descriptor, the size in bytes to "
"transfer (which should generally correspond to the size of the DMABUF), and "
"a 'flags' field which is unused for now. Returns zero on success, and a "
"negative errno value on error."
msgstr ""
