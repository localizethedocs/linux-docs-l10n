# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../virt/kvm/devices/vcpu.rst:5
msgid "Generic vcpu interface"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:7
msgid ""
"The virtual cpu \"device\" also accepts the ioctls KVM_SET_DEVICE_ATTR, "
"KVM_GET_DEVICE_ATTR, and KVM_HAS_DEVICE_ATTR. The interface uses the same "
"struct kvm_device_attr as other devices, but targets VCPU-wide settings and "
"controls."
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:11
msgid ""
"The groups and attributes per virtual cpu, if any, are architecture specific."
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:14
msgid "1. GROUP: KVM_ARM_VCPU_PMU_V3_CTRL"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:0
msgid "Architectures"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:16 ../../../virt/kvm/devices/vcpu.rst:167
#: ../../../virt/kvm/devices/vcpu.rst:205
msgid "ARM64"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:19
msgid "1.1. ATTRIBUTE: KVM_ARM_VCPU_PMU_V3_IRQ"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:0
msgid "Parameters"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:21
msgid ""
"in kvm_device_attr.addr the address for PMU overflow interrupt is a pointer "
"to an int"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:24 ../../../virt/kvm/devices/vcpu.rst:47
#: ../../../virt/kvm/devices/vcpu.rst:175
#: ../../../virt/kvm/devices/vcpu.rst:212
#: ../../../virt/kvm/devices/vcpu.rst:234
msgid "Returns:"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:27 ../../../virt/kvm/devices/vcpu.rst:54
#: ../../../virt/kvm/devices/vcpu.rst:73 ../../../virt/kvm/devices/vcpu.rst:116
#: ../../../virt/kvm/devices/vcpu.rst:149
#: ../../../virt/kvm/devices/vcpu.rst:179
msgid "-EBUSY"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:27
msgid "The PMU overflow interrupt is already set"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:28 ../../../virt/kvm/devices/vcpu.rst:118
#: ../../../virt/kvm/devices/vcpu.rst:151
#: ../../../virt/kvm/devices/vcpu.rst:237
msgid "-EFAULT"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:28
msgid "Error reading interrupt number"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:29 ../../../virt/kvm/devices/vcpu.rst:52
#: ../../../virt/kvm/devices/vcpu.rst:71 ../../../virt/kvm/devices/vcpu.rst:119
#: ../../../virt/kvm/devices/vcpu.rst:215
#: ../../../virt/kvm/devices/vcpu.rst:239
msgid "-ENXIO"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:29
msgid ""
"PMUv3 not supported or the overflow interrupt not set when attempting to get "
"it"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:31 ../../../virt/kvm/devices/vcpu.rst:51
#: ../../../virt/kvm/devices/vcpu.rst:70 ../../../virt/kvm/devices/vcpu.rst:120
#: ../../../virt/kvm/devices/vcpu.rst:152
msgid "-ENODEV"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:31
msgid "KVM_ARM_VCPU_PMU_V3 feature missing from VCPU"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:32 ../../../virt/kvm/devices/vcpu.rst:74
#: ../../../virt/kvm/devices/vcpu.rst:153
#: ../../../virt/kvm/devices/vcpu.rst:178
#: ../../../virt/kvm/devices/vcpu.rst:217
msgid "-EINVAL"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:32
msgid ""
"Invalid PMU overflow interrupt number supplied or trying to set the IRQ "
"number without using an in-kernel irqchip."
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:37
msgid ""
"A value describing the PMUv3 (Performance Monitor Unit v3) overflow "
"interrupt number for this vcpu. This interrupt could be a PPI or SPI, but "
"the interrupt type must be same for each vcpu. As a PPI, the interrupt "
"number is the same for all vcpus, while as an SPI it must be a separate "
"number per vcpu."
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:43
msgid "1.2 ATTRIBUTE: KVM_ARM_VCPU_PMU_V3_INIT"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:45
msgid "no additional parameter in kvm_device_attr.addr"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:50 ../../../virt/kvm/devices/vcpu.rst:216
msgid "-EEXIST"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:50
msgid "Interrupt number already used"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:51 ../../../virt/kvm/devices/vcpu.rst:70
#: ../../../virt/kvm/devices/vcpu.rst:120
#: ../../../virt/kvm/devices/vcpu.rst:152
msgid "PMUv3 not supported or GIC not initialized"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:52
msgid "PMUv3 not supported, missing VCPU feature or interrupt number not set"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:54
msgid "PMUv3 already initialized"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:57
msgid ""
"Request the initialization of the PMUv3.  If using the PMUv3 with an in-"
"kernel virtual GIC implementation, this must be done after initializing the "
"in-kernel irqchip."
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:62
msgid "1.3 ATTRIBUTE: KVM_ARM_VCPU_PMU_V3_FILTER"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:64
msgid ""
"in kvm_device_attr.addr the address for a PMU event filter is a pointer to a "
"struct kvm_pmu_event_filter"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:0
msgid "Returns"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:71
msgid ""
"PMUv3 not properly configured or in-kernel irqchip not configured as "
"required prior to calling this attribute"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:73
msgid "PMUv3 already initialized or a VCPU has already run"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:74
msgid "Invalid filter range"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:77
msgid "Request the installation of a PMU event filter described as follows::"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:90
msgid ""
"A filter range is defined as the range [@base_event, @base_event + "
"@nevents), together with an @action (KVM_PMU_EVENT_ALLOW or "
"KVM_PMU_EVENT_DENY). The first registered range defines the global policy "
"(global ALLOW if the first @action is DENY, global DENY if the first @action "
"is ALLOW). Multiple ranges can be programmed, and must fit within the event "
"space defined by the PMU architecture (10 bits on ARMv8.0, 16 bits from "
"ARMv8.1 onwards)."
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:97
msgid ""
"Note: \"Cancelling\" a filter by registering the opposite action for the "
"same range doesn't change the default action. For example, installing an "
"ALLOW filter for event range [0:10) as the first filter and then applying a "
"DENY action for the same range will leave the whole range as disabled."
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:102
msgid ""
"Restrictions: Event 0 (SW_INCR) is never filtered, as it doesn't count a "
"hardware event. Filtering event 0x1E (CHAIN) has no effect either, as it "
"isn't strictly speaking an event. Filtering the cycle counter is possible "
"using event 0x11 (CPU_CYCLES)."
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:108
msgid "1.4 ATTRIBUTE: KVM_ARM_VCPU_PMU_V3_SET_PMU"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:110
msgid ""
"in kvm_device_attr.addr the address to an int representing the PMU "
"identifier."
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:116
#: ../../../virt/kvm/devices/vcpu.rst:149
msgid ""
"PMUv3 already initialized, a VCPU has already run or an event filter has "
"already been set"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:118
msgid "Error accessing the PMU identifier"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:119
msgid "PMU not found"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:121
msgid "-ENOMEM"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:121
msgid "Could not allocate memory"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:124
msgid ""
"Request that the VCPU uses the specified hardware PMU when creating guest "
"events for the purpose of PMU emulation. The PMU identifier can be read from "
"the \"type\" file for the desired PMU instance under /sys/devices (or, "
"equivalent, /sys/bus/even_source). This attribute is particularly useful on "
"heterogeneous systems where there are at least two CPU PMUs on the system. "
"The PMU that is set for one VCPU will be used by all the other VCPUs. It "
"isn't possible to set a PMU if a PMU event filter is already present."
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:132
msgid ""
"Note that KVM will not make any attempts to run the VCPU on the physical "
"CPUs associated with the PMU specified by this attribute. This is entirely "
"left to userspace. However, attempting to run the VCPU on a physical CPU not "
"supported by the PMU will fail and KVM_RUN will return with exit_reason = "
"KVM_EXIT_FAIL_ENTRY and populate the fail_entry struct by setting "
"hardare_entry_failure_reason field to KVM_EXIT_FAIL_ENTRY_CPU_UNSUPPORTED "
"and the cpu field to the processor id."
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:141
msgid "1.5 ATTRIBUTE: KVM_ARM_VCPU_PMU_V3_SET_NR_COUNTERS"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:143
msgid ""
"in kvm_device_attr.addr the address to an unsigned int representing the "
"maximum value taken by PMCR_EL0.N"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:151
msgid "Error accessing the value pointed to by addr"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:153
msgid "No PMUv3 explicitly selected, or value of N out of range"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:157
msgid ""
"Set the number of implemented event counters in the virtual PMU. This "
"mandates that a PMU has explicitly been selected via "
"KVM_ARM_VCPU_PMU_V3_SET_PMU, and will fail when no PMU has been explicitly "
"selected, or the number of counters is out of range for the selected PMU. "
"Selecting a new PMU cancels the effect of setting this attribute."
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:165
msgid "2. GROUP: KVM_ARM_VCPU_TIMER_CTRL"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:170
msgid "2.1. ATTRIBUTES: KVM_ARM_VCPU_TIMER_IRQ_{VTIMER,PTIMER,HVTIMER,HPTIMER}"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:172
msgid ""
"in kvm_device_attr.addr the address for the timer interrupt is a pointer to "
"an int"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:178
msgid "Invalid timer interrupt number"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:179
msgid "One or more VCPUs has already run"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:182
msgid ""
"A value describing the architected timer interrupt number when connected to "
"an in-kernel virtual GIC.  These must be a PPI (16 <= intid < 32).  Setting "
"the attribute overrides the default values (see below)."
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:187
msgid "KVM_ARM_VCPU_TIMER_IRQ_VTIMER"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:187
msgid "The EL1 virtual timer intid (default: 27)"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:188
msgid "KVM_ARM_VCPU_TIMER_IRQ_PTIMER"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:188
msgid "The EL1 physical timer intid (default: 30)"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:189
msgid "KVM_ARM_VCPU_TIMER_IRQ_HVTIMER"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:189
msgid "The EL2 virtual timer intid (default: 28)"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:190
msgid "KVM_ARM_VCPU_TIMER_IRQ_HPTIMER"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:190
msgid "The EL2 physical timer intid (default: 26)"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:193
msgid ""
"Setting the same PPI for different timers will prevent the VCPUs from "
"running. Setting the interrupt number on a VCPU configures all VCPUs created "
"at that time to use the number provided for a given timer, overwriting any "
"previously configured values on other VCPUs.  Userspace should configure the "
"interrupt numbers on at least one VCPU after creating all VCPUs and before "
"running any VCPUs."
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:203
msgid "3. GROUP: KVM_ARM_VCPU_PVTIME_CTRL"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:208
msgid "3.1 ATTRIBUTE: KVM_ARM_VCPU_PVTIME_IPA"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:210
msgid "64-bit base address"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:215
msgid "Stolen time not implemented"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:216
msgid "Base address already set for this VCPU"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:217
msgid "Base address not 64 byte aligned"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:220
msgid ""
"Specifies the base address of the stolen time structure for this VCPU. The "
"base address must be 64 byte aligned and exist within a valid guest memory "
"region. See Documentation/virt/kvm/arm/pvtime.rst for more information "
"including the layout of the stolen time structure."
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:226
msgid "4. GROUP: KVM_VCPU_TSC_CTRL"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:228
msgid "x86"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:230
msgid "4.1 ATTRIBUTE: KVM_VCPU_TSC_OFFSET"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:232
msgid "64-bit unsigned TSC offset"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:237
msgid "Error reading/writing the provided parameter address."
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:239
msgid "Attribute not supported"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:242
msgid ""
"Specifies the guest's TSC offset relative to the host's TSC. The guest's TSC "
"is then derived by the following equation:"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:245
msgid "guest_tsc = host_tsc + KVM_VCPU_TSC_OFFSET"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:247
msgid ""
"This attribute is useful to adjust the guest's TSC on live migration, so "
"that the TSC counts the time during which the VM was paused. The following "
"describes a possible algorithm to use for this purpose."
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:251
msgid "From the source VMM process:"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:253
msgid ""
"Invoke the KVM_GET_CLOCK ioctl to record the host TSC (tsc_src), kvmclock "
"nanoseconds (guest_src), and host CLOCK_REALTIME nanoseconds (host_src)."
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:257
msgid ""
"Read the KVM_VCPU_TSC_OFFSET attribute for every vCPU to record the guest "
"TSC offset (ofs_src[i])."
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:260
msgid ""
"Invoke the KVM_GET_TSC_KHZ ioctl to record the frequency of the guest's TSC "
"(freq)."
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:263
msgid "From the destination VMM process:"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:265
msgid ""
"Invoke the KVM_SET_CLOCK ioctl, providing the source nanoseconds from "
"kvmclock (guest_src) and CLOCK_REALTIME (host_src) in their respective "
"fields.  Ensure that the KVM_CLOCK_REALTIME flag is set in the provided "
"structure."
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:270
msgid ""
"KVM will advance the VM's kvmclock to account for elapsed time since "
"recording the clock values.  Note that this will cause problems in the guest "
"(e.g., timeouts) unless CLOCK_REALTIME is synchronized between the source "
"and destination, and a reasonably short time passes between the source "
"pausing the VMs and the destination executing steps 4-7."
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:277
msgid ""
"Invoke the KVM_GET_CLOCK ioctl to record the host TSC (tsc_dest) and "
"kvmclock nanoseconds (guest_dest)."
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:280
msgid ""
"Adjust the guest TSC offsets for every vCPU to account for (1) time elapsed "
"since recording state and (2) difference in TSCs between the source and "
"destination machine:"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:284
msgid "ofs_dst[i] = ofs_src[i] -"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:285
msgid "(guest_src - guest_dest) * freq + (tsc_src - tsc_dest)"
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:288
msgid ""
"(\"ofs[i] + tsc - guest * freq\" is the guest TSC value corresponding to a "
"time of 0 in kvmclock.  The above formula ensures that it is the same on the "
"destination as it was on the source)."
msgstr ""

#: ../../../virt/kvm/devices/vcpu.rst:292
msgid ""
"Write the KVM_VCPU_TSC_OFFSET attribute for every vCPU with the respective "
"value derived in the previous step."
msgstr ""
