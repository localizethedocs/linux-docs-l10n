# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 08:27+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../trace/fprobe.rst:5
msgid "Fprobe - Function entry/exit probe"
msgstr ""

#: ../../../trace/fprobe.rst:10
msgid "Introduction"
msgstr ""

#: ../../../trace/fprobe.rst:12
msgid ""
"Fprobe is a function entry/exit probe based on the function-graph tracing "
"feature in ftrace. Instead of tracing all functions, if you want to attach "
"callbacks on specific function entry and exit, similar to the kprobes and "
"kretprobes, you can use fprobe. Compared with kprobes and kretprobes, fprobe "
"gives faster instrumentation for multiple functions with single handler. "
"This document describes how to use fprobe."
msgstr ""

#: ../../../trace/fprobe.rst:21
msgid "The usage of fprobe"
msgstr ""

#: ../../../trace/fprobe.rst:23
msgid ""
"The fprobe is a wrapper of ftrace (+ kretprobe-like return callback) to "
"attach callbacks to multiple function entry and exit. User needs to set up "
"the `struct fprobe` and pass it to `register_fprobe()`."
msgstr ""

#: ../../../trace/fprobe.rst:27
msgid ""
"Typically, `fprobe` data structure is initialized with the `entry_handler` "
"and/or `exit_handler` as below."
msgstr ""

#: ../../../trace/fprobe.rst:37
msgid ""
"To enable the fprobe, call one of register_fprobe(), register_fprobe_ips(), "
"and register_fprobe_syms(). These functions register the fprobe with "
"different types of parameters."
msgstr ""

#: ../../../trace/fprobe.rst:41
msgid ""
"The register_fprobe() enables a fprobe by function-name filters. E.g. this "
"enables @fp on \"func*()\" function except \"func2()\".::"
msgstr ""

#: ../../../trace/fprobe.rst:46
msgid ""
"The register_fprobe_ips() enables a fprobe by ftrace-location addresses. E.g."
msgstr ""

#: ../../../trace/fprobe.rst:55
msgid "And the register_fprobe_syms() enables a fprobe by symbol names. E.g."
msgstr ""

#: ../../../trace/fprobe.rst:64
msgid "To disable (remove from functions) this fprobe, call::"
msgstr ""

#: ../../../trace/fprobe.rst:68
msgid "You can temporally (soft) disable the fprobe by::"
msgstr ""

#: ../../../trace/fprobe.rst:72
msgid "and resume by::"
msgstr ""

#: ../../../trace/fprobe.rst:76
msgid "The above is defined by including the header::"
msgstr ""

#: ../../../trace/fprobe.rst:80
msgid ""
"Same as ftrace, the registered callbacks will start being called some time "
"after the register_fprobe() is called and before it returns. See :file:"
"`Documentation/trace/ftrace.rst`."
msgstr ""

#: ../../../trace/fprobe.rst:84
msgid ""
"Also, the unregister_fprobe() will guarantee that both enter and exit "
"handlers are no longer being called by functions after unregister_fprobe() "
"returns as same as unregister_ftrace_function()."
msgstr ""

#: ../../../trace/fprobe.rst:89
msgid "The fprobe entry/exit handler"
msgstr ""

#: ../../../trace/fprobe.rst:91
msgid "The prototype of the entry/exit callback function are as follows:"
msgstr ""

#: ../../../trace/fprobe.rst:99
msgid ""
"Note that the @entry_ip is saved at function entry and passed to exit "
"handler. If the entry callback function returns !0, the corresponding exit "
"callback will be cancelled."
msgstr ""

#: ../../../trace/fprobe.rst:104
msgid "@fp"
msgstr ""

#: ../../../trace/fprobe.rst:105
msgid ""
"This is the address of `fprobe` data structure related to this handler. You "
"can embed the `fprobe` to your data structure and get it by container_of() "
"macro from @fp. The @fp must not be NULL."
msgstr ""

#: ../../../trace/fprobe.rst:109
msgid "@entry_ip"
msgstr ""

#: ../../../trace/fprobe.rst:110
msgid ""
"This is the ftrace address of the traced function (both entry and exit). "
"Note that this may not be the actual entry address of the function but the "
"address where the ftrace is instrumented."
msgstr ""

#: ../../../trace/fprobe.rst:114
msgid "@ret_ip"
msgstr ""

#: ../../../trace/fprobe.rst:115
msgid ""
"This is the return address that the traced function will return to, "
"somewhere in the caller. This can be used at both entry and exit."
msgstr ""

#: ../../../trace/fprobe.rst:118
msgid "@fregs"
msgstr ""

#: ../../../trace/fprobe.rst:119
msgid ""
"This is the `ftrace_regs` data structure at the entry and exit. This "
"includes the function parameters, or the return values. So user can access "
"thos values via appropriate `ftrace_regs_*` APIs."
msgstr ""

#: ../../../trace/fprobe.rst:123
msgid "@entry_data"
msgstr ""

#: ../../../trace/fprobe.rst:124
msgid ""
"This is a local storage to share the data between entry and exit handlers. "
"This storage is NULL by default. If the user specify `exit_handler` field "
"and `entry_data_size` field when registering the fprobe, the storage is "
"allocated and passed to both `entry_handler` and `exit_handler`."
msgstr ""

#: ../../../trace/fprobe.rst:130
msgid "Entry data size and exit handlers on the same function"
msgstr ""

#: ../../../trace/fprobe.rst:132
msgid ""
"Since the entry data is passed via per-task stack and it has limited size, "
"the entry data size per probe is limited to `15 * sizeof(long)`. You also "
"need to take care that the different fprobes are probing on the same "
"function, this limit becomes smaller. The entry data size is aligned to "
"`sizeof(long)` and each fprobe which has exit handler uses a `sizeof(long)` "
"space on the stack, you should keep the number of fprobes on the same "
"function as small as possible."
msgstr ""

#: ../../../trace/fprobe.rst:141
msgid "Share the callbacks with kprobes"
msgstr ""

#: ../../../trace/fprobe.rst:143
msgid ""
"Since the recursion safeness of the fprobe (and ftrace) is a bit different "
"from the kprobes, this may cause an issue if user wants to run the same code "
"from the fprobe and the kprobes."
msgstr ""

#: ../../../trace/fprobe.rst:147
msgid ""
"Kprobes has per-cpu 'current_kprobe' variable which protects the kprobe "
"handler from recursion in all cases. On the other hand, fprobe uses only "
"ftrace_test_recursion_trylock(). This allows interrupt context to call "
"another (or same) fprobe while the fprobe user handler is running."
msgstr ""

#: ../../../trace/fprobe.rst:152
msgid ""
"This is not a matter if the common callback code has its own recursion "
"detection, or it can handle the recursion in the different contexts (normal/"
"interrupt/NMI.) But if it relies on the 'current_kprobe' recursion lock, it "
"has to check kprobe_running() and use kprobe_busy_*() APIs."
msgstr ""

#: ../../../trace/fprobe.rst:158
msgid ""
"Fprobe has FPROBE_FL_KPROBE_SHARED flag to do this. If your common callback "
"code will be shared with kprobes, please set FPROBE_FL_KPROBE_SHARED "
"*before* registering the fprobe, like:"
msgstr ""

#: ../../../trace/fprobe.rst:168
msgid "This will protect your common callback from the nested call."
msgstr ""

#: ../../../trace/fprobe.rst:171
msgid "The missed counter"
msgstr ""

#: ../../../trace/fprobe.rst:173
msgid ""
"The `fprobe` data structure has `fprobe::nmissed` counter field as same as "
"kprobes. This counter counts up when;"
msgstr ""

#: ../../../trace/fprobe.rst:177
msgid ""
"fprobe fails to take ftrace_recursion lock. This usually means that a "
"function which is traced by other ftrace users is called from the "
"entry_handler."
msgstr ""

#: ../../../trace/fprobe.rst:180
msgid ""
"fprobe fails to setup the function exit because of failing to allocate the "
"data buffer from the per-task shadow stack."
msgstr ""

#: ../../../trace/fprobe.rst:183
msgid ""
"The `fprobe::nmissed` field counts up in both cases. Therefore, the former "
"skips both of entry and exit callback and the latter skips the exit "
"callback, but in both case the counter will increase by 1."
msgstr ""

#: ../../../trace/fprobe.rst:187
msgid ""
"Note that if you set the FTRACE_OPS_FL_RECURSION and/or FTRACE_OPS_FL_RCU to "
"`fprobe::ops::flags` (ftrace_ops::flags) when registering the fprobe, this "
"counter may not work correctly, because ftrace skips the fprobe function "
"which increase the counter."
msgstr ""

#: ../../../trace/fprobe.rst:194
msgid "Functions and structures"
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:22
msgid "address based hash list node for fprobe."
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:26
#: include/linux/fprobe.h:39 include/linux/fprobe.h:56
msgid "**Definition**::"
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:34
#: include/linux/fprobe.h:49 include/linux/fprobe.h:67
msgid "**Members**"
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:24
#: include/linux/fprobe.h:37
msgid "``hlist``"
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:25
msgid "The hlist node for address search hash table."
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:25
msgid "``addr``"
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:26
msgid "One of the probing address of **fp**."
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:26
#: include/linux/fprobe.h:39
msgid "``fp``"
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:27
msgid "The fprobe which owns this."
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:35
msgid "hash list nodes for fprobe."
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:38
msgid "The hlist node for existence checking hash table."
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:38
msgid "``rcu``"
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:39
msgid "rcu_head for RCU deferred release."
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:40
msgid "The fprobe which owns this fprobe_hlist."
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:40
msgid "``size``"
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:41
msgid "The size of **array**."
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:41
msgid "``array``"
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:42
msgid "The fprobe_hlist_node for each address to probe."
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:52
msgid "ftrace based probe."
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:54
msgid "``nmissed``"
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:55
msgid "The counter for missing events."
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:55
msgid "``flags``"
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:56
msgid "The status flag."
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:56
msgid "``entry_data_size``"
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:57
msgid "The private data storage size."
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:57
msgid "``entry_handler``"
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:58
msgid "The callback function for function entry."
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:58
msgid "``exit_handler``"
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:59
msgid "The callback function for function exit."
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:59
msgid "``hlist_array``"
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:60
msgid "The fprobe_hlist for fprobe search from IP hash table."
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:126
msgid "Disable fprobe"
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:130
#: include/linux/fprobe.h:143 ../../../trace/fprobe:197:
#: kernel/trace/fprobe.c:662 kernel/trace/fprobe.c:708
#: kernel/trace/fprobe.c:748 kernel/trace/fprobe.c:786
msgid "**Parameters**"
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:132
#: include/linux/fprobe.h:145 ../../../trace/fprobe:197:
#: kernel/trace/fprobe.c:664 kernel/trace/fprobe.c:710
#: kernel/trace/fprobe.c:750 kernel/trace/fprobe.c:788
msgid "``struct fprobe *fp``"
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:127
msgid "The fprobe to be disabled."
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:129
#: include/linux/fprobe.h:142 ../../../trace/fprobe:197:
#: kernel/trace/fprobe.c:663 kernel/trace/fprobe.c:709
#: kernel/trace/fprobe.c:749 kernel/trace/fprobe.c:785
msgid "**Description**"
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:128
msgid ""
"This will soft-disable **fp**. Note that this doesn't remove the ftrace "
"hooks from the function entry."
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:139
msgid "Enable fprobe"
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:140
msgid "The fprobe to be enabled."
msgstr ""

#: ../../../trace/fprobe:196: include/linux/fprobe.h:141
msgid "This will soft-enable **fp**."
msgstr ""

#: ../../../trace/fprobe:197: kernel/trace/fprobe.c:658
msgid "Register fprobe to ftrace by pattern."
msgstr ""

#: ../../../trace/fprobe:197: kernel/trace/fprobe.c:659
#: kernel/trace/fprobe.c:705 kernel/trace/fprobe.c:745
msgid "A fprobe data structure to be registered."
msgstr ""

#: ../../../trace/fprobe:197: kernel/trace/fprobe.c:661
msgid "``const char *filter``"
msgstr ""

#: ../../../trace/fprobe:197: kernel/trace/fprobe.c:660
msgid "A wildcard pattern of probed symbols."
msgstr ""

#: ../../../trace/fprobe:197: kernel/trace/fprobe.c:662
msgid "``const char *notfilter``"
msgstr ""

#: ../../../trace/fprobe:197: kernel/trace/fprobe.c:661
msgid "A wildcard pattern of NOT probed symbols."
msgstr ""

#: ../../../trace/fprobe:197: kernel/trace/fprobe.c:662
msgid ""
"Register **fp** to ftrace for enabling the probe on the symbols matched to "
"**filter**. If **notfilter** is not NULL, the symbols matched the "
"**notfilter** are not probed."
msgstr ""

#: ../../../trace/fprobe:197: kernel/trace/fprobe.c:665
#: kernel/trace/fprobe.c:713 kernel/trace/fprobe.c:751
msgid "Return 0 if **fp** is registered successfully, -errno if not."
msgstr ""

#: ../../../trace/fprobe:197: kernel/trace/fprobe.c:704
msgid "Register fprobe to ftrace by address."
msgstr ""

#: ../../../trace/fprobe:197: kernel/trace/fprobe.c:707
msgid "``unsigned long *addrs``"
msgstr ""

#: ../../../trace/fprobe:197: kernel/trace/fprobe.c:706
msgid "An array of target function address."
msgstr ""

#: ../../../trace/fprobe:197: kernel/trace/fprobe.c:708
#: kernel/trace/fprobe.c:748
msgid "``int num``"
msgstr ""

#: ../../../trace/fprobe:197: kernel/trace/fprobe.c:707
msgid "The number of entries of **addrs**."
msgstr ""

#: ../../../trace/fprobe:197: kernel/trace/fprobe.c:708
msgid ""
"Register **fp** to ftrace for enabling the probe on the address given by "
"**addrs**. The **addrs** must be the addresses of ftrace location address, "
"which may be the symbol address + arch-dependent offset. If you unsure what "
"this mean, please use other registration functions."
msgstr ""

#: ../../../trace/fprobe:197: kernel/trace/fprobe.c:744
msgid "Register fprobe to ftrace by symbols."
msgstr ""

#: ../../../trace/fprobe:197: kernel/trace/fprobe.c:747
msgid "``const char **syms``"
msgstr ""

#: ../../../trace/fprobe:197: kernel/trace/fprobe.c:746
msgid "An array of target symbols."
msgstr ""

#: ../../../trace/fprobe:197: kernel/trace/fprobe.c:747
msgid "The number of entries of **syms**."
msgstr ""

#: ../../../trace/fprobe:197: kernel/trace/fprobe.c:748
msgid ""
"Register **fp** to the symbols given by **syms** array. This will be useful "
"if you are sure the symbols exist in the kernel."
msgstr ""

#: ../../../trace/fprobe:197: kernel/trace/fprobe.c:782
msgid "Unregister fprobe."
msgstr ""

#: ../../../trace/fprobe:197: kernel/trace/fprobe.c:783
msgid "A fprobe data structure to be unregistered."
msgstr ""

#: ../../../trace/fprobe:197: kernel/trace/fprobe.c:784
msgid "Unregister fprobe (and remove ftrace hooks from the function entries)."
msgstr ""

#: ../../../trace/fprobe:197: kernel/trace/fprobe.c:786
msgid "Return 0 if **fp** is unregistered successfully, -errno if not."
msgstr ""
