# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/page_pool.rst:5
msgid "Page Pool API"
msgstr ""

#: ../../../networking/page_pool:7: include/net/page_pool/helpers.h:9
msgid ""
"The page_pool allocator is optimized for recycling page or page fragment "
"used by skb packet and xdp frame."
msgstr ""

#: ../../../networking/page_pool:7: include/net/page_pool/helpers.h:12
msgid ""
"Basic use involves replacing any alloc_pages() calls with page_pool_alloc(), "
"which allocate memory with or without page splitting depending on the "
"requested memory size."
msgstr ""

#: ../../../networking/page_pool:7: include/net/page_pool/helpers.h:16
msgid ""
"If the driver knows that it always requires full pages or its allocations "
"are always smaller than half a page, it can use one of the more specific API "
"calls:"
msgstr ""

#: ../../../networking/page_pool:7: include/net/page_pool/helpers.h:20
msgid ""
"1. page_pool_alloc_pages(): allocate memory without page splitting when "
"driver knows that the memory it need is always bigger than half of the page "
"allocated from page pool. There is no cache line dirtying for 'struct page' "
"when a page is recycled back to the page pool."
msgstr ""

#: ../../../networking/page_pool:7: include/net/page_pool/helpers.h:25
msgid ""
"2. page_pool_alloc_frag(): allocate memory with page splitting when driver "
"knows that the memory it need is always smaller than or equal to half of the "
"page allocated from page pool. Page splitting enables memory saving and thus "
"avoids TLB/cache miss for data access, but there also is some cost to "
"implement page splitting, mainly some cache line dirtying/bouncing for "
"'struct page' and atomic operation for page->pp_ref_count."
msgstr ""

#: ../../../networking/page_pool:7: include/net/page_pool/helpers.h:32
msgid ""
"The API keeps track of in-flight pages, in order to let API users know when "
"it is safe to free a page_pool object, the API users must call "
"page_pool_put_page() or page_pool_free_va() to free the page_pool object, or "
"attach the page_pool object to a page_pool-aware object like skbs marked "
"with skb_mark_for_recycle()."
msgstr ""

#: ../../../networking/page_pool:7: include/net/page_pool/helpers.h:38
msgid ""
"page_pool_put_page() may be called multiple times on the same page if a page "
"is split into multiple fragments. For the last fragment, it will either "
"recycle the page, or in case of page->_refcount > 1, it will release the DMA "
"mapping and in-flight state accounting."
msgstr ""

#: ../../../networking/page_pool:7: include/net/page_pool/helpers.h:43
msgid ""
"dma_sync_single_range_for_device() is only called for the last fragment when "
"page_pool is created with PP_FLAG_DMA_SYNC_DEV flag, so it depends on the "
"last freed fragment to do the sync_for_device operation for all fragments in "
"the same page when a page is split. The API user must setup pool->p.max_len "
"and pool->p.offset correctly and ensure that page_pool_put_page() is called "
"with dma_sync_size being -1 for fragment API."
msgstr ""

#: ../../../networking/page_pool.rst:11
msgid "Architecture overview"
msgstr ""

#: ../../../networking/page_pool.rst:45
msgid "Monitoring"
msgstr ""

#: ../../../networking/page_pool.rst:46
msgid ""
"Information about page pools on the system can be accessed via the netdev "
"genetlink family (see Documentation/netlink/specs/netdev.yaml)."
msgstr ""

#: ../../../networking/page_pool.rst:50
msgid "API interface"
msgstr ""

#: ../../../networking/page_pool.rst:51
msgid ""
"The number of pools created **must** match the number of hardware queues "
"unless hardware restrictions make that impossible. This would otherwise beat "
"the purpose of page pool, which is allocate pages fast from cache without "
"locking. This lockless guarantee naturally comes from running under a NAPI "
"softirq. The protection doesn't strictly have to be NAPI, any guarantee that "
"allocating a page will cause no race conditions is enough."
msgstr ""

#: ../../../networking/page_pool:58: net/core/page_pool.c:367
msgid "create a page pool"
msgstr ""

#: ../../../networking/page_pool:58: net/core/page_pool.c:371
#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:91
#: include/net/page_pool/helpers.h:104 include/net/page_pool/helpers.h:175
#: include/net/page_pool/helpers.h:210 include/net/page_pool/helpers.h:229
#: include/net/page_pool/helpers.h:352 include/net/page_pool/helpers.h:381
#: include/net/page_pool/helpers.h:396 include/net/page_pool/helpers.h:419
#: include/net/page_pool/helpers.h:443 ../../../networking/page_pool:71:
#: net/core/page_pool.c:79
msgid "**Parameters**"
msgstr ""

#: ../../../networking/page_pool:58: net/core/page_pool.c:373
msgid "``const struct page_pool_params *params``"
msgstr ""

#: ../../../networking/page_pool:58: net/core/page_pool.c:368
msgid "parameters, see struct page_pool_params"
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:62
msgid "page pool parameters"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:105
#: include/net/page_pool/types.h:124 include/net/page_pool/types.h:140
#: ../../../networking/page_pool:61: include/net/page_pool/types.h:66
msgid "**Definition**::"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:116
#: include/net/page_pool/types.h:134 include/net/page_pool/types.h:147
#: ../../../networking/page_pool:61: include/net/page_pool/types.h:84
msgid "**Members**"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:102
#: ../../../networking/page_pool:61: include/net/page_pool/types.h:63
msgid "``fast``"
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:64
msgid "params accessed frequently on hotpath"
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:64
msgid "``order``"
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:65
msgid "2^order pages on allocation"
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:65
msgid "``pool_size``"
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:66
msgid "size of the ptr_ring"
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:66
msgid "``nid``"
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:67
msgid "NUMA node id to allocate from pages from"
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:67
msgid "``dev``"
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:68
msgid "device, for DMA pre-mapping purposes"
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:68
msgid "``napi``"
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:69
msgid "NAPI which is the sole consumer of pages, otherwise NULL"
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:69
msgid "``dma_dir``"
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:70
msgid "DMA mapping direction"
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:70
msgid "``max_len``"
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:71
msgid "max DMA sync memory size for PP_FLAG_DMA_SYNC_DEV"
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:71
msgid "``offset``"
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:72
msgid "DMA sync address offset for PP_FLAG_DMA_SYNC_DEV"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:103
#: ../../../networking/page_pool:61: include/net/page_pool/types.h:72
msgid "``slow``"
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:73
msgid "params with slowpath access only (initialization and Netlink)"
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:73
msgid "``netdev``"
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:74
msgid "netdev this pool will serve (leave as NULL if none or multiple)"
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:74
msgid "``queue_idx``"
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:75
msgid "queue idx this page_pool is being created for."
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:75
msgid "``flags``"
msgstr ""

#: ../../../networking/page_pool:61: include/net/page_pool/types.h:76
msgid ""
"PP_FLAG_DMA_MAP, PP_FLAG_DMA_SYNC_DEV, PP_FLAG_SYSTEM_POOL, "
"PP_FLAG_ALLOW_UNREADABLE_NETMEM."
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:87
msgid "allocate a page."
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:93
#: include/net/page_pool/helpers.h:106 include/net/page_pool/helpers.h:177
#: include/net/page_pool/helpers.h:212 include/net/page_pool/helpers.h:354
#: include/net/page_pool/helpers.h:383 include/net/page_pool/helpers.h:398
#: include/net/page_pool/helpers.h:421
msgid "``struct page_pool *pool``"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:88
#: include/net/page_pool/helpers.h:101 include/net/page_pool/helpers.h:172
#: include/net/page_pool/helpers.h:208
msgid "pool from which to allocate"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:142
#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:90
#: include/net/page_pool/helpers.h:105 include/net/page_pool/helpers.h:176
#: include/net/page_pool/helpers.h:211 include/net/page_pool/helpers.h:228
#: include/net/page_pool/helpers.h:354 include/net/page_pool/helpers.h:382
#: include/net/page_pool/helpers.h:396 include/net/page_pool/helpers.h:420
#: include/net/page_pool/helpers.h:442 ../../../networking/page_pool:71:
#: net/core/page_pool.c:79
msgid "**Description**"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:89
msgid "Get a page from the page allocator or page_pool caches."
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:100
msgid "allocate a page fragment."
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:103
#: include/net/page_pool/helpers.h:174
msgid "``unsigned int *offset``"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:102
#: include/net/page_pool/helpers.h:173
msgid "offset to the allocated page"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:104
msgid "``unsigned int size``"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:103
msgid "requested size"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:104
msgid "Get a page fragment from the page allocator or page_pool caches."
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:106
#: include/net/page_pool/helpers.h:179 include/net/page_pool/helpers.h:213
msgid "**Return**"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:107
msgid "allocated page fragment, otherwise return NULL."
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:171
msgid "allocate a page or a page fragment."
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:175
#: include/net/page_pool/helpers.h:210
msgid "``unsigned int *size``"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:174
#: include/net/page_pool/helpers.h:209
msgid "in as the requested size, out as the allocated size"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:175
msgid ""
"Get a page or a page fragment from the page allocator or page_pool caches "
"depending on the requested size in order to allocate memory with least "
"memory utilization and performance penalty."
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:180
msgid "allocated page or page fragment, otherwise return NULL."
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:206
msgid "allocate a page or a page fragment and return its va."
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:210
msgid ""
"This is just a thin wrapper around the page_pool_alloc() API, and it returns "
"va of the allocated page or page fragment."
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:214
msgid "the va for the allocated page or page fragment, otherwise return NULL."
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:225
msgid "Retrieve the stored DMA direction."
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:231
#: ../../../networking/page_pool:71: net/core/page_pool.c:81
msgid "``const struct page_pool *pool``"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:226
#: include/net/page_pool/helpers.h:349 include/net/page_pool/helpers.h:378
#: include/net/page_pool/helpers.h:393 ../../../networking/page_pool:71:
#: net/core/page_pool.c:76
msgid "pool from which page was allocated"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:227
msgid ""
"Get the stored dma direction. A driver might decide to store this locally "
"and avoid the extra cache line from page_pool to determine the direction."
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:348
msgid "release a reference to a page pool page"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:351
#: include/net/page_pool/helpers.h:380 include/net/page_pool/helpers.h:395
msgid "``struct page *page``"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:350
#: include/net/page_pool/helpers.h:379 include/net/page_pool/helpers.h:394
msgid "page to release a reference on"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:352
msgid "``unsigned int dma_sync_size``"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:351
msgid "how much of the page may have been touched by the device"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:353
#: include/net/page_pool/helpers.h:381 include/net/page_pool/helpers.h:419
msgid "``bool allow_direct``"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:352
#: include/net/page_pool/helpers.h:380
msgid "released by the consumer, allow lockless caching"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:353
msgid ""
"The outcome of this depends on the page refcnt. If the driver bumps the "
"refcnt > 1 this will unmap the page. If the page refcnt is 1 the allocator "
"owns the page and will try to recycle it in one of the pool caches. If "
"PP_FLAG_DMA_SYNC_DEV is set, the page will be synced for_device using "
"dma_sync_single_range_for_device()."
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:377
#: include/net/page_pool/helpers.h:392
msgid "release a reference on a page pool page"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:381
msgid ""
"Similar to page_pool_put_page(), but will DMA sync the entire memory area as "
"configured in :c:type:`page_pool_params.max_len <page_pool_params>`."
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:395
msgid ""
"Similar to page_pool_put_full_page() but caller must guarantee safe context "
"(e.g NAPI), since it will recycle the page directly into the pool fast cache."
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:415
msgid "free a va into the page_pool"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:416
msgid "pool from which va was allocated"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:418
msgid "``void *va``"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:417
msgid "va to be freed"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:418
msgid "freed by the consumer, allow lockless caching"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:419
msgid "Free a va allocated from page_pool_allo_va()."
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:439
msgid "Retrieve the stored DMA address."
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:445
msgid "``const struct page *page``"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:440
msgid "page allocated from a page pool"
msgstr ""

#: ../../../networking/page_pool:64: include/net/page_pool/helpers.h:441
msgid ""
"Fetch the DMA address of the page. The page pool to which the page belongs "
"must had been created with PP_FLAG_DMA_MAP."
msgstr ""

#: ../../../networking/page_pool:71: net/core/page_pool.c:75
msgid "fetch page pool stats"
msgstr ""

#: ../../../networking/page_pool:71: net/core/page_pool.c:78
msgid "``struct page_pool_stats *stats``"
msgstr ""

#: ../../../networking/page_pool:71: net/core/page_pool.c:77
msgid "struct page_pool_stats to fill in"
msgstr ""

#: ../../../networking/page_pool:71: net/core/page_pool.c:78
msgid ""
"Retrieve statistics about the page_pool. This API is only available if the "
"kernel has been configured with ``CONFIG_PAGE_POOL_STATS=y``. A pointer to a "
"caller allocated struct page_pool_stats structure is passed to this API "
"which is filled in. The caller can then report those stats to the user "
"(perhaps via ethtool, debugfs, etc.)."
msgstr ""

#: ../../../networking/page_pool.rst:75
msgid "DMA sync"
msgstr ""

#: ../../../networking/page_pool.rst:76
msgid ""
"Driver is always responsible for syncing the pages for the CPU. Drivers may "
"choose to take care of syncing for the device as well or set the "
"``PP_FLAG_DMA_SYNC_DEV`` flag to request that pages allocated from the page "
"pool are already synced for the device."
msgstr ""

#: ../../../networking/page_pool.rst:81
msgid ""
"If ``PP_FLAG_DMA_SYNC_DEV`` is set, the driver must inform the core what "
"portion of the buffer has to be synced. This allows the core to avoid "
"syncing the entire page when the drivers knows that the device only accessed "
"a portion of the page."
msgstr ""

#: ../../../networking/page_pool.rst:85
msgid ""
"Most drivers will reserve headroom in front of the frame. This part of the "
"buffer is not touched by the device, so to avoid syncing it drivers can set "
"the ``offset`` field in struct page_pool_params appropriately."
msgstr ""

#: ../../../networking/page_pool.rst:90
msgid ""
"For pages recycled on the XDP xmit and skb paths the page pool will use the "
"``max_len`` member of struct page_pool_params to decide how much of the page "
"needs to be synced (starting at ``offset``). When directly freeing pages in "
"the driver (page_pool_put_page()) the ``dma_sync_size`` argument specifies "
"how much of the buffer needs to be synced."
msgstr ""

#: ../../../networking/page_pool.rst:97
msgid ""
"If in doubt set ``offset`` to 0, ``max_len`` to ``PAGE_SIZE`` and pass -1 as "
"``dma_sync_size``. That combination of arguments is always correct."
msgstr ""

#: ../../../networking/page_pool.rst:101
msgid ""
"Note that the syncing parameters are for the entire page. This is important "
"to remember when using fragments (``PP_FLAG_PAGE_FRAG``), where allocated "
"buffers may be smaller than a full page. Unless the driver author really "
"understands page pool internals it's recommended to always use ``offset = "
"0``, ``max_len = PAGE_SIZE`` with fragmented page pools."
msgstr ""

#: ../../../networking/page_pool.rst:109
msgid "Stats API and structures"
msgstr ""

#: ../../../networking/page_pool.rst:110
msgid ""
"If the kernel is configured with ``CONFIG_PAGE_POOL_STATS=y``, the API "
"page_pool_get_stats() and structures described below are available. It takes "
"a  pointer to a ``struct page_pool`` and a pointer to a struct "
"page_pool_stats allocated by the caller."
msgstr ""

#: ../../../networking/page_pool.rst:115
msgid ""
"Older drivers expose page pool statistics via ethtool or debugfs. The same "
"statistics are accessible via the netlink netdev family in a driver-"
"independent fashion."
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:101
msgid "allocation statistics"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:103
msgid "successful fast path allocations"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:104
msgid "slow path order-0 allocations"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:104
msgid "``slow_high_order``"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:105
msgid "slow path high order allocations"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:105
msgid "``empty``"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:106
msgid "ptr ring is empty, so a slow path allocation was forced"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:106
msgid "``refill``"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:107
msgid "an allocation which triggered a refill of the cache"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:107
msgid "``waive``"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:108
msgid ""
"pages obtained from the ptr ring that cannot be added to the cache due to a "
"NUMA mismatch"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:120
msgid "recycling (freeing) statistics"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:121
msgid "``cached``"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:122
msgid "recycling placed page in the page pool cache"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:122
msgid "``cache_full``"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:123
msgid "page pool cache was full"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:123
msgid "``ring``"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:124
msgid "page placed into the ptr ring"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:124
msgid "``ring_full``"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:125
msgid "page released from page pool because the ptr ring was full"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:125
msgid "``released_refcnt``"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:126
msgid "page released (and not recycled) because refcnt > 1"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:136
msgid "combined page pool use statistics"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:137
msgid "``alloc_stats``"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:138
msgid "see struct page_pool_alloc_stats"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:138
msgid "``recycle_stats``"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:139
msgid "see struct page_pool_recycle_stats"
msgstr ""

#: ../../../networking/page_pool:119: include/net/page_pool/types.h:139
msgid ""
"Wrapper struct for combining page pool stats with different storage "
"requirements."
msgstr ""

#: ../../../networking/page_pool.rst:125
msgid "Coding examples"
msgstr ""

#: ../../../networking/page_pool.rst:128
msgid "Registration"
msgstr ""

#: ../../../networking/page_pool.rst:156
msgid "NAPI poller"
msgstr ""

#: ../../../networking/page_pool.rst:178
msgid "Stats"
msgstr ""

#: ../../../networking/page_pool.rst:193
msgid "Driver unload"
msgstr ""
