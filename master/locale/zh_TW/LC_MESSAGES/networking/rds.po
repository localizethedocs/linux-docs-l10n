# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/rds.rst:5
msgid "RDS"
msgstr ""

#: ../../../networking/rds.rst:8
msgid "Overview"
msgstr ""

#: ../../../networking/rds.rst:10
msgid ""
"This readme tries to provide some background on the hows and whys of RDS, "
"and will hopefully help you find your way around the code."
msgstr ""

#: ../../../networking/rds.rst:13
msgid ""
"In addition, please see this email about RDS origins: http://oss.oracle.com/"
"pipermail/rds-devel/2007-November/000228.html"
msgstr ""

#: ../../../networking/rds.rst:17
msgid "RDS Architecture"
msgstr ""

#: ../../../networking/rds.rst:19
msgid ""
"RDS provides reliable, ordered datagram delivery by using a single reliable "
"connection between any two nodes in the cluster. This allows applications to "
"use a single socket to talk to any other process in the cluster - so in a "
"cluster with N processes you need N sockets, in contrast to N*N if you use a "
"connection-oriented socket transport like TCP."
msgstr ""

#: ../../../networking/rds.rst:25
msgid ""
"RDS is not Infiniband-specific; it was designed to support different "
"transports.  The current implementation used to support RDS over TCP as well "
"as IB."
msgstr ""

#: ../../../networking/rds.rst:29
msgid ""
"The high-level semantics of RDS from the application's point of view are"
msgstr ""

#: ../../../networking/rds.rst:31
msgid "Addressing"
msgstr ""

#: ../../../networking/rds.rst:33
msgid ""
"RDS uses IPv4 addresses and 16bit port numbers to identify the end point of "
"a connection. All socket operations that involve passing addresses between "
"kernel and user space generally use a struct sockaddr_in."
msgstr ""

#: ../../../networking/rds.rst:38
msgid ""
"The fact that IPv4 addresses are used does not mean the underlying transport "
"has to be IP-based. In fact, RDS over IB uses a reliable IB connection; the "
"IP address is used exclusively to locate the remote node's GID (by ARPing "
"for the given IP)."
msgstr ""

#: ../../../networking/rds.rst:43
msgid ""
"The port space is entirely independent of UDP, TCP or any other protocol."
msgstr ""

#: ../../../networking/rds.rst:46
msgid "Socket interface"
msgstr ""

#: ../../../networking/rds.rst:48
msgid ""
"RDS sockets work *mostly* as you would expect from a BSD socket. The next "
"section will cover the details. At any rate, all I/O is performed through "
"the standard BSD socket API. Some additions like zerocopy support are "
"implemented through control messages, while other extensions use the "
"getsockopt/ setsockopt calls."
msgstr ""

#: ../../../networking/rds.rst:55
msgid ""
"Sockets must be bound before you can send or receive data. This is needed "
"because binding also selects a transport and attaches it to the socket. Once "
"bound, the transport assignment does not change. RDS will tolerate IPs "
"moving around (eg in a active-active HA scenario), but only as long as the "
"address doesn't move to a different transport."
msgstr ""

#: ../../../networking/rds.rst:62
msgid "sysctls"
msgstr ""

#: ../../../networking/rds.rst:64
msgid "RDS supports a number of sysctls in /proc/sys/net/rds"
msgstr ""

#: ../../../networking/rds.rst:68
msgid "Socket Interface"
msgstr ""

#: ../../../networking/rds.rst:70
msgid "AF_RDS, PF_RDS, SOL_RDS"
msgstr ""

#: ../../../networking/rds.rst:71
msgid ""
"AF_RDS and PF_RDS are the domain type to be used with socket(2) to create "
"RDS sockets. SOL_RDS is the socket-level to be used with setsockopt(2) and "
"getsockopt(2) for RDS specific socket options."
msgstr ""

#: ../../../networking/rds.rst:76
msgid "fd = socket(PF_RDS, SOCK_SEQPACKET, 0);"
msgstr ""

#: ../../../networking/rds.rst:77
msgid "This creates a new, unbound RDS socket."
msgstr ""

#: ../../../networking/rds.rst:79
msgid "setsockopt(SOL_SOCKET): send and receive buffer size"
msgstr ""

#: ../../../networking/rds.rst:80
msgid ""
"RDS honors the send and receive buffer size socket options. You are not "
"allowed to queue more than SO_SNDSIZE bytes to a socket. A message is queued "
"when sendmsg is called, and it leaves the queue when the remote system "
"acknowledges its arrival."
msgstr ""

#: ../../../networking/rds.rst:86
msgid ""
"The SO_RCVSIZE option controls the maximum receive queue length. This is a "
"soft limit rather than a hard limit - RDS will continue to accept and queue "
"incoming messages, even if that takes the queue length over the limit. "
"However, it will also mark the port as \"congested\" and send a congestion "
"update to the source node. The source node is supposed to throttle any "
"processes sending to this congested port."
msgstr ""

#: ../../../networking/rds.rst:94
msgid "bind(fd, &sockaddr_in, ...)"
msgstr ""

#: ../../../networking/rds.rst:95
msgid ""
"This binds the socket to a local IP address and port, and a transport, if "
"one has not already been selected via the SO_RDS_TRANSPORT socket option"
msgstr ""

#: ../../../networking/rds.rst:99
msgid "sendmsg(fd, ...)"
msgstr ""

#: ../../../networking/rds.rst:100
msgid ""
"Sends a message to the indicated recipient. The kernel will transparently "
"establish the underlying reliable connection if it isn't up yet."
msgstr ""

#: ../../../networking/rds.rst:104
msgid ""
"An attempt to send a message that exceeds SO_SNDSIZE will return with -"
"EMSGSIZE"
msgstr ""

#: ../../../networking/rds.rst:107
msgid ""
"An attempt to send a message that would take the total number of queued "
"bytes over the SO_SNDSIZE threshold will return EAGAIN."
msgstr ""

#: ../../../networking/rds.rst:111
msgid ""
"An attempt to send a message to a destination that is marked as "
"\"congested\" will return ENOBUFS."
msgstr ""

#: ../../../networking/rds.rst:114
msgid "recvmsg(fd, ...)"
msgstr ""

#: ../../../networking/rds.rst:115
msgid ""
"Receives a message that was queued to this socket. The sockets recv queue "
"accounting is adjusted, and if the queue length drops below SO_SNDSIZE, the "
"port is marked uncongested, and a congestion update is sent to all peers."
msgstr ""

#: ../../../networking/rds.rst:120
msgid ""
"Applications can ask the RDS kernel module to receive notifications via "
"control messages (for instance, there is a notification when a congestion "
"update arrived, or when a RDMA operation completes). These notifications are "
"received through the msg.msg_control buffer of struct msghdr. The format of "
"the messages is described in manpages."
msgstr ""

#: ../../../networking/rds.rst:127
msgid "poll(fd)"
msgstr ""

#: ../../../networking/rds.rst:128
msgid ""
"RDS supports the poll interface to allow the application to implement async "
"I/O."
msgstr ""

#: ../../../networking/rds.rst:131
msgid ""
"POLLIN handling is pretty straightforward. When there's an incoming message "
"queued to the socket, or a pending notification, we signal POLLIN."
msgstr ""

#: ../../../networking/rds.rst:135
msgid ""
"POLLOUT is a little harder. Since you can essentially send to any "
"destination, RDS will always signal POLLOUT as long as there's room on the "
"send queue (ie the number of bytes queued is less than the sendbuf size)."
msgstr ""

#: ../../../networking/rds.rst:140
msgid ""
"However, the kernel will refuse to accept messages to a destination marked "
"congested - in this case you will loop forever if you rely on poll to tell "
"you what to do. This isn't a trivial problem, but applications can deal with "
"this - by using congestion notifications, and by checking for ENOBUFS errors "
"returned by sendmsg."
msgstr ""

#: ../../../networking/rds.rst:147
msgid "setsockopt(SOL_RDS, RDS_CANCEL_SENT_TO, &sockaddr_in)"
msgstr ""

#: ../../../networking/rds.rst:148
msgid ""
"This allows the application to discard all messages queued to a specific "
"destination on this particular socket."
msgstr ""

#: ../../../networking/rds.rst:151
msgid ""
"This allows the application to cancel outstanding messages if it detects a "
"timeout. For instance, if it tried to send a message, and the remote host is "
"unreachable, RDS will keep trying forever. The application may decide it's "
"not worth it, and cancel the operation. In this case, it would use "
"RDS_CANCEL_SENT_TO to nuke any pending messages."
msgstr ""

#: ../../../networking/rds.rst:158
msgid ""
"``setsockopt(fd, SOL_RDS, SO_RDS_TRANSPORT, (int *)&transport ..), "
"getsockopt(fd, SOL_RDS, SO_RDS_TRANSPORT, (int *)&transport ..)``"
msgstr ""

#: ../../../networking/rds.rst:159
msgid ""
"Set or read an integer defining  the underlying encapsulating transport to "
"be used for RDS packets on the socket. When setting the option, integer "
"argument may be one of RDS_TRANS_TCP or RDS_TRANS_IB. When retrieving the "
"value, RDS_TRANS_NONE will be returned on an unbound socket. This socket "
"option may only be set exactly once on the socket, prior to binding it via "
"the bind(2) system call. Attempts to set SO_RDS_TRANSPORT on a socket for "
"which the transport has been previously attached explicitly (by "
"SO_RDS_TRANSPORT) or implicitly (via bind(2)) will return an error of "
"EOPNOTSUPP. An attempt to set SO_RDS_TRANSPORT to RDS_TRANS_NONE will always "
"return EINVAL."
msgstr ""

#: ../../../networking/rds.rst:173
msgid "RDMA for RDS"
msgstr ""

#: ../../../networking/rds.rst:175
msgid "see rds-rdma(7) manpage (available in rds-tools)"
msgstr ""

#: ../../../networking/rds.rst:179
msgid "Congestion Notifications"
msgstr ""

#: ../../../networking/rds.rst:181
msgid "see rds(7) manpage"
msgstr ""

#: ../../../networking/rds.rst:185
msgid "RDS Protocol"
msgstr ""

#: ../../../networking/rds.rst:187
msgid "Message header"
msgstr ""

#: ../../../networking/rds.rst:189
msgid "The message header is a 'struct rds_header' (see rds.h):"
msgstr ""

#: ../../../networking/rds.rst:191
msgid "Fields:"
msgstr ""

#: ../../../networking/rds.rst:193
msgid "h_sequence:"
msgstr ""

#: ../../../networking/rds.rst:194
msgid "per-packet sequence number"
msgstr ""

#: ../../../networking/rds.rst:195
msgid "h_ack:"
msgstr ""

#: ../../../networking/rds.rst:196
msgid "piggybacked acknowledgment of last packet received"
msgstr ""

#: ../../../networking/rds.rst:197
msgid "h_len:"
msgstr ""

#: ../../../networking/rds.rst:198
msgid "length of data, not including header"
msgstr ""

#: ../../../networking/rds.rst:199
msgid "h_sport:"
msgstr ""

#: ../../../networking/rds.rst:200
msgid "source port"
msgstr ""

#: ../../../networking/rds.rst:201
msgid "h_dport:"
msgstr ""

#: ../../../networking/rds.rst:202
msgid "destination port"
msgstr ""

#: ../../../networking/rds.rst:203
msgid "h_flags:"
msgstr ""

#: ../../../networking/rds.rst:204
msgid "Can be:"
msgstr ""

#: ../../../networking/rds.rst:207
msgid "CONG_BITMAP"
msgstr ""

#: ../../../networking/rds.rst:207
msgid "this is a congestion update bitmap"
msgstr ""

#: ../../../networking/rds.rst:208
msgid "ACK_REQUIRED"
msgstr ""

#: ../../../networking/rds.rst:208
msgid "receiver must ack this packet"
msgstr ""

#: ../../../networking/rds.rst:209
msgid "RETRANSMITTED"
msgstr ""

#: ../../../networking/rds.rst:209
msgid "packet has previously been sent"
msgstr ""

#: ../../../networking/rds.rst:212
msgid "h_credit:"
msgstr ""

#: ../../../networking/rds.rst:213
msgid ""
"indicate to other end of connection that it has more credits available (i.e. "
"there is more send room)"
msgstr ""

#: ../../../networking/rds.rst:216
msgid "h_padding[4]:"
msgstr ""

#: ../../../networking/rds.rst:217
msgid "unused, for future use"
msgstr ""

#: ../../../networking/rds.rst:218
msgid "h_csum:"
msgstr ""

#: ../../../networking/rds.rst:219
msgid "header checksum"
msgstr ""

#: ../../../networking/rds.rst:220
msgid "h_exthdr:"
msgstr ""

#: ../../../networking/rds.rst:221
msgid ""
"optional data can be passed here. This is currently used for passing RDMA-"
"related information."
msgstr ""

#: ../../../networking/rds.rst:224
msgid "ACK and retransmit handling"
msgstr ""

#: ../../../networking/rds.rst:226
msgid ""
"One might think that with reliable IB connections you wouldn't need to ack "
"messages that have been received.  The problem is that IB hardware generates "
"an ack message before it has DMAed the message into memory.  This creates a "
"potential message loss if the HCA is disabled for any reason between when it "
"sends the ack and before the message is DMAed and processed.  This is only a "
"potential issue if another HCA is available for fail-over."
msgstr ""

#: ../../../networking/rds.rst:234
msgid ""
"Sending an ack immediately would allow the sender to free the sent message "
"from their send queue quickly, but could cause excessive traffic to be used "
"for acks. RDS piggybacks acks on sent data packets.  Ack-only packets are "
"reduced by only allowing one to be in flight at a time, and by the sender "
"only asking for acks when its send buffers start to fill up. All "
"retransmissions are also acked."
msgstr ""

#: ../../../networking/rds.rst:242
msgid "Flow Control"
msgstr ""

#: ../../../networking/rds.rst:244
msgid ""
"RDS's IB transport uses a credit-based mechanism to verify that there is "
"space in the peer's receive buffers for more data. This eliminates the need "
"for hardware retries on the connection."
msgstr ""

#: ../../../networking/rds.rst:248
msgid "Congestion"
msgstr ""

#: ../../../networking/rds.rst:250
msgid ""
"Messages waiting in the receive queue on the receiving socket are accounted "
"against the sockets SO_RCVBUF option value.  Only the payload bytes in the "
"message are accounted for.  If the number of bytes queued equals or exceeds "
"rcvbuf then the socket is congested.  All sends attempted to this socket's "
"address should return block or return -EWOULDBLOCK."
msgstr ""

#: ../../../networking/rds.rst:257
msgid ""
"Applications are expected to be reasonably tuned such that this situation "
"very rarely occurs.  An application encountering this \"back-pressure\" is "
"considered a bug."
msgstr ""

#: ../../../networking/rds.rst:261
msgid ""
"This is implemented by having each node maintain bitmaps which indicate "
"which ports on bound addresses are congested.  As the bitmap changes it is "
"sent through all the connections which terminate in the local address of the "
"bitmap which changed."
msgstr ""

#: ../../../networking/rds.rst:266
msgid ""
"The bitmaps are allocated as connections are brought up.  This avoids "
"allocation in the interrupt handling path which queues messages on sockets.  "
"The dense bitmaps let transports send the entire bitmap on any bitmap change "
"reasonably efficiently.  This is much easier to implement than some finer-"
"grained communication of per-port congestion.  The sender does a very "
"inexpensive bit test to test if the port it's about to send to is congested "
"or not."
msgstr ""

#: ../../../networking/rds.rst:277
msgid "RDS Transport Layer"
msgstr ""

#: ../../../networking/rds.rst:279
msgid ""
"As mentioned above, RDS is not IB-specific. Its code is divided into a "
"general RDS layer and a transport layer."
msgstr ""

#: ../../../networking/rds.rst:282
msgid ""
"The general layer handles the socket API, congestion handling, loopback, "
"stats, usermem pinning, and the connection state machine."
msgstr ""

#: ../../../networking/rds.rst:285
msgid ""
"The transport layer handles the details of the transport. The IB transport, "
"for example, handles all the queue pairs, work requests, CM event handlers, "
"and other Infiniband details."
msgstr ""

#: ../../../networking/rds.rst:291
msgid "RDS Kernel Structures"
msgstr ""

#: ../../../networking/rds.rst:293
msgid "struct rds_message"
msgstr ""

#: ../../../networking/rds.rst:294
msgid ""
"aka possibly \"rds_outgoing\", the generic RDS layer copies data to be sent "
"and sets header fields as needed, based on the socket API. This is then "
"queued for the individual connection and sent by the connection's transport."
msgstr ""

#: ../../../networking/rds.rst:299
msgid "struct rds_incoming"
msgstr ""

#: ../../../networking/rds.rst:300
msgid ""
"a generic struct referring to incoming data that can be handed from the "
"transport to the general code and queued by the general code while the "
"socket is awoken. It is then passed back to the transport code to handle the "
"actual copy-to-user."
msgstr ""

#: ../../../networking/rds.rst:305
msgid "struct rds_socket"
msgstr ""

#: ../../../networking/rds.rst:306
msgid "per-socket information"
msgstr ""

#: ../../../networking/rds.rst:308
msgid "struct rds_connection"
msgstr ""

#: ../../../networking/rds.rst:309
msgid "per-connection information"
msgstr ""

#: ../../../networking/rds.rst:311
msgid "struct rds_transport"
msgstr ""

#: ../../../networking/rds.rst:312
msgid "pointers to transport-specific functions"
msgstr ""

#: ../../../networking/rds.rst:314
msgid "struct rds_statistics"
msgstr ""

#: ../../../networking/rds.rst:315
msgid "non-transport-specific statistics"
msgstr ""

#: ../../../networking/rds.rst:317
msgid "struct rds_cong_map"
msgstr ""

#: ../../../networking/rds.rst:318
msgid "wraps the raw congestion bitmap, contains rbnode, waitq, etc."
msgstr ""

#: ../../../networking/rds.rst:321
msgid "Connection management"
msgstr ""

#: ../../../networking/rds.rst:323
msgid ""
"Connections may be in UP, DOWN, CONNECTING, DISCONNECTING, and ERROR states."
msgstr ""

#: ../../../networking/rds.rst:326
msgid ""
"The first time an attempt is made by an RDS socket to send data to a node, a "
"connection is allocated and connected. That connection is then maintained "
"forever -- if there are transport errors, the connection will be dropped and "
"re-established."
msgstr ""

#: ../../../networking/rds.rst:331
msgid ""
"Dropping a connection while packets are queued will cause queued or "
"partially-sent datagrams to be retransmitted when the connection is re-"
"established."
msgstr ""

#: ../../../networking/rds.rst:337
msgid "The send path"
msgstr ""

#: ../../../networking/rds.rst:339
msgid "rds_sendmsg()"
msgstr ""

#: ../../../networking/rds.rst:340
msgid "struct rds_message built from incoming data"
msgstr ""

#: ../../../networking/rds.rst:341
msgid "CMSGs parsed (e.g. RDMA ops)"
msgstr ""

#: ../../../networking/rds.rst:342
msgid "transport connection alloced and connected if not already"
msgstr ""

#: ../../../networking/rds.rst:343
msgid "rds_message placed on send queue"
msgstr ""

#: ../../../networking/rds.rst:344
msgid "send worker awoken"
msgstr ""

#: ../../../networking/rds.rst:346
msgid "rds_send_worker()"
msgstr ""

#: ../../../networking/rds.rst:347
msgid "calls rds_send_xmit() until queue is empty"
msgstr ""

#: ../../../networking/rds.rst:349
msgid "rds_send_xmit()"
msgstr ""

#: ../../../networking/rds.rst:350
msgid "transmits congestion map if one is pending"
msgstr ""

#: ../../../networking/rds.rst:351
msgid "may set ACK_REQUIRED"
msgstr ""

#: ../../../networking/rds.rst:352
msgid ""
"calls transport to send either non-RDMA or RDMA message (RDMA ops never "
"retransmitted)"
msgstr ""

#: ../../../networking/rds.rst:355
msgid "rds_ib_xmit()"
msgstr ""

#: ../../../networking/rds.rst:356
msgid "allocs work requests from send ring"
msgstr ""

#: ../../../networking/rds.rst:357
msgid "adds any new send credits available to peer (h_credits)"
msgstr ""

#: ../../../networking/rds.rst:358
msgid "maps the rds_message's sg list"
msgstr ""

#: ../../../networking/rds.rst:359
msgid "piggybacks ack"
msgstr ""

#: ../../../networking/rds.rst:360
msgid "populates work requests"
msgstr ""

#: ../../../networking/rds.rst:361
msgid "post send to connection's queue pair"
msgstr ""

#: ../../../networking/rds.rst:364
msgid "The recv path"
msgstr ""

#: ../../../networking/rds.rst:366
msgid "rds_ib_recv_cq_comp_handler()"
msgstr ""

#: ../../../networking/rds.rst:367
msgid "looks at write completions"
msgstr ""

#: ../../../networking/rds.rst:368
msgid "unmaps recv buffer from device"
msgstr ""

#: ../../../networking/rds.rst:369
msgid "no errors, call rds_ib_process_recv()"
msgstr ""

#: ../../../networking/rds.rst:370
msgid "refill recv ring"
msgstr ""

#: ../../../networking/rds.rst:372
msgid "rds_ib_process_recv()"
msgstr ""

#: ../../../networking/rds.rst:373
msgid "validate header checksum"
msgstr ""

#: ../../../networking/rds.rst:374
msgid "copy header to rds_ib_incoming struct if start of a new datagram"
msgstr ""

#: ../../../networking/rds.rst:375
msgid "add to ibinc's fraglist"
msgstr ""

#: ../../../networking/rds.rst:376
msgid "if completed datagram:"
msgstr ""

#: ../../../networking/rds.rst:377
msgid "update cong map if datagram was cong update"
msgstr ""

#: ../../../networking/rds.rst:378
msgid "call rds_recv_incoming() otherwise"
msgstr ""

#: ../../../networking/rds.rst:379
msgid "note if ack is required"
msgstr ""

#: ../../../networking/rds.rst:381
msgid "rds_recv_incoming()"
msgstr ""

#: ../../../networking/rds.rst:382
msgid "drop duplicate packets"
msgstr ""

#: ../../../networking/rds.rst:383
msgid "respond to pings"
msgstr ""

#: ../../../networking/rds.rst:384
msgid "find the sock associated with this datagram"
msgstr ""

#: ../../../networking/rds.rst:385
msgid "add to sock queue"
msgstr ""

#: ../../../networking/rds.rst:386
msgid "wake up sock"
msgstr ""

#: ../../../networking/rds.rst:387
msgid "do some congestion calculations"
msgstr ""

#: ../../../networking/rds.rst:388
msgid "rds_recvmsg"
msgstr ""

#: ../../../networking/rds.rst:389
msgid "copy data into user iovec"
msgstr ""

#: ../../../networking/rds.rst:390
msgid "handle CMSGs"
msgstr ""

#: ../../../networking/rds.rst:391
msgid "return to application"
msgstr ""

#: ../../../networking/rds.rst:394
msgid "Multipath RDS (mprds)"
msgstr ""

#: ../../../networking/rds.rst:395
msgid ""
"Mprds is multipathed-RDS, primarily intended for RDS-over-TCP (though the "
"concept can be extended to other transports). The classical implementation "
"of RDS-over-TCP is implemented by demultiplexing multiple PF_RDS sockets "
"between any 2 endpoints (where endpoint == [IP address, port]) over a single "
"TCP socket between the 2 IP addresses involved. This has the limitation that "
"it ends up funneling multiple RDS flows over a single TCP flow, thus it is "
"(a) upper-bounded to the single-flow bandwidth, (b) suffers from head-of-"
"line blocking for all the RDS sockets."
msgstr ""

#: ../../../networking/rds.rst:405
msgid ""
"Better throughput (for a fixed small packet size, MTU) can be achieved by "
"having multiple TCP/IP flows per rds/tcp connection, i.e., multipathed RDS "
"(mprds).  Each such TCP/IP flow constitutes a path for the rds/tcp "
"connection. RDS sockets will be attached to a path based on some hash (e.g., "
"of local address and RDS port number) and packets for that RDS socket will "
"be sent over the attached path using TCP to segment/reassemble RDS datagrams "
"on that path."
msgstr ""

#: ../../../networking/rds.rst:413
msgid ""
"Multipathed RDS is implemented by splitting the struct rds_connection into a "
"common (to all paths) part, and a per-path struct rds_conn_path. All I/O "
"workqs and reconnect threads are driven from the rds_conn_path. Transports "
"such as TCP that are multipath capable may then set up a TCP socket per "
"rds_conn_path, and this is managed by the transport via the transport "
"private cp_transport_data pointer."
msgstr ""

#: ../../../networking/rds.rst:420
msgid ""
"Transports announce themselves as multipath capable by setting the "
"t_mp_capable bit during registration with the rds core module. When the "
"transport is multipath-capable, rds_sendmsg() hashes outgoing traffic across "
"multiple paths. The outgoing hash is computed based on the local address and "
"port that the PF_RDS socket is bound to."
msgstr ""

#: ../../../networking/rds.rst:426
msgid ""
"Additionally, even if the transport is MP capable, we may be peering with "
"some node that does not support mprds, or supports a different number of "
"paths. As a result, the peering nodes need to agree on the number of paths "
"to be used for the connection. This is done by sending out a control packet "
"exchange before the first data packet. The control packet exchange must have "
"completed prior to outgoing hash completion in rds_sendmsg() when the "
"transport is multipath capable."
msgstr ""

#: ../../../networking/rds.rst:435
msgid ""
"The control packet is an RDS ping packet (i.e., packet to rds dest port 0) "
"with the ping packet having a rds extension header option  of type "
"RDS_EXTHDR_NPATHS, length 2 bytes, and the value is the number of paths "
"supported by the sender. The \"probe\" ping packet will get sent from some "
"reserved port, RDS_FLAG_PROBE_PORT (in <linux/rds.h>) The receiver of a ping "
"from RDS_FLAG_PROBE_PORT will thus immediately be able to compute the "
"min(sender_paths, rcvr_paths). The pong sent in response to a probe-ping "
"should contain the rcvr's npaths when the rcvr is mprds-capable."
msgstr ""

#: ../../../networking/rds.rst:445
msgid ""
"If the rcvr is not mprds-capable, the exthdr in the ping will be ignored.  "
"In this case the pong will not have any exthdrs, so the sender of the probe-"
"ping can default to single-path mprds."
msgstr ""
