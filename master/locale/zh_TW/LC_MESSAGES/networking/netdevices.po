# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-16 08:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/netdevices.rst:5
msgid "Network Devices, the Kernel, and You!"
msgstr ""

#: ../../../networking/netdevices.rst:9
msgid "Introduction"
msgstr "介紹"

#: ../../../networking/netdevices.rst:10
msgid ""
"The following is a random collection of documentation regarding network "
"devices. It is intended for driver developers."
msgstr ""

#: ../../../networking/netdevices.rst:14
msgid "struct net_device lifetime rules"
msgstr ""

#: ../../../networking/netdevices.rst:15
msgid ""
"Network device structures need to persist even after module is unloaded and "
"must be allocated with alloc_netdev_mqs() and friends. If device has "
"registered successfully, it will be freed on last use by free_netdev(). This "
"is required to handle the pathological case cleanly (example: ``rmmod "
"mydriver </sys/class/net/myeth/mtu``)"
msgstr ""

#: ../../../networking/netdevices.rst:21
msgid ""
"alloc_netdev_mqs() / alloc_netdev() reserve extra space for driver private "
"data which gets freed when the network device is freed. If separately "
"allocated data is attached to the network device (netdev_priv()) then it is "
"up to the module exit handler to free that."
msgstr ""

#: ../../../networking/netdevices.rst:26
msgid ""
"There are two groups of APIs for registering struct net_device. First group "
"can be used in normal contexts where ``rtnl_lock`` is not already held: "
"register_netdev(), unregister_netdev(). Second group can be used when "
"``rtnl_lock`` is already held: register_netdevice(), unregister_netdevice(), "
"free_netdevice()."
msgstr ""

#: ../../../networking/netdevices.rst:33
msgid "Simple drivers"
msgstr ""

#: ../../../networking/netdevices.rst:35
msgid ""
"Most drivers (especially device drivers) handle lifetime of struct "
"net_device in context where ``rtnl_lock`` is not held (e.g. driver probe and "
"remove paths)."
msgstr ""

#: ../../../networking/netdevices.rst:38
msgid ""
"In that case the struct net_device registration is done using the "
"register_netdev(), and unregister_netdev() functions:"
msgstr ""

#: ../../../networking/netdevices.rst:74
msgid ""
"Note that after calling register_netdev() the device is visible in the "
"system. Users can open it and start sending / receiving traffic immediately, "
"or run any other callback, so all initialization must be done prior to "
"registration."
msgstr ""

#: ../../../networking/netdevices.rst:79
msgid ""
"unregister_netdev() closes the device and waits for all users to be done "
"with it. The memory of struct net_device itself may still be referenced by "
"sysfs but all operations on that device will fail."
msgstr ""

#: ../../../networking/netdevices.rst:83
msgid ""
"free_netdev() can be called after unregister_netdev() returns or when "
"register_netdev() failed."
msgstr ""

#: ../../../networking/netdevices.rst:87
msgid "Device management under RTNL"
msgstr ""

#: ../../../networking/netdevices.rst:89
msgid ""
"Registering struct net_device while in context which already holds the "
"``rtnl_lock`` requires extra care. In those scenarios most drivers will want "
"to make use of struct net_device's ``needs_free_netdev`` and "
"``priv_destructor`` members for freeing of state."
msgstr ""

#: ../../../networking/netdevices.rst:94
msgid "Example flow of netdev handling under ``rtnl_lock``:"
msgstr ""

#: ../../../networking/netdevices.rst:152
msgid ""
"If struct net_device.priv_destructor is set it will be called by the core "
"some time after unregister_netdevice(), it will also be called if "
"register_netdevice() fails. The callback may be invoked with or without "
"``rtnl_lock`` held."
msgstr ""

#: ../../../networking/netdevices.rst:157
msgid ""
"There is no explicit constructor callback, driver \"constructs\" the private "
"netdev state after allocating it and before registration."
msgstr ""

#: ../../../networking/netdevices.rst:160
msgid ""
"Setting struct net_device.needs_free_netdev makes core call free_netdevice() "
"automatically after unregister_netdevice() when all references to the device "
"are gone. It only takes effect after a successful call to "
"register_netdevice() so if register_netdevice() fails driver is responsible "
"for calling free_netdev()."
msgstr ""

#: ../../../networking/netdevices.rst:166
msgid ""
"free_netdev() is safe to call on error paths right after "
"unregister_netdevice() or when register_netdevice() fails. Parts of netdev "
"(de)registration process happen after ``rtnl_lock`` is released, therefore "
"in those cases free_netdev() will defer some of the processing until "
"``rtnl_lock`` is released."
msgstr ""

#: ../../../networking/netdevices.rst:171
msgid ""
"Devices spawned from struct rtnl_link_ops should never free the struct "
"net_device directly."
msgstr ""

#: ../../../networking/netdevices.rst:175
msgid ".ndo_init and .ndo_uninit"
msgstr ""

#: ../../../networking/netdevices.rst:177
msgid ""
"``.ndo_init`` and ``.ndo_uninit`` callbacks are called during net_device "
"registration and de-registration, under ``rtnl_lock``. Drivers can use those "
"e.g. when parts of their init process need to run under ``rtnl_lock``."
msgstr ""

#: ../../../networking/netdevices.rst:181
msgid ""
"``.ndo_init`` runs before device is visible in the system, ``.ndo_uninit`` "
"runs during de-registering after device is closed but other subsystems may "
"still have outstanding references to the netdevice."
msgstr ""

#: ../../../networking/netdevices.rst:186
msgid "MTU"
msgstr ""

#: ../../../networking/netdevices.rst:187
msgid ""
"Each network device has a Maximum Transfer Unit. The MTU does not include "
"any link layer protocol overhead. Upper layer protocols must not pass a "
"socket buffer (skb) to a device to transmit with more data than the mtu. The "
"MTU does not include link layer header overhead, so for example on Ethernet "
"if the standard MTU is 1500 bytes used, the actual skb will contain up to "
"1514 bytes because of the Ethernet header. Devices should allow for the 4 "
"byte VLAN header as well."
msgstr ""

#: ../../../networking/netdevices.rst:195
msgid ""
"Segmentation Offload (GSO, TSO) is an exception to this rule.  The upper "
"layer protocol may pass a large socket buffer to the device transmit "
"routine, and the device will break that up into separate packets based on "
"the current MTU."
msgstr ""

#: ../../../networking/netdevices.rst:200
msgid ""
"MTU is symmetrical and applies both to receive and transmit. A device must "
"be able to receive at least the maximum size packet allowed by the MTU. A "
"network device may use the MTU as mechanism to size receive buffers, but the "
"device should allow packets with VLAN header. With standard Ethernet mtu of "
"1500 bytes, the device should allow up to 1518 byte packets (1500 + 14 "
"header + 4 tag).  The device may either: drop, truncate, or pass up oversize "
"packets, but dropping oversize packets is preferred."
msgstr ""

#: ../../../networking/netdevices.rst:211
msgid "struct net_device synchronization rules"
msgstr ""

#: ../../../networking/netdevices.rst:212
msgid "ndo_open:"
msgstr ""

#: ../../../networking/netdevices.rst:213
#: ../../../networking/netdevices.rst:231
#: ../../../networking/netdevices.rst:239
#: ../../../networking/netdevices.rst:247
#: ../../../networking/netdevices.rst:255
msgid ""
"Synchronization: rtnl_lock() semaphore. In addition, netdev instance lock if "
"the driver implements queue management or shaper API. Context: process"
msgstr ""

#: ../../../networking/netdevices.rst:217
msgid "ndo_stop:"
msgstr ""

#: ../../../networking/netdevices.rst:218
msgid ""
"Synchronization: rtnl_lock() semaphore. In addition, netdev instance lock if "
"the driver implements queue management or shaper API. Context: process Note: "
"netif_running() is guaranteed false"
msgstr ""

#: ../../../networking/netdevices.rst:223
msgid "ndo_do_ioctl:"
msgstr ""

#: ../../../networking/netdevices.rst:224
msgid "Synchronization: rtnl_lock() semaphore."
msgstr ""

#: ../../../networking/netdevices.rst:226
msgid ""
"This is only called by network subsystems internally, not by user space "
"calling ioctl as it was in before linux-5.14."
msgstr ""

#: ../../../networking/netdevices.rst:230
msgid "ndo_siocbond:"
msgstr ""

#: ../../../networking/netdevices.rst:235
msgid "Used by the bonding driver for the SIOCBOND family of ioctl commands."
msgstr ""

#: ../../../networking/netdevices.rst:238
msgid "ndo_siocwandev:"
msgstr ""

#: ../../../networking/netdevices.rst:243
msgid ""
"Used by the drivers/net/wan framework to handle the SIOCWANDEV ioctl with "
"the if_settings structure."
msgstr ""

#: ../../../networking/netdevices.rst:246
msgid "ndo_siocdevprivate:"
msgstr ""

#: ../../../networking/netdevices.rst:251
msgid ""
"This is used to implement SIOCDEVPRIVATE ioctl helpers. These should not be "
"added to new drivers, so don't use."
msgstr ""

#: ../../../networking/netdevices.rst:254
msgid "ndo_eth_ioctl:"
msgstr ""

#: ../../../networking/netdevices.rst:259
msgid "ndo_get_stats:"
msgstr ""

#: ../../../networking/netdevices.rst:260
msgid ""
"Synchronization: RCU (can be called concurrently with the stats update "
"path). Context: atomic (can't sleep under RCU)"
msgstr ""

#: ../../../networking/netdevices.rst:264
msgid "ndo_start_xmit:"
msgstr ""

#: ../../../networking/netdevices.rst:265
msgid "Synchronization: __netif_tx_lock spinlock."
msgstr ""

#: ../../../networking/netdevices.rst:267
msgid ""
"When the driver sets dev->lltx this will be called without holding "
"netif_tx_lock. In this case the driver has to lock by itself when needed. "
"The locking there should also properly protect against set_rx_mode. WARNING: "
"use of dev->lltx is deprecated. Don't use it for new drivers."
msgstr ""

#: ../../../networking/netdevices.rst:274
msgid "Context: Process with BHs disabled or BH (timer),"
msgstr ""

#: ../../../networking/netdevices.rst:275
msgid "will be called with interrupts disabled by netconsole."
msgstr ""

#: ../../../networking/netdevices.rst:277
msgid "Return codes:"
msgstr ""

#: ../../../networking/netdevices.rst:279
msgid "NETDEV_TX_OK everything ok."
msgstr ""

#: ../../../networking/netdevices.rst:280
msgid ""
"NETDEV_TX_BUSY Cannot transmit packet, try later Usually a bug, means queue "
"start/stop flow control is broken in the driver. Note: the driver must NOT "
"put the skb in its DMA ring."
msgstr ""

#: ../../../networking/netdevices.rst:284
msgid "ndo_tx_timeout:"
msgstr ""

#: ../../../networking/netdevices.rst:285
msgid ""
"Synchronization: netif_tx_lock spinlock; all TX queues frozen. Context: BHs "
"disabled Notes: netif_queue_stopped() is guaranteed true"
msgstr ""

#: ../../../networking/netdevices.rst:289
msgid "ndo_set_rx_mode:"
msgstr ""

#: ../../../networking/netdevices.rst:290
msgid "Synchronization: netif_addr_lock spinlock. Context: BHs disabled"
msgstr ""

#: ../../../networking/netdevices.rst:293
msgid "ndo_setup_tc:"
msgstr ""

#: ../../../networking/netdevices.rst:294
msgid ""
"``TC_SETUP_BLOCK`` and ``TC_SETUP_FT`` are running under NFT locks (i.e. no "
"``rtnl_lock`` and no device instance lock). The rest of ``tc_setup_type`` "
"types run under netdev instance lock if the driver implements queue "
"management or shaper API."
msgstr ""

#: ../../../networking/netdevices.rst:299
msgid ""
"Most ndo callbacks not specified in the list above are running under "
"``rtnl_lock``. In addition, netdev instance lock is taken as well if the "
"driver implements queue management or shaper API."
msgstr ""

#: ../../../networking/netdevices.rst:304
msgid "struct napi_struct synchronization rules"
msgstr ""

#: ../../../networking/netdevices.rst:305
msgid "napi->poll:"
msgstr ""

#: ../../../networking/netdevices.rst:306
msgid "Synchronization:"
msgstr ""

#: ../../../networking/netdevices.rst:307
msgid ""
"NAPI_STATE_SCHED bit in napi->state.  Device driver's ndo_stop method will "
"invoke napi_disable() on all NAPI instances which will do a sleeping poll on "
"the NAPI_STATE_SCHED napi->state bit, waiting for all pending NAPI activity "
"to cease."
msgstr ""

#: ../../../networking/netdevices.rst:313
msgid "Context:"
msgstr ""

#: ../../../networking/netdevices.rst:314
msgid "softirq will be called with interrupts disabled by netconsole."
msgstr ""

#: ../../../networking/netdevices.rst:318
msgid "netdev instance lock"
msgstr ""

#: ../../../networking/netdevices.rst:320
msgid ""
"Historically, all networking control operations were protected by a single "
"global lock known as ``rtnl_lock``. There is an ongoing effort to replace "
"this global lock with separate locks for each network namespace. "
"Additionally, properties of individual netdev are increasingly protected by "
"per-netdev locks."
msgstr ""

#: ../../../networking/netdevices.rst:325
msgid ""
"For device drivers that implement shaping or queue management APIs, all "
"control operations will be performed under the netdev instance lock. Drivers "
"can also explicitly request instance lock to be held during ops by setting "
"``request_ops_lock`` to true. Code comments and docs refer to drivers which "
"have ops called under the instance lock as \"ops locked\". See also the "
"documentation of the ``lock`` member of struct net_device."
msgstr ""

#: ../../../networking/netdevices.rst:332
msgid ""
"In the future, there will be an option for individual drivers to opt out of "
"using ``rtnl_lock`` and instead perform their control operations directly "
"under the netdev instance lock."
msgstr ""

#: ../../../networking/netdevices.rst:336
msgid ""
"Device drivers are encouraged to rely on the instance lock where possible."
msgstr ""

#: ../../../networking/netdevices.rst:338
msgid ""
"For the (mostly software) drivers that need to interact with the core stack, "
"there are two sets of interfaces: ``dev_xxx``/``netdev_xxx`` and "
"``netif_xxx`` (e.g., ``dev_set_mtu`` and ``netif_set_mtu``). The ``dev_xxx``/"
"``netdev_xxx`` functions handle acquiring the instance lock themselves, "
"while the ``netif_xxx`` functions assume that the driver has already "
"acquired the instance lock."
msgstr ""

#: ../../../networking/netdevices.rst:346
msgid "struct net_device_ops"
msgstr ""

#: ../../../networking/netdevices.rst:348
msgid "``ndos`` are called without holding the instance lock for most drivers."
msgstr ""

#: ../../../networking/netdevices.rst:350
msgid ""
"\"Ops locked\" drivers will have most of the ``ndos`` invoked under the "
"instance lock."
msgstr ""

#: ../../../networking/netdevices.rst:354
msgid "struct ethtool_ops"
msgstr ""

#: ../../../networking/netdevices.rst:356
msgid ""
"Similarly to ``ndos`` the instance lock is only held for select drivers. For "
"\"ops locked\" drivers all ethtool ops without exceptions should be called "
"under the instance lock."
msgstr ""

#: ../../../networking/netdevices.rst:361
msgid "struct netdev_stat_ops"
msgstr ""

#: ../../../networking/netdevices.rst:363
msgid ""
"\"qstat\" ops are invoked under the instance lock for \"ops locked\" "
"drivers, and under rtnl_lock for all other drivers."
msgstr ""

#: ../../../networking/netdevices.rst:367
msgid "struct net_shaper_ops"
msgstr ""

#: ../../../networking/netdevices.rst:369
msgid ""
"All net shaper callbacks are invoked while holding the netdev instance lock. "
"``rtnl_lock`` may or may not be held."
msgstr ""

#: ../../../networking/netdevices.rst:372
msgid "Note that supporting net shapers automatically enables \"ops locking\"."
msgstr ""

#: ../../../networking/netdevices.rst:375
msgid "struct netdev_queue_mgmt_ops"
msgstr ""

#: ../../../networking/netdevices.rst:377
msgid ""
"All queue management callbacks are invoked while holding the netdev instance "
"lock. ``rtnl_lock`` may or may not be held."
msgstr ""

#: ../../../networking/netdevices.rst:380
msgid ""
"Note that supporting struct netdev_queue_mgmt_ops automatically enables "
"\"ops locking\"."
msgstr ""

#: ../../../networking/netdevices.rst:384
msgid "Notifiers and netdev instance lock"
msgstr ""

#: ../../../networking/netdevices.rst:386
msgid ""
"For device drivers that implement shaping or queue management APIs, some of "
"the notifiers (``enum netdev_cmd``) are running under the netdev instance "
"lock."
msgstr ""

#: ../../../networking/netdevices.rst:390
msgid ""
"The following netdev notifiers are always run under the instance lock: * "
"``NETDEV_XDP_FEAT_CHANGE``"
msgstr ""

#: ../../../networking/netdevices.rst:393
msgid ""
"For devices with locked ops, currently only the following notifiers are "
"running under the lock: * ``NETDEV_CHANGE`` * ``NETDEV_REGISTER`` * "
"``NETDEV_UP``"
msgstr ""

#: ../../../networking/netdevices.rst:399
msgid ""
"The following notifiers are running without the lock: * ``NETDEV_UNREGISTER``"
msgstr ""

#: ../../../networking/netdevices.rst:402
msgid ""
"There are no clear expectations for the remaining notifiers. Notifiers not "
"on the list may run with or without the instance lock, potentially even "
"invoking the same notifier type with and without the lock from different "
"code paths. The goal is to eventually ensure that all (or most, with a few "
"documented exceptions) notifiers run under the instance lock. Please extend "
"this documentation whenever you make explicit assumption about lock being "
"held from a notifier."
msgstr ""

#: ../../../networking/netdevices.rst:411
msgid "NETDEV_INTERNAL symbol namespace"
msgstr ""

#: ../../../networking/netdevices.rst:413
msgid ""
"Symbols exported as NETDEV_INTERNAL can only be used in networking core and "
"drivers which exclusively flow via the main networking list and trees. Note "
"that the inverse is not true, most symbols outside of NETDEV_INTERNAL are "
"not expected to be used by random code outside netdev either. Symbols may "
"lack the designation because they predate the namespaces, or simply due to "
"an oversight."
msgstr ""
