# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-16 08:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../wmi/driver-development-guide.rst:5
msgid "WMI driver development guide"
msgstr "WMI 驅動器開發指南"

#: ../../../wmi/driver-development-guide.rst:7
msgid ""
"The WMI subsystem provides a rich driver API for implementing WMI drivers, "
"documented at Documentation/driver-api/wmi.rst. This document will serve as "
"an introductory guide for WMI driver writers using this API. It is supposed "
"to be a successor to the original LWN article [1]_ which deals with WMI "
"drivers using the deprecated GUID-based WMI interface."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:14
msgid "Obtaining WMI device information"
msgstr ""

#: ../../../wmi/driver-development-guide.rst:16
msgid ""
"Before developing an WMI driver, information about the WMI device in "
"question must be obtained. The `lswmi <https://pypi.org/project/lswmi>`_ "
"utility can be used to extract detailed WMI device information using the "
"following command:"
msgstr ""

#: ../../../wmi/driver-development-guide.rst:24
msgid ""
"The resulting output will contain information about all WMI devices "
"available on a given machine, plus some extra information."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:27
msgid ""
"In order to find out more about the interface used to communicate with a WMI "
"device, the `bmfdec <https://github.com/pali/bmfdec>`_ utilities can be used "
"to decode the Binary MOF (Managed Object Format) information used to "
"describe WMI devices. The ``wmi-bmof`` driver exposes this information to "
"userspace, see Documentation/wmi/devices/wmi-bmof.rst."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:33
msgid ""
"In order to retrieve the decoded Binary MOF information, use the following "
"command (requires root):"
msgstr ""

#: ../../../wmi/driver-development-guide.rst:39
msgid ""
"Sometimes, looking at the disassembled ACPI tables used to describe the WMI "
"device helps in understanding how the WMI device is supposed to work. The "
"path of the ACPI method associated with a given WMI device can be retrieved "
"using the ``lswmi`` utility as mentioned above."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:44
msgid ""
"If you are attempting to port a driver to Linux and are working on a Windows "
"system, `WMIExplorer <https://github.com/vinaypamnani/wmie2>`_ can be useful "
"for inspecting available WMI methods and invoking them directly."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:49
msgid "Basic WMI driver structure"
msgstr ""

#: ../../../wmi/driver-development-guide.rst:51
msgid ""
"The basic WMI driver is build around the struct wmi_driver, which is then "
"bound to matching WMI devices using a struct wmi_device_id table:"
msgstr ""

#: ../../../wmi/driver-development-guide.rst:79
msgid ""
"The probe() callback is called when the WMI driver is bound to a matching "
"WMI device. Allocating driver-specific data structures and initialising "
"interfaces to other kernel subsystems should normally be done in this "
"function."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:83
msgid ""
"The remove() callback is then called when the WMI driver is unbound from a "
"WMI device. In order to unregister interfaces to other kernel subsystems and "
"release resources, devres should be used. This simplifies error handling "
"during probe and often allows to omit this callback entirely, see "
"Documentation/driver-api/driver-model/devres.rst for details."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:88
msgid ""
"The shutdown() callback is called during shutdown, reboot or kexec. Its sole "
"purpose is to disable the WMI device and put it in a well-known state for "
"the WMI driver to pick up later after reboot or kexec. Most WMI drivers need "
"no special shutdown handling and can thus omit this callback."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:92
msgid ""
"Please note that new WMI drivers are required to be able to be instantiated "
"multiple times, and are forbidden from using any deprecated GUID-based or "
"ACPI-based WMI functions. This means that the WMI driver should be prepared "
"for the scenario that multiple matching WMI devices are present on a given "
"machine."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:97
msgid ""
"Because of this, WMI drivers should use the state container design pattern "
"as described in Documentation/driver-api/driver-model/design-patterns.rst."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:100
msgid ""
"Using both GUID-based and non-GUID-based functions for querying WMI data "
"blocks and handling WMI events simultaneously on the same device is "
"guaranteed to corrupt the WMI device state and might lead to erratic "
"behaviour."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:105
msgid "WMI method drivers"
msgstr ""

#: ../../../wmi/driver-development-guide.rst:107
msgid ""
"WMI drivers can call WMI device methods using wmidev_invoke_method(). For "
"each WMI method invocation the WMI driver needs to provide the instance "
"number and the method ID, as well as a buffer with the method arguments and "
"optionally a buffer for the results."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:111
msgid ""
"The layout of said buffers is device-specific and described by the Binary "
"MOF data associated with a given WMI device. Said Binary MOF data also "
"describes the method ID of a given WMI method with the ``WmiMethodId`` "
"qualifier. WMI devices exposing WMI methods usually expose only a single "
"instance (instance number 0), but in theory can expose multiple instances as "
"well. In such a case the number of instances can be retrieved using "
"wmidev_instance_count()."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:117
msgid ""
"Take a look at drivers/platform/x86/intel/wmi/thunderbolt.c for an example "
"WMI method driver."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:120
msgid "WMI data block drivers"
msgstr ""

#: ../../../wmi/driver-development-guide.rst:122
msgid ""
"WMI drivers can query WMI data blocks using wmidev_query_block(), the layout "
"of the returned buffer is again device-specific and described by the Binary "
"MOF data. Some WMI data blocks are also writeable and can be set using "
"wmidev_set_block(). The number of data block instances can again be "
"retrieved using wmidev_instance_count()."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:127
msgid ""
"Take a look at drivers/platform/x86/intel/wmi/sbl-fw-update.c for an example "
"WMI data block driver."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:130
msgid "WMI event drivers"
msgstr ""

#: ../../../wmi/driver-development-guide.rst:132
msgid ""
"WMI drivers can receive WMI events via the notify_new() callback inside the "
"struct wmi_driver. The WMI subsystem will then take care of setting up the "
"WMI event accordingly. Please note that the layout of the buffer passed to "
"this callback is device-specific, and freeing of the buffer is done by the "
"WMI subsystem itself, not the driver."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:137
msgid ""
"The WMI driver core will take care that the notify_new() callback will only "
"be called after the probe() callback has been called, and that no events are "
"being received by the driver right before and after calling its remove() or "
"shutdown() callback."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:141
msgid ""
"However WMI driver developers should be aware that multiple WMI events can "
"be received concurrently, so any locking (if necessary) needs to be provided "
"by the WMI driver itself."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:144
msgid ""
"In order to be able to receive WMI events containing no additional event "
"data, the ``no_notify_data`` flag inside struct wmi_driver should be set to "
"``true``."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:147
msgid ""
"Take a look at drivers/platform/x86/xiaomi-wmi.c for an example WMI event "
"driver."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:150
msgid "Exchanging data with the WMI driver core"
msgstr ""

#: ../../../wmi/driver-development-guide.rst:152
msgid ""
"WMI drivers can exchange data with the WMI driver core using struct "
"wmi_buffer. The internal structure of those buffers is device-specific and "
"only known by the WMI driver. Because of this the WMI driver itself is "
"responsible for parsing and validating the data received from its WMI device."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:157
msgid ""
"The structure of said buffers is described by the MOF data associated with "
"the WMI device in question. When such a buffer contains multiple data items "
"it usually makes sense to define a C structure and use it during parsing. "
"Since the WMI driver core guarantees that all buffers received from a WMI "
"device are aligned on an 8-byte boundary, WMI drivers can simply perform a "
"cast between the WMI buffer data and this C structure."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:163
msgid ""
"This however should only be done after the size of the buffer was verified "
"to be large enough to hold the whole C structure. WMI drivers should reject "
"undersized buffers as they are usually sent by the WMI device to signal an "
"internal error. Oversized buffers however should be accepted to emulate the "
"behavior of the Windows WMI implementation."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:168
msgid ""
"When defining a C structure for parsing WMI buffers the alignment of the "
"data items should be respected. This is especially important for 64-bit "
"integers as those have different alignments on 64-bit (8-byte alignment) and "
"32-bit (4-byte alignment) architectures. It is thus a good idea to manually "
"specify the alignment of such data items or mark the whole structure as "
"packed when appropriate. Integer data items in general are little-endian "
"integers and should be marked as such using ``__le64`` and friends. When "
"parsing WMI string data items the struct wmi_string should be used as WMI "
"strings have a different layout than C strings."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:176
msgid ""
"See Documentation/wmi/acpi-interface.rst for more information regarding the "
"binary format of WMI data items."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:180
msgid "Handling multiple WMI devices at once"
msgstr ""

#: ../../../wmi/driver-development-guide.rst:182
msgid ""
"There are many cases of firmware vendors using multiple WMI devices to "
"control different aspects of a single physical device. This can make "
"developing WMI drivers complicated, as those drivers might need to "
"communicate with each other to present a unified interface to userspace."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:186
msgid ""
"On such case involves a WMI event device which needs to talk to a WMI data "
"block device or WMI method device upon receiving an WMI event. In such a "
"case, two WMI drivers should be developed, one for the WMI event device and "
"one for the other WMI device."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:190
msgid ""
"The WMI event device driver has only one purpose: to receive WMI events, "
"validate any additional event data and invoke a notifier chain. The other "
"WMI driver adds itself to this notifier chain during probing and thus gets "
"notified every time a WMI event is received. This WMI driver might then "
"process the event further for example by using an input device."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:195
msgid "For other WMI device constellations, similar mechanisms can be used."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:198
msgid "Things to avoid"
msgstr ""

#: ../../../wmi/driver-development-guide.rst:200
msgid ""
"When developing WMI drivers, there are a couple of things which should be "
"avoided:"
msgstr ""

#: ../../../wmi/driver-development-guide.rst:202
msgid ""
"usage of the deprecated GUID-based WMI interface which uses GUIDs instead of "
"WMI device structs"
msgstr ""

#: ../../../wmi/driver-development-guide.rst:203
msgid ""
"usage of the deprecated ACPI-based WMI interface which uses ACPI objects "
"instead of plain buffers"
msgstr ""

#: ../../../wmi/driver-development-guide.rst:204
msgid "bypassing of the WMI subsystem when talking to WMI devices"
msgstr ""

#: ../../../wmi/driver-development-guide.rst:205
msgid "WMI drivers which cannot be instantiated multiple times."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:207
msgid ""
"Many older WMI drivers violate one or more points from this list. The reason "
"for this is that the WMI subsystem evolved significantly over the last two "
"decades, so there is a lot of legacy cruft inside older WMI drivers."
msgstr ""

#: ../../../wmi/driver-development-guide.rst:211
msgid ""
"New WMI drivers are also required to conform to the linux kernel coding "
"style as specified in Documentation/process/coding-style.rst. The checkpatch "
"utility can catch many common coding style violations, you can invoke it "
"with the following command:"
msgstr ""

#: ../../../wmi/driver-development-guide.rst:220
msgid "References"
msgstr ""

#: ../../../wmi/driver-development-guide.rst:222
msgid "https://lwn.net/Articles/391230/"
msgstr ""
