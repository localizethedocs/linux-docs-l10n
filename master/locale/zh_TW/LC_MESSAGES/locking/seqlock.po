# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-16 08:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../locking/seqlock.rst:5
msgid "Sequence counters and sequential locks"
msgstr ""

#: ../../../locking/seqlock.rst:8
msgid "Introduction"
msgstr "介紹"

#: ../../../locking/seqlock.rst:10
msgid ""
"Sequence counters are a reader-writer consistency mechanism with lockless "
"readers (read-only retry loops), and no writer starvation. They are used for "
"data that's rarely written to (e.g. system time), where the reader wants a "
"consistent set of information and is willing to retry if that information "
"changes."
msgstr ""

#: ../../../locking/seqlock.rst:16
msgid ""
"A data set is consistent when the sequence count at the beginning of the "
"read side critical section is even and the same sequence count value is read "
"again at the end of the critical section. The data in the set must be copied "
"out inside the read side critical section. If the sequence count has changed "
"between the start and the end of the critical section, the reader must retry."
msgstr ""

#: ../../../locking/seqlock.rst:23
msgid ""
"Writers increment the sequence count at the start and the end of their "
"critical section. After starting the critical section the sequence count is "
"odd and indicates to the readers that an update is in progress. At the end "
"of the write side critical section the sequence count becomes even again "
"which lets readers make progress."
msgstr ""

#: ../../../locking/seqlock.rst:29
msgid ""
"A sequence counter write side critical section must never be preempted or "
"interrupted by read side sections. Otherwise the reader will spin for the "
"entire scheduler tick due to the odd sequence count value and the "
"interrupted writer. If that reader belongs to a real-time scheduling class, "
"it can spin forever and the kernel will livelock."
msgstr ""

#: ../../../locking/seqlock.rst:35
msgid ""
"This mechanism cannot be used if the protected data contains pointers, as "
"the writer can invalidate a pointer that the reader is following."
msgstr ""

#: ../../../locking/seqlock.rst:42
msgid "Sequence counters (``seqcount_t``)"
msgstr ""

#: ../../../locking/seqlock.rst:44
msgid ""
"This is the raw counting mechanism, which does not protect against multiple "
"writers.  Write side critical sections must thus be serialized by an "
"external lock."
msgstr ""

#: ../../../locking/seqlock.rst:48
msgid ""
"If the write serialization primitive is not implicitly disabling preemption, "
"preemption must be explicitly disabled before entering the write side "
"section. If the read section can be invoked from hardirq or softirq "
"contexts, interrupts or bottom halves must also be respectively disabled "
"before entering the write section."
msgstr ""

#: ../../../locking/seqlock.rst:54
msgid ""
"If it's desired to automatically handle the sequence counter requirements of "
"writer serialization and non-preemptibility, use :ref:`seqlock_t` instead."
msgstr ""

#: ../../../locking/seqlock.rst:58 ../../../locking/seqlock.rst:173
msgid "Initialization::"
msgstr ""

#: ../../../locking/seqlock.rst:72 ../../../locking/seqlock.rst:187
msgid "Write path::"
msgstr ""

#: ../../../locking/seqlock.rst:82
msgid "Read path::"
msgstr ""

#: ../../../locking/seqlock.rst:95
msgid "Sequence counters with associated locks (``seqcount_LOCKNAME_t``)"
msgstr ""

#: ../../../locking/seqlock.rst:97
msgid ""
"As discussed at :ref:`seqcount_t`, sequence count write side critical "
"sections must be serialized and non-preemptible. This variant of sequence "
"counters associate the lock used for writer serialization at initialization "
"time, which enables lockdep to validate that the write side critical "
"sections are properly serialized."
msgstr ""

#: ../../../locking/seqlock.rst:103
msgid ""
"This lock association is a NOOP if lockdep is disabled and has neither "
"storage nor runtime overhead. If lockdep is enabled, the lock pointer is "
"stored in struct seqcount and lockdep's \"lock is held\" assertions are "
"injected at the beginning of the write side critical section to validate "
"that it is properly protected."
msgstr ""

#: ../../../locking/seqlock.rst:109
msgid ""
"For lock types which do not implicitly disable preemption, preemption "
"protection is enforced in the write side function."
msgstr ""

#: ../../../locking/seqlock.rst:112
msgid "The following sequence counters with associated locks are defined:"
msgstr ""

#: ../../../locking/seqlock.rst:114
msgid "``seqcount_spinlock_t``"
msgstr ""

#: ../../../locking/seqlock.rst:115
msgid "``seqcount_raw_spinlock_t``"
msgstr ""

#: ../../../locking/seqlock.rst:116
msgid "``seqcount_rwlock_t``"
msgstr ""

#: ../../../locking/seqlock.rst:117
msgid "``seqcount_mutex_t``"
msgstr ""

#: ../../../locking/seqlock.rst:118
msgid "``seqcount_ww_mutex_t``"
msgstr ""

#: ../../../locking/seqlock.rst:120
msgid ""
"The sequence counter read and write APIs can take either a plain seqcount_t "
"or any of the seqcount_LOCKNAME_t variants above."
msgstr ""

#: ../../../locking/seqlock.rst:123
msgid "Initialization (replace \"LOCKNAME\" with one of the supported locks)::"
msgstr ""

#: ../../../locking/seqlock.rst:138
msgid ""
"Write path: same as in :ref:`seqcount_t`, while running from a context with "
"the associated write serialization lock acquired."
msgstr ""

#: ../../../locking/seqlock.rst:141
msgid "Read path: same as in :ref:`seqcount_t`."
msgstr ""

#: ../../../locking/seqlock.rst:147
msgid "Latch sequence counters (``seqcount_latch_t``)"
msgstr ""

#: ../../../locking/seqlock.rst:149
msgid ""
"Latch sequence counters are a multiversion concurrency control mechanism "
"where the embedded seqcount_t counter even/odd value is used to switch "
"between two copies of protected data. This allows the sequence counter read "
"path to safely interrupt its own write side critical section."
msgstr ""

#: ../../../locking/seqlock.rst:154
msgid ""
"Use seqcount_latch_t when the write side sections cannot be protected from "
"interruption by readers. This is typically the case when the read side can "
"be invoked from NMI handlers."
msgstr ""

#: ../../../locking/seqlock.rst:158
msgid "Check `write_seqcount_latch()` for more information."
msgstr ""

#: ../../../locking/seqlock.rst:164
msgid "Sequential locks (``seqlock_t``)"
msgstr ""

#: ../../../locking/seqlock.rst:166
msgid ""
"This contains the :ref:`seqcount_t` mechanism earlier discussed, plus an "
"embedded spinlock for writer serialization and non-preemptibility."
msgstr ""

#: ../../../locking/seqlock.rst:169
msgid ""
"If the read side section can be invoked from hardirq or softirq context, use "
"the write side function variants which disable interrupts or bottom halves "
"respectively."
msgstr ""

#: ../../../locking/seqlock.rst:195
msgid "Read path, three categories:"
msgstr ""

#: ../../../locking/seqlock.rst:197
msgid ""
"Normal Sequence readers which never block a writer but they must retry if a "
"writer is in progress by detecting change in the sequence number.  Writers "
"do not wait for a sequence reader::"
msgstr ""

#: ../../../locking/seqlock.rst:208
msgid ""
"Locking readers which will wait if a writer or another locking reader is in "
"progress. A locking reader in progress will also block a writer from "
"entering its critical section. This read lock is exclusive. Unlike rwlock_t, "
"only one locking reader can acquire it::"
msgstr ""

#: ../../../locking/seqlock.rst:219
msgid ""
"Conditional lockless reader (as in 1), or locking reader (as in 2), "
"according to a passed marker. This is used to avoid lockless readers "
"starvation (too much retry loops) in case of a sharp spike in write "
"activity. First, a lockless read is tried (even marker passed). If that "
"trial fails (sequence counter doesn't match), make the marker odd for the "
"next iteration, the lockless read is transformed to a full locking read and "
"no retry loop is necessary, for example::"
msgstr ""

#: ../../../locking/seqlock.rst:240
msgid "API documentation"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:60
msgid "``seqcount_init (s)``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:58
msgid "runtime initializer for seqcount_t"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:62
#: ../include/linux/seqlock.h:89 ../include/linux/seqlock.h:271
#: ../include/linux/seqlock.h:288 ../include/linux/seqlock.h:296
#: ../include/linux/seqlock.h:308 ../include/linux/seqlock.h:327
#: ../include/linux/seqlock.h:350 ../include/linux/seqlock.h:376
#: ../include/linux/seqlock.h:400 ../include/linux/seqlock.h:420
#: ../include/linux/seqlock.h:441 ../include/linux/seqlock.h:462
#: ../include/linux/seqlock.h:487 ../include/linux/seqlock.h:512
#: ../include/linux/seqlock.h:533 ../include/linux/seqlock.h:586
#: ../include/linux/seqlock.h:619 ../include/linux/seqlock.h:627
#: ../include/linux/seqlock.h:633 ../include/linux/seqlock.h:653
#: ../include/linux/seqlock.h:670 ../include/linux/seqlock.h:684
#: ../include/linux/seqlock.h:698 ../include/linux/seqlock.h:709
#: ../include/linux/seqlock.h:790 ../include/linux/seqlock.h:799
#: ../include/linux/seqlock.h:817 ../include/linux/seqlock.h:827
#: ../include/linux/seqlock.h:834 ../include/linux/seqlock.h:846
#: ../include/linux/seqlock.h:869 ../include/linux/seqlock.h:889
#: ../include/linux/seqlock.h:903 ../include/linux/seqlock.h:917
#: ../include/linux/seqlock.h:932 ../include/linux/seqlock.h:946
#: ../include/linux/seqlock.h:970 ../include/linux/seqlock.h:983
#: ../include/linux/seqlock.h:1000 ../include/linux/seqlock.h:1022
#: ../include/linux/seqlock.h:1032 ../include/linux/seqlock.h:1047
#: ../include/linux/seqlock.h:1058 ../include/linux/seqlock.h:1073
#: ../include/linux/seqlock.h:1093 ../include/linux/seqlock.h:1107
#: ../include/linux/seqlock.h:1120 ../include/linux/seqlock.h:1160
#: ../include/linux/seqlock.h:1173 ../include/linux/seqlock.h:1188
#: ../include/linux/seqlock.h:1222 ../include/linux/seqlock.h:1346
msgid "**Parameters**"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:64
#: ../include/linux/seqlock.h:273 ../include/linux/seqlock.h:290
#: ../include/linux/seqlock.h:298 ../include/linux/seqlock.h:310
#: ../include/linux/seqlock.h:329 ../include/linux/seqlock.h:352
#: ../include/linux/seqlock.h:378 ../include/linux/seqlock.h:402
#: ../include/linux/seqlock.h:422 ../include/linux/seqlock.h:443
#: ../include/linux/seqlock.h:464 ../include/linux/seqlock.h:489
#: ../include/linux/seqlock.h:514 ../include/linux/seqlock.h:535
#: ../include/linux/seqlock.h:588 ../include/linux/seqlock.h:629
msgid "``s``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:59
msgid "Pointer to the seqcount_t instance"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:87
msgid "``SEQCNT_ZERO (name)``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:85
msgid "static initializer for seqcount_t"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:91
msgid "``name``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:86
msgid "Name of the seqcount_t instance"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:269
msgid "``__read_seqcount_begin (s)``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:267
msgid "begin a seqcount_t read section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:268
#: ../include/linux/seqlock.h:285 ../include/linux/seqlock.h:293
#: ../include/linux/seqlock.h:305 ../include/linux/seqlock.h:325
#: ../include/linux/seqlock.h:348 ../include/linux/seqlock.h:373
#: ../include/linux/seqlock.h:397 ../include/linux/seqlock.h:417
#: ../include/linux/seqlock.h:438 ../include/linux/seqlock.h:460
#: ../include/linux/seqlock.h:484 ../include/linux/seqlock.h:509
#: ../include/linux/seqlock.h:530 ../include/linux/seqlock.h:584
msgid "Pointer to seqcount_t or any of the seqcount_LOCKNAME_t variants"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:270
#: ../include/linux/seqlock.h:287 ../include/linux/seqlock.h:295
#: ../include/linux/seqlock.h:311 ../include/linux/seqlock.h:336
#: ../include/linux/seqlock.h:359 ../include/linux/seqlock.h:383
#: ../include/linux/seqlock.h:403 ../include/linux/seqlock.h:634
#: ../include/linux/seqlock.h:654 ../include/linux/seqlock.h:670
#: ../include/linux/seqlock.h:684 ../include/linux/seqlock.h:833
#: ../include/linux/seqlock.h:849 ../include/linux/seqlock.h:1138
#: ../include/linux/seqlock.h:1160
msgid "**Return**"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:270
#: ../include/linux/seqlock.h:287 ../include/linux/seqlock.h:295
#: ../include/linux/seqlock.h:312 ../include/linux/seqlock.h:326
#: ../include/linux/seqlock.h:360
msgid "count to be passed to read_seqcount_retry()"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:286
msgid "``raw_read_seqcount_begin (s)``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:284
msgid "begin a seqcount_t read section w/o lockdep"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:294
msgid "``read_seqcount_begin (s)``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:292
msgid "begin a seqcount_t read critical section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:306
msgid "``raw_read_seqcount (s)``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:304
msgid "read the raw seqcount_t counter value"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:307
#: ../include/linux/seqlock.h:328 ../include/linux/seqlock.h:350
#: ../include/linux/seqlock.h:376 ../include/linux/seqlock.h:400
#: ../include/linux/seqlock.h:463 ../include/linux/seqlock.h:532
#: ../include/linux/seqlock.h:586 ../include/linux/seqlock.h:632
#: ../include/linux/seqlock.h:652 ../include/linux/seqlock.h:708
#: ../include/linux/seqlock.h:798 ../include/linux/seqlock.h:846
#: ../include/linux/seqlock.h:868 ../include/linux/seqlock.h:888
#: ../include/linux/seqlock.h:902 ../include/linux/seqlock.h:916
#: ../include/linux/seqlock.h:931 ../include/linux/seqlock.h:945
#: ../include/linux/seqlock.h:972 ../include/linux/seqlock.h:984
#: ../include/linux/seqlock.h:999 ../include/linux/seqlock.h:1032
#: ../include/linux/seqlock.h:1058 ../include/linux/seqlock.h:1095
#: ../include/linux/seqlock.h:1125 ../include/linux/seqlock.h:1173
#: ../include/linux/seqlock.h:1189 ../include/linux/seqlock.h:1225
#: ../include/linux/seqlock.h:1349
msgid "**Description**"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:306
msgid ""
"raw_read_seqcount opens a read critical section of the given seqcount_t, "
"without any lockdep checking, and without checking or masking the sequence "
"counter LSB. Calling code is responsible for handling that."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:325
msgid "``raw_seqcount_try_begin (s, start)``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:323
#: ../include/linux/seqlock.h:346
msgid ""
"begin a seqcount_t read critical section w/o lockdep and w/o counter "
"stabilization"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:327
#: ../include/linux/seqlock.h:375 ../include/linux/seqlock.h:399
msgid "``start``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:327
msgid ""
"Similar to raw_seqcount_begin(), except it enables eliding the critical "
"section entirely if odd, instead of doing the speculation knowing it will "
"fail."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:331
msgid ""
"Useful when counter stabilization is more or less equivalent to taking the "
"lock and there is a slowpath that does that."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:334
msgid "If true, start will be set to the (even) sequence count read."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:337
msgid "true when a read critical section is started."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:348
msgid "``raw_seqcount_begin (s)``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:349
msgid ""
"raw_seqcount_begin opens a read critical section of the given seqcount_t. "
"Unlike read_seqcount_begin(), this function will not wait for the count to "
"stabilize. If a writer is active when it begins, it will fail the "
"read_seqcount_retry() at the end of the read critical section instead of "
"stabilizing at the beginning of it."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:355
msgid ""
"Use this only in special kernel hot paths where the read section is small "
"and has a high probability of success through other external means. It will "
"save a single branching instruction."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:374
msgid "``__read_seqcount_retry (s, start)``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:372
msgid "end a seqcount_t read section w/o barrier"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:374
#: ../include/linux/seqlock.h:398
msgid "count, from read_seqcount_begin()"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:375
msgid ""
"__read_seqcount_retry is like read_seqcount_retry, but has no smp_rmb() "
"barrier. Callers should ensure that smp_rmb() or equivalent ordering is "
"provided before actually loading any of the variables that are to be "
"protected in this critical section."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:380
msgid ""
"Use carefully, only in critical code, and comment how the barrier is "
"provided."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:384
#: ../include/linux/seqlock.h:404 ../include/linux/seqlock.h:670
#: ../include/linux/seqlock.h:684 ../include/linux/seqlock.h:850
msgid "true if a read section retry is required, else false"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:398
msgid "``read_seqcount_retry (s, start)``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:396
msgid "end a seqcount_t read critical section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:399
msgid ""
"read_seqcount_retry closes the read critical section of given seqcount_t.  "
"If the critical section was invalid, it must be ignored (and typically "
"retried)."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:418
msgid "``raw_write_seqcount_begin (s)``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:416
msgid "start a seqcount_t write section w/o lockdep"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:419
#: ../include/linux/seqlock.h:440 ../include/linux/seqlock.h:464
#: ../include/linux/seqlock.h:486 ../include/linux/seqlock.h:511
#: ../include/linux/seqlock.h:872 ../include/linux/seqlock.h:1007
#: ../include/linux/seqlock.h:1136
msgid "**Context**"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:419
#: ../include/linux/seqlock.h:464
msgid "check write_seqcount_begin()"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:439
msgid "``raw_write_seqcount_end (s)``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:437
msgid "end a seqcount_t write section w/o lockdep"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:440
msgid "check write_seqcount_end()"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:460
msgid "``write_seqcount_begin_nested (s, subclass)``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:458
msgid "start a seqcount_t write section with custom lockdep nesting level"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:462
msgid "``subclass``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:461
msgid "lockdep nesting level"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:462
msgid "See Documentation/locking/lockdep-design.rst"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:485
msgid "``write_seqcount_begin (s)``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:483
msgid "start a seqcount_t write side critical section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:486
msgid ""
"sequence counter write side sections must be serialized and non-preemptible. "
"Preemption will be automatically disabled if and only if the seqcount write "
"serialization lock is associated, and preemptible.  If readers can be "
"invoked from hardirq or softirq context, interrupts or bottom halves must be "
"respectively disabled."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:510
msgid "``write_seqcount_end (s)``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:508
msgid "end a seqcount_t write side critical section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:511
msgid ""
"Preemption will be automatically re-enabled if and only if the seqcount "
"write serialization lock is associated, and preemptible."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:531
msgid "``raw_write_seqcount_barrier (s)``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:529
msgid "do a seqcount_t write barrier"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:531
msgid ""
"This can be used to provide an ordering guarantee instead of the usual "
"consistency guarantee. It is one wmb cheaper, because it can collapse the "
"two back-to-back wmb()s."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:535
msgid ""
"Note that writes surrounding the barrier should be declared atomic (e.g. via "
"WRITE_ONCE): a) to ensure the writes become visible to other threads "
"atomically, avoiding compiler optimizations; b) to document which writes are "
"meant to propagate to the reader critical section. This is necessary because "
"neither writes before nor after the barrier are enclosed in a seq-writer "
"critical section that would ensure readers are aware of ongoing writes::"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:584
msgid "``write_seqcount_invalidate (s)``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:582
msgid "invalidate in-progress seqcount_t read side operations"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:585
msgid ""
"After write_seqcount_invalidate, no seqcount_t read side operations will "
"complete successfully and see data older than this."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:617
msgid "``SEQCNT_LATCH_ZERO (seq_name)``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:615
msgid "static initializer for seqcount_latch_t"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:621
msgid "``seq_name``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:616
msgid "Name of the seqcount_latch_t instance"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:625
msgid "``seqcount_latch_init (s)``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:623
msgid "runtime initializer for seqcount_latch_t"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:624
msgid "Pointer to the seqcount_latch_t instance"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:629
#: ../include/linux/seqlock.h:649
msgid "pick even/odd latch data copy"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:635
#: ../include/linux/seqlock.h:655 ../include/linux/seqlock.h:672
#: ../include/linux/seqlock.h:686
msgid "``const seqcount_latch_t *s``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:630
#: ../include/linux/seqlock.h:650 ../include/linux/seqlock.h:667
#: ../include/linux/seqlock.h:681 ../include/linux/seqlock.h:695
#: ../include/linux/seqlock.h:706 ../include/linux/seqlock.h:787
#: ../include/linux/seqlock.h:796
msgid "Pointer to seqcount_latch_t"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:631
msgid ""
"See raw_write_seqcount_latch() for details and a full reader/writer usage "
"example."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:635
msgid ""
"sequence counter raw value. Use the lowest bit as an index for picking which "
"data copy to read. The full counter must then be checked with "
"raw_read_seqcount_latch_retry()."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:651
msgid ""
"See write_seqcount_latch() for details and a full reader/writer usage "
"example."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:655
msgid ""
"sequence counter raw value. Use the lowest bit as an index for picking which "
"data copy to read. The full counter must then be checked with "
"read_seqcount_latch_retry()."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:666
#: ../include/linux/seqlock.h:680
msgid "end a seqcount_latch_t read section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:669
#: ../include/linux/seqlock.h:683 ../include/linux/seqlock.h:845
msgid "``unsigned start``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:668
msgid "count, from raw_read_seqcount_latch()"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:682
msgid "count, from read_seqcount_latch()"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:694
msgid "redirect latch readers to even/odd copy"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:700
#: ../include/linux/seqlock.h:711 ../include/linux/seqlock.h:792
#: ../include/linux/seqlock.h:801
msgid "``seqcount_latch_t *s``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:705
msgid "redirect latch readers to odd copy"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:707
msgid ""
"The latch technique is a multiversion concurrency control method that allows "
"queries during non-atomic modifications. If you can guarantee queries never "
"interrupt the modification -- e.g. the concurrency is strictly between CPUs "
"-- you most likely do not need this."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:712
msgid ""
"Where the traditional RCU/lockless data structures rely on atomic "
"modifications to ensure queries observe either the old or the new state the "
"latch allows the same for non-atomic updates. The trade-off is doubling the "
"cost of storage; we have to maintain two copies of the entire data structure."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:718
msgid ""
"Very simply put: we first modify one copy and then the other. This ensures "
"there is always one copy in a stable state, ready to give us an answer."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:721
msgid "The basic form is a data structure like::"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:728
msgid ""
"Where a modification, which is assumed to be externally serialized, does the "
"following::"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:740
msgid "The query will have a form like::"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:759
msgid ""
"So during the modification, queries are first redirected to data[1]. Then we "
"modify data[0]. When that is complete, we redirect queries back to data[0] "
"and we can modify data[1]."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:763
msgid "**NOTE**"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:764
msgid ""
"The non-requirement for atomic modifications does _NOT_ include the "
"publishing of new entries in the case where data is a dynamic data structure."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:768
msgid ""
"An iteration might start in data[0] and get suspended long enough to miss an "
"entire modification sequence, once it resumes it might observe the new entry."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:772
msgid "NOTE2:"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:774
msgid ""
"When data is a dynamic data structure; one should use regular RCU patterns "
"to manage the lifetimes of the objects within."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:786
msgid "redirect latch readers to even copy"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:795
msgid "end a seqcount_latch_t write section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:797
msgid ""
"Marks the end of a seqcount_latch_t writer section, after all copies of the "
"latch-protected data have been updated."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:815
msgid "``seqlock_init (sl)``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:813
msgid "dynamic initializer for seqlock_t"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:819
#: ../include/linux/seqlock.h:829
msgid "``sl``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:814
msgid "Pointer to the seqlock_t instance"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:825
msgid "``DEFINE_SEQLOCK (sl)``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:823
msgid "Define a statically allocated seqlock_t"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:824
msgid "Name of the seqlock_t instance"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:830
msgid "start a seqlock_t read side critical section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:836
#: ../include/linux/seqlock.h:848
msgid "``const seqlock_t *sl``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:831
#: ../include/linux/seqlock.h:843 ../include/linux/seqlock.h:866
#: ../include/linux/seqlock.h:886 ../include/linux/seqlock.h:900
#: ../include/linux/seqlock.h:914 ../include/linux/seqlock.h:929
#: ../include/linux/seqlock.h:943 ../include/linux/seqlock.h:968
#: ../include/linux/seqlock.h:981 ../include/linux/seqlock.h:997
#: ../include/linux/seqlock.h:1019 ../include/linux/seqlock.h:1030
#: ../include/linux/seqlock.h:1045 ../include/linux/seqlock.h:1056
#: ../include/linux/seqlock.h:1071 ../include/linux/seqlock.h:1091
#: ../include/linux/seqlock.h:1105 ../include/linux/seqlock.h:1117
#: ../include/linux/seqlock.h:1157 ../include/linux/seqlock.h:1170
#: ../include/linux/seqlock.h:1186 ../include/linux/seqlock.h:1220
msgid "Pointer to seqlock_t"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:833
msgid "count, to be passed to read_seqretry()"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:842
msgid "end a seqlock_t read side section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:844
msgid "count, from read_seqbegin()"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:845
msgid ""
"read_seqretry closes the read side critical section of given seqlock_t. If "
"the critical section was invalid, it must be ignored (and typically retried)."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:865
msgid "start a seqlock_t write side critical section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:871
#: ../include/linux/seqlock.h:891 ../include/linux/seqlock.h:905
#: ../include/linux/seqlock.h:919 ../include/linux/seqlock.h:934
#: ../include/linux/seqlock.h:948 ../include/linux/seqlock.h:985
#: ../include/linux/seqlock.h:1002 ../include/linux/seqlock.h:1024
#: ../include/linux/seqlock.h:1034 ../include/linux/seqlock.h:1049
#: ../include/linux/seqlock.h:1060 ../include/linux/seqlock.h:1075
#: ../include/linux/seqlock.h:1109
msgid "``seqlock_t *sl``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:867
msgid ""
"write_seqlock opens a write side critical section for the given seqlock_t.  "
"It also implicitly acquires the spinlock_t embedded inside that sequential "
"lock. All seqlock_t write side sections are thus automatically serialized "
"and non-preemptible."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:873
msgid ""
"if the seqlock_t read section, or other write side critical sections, can be "
"invoked from hardirq or softirq contexts, use the _irqsave or _bh variants "
"of this function instead."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:885
msgid "end a seqlock_t write side critical section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:887
msgid ""
"write_sequnlock closes the (serialized and non-preemptible) write side "
"critical section of given seqlock_t."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:899
msgid "start a softirqs-disabled seqlock_t write section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:901
msgid ""
"_bh variant of write_seqlock(). Use only if the read side section, or other "
"write side sections, can be invoked from softirq contexts."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:913
msgid "end a softirqs-disabled seqlock_t write section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:915
msgid ""
"write_sequnlock_bh closes the serialized, non-preemptible, and softirqs-"
"disabled, seqlock_t write side critical section opened with "
"write_seqlock_bh()."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:928
#: ../include/linux/seqlock.h:966
msgid "start a non-interruptible seqlock_t write section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:930
msgid ""
"_irq variant of write_seqlock(). Use only if the read side section, or other "
"write sections, can be invoked from hardirq contexts."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:942
msgid "end a non-interruptible seqlock_t write section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:944
msgid ""
"write_sequnlock_irq closes the serialized and non-interruptible seqlock_t "
"write side section opened with write_seqlock_irq()."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:968
msgid "``write_seqlock_irqsave (lock, flags)``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:972
#: ../include/linux/seqlock.h:1095
msgid "``lock``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:970
#: ../include/linux/seqlock.h:1093
msgid "``flags``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:969
msgid ""
"Stack-allocated storage for saving caller's local interrupt state, to be "
"passed to write_sequnlock_irqrestore()."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:971
msgid ""
"_irqsave variant of write_seqlock(). Use it only if the read side section, "
"or other write sections, can be invoked from hardirq context."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:979
msgid "end non-interruptible seqlock_t write section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:983
#: ../include/linux/seqlock.h:1107 ../include/linux/seqlock.h:1223
msgid "``unsigned long flags``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:982
msgid "Caller's saved interrupt state, from write_seqlock_irqsave()"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:983
msgid ""
"write_sequnlock_irqrestore closes the serialized and non-interruptible "
"seqlock_t write section previously opened with write_seqlock_irqsave()."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:996
msgid "begin a seqlock_t locking reader section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:998
msgid ""
"read_seqlock_excl opens a seqlock_t locking reader critical section.  A "
"locking reader exclusively locks out *both* other writers *and* other "
"locking readers, but it does not update the embedded sequence number."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1002
msgid "Locking readers act like a normal spin_lock()/spin_unlock()."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1005
msgid "The opened read section must be closed with read_sequnlock_excl()."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1005
#: ../include/linux/seqlock.h:1134
msgid ""
"if the seqlock_t write section, *or other read sections*, can be invoked "
"from hardirq or softirq contexts, use the _irqsave or _bh variant of this "
"function instead."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1018
msgid "end a seqlock_t locking reader critical section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1028
msgid "start a seqlock_t locking reader section with softirqs disabled"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1031
msgid ""
"_bh variant of read_seqlock_excl(). Use this variant only if the seqlock_t "
"write side section, *or other read sections*, can be invoked from softirq "
"contexts."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1043
msgid "stop a seqlock_t softirq-disabled locking reader section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1054
#: ../include/linux/seqlock.h:1089
msgid "start a non-interruptible seqlock_t locking reader section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1057
msgid ""
"_irq variant of read_seqlock_excl(). Use this only if the seqlock_t write "
"side section, *or other read sections*, can be invoked from a hardirq "
"context."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1069
msgid "end an interrupts-disabled seqlock_t locking reader section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1091
msgid "``read_seqlock_excl_irqsave (lock, flags)``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1092
msgid ""
"Stack-allocated storage for saving caller's local interrupt state, to be "
"passed to read_sequnlock_excl_irqrestore()."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1094
msgid ""
"_irqsave variant of read_seqlock_excl(). Use this only if the seqlock_t "
"write side section, *or other read sections*, can be invoked from a hardirq "
"context."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1103
msgid "end non-interruptible seqlock_t locking reader section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1106
msgid "Caller saved interrupt state, from read_seqlock_excl_irqsave()"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1116
msgid "begin a seqlock_t lockless or locking reader"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1122
#: ../include/linux/seqlock.h:1162 ../include/linux/seqlock.h:1175
#: ../include/linux/seqlock.h:1190 ../include/linux/seqlock.h:1224
msgid "``seqlock_t *lock``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1119
#: ../include/linux/seqlock.h:1188
msgid "``int *seq``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1118
msgid ""
"Marker and return parameter. If the passed value is even, the reader will "
"become a *lockless* seqlock_t reader as in read_seqbegin(). If the passed "
"value is odd, the reader will become a *locking* reader as in "
"read_seqlock_excl().  In the first call to this function, the caller *must* "
"initialize and pass an even value to **seq**; this way, a lockless read can "
"be optimistically tried first."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1124
msgid ""
"read_seqbegin_or_lock is an API designed to optimistically try a normal "
"lockless seqlock_t read section first.  If an odd counter is found, the "
"lockless read trial has failed, and the next read iteration transforms "
"itself into a full seqlock_t locking reader."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1129
msgid ""
"This is typically used to avoid seqlock_t lockless readers starvation (too "
"much retry loops) in the case of a sharp spike in write side activity."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1134
msgid "Check Documentation/locking/seqlock.rst for template example code."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1140
msgid ""
"the encountered sequence counter value, through the **seq** parameter, which "
"is overloaded as a return parameter. This returned value must be checked "
"with need_seqretry(). If the read section need to be retried, this returned "
"value must also be passed as the **seq** parameter of the next "
"read_seqbegin_or_lock() iteration."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1156
msgid "validate seqlock_t \"locking or lockless\" read section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1159
#: ../include/linux/seqlock.h:1172 ../include/linux/seqlock.h:1222
msgid "``int seq``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1158
msgid "sequence count, from read_seqbegin_or_lock()"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1160
msgid "true if a read section retry is required, false otherwise"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1169
msgid "end seqlock_t \"locking or lockless\" reader section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1171
msgid "count, from read_seqbegin_or_lock()"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1172
msgid ""
"done_seqretry finishes the seqlock_t read side critical section started with "
"read_seqbegin_or_lock() and validated by need_seqretry()."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1184
msgid ""
"begin a seqlock_t lockless reader, or a non-interruptible locking reader"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1187
msgid "Marker and return parameter. Check read_seqbegin_or_lock()."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1188
msgid ""
"This is the _irqsave variant of read_seqbegin_or_lock(). Use it only if the "
"seqlock_t write section, *or other read sections*, can be invoked from "
"hardirq context."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1193
msgid ""
"The saved local interrupts state in case of a locking reader, to be passed "
"to done_seqretry_irqrestore()."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1196
msgid ""
"The encountered sequence counter value, returned through **seq** overloaded "
"as a return parameter. Check read_seqbegin_or_lock()."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1199
msgid "**Note**"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1193
msgid "Interrupts will be disabled only for \"locking reader\" mode."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1218
msgid ""
"end a seqlock_t lockless reader, or a non-interruptible locking reader "
"section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1221
msgid "Count, from read_seqbegin_or_lock_irqsave()"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1222
msgid ""
"Caller's saved local interrupt state in case of a locking reader, also from "
"read_seqbegin_or_lock_irqsave()"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1224
msgid ""
"This is the _irqrestore variant of done_seqretry(). The read section must've "
"been opened with read_seqbegin_or_lock_irqsave(), and validated by "
"need_seqretry()."
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1344
msgid "``scoped_seqlock_read (_seqlock, _target)``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1342
msgid ""
"execute the read-side critical section without manual sequence counter "
"handling or calls to other helpers"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1348
msgid "``_seqlock``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1345
msgid "pointer to seqlock_t protecting the data"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1347
msgid "``_target``"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1346
msgid ""
"an enum ss_state: one of {ss_lock, ss_lock_irqsave, ss_lockless} indicating "
"the type of critical read section"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1348
msgid "Example::"
msgstr ""

#: ../../../locking/seqlock:242: ../include/linux/seqlock.h:1354
msgid ""
"Starts with a lockess pass first. If it fails, restarts the critical section "
"with the lock held."
msgstr ""
