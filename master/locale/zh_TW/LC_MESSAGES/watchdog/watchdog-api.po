# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../watchdog/watchdog-api.rst:3
msgid "The Linux Watchdog driver API"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:5
msgid "Last reviewed: 10/05/2007"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:9
msgid "Copyright 2002 Christer Weingel <wingel@nano-system.com>"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:11
msgid ""
"Some parts of this document are copied verbatim from the sbc60xxwdt driver "
"which is (c) Copyright 2000 Jakob Oestergaard <jakob@ostenfeld.dk>"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:14
msgid "This document describes the state of the Linux 2.4.18 kernel."
msgstr ""

#: ../../../watchdog/watchdog-api.rst:17
msgid "Introduction"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:19
msgid ""
"A Watchdog Timer (WDT) is a hardware circuit that can reset the computer "
"system in case of a software fault.  You probably knew that already."
msgstr ""

#: ../../../watchdog/watchdog-api.rst:23
msgid ""
"Usually a userspace daemon will notify the kernel watchdog driver via the /"
"dev/watchdog special device file that userspace is still alive, at regular "
"intervals.  When such a notification occurs, the driver will usually tell "
"the hardware watchdog that everything is in order, and that the watchdog "
"should wait for yet another little while to reset the system.  If userspace "
"fails (RAM error, kernel bug, whatever), the notifications cease to occur, "
"and the hardware watchdog will reset the system (causing a reboot) after the "
"timeout occurs."
msgstr ""

#: ../../../watchdog/watchdog-api.rst:32
msgid ""
"The Linux watchdog API is a rather ad-hoc construction and different drivers "
"implement different, and sometimes incompatible, parts of it. This file is "
"an attempt to document the existing usage and allow future driver writers to "
"use it as a reference."
msgstr ""

#: ../../../watchdog/watchdog-api.rst:38
msgid "The simplest API"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:40
msgid ""
"All drivers support the basic mode of operation, where the watchdog "
"activates as soon as /dev/watchdog is opened and will reboot unless the "
"watchdog is pinged within a certain time, this time is called the timeout or "
"margin.  The simplest way to ping the watchdog is to write some data to the "
"device.  So a very simple watchdog daemon would look like this source file:  "
"see samples/watchdog/watchdog-simple.c"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:47
msgid ""
"A more advanced driver could for example check that a HTTP server is still "
"responding before doing the write call to ping the watchdog."
msgstr ""

#: ../../../watchdog/watchdog-api.rst:50
msgid ""
"When the device is closed, the watchdog is disabled, unless the \"Magic "
"Close\" feature is supported (see below).  This is not always such a good "
"idea, since if there is a bug in the watchdog daemon and it crashes the "
"system will not reboot.  Because of this, some of the drivers support the "
"configuration option \"Disable watchdog shutdown on close\", "
"CONFIG_WATCHDOG_NOWAYOUT.  If it is set to Y when compiling the kernel, "
"there is no way of disabling the watchdog once it has been started.  So, if "
"the watchdog daemon crashes, the system will reboot after the timeout has "
"passed. Watchdog devices also usually support the nowayout module parameter "
"so that this option can be controlled at runtime."
msgstr ""

#: ../../../watchdog/watchdog-api.rst:63
msgid "Magic Close feature"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:65
msgid ""
"If a driver supports \"Magic Close\", the driver will not disable the "
"watchdog unless a specific magic character 'V' has been sent to /dev/"
"watchdog just before closing the file.  If the userspace daemon closes the "
"file without sending this special character, the driver will assume that the "
"daemon (and userspace in general) died, and will stop pinging the watchdog "
"without disabling it first.  This will then cause a reboot if the watchdog "
"is not re-opened in sufficient time."
msgstr ""

#: ../../../watchdog/watchdog-api.rst:74
msgid "The ioctl API"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:76
msgid "All conforming drivers also support an ioctl API."
msgstr ""

#: ../../../watchdog/watchdog-api.rst:78
msgid "Pinging the watchdog using an ioctl:"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:80
msgid ""
"All drivers that have an ioctl interface support at least one ioctl, "
"KEEPALIVE.  This ioctl does exactly the same thing as a write to the "
"watchdog device, so the main loop in the above program could be replaced "
"with::"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:90
msgid "the argument to the ioctl is ignored."
msgstr ""

#: ../../../watchdog/watchdog-api.rst:93
msgid "Setting and getting the timeout"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:95
msgid ""
"For some drivers it is possible to modify the watchdog timeout on the fly "
"with the SETTIMEOUT ioctl, those drivers have the WDIOF_SETTIMEOUT flag set "
"in their option field.  The argument is an integer representing the timeout "
"in seconds.  The driver returns the real timeout used in the same variable, "
"and this timeout might differ from the requested one due to limitation of "
"the hardware::"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:106
msgid ""
"This example might actually print \"The timeout was set to 60 seconds\" if "
"the device has a granularity of minutes for its timeout."
msgstr ""

#: ../../../watchdog/watchdog-api.rst:109
msgid ""
"Starting with the Linux 2.4.18 kernel, it is possible to query the current "
"timeout using the GETTIMEOUT ioctl::"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:116
msgid "Pretimeouts"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:118
msgid ""
"Some watchdog timers can be set to have a trigger go off before the actual "
"time they will reset the system.  This can be done with an NMI, interrupt, "
"or other mechanism.  This allows Linux to record useful information (like "
"panic information and kernel coredumps) before it resets::"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:127
msgid ""
"Note that the pretimeout is the number of seconds before the time when the "
"timeout will go off.  It is not the number of seconds until the pretimeout.  "
"So, for instance, if you set the timeout to 60 seconds and the pretimeout to "
"10 seconds, the pretimeout will go off in 50 seconds.  Setting a pretimeout "
"to zero disables it."
msgstr ""

#: ../../../watchdog/watchdog-api.rst:133
msgid "There is also a get function for getting the pretimeout::"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:138
msgid "Not all watchdog drivers will support a pretimeout."
msgstr ""

#: ../../../watchdog/watchdog-api.rst:141
msgid "Get the number of seconds before reboot"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:143
msgid ""
"Some watchdog drivers have the ability to report the remaining time before "
"the system will reboot. The WDIOC_GETTIMELEFT is the ioctl that returns the "
"number of seconds before reboot::"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:151
msgid "Environmental monitoring"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:153
msgid ""
"All watchdog drivers are required return more information about the system, "
"some do temperature, fan and power level monitoring, some can tell you the "
"reason for the last reboot of the system.  The GETSUPPORT ioctl is available "
"to ask what the device can do::"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:161
msgid "the fields returned in the ident struct are:"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:164
msgid "identity"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:164
msgid "a string identifying the watchdog driver"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:165
msgid "firmware_version"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:165
msgid "the firmware version of the card if available"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:166
msgid "options"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:166
msgid "a flags describing what the device supports"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:169
msgid ""
"the options field can have the following bits set, and describes what kind "
"of information that the GET_STATUS and GET_BOOT_STATUS ioctls can return."
msgstr ""

#: ../../../watchdog/watchdog-api.rst:174
msgid "WDIOF_OVERHEAT"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:174
msgid "Reset due to CPU overheat"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:177
msgid ""
"The machine was last rebooted by the watchdog because the thermal limit was "
"exceeded:"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:181
msgid "WDIOF_FANFAULT"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:181
msgid "Fan failed"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:184
msgid "A system fan monitored by the watchdog card has failed"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:187
msgid "WDIOF_EXTERN1"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:187
msgid "External relay 1"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:190
msgid ""
"External monitoring relay/source 1 was triggered. Controllers intended for "
"real world applications include external monitoring pins that will trigger a "
"reset."
msgstr ""

#: ../../../watchdog/watchdog-api.rst:195
msgid "WDIOF_EXTERN2"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:195
msgid "External relay 2"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:198
msgid "External monitoring relay/source 2 was triggered"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:201
msgid "WDIOF_POWERUNDER"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:201
msgid "Power bad/power fault"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:204
msgid "The machine is showing an undervoltage status"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:207
msgid "WDIOF_CARDRESET"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:207
msgid "Card previously reset the CPU"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:210
msgid "The last reboot was caused by the watchdog card"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:213
msgid "WDIOF_POWEROVER"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:213
msgid "Power over voltage"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:216
msgid ""
"The machine is showing an overvoltage status. Note that if one level is "
"under and one over both bits will be set - this may seem odd but makes sense."
msgstr ""

#: ../../../watchdog/watchdog-api.rst:221
msgid "WDIOF_KEEPALIVEPING"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:221
msgid "Keep alive ping reply"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:224
msgid "The watchdog saw a keepalive ping since it was last queried."
msgstr ""

#: ../../../watchdog/watchdog-api.rst:227
msgid "WDIOF_SETTIMEOUT"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:227
msgid "Can set/get the timeout"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:230
msgid "The watchdog can do pretimeouts."
msgstr ""

#: ../../../watchdog/watchdog-api.rst:233
msgid "WDIOF_PRETIMEOUT"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:233
msgid "Pretimeout (in seconds), get/set"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:237
msgid ""
"For those drivers that return any bits set in the option field, the "
"GETSTATUS and GETBOOTSTATUS ioctls can be used to ask for the current "
"status, and the status at the last reboot, respectively::"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:248
msgid ""
"Note that not all devices support these two calls, and some only support the "
"GETBOOTSTATUS call."
msgstr ""

#: ../../../watchdog/watchdog-api.rst:251
msgid ""
"Some drivers can measure the temperature using the GETTEMP ioctl.  The "
"returned value is the temperature in degrees Fahrenheit::"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:257
msgid ""
"Finally the SETOPTIONS ioctl can be used to control some aspects of the "
"cards operation::"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:263
msgid "The following options are available:"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:266
msgid "WDIOS_DISABLECARD"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:266
msgid "Turn off the watchdog timer"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:267
msgid "WDIOS_ENABLECARD"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:267
msgid "Turn on the watchdog timer"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:268
msgid "WDIOS_TEMPPANIC"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:268
msgid "Kernel panic on temperature trip"
msgstr ""

#: ../../../watchdog/watchdog-api.rst:271
msgid "[FIXME -- better explanations]"
msgstr ""
