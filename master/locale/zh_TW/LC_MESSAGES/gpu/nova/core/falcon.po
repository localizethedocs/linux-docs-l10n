# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../gpu/nova/core/falcon.rst:5
msgid "Falcon (FAst Logic Controller)"
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:6
msgid ""
"The following sections describe the Falcon core and the ucode running on it. "
"The descriptions are based on the Ampere GPU or earlier designs; however, "
"they should mostly apply to future designs as well, but everything is "
"subject to change. The overview provided here is mainly tailored towards "
"understanding the interactions of nova-core driver with the Falcon."
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:12
msgid ""
"NVIDIA GPUs embed small RISC-like microcontrollers called Falcon cores, "
"which handle secure firmware tasks, initialization, and power management. "
"Modern NVIDIA GPUs may have multiple such Falcon instances (e.g., GSP (the "
"GPU system processor) and SEC2 (the security engine)) and also may integrate "
"a RISC-V core. This core is capable of running both RISC-V and Falcon code."
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:18
msgid ""
"The code running on the Falcon cores is also called 'ucode', and will be "
"referred to as such in the following sections."
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:21
msgid ""
"Falcons have separate instruction and data memories (IMEM/DMEM) and provide "
"a small DMA engine (via the FBIF - \"Frame Buffer Interface\") to load code "
"from system memory. The nova-core driver must reset and configure the "
"Falcon, load its firmware via DMA, and start its CPU."
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:27
msgid "Falcon security levels"
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:28
msgid ""
"Falcons can run in Non-secure (NS), Light Secure (LS), or Heavy Secure (HS) "
"modes."
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:32
msgid "Heavy Secured (HS) also known as Privilege Level 3 (PL3)"
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:33
msgid ""
"HS ucode is the most trusted code and has access to pretty much everything "
"on the chip. The HS binary includes a signature in it which is verified at "
"boot. This signature verification is done by the hardware itself, thus "
"establishing a root of trust. For example, the FWSEC-FRTS command (see fwsec."
"rst) runs on the GSP in HS mode. FRTS, which involves setting up and loading "
"content into the WPR (Write Protect Region), has to be done by the HS ucode "
"and cannot be done by the host CPU or LS ucode."
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:42
msgid "Light Secured (LS or PL2) and Non Secured (NS or PL0)"
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:43
msgid ""
"These modes are less secure than HS. Like HS, the LS or NS ucode binary also "
"typically includes a signature in it. To load firmware in LS or NS mode onto "
"a Falcon, another Falcon needs to be running in HS mode, which also "
"establishes the root of trust. For example, in the case of an Ampere GPU, "
"the CPU runs the \"Booter\" ucode in HS mode on the SEC2 Falcon, which then "
"authenticates and runs the run-time GSP binary (GSP-RM) in LS mode on the "
"GSP Falcon. Similarly, as an example, after reset on an Ampere, FWSEC runs "
"on the GSP which then loads the devinit engine onto the PMU in LS mode."
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:53
msgid "Root of trust establishment"
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:54
msgid ""
"To establish a root of trust, the code running on a Falcon must be immutable "
"and hardwired into a read-only memory (ROM). This follows industry norms for "
"verification of firmware. This code is called the Boot ROM (BROM). The nova-"
"core driver on the CPU communicates with Falcon's Boot ROM through various "
"Falcon registers prefixed with \"BROM\" (see regs.rs)."
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:60
msgid ""
"After nova-core driver reads the necessary ucode from VBIOS, it programs the "
"BROM and DMA registers to trigger the Falcon to load the HS ucode from the "
"system memory into the Falcon's IMEM/DMEM. Once the HS ucode is loaded, it "
"is verified by the Falcon's Boot ROM."
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:65
msgid ""
"Once the verified HS code is running on a Falcon, it can verify and load "
"other LS/NS ucode binaries onto other Falcons and start them. The process of "
"signature verification is the same as HS; just in this case, the hardware "
"(BROM) doesn't compute the signature, but the HS ucode does."
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:70
msgid "The root of trust is therefore established as follows:"
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:71
msgid "Hardware (Boot ROM running on the Falcon) -> HS ucode -> LS/NS ucode."
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:73
msgid "On an Ampere GPU, for example, the boot verification flow is:"
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:74
msgid "Hardware (Boot ROM running on the SEC2) ->"
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:75
msgid "HS ucode (Booter running on the SEC2) ->"
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:76
msgid "LS ucode (GSP-RM running on the GSP)"
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:79
msgid ""
"While the CPU can load HS ucode onto a Falcon microcontroller and have it "
"verified by the hardware and run, the CPU itself typically does not load LS "
"or NS ucode and run it. Loading of LS or NS ucode is done mainly by the HS "
"ucode. For example, on an Ampere GPU, after the Booter ucode runs on the "
"SEC2 in HS mode and loads the GSP-RM binary onto the GSP, it needs to run "
"the \"SEC2-RTOS\" ucode at runtime. This presents a problem: there is no "
"component to load the SEC2-RTOS ucode onto the SEC2. The CPU cannot load LS "
"code, and GSP-RM must run in LS mode. To overcome this, the GSP is "
"temporarily made to run HS ucode (which is itself loaded by the CPU via the "
"nova-core driver using a \"GSP-provided sequencer\") which then loads the "
"SEC2-RTOS ucode onto the SEC2 in LS mode. The GSP then resumes running its "
"own GSP-RM LS ucode."
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:93
msgid "Falcon memory subsystem and DMA engine"
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:94
msgid ""
"Falcons have separate instruction and data memories (IMEM/DMEM) and contains "
"a small DMA engine called FBDMA (Framebuffer DMA) which does DMA transfers "
"to/from the IMEM/DMEM memory inside the Falcon via the FBIF (Framebuffer "
"Interface), to external memory."
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:99
msgid ""
"DMA transfers are possible from the Falcon's memory to both the system "
"memory and the framebuffer memory (VRAM)."
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:102
msgid ""
"To perform a DMA via the FBDMA, the FBIF is configured to decide how the "
"memory is accessed (also known as aperture type). In the nova-core driver, "
"this is determined by the `FalconFbifTarget` enum."
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:106
msgid ""
"The IO-PMP block (Input/Output Physical Memory Protection) unit in the "
"Falcon controls access by the FBDMA to the external memory."
msgstr ""

#: ../../../gpu/nova/core/falcon.rst:109
msgid ""
"Conceptual diagram (not exact) of the Falcon and its memory subsystem is as "
"follows::"
msgstr ""
