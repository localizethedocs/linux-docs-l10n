# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-20 11:24+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../gpu/xe/xe_mm.rst:5
msgid "Memory Management"
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:13
msgid "TTM manages (placement, eviction, etc...) all BOs in XE."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:18
msgid ""
"Create a chunk of memory which can be used by the GPU. Placement rules "
"(sysmem or vram region) passed in upon creation. TTM handles placement of BO "
"and can trigger eviction of other BOs to make space for the new BO."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:25
msgid ""
"A kernel BO is created as part of driver load (e.g. uC firmware images, GuC "
"ADS, etc...) or a BO created as part of a user operation which requires a "
"kernel BO (e.g. engine state, memory for page tables, etc...). These BOs are "
"typically mapped in the GGTT (any kernel BOs aside memory for page tables "
"are in the GGTT), are pinned (can't move or be evicted at runtime), have a "
"vmap (XE can access the memory via xe_map layer) and have contiguous "
"physical memory."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:33
msgid "More details of why kernel BOs are pinned and contiguous below."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:38
msgid ""
"A user BO is created via the DRM_IOCTL_XE_GEM_CREATE IOCTL. Once it is "
"created the BO can be mmap'd (via DRM_IOCTL_XE_GEM_MMAP_OFFSET) for user "
"access and it can be bound for GPU access (via DRM_IOCTL_XE_VM_BIND). All "
"user BOs are evictable and user BOs are never pinned by XE. The allocation "
"of the backing store can be deferred from creation time until first use "
"which is either mmap, bind, or pagefault."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:48
msgid ""
"A private BO is a user BO created with a valid VM argument passed into the "
"create IOCTL. If a BO is private it cannot be exported via prime FD and "
"mappings can only be created for the BO within the VM it is tied to. Lastly, "
"the BO dma-resv slots / lock point to the VM's dma-resv slots / lock (all "
"private BOs to a VM share common dma-resv slots / lock)."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:57
msgid ""
"An external BO is a user BO created with a NULL VM argument passed into the "
"create IOCTL. An external BO can be shared with different UMDs / devices via "
"prime FD and the BO can be mapped into multiple VMs. An external BO has its "
"own unique dma-resv slots / lock. An external BO will be in an array of all "
"VMs which has a mapping of the BO. This allows VMs to lookup and lock all "
"external BOs mapped in the VM as needed."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:67
msgid ""
"When a user BO is created, a mask of valid placements is passed indicating "
"which memory regions are considered valid."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:70
msgid ""
"The memory region information is available via query uAPI (TODO: add link)."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:75
msgid ""
"BO validation (ttm_bo_validate) refers to ensuring a BO has a valid "
"placement. If a BO was swapped to temporary storage, a validation call will "
"trigger a move back to a valid (location where GPU can access BO) placement. "
"Validation of a BO may evict other BOs to make room for the BO being "
"validated."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:84
msgid ""
"All eviction (or in other words, moving a BO from one memory location to "
"another) is routed through TTM with a callback into XE."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:90
msgid ""
"Runtime evictions refers to during normal operations where TTM decides it "
"needs to move a BO. Typically this is because TTM needs to make room for "
"another BO and the evicted BO is first BO on LRU list that is not locked."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:94
msgid ""
"An example of this is a new BO which can only be placed in VRAM but there is "
"not space in VRAM. There could be multiple BOs which have sysmem and VRAM "
"placement rules which currently reside in VRAM, TTM trigger a will move of "
"one (or multiple) of these BO(s) until there is room in VRAM to place the "
"new BO. The evicted BO(s) are valid but still need new bindings before the "
"BO used again (exec or compute mode rebind worker)."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:101
msgid ""
"Another example would be, TTM can't find a BO to evict which has another "
"valid placement. In this case TTM will evict one (or multiple) unlocked "
"BO(s) to a temporary unreachable (invalid) placement. The evicted BO(s) are "
"invalid and before next use need to be moved to a valid placement and "
"rebound."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:106
msgid ""
"In both cases, moves of these BOs are scheduled behind the fences in the "
"BO's dma-resv slots."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:109
msgid ""
"WW locking tries to ensures if 2 VMs use 51% of the memory forward progress "
"is made on both VMs."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:112
msgid ""
"Runtime eviction uses per a GT migration engine (TODO: link to migration "
"engine doc) to do a GPU memcpy from one location to another."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:118
msgid ""
"When BOs are moved, every mapping (VMA) of the BO needs to rebound before "
"the BO is used again. Every VMA is added to an evicted list of its VM when "
"the BO is moved. This is safe because of the VM locking structure (TODO: "
"link to VM locking doc). On the next use of a VM (exec or compute mode "
"rebind worker) the evicted VMA list is checked and rebinds are triggered. In "
"the case of faulting VM, the rebind is done in the page fault handler."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:128
msgid ""
"During device suspend / resume VRAM may lose power which means the contents "
"of VRAM's memory is blown away. Thus BOs present in VRAM at the time of "
"suspend must be moved to sysmem in order for their contents to be saved."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:132
msgid ""
"A simple TTM call (ttm_resource_manager_evict_all) can move all non-pinned "
"(user) BOs to sysmem. External BOs that are pinned need to be manually "
"evicted with a simple loop + xe_bo_evict call. It gets a little trickier "
"with kernel BOs."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:137
msgid ""
"Some kernel BOs are used by the GT migration engine to do moves, thus we "
"can't move all of the BOs via the GT migration engine. For simplity, use a "
"TTM memcpy (CPU) to move any kernel (pinned) BO on either suspend or resume."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:141
msgid ""
"Some kernel BOs need to be restored to the exact same physical location. TTM "
"makes this rather easy but the caveat is the memory must be contiguous. "
"Again for simplity, we enforce that all kernel (pinned) BOs are contiguous "
"and restored to the same physical location."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:146
msgid "Pinned external BOs in VRAM are restored on resume via the GPU."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:151
msgid ""
"Most kernel BOs have GGTT mappings which must be restored during the resume "
"process. All user BOs are rebound after validation on their next use."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:157
msgid ""
"Trim the list of BOs which is saved / restored via TTM memcpy on suspend / "
"resume. All we really need to save / restore via TTM memcpy is the memory "
"required for the GuC to load and the memory for the GT migrate engine to "
"operate."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:162
msgid ""
"Do not require kernel BOs to be contiguous in physical memory / restored to "
"the same physical address on resume. In all likelihood the only memory that "
"needs to be restored to the same physical address is memory used for page "
"tables. All of that memory is allocated 1 page at time so the contiguous "
"requirement isn't needed. Some work on the vmap code would need to be done "
"if kernel BOs are not contiguous too."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:169
msgid ""
"Make some kernel BO evictable rather than pinned. An example of this would "
"be engine state, in all likelihood if the dma-slots of these BOs where "
"properly used rather than pinning we could safely evict + rebind these BOs "
"as needed."
msgstr ""

#: ../../../gpu/xe/xe_mm:7: drivers/gpu/drm/xe/xe_bo_doc.h:173
msgid ""
"Some kernel BOs do not need to be restored on resume (e.g. GuC ADS as that "
"is repopulated on resume), add flag to mark such objects as no save / "
"restore."
msgstr ""

#: ../../../gpu/xe/xe_mm.rst:11
msgid "GGTT"
msgstr ""

#: ../../../gpu/xe/xe_mm:13: drivers/gpu/drm/xe/xe_ggtt.c:38
msgid ""
"Xe GGTT implements the support for a Global Virtual Address space that is "
"used for resources that are accessible to privileged (i.e. kernel-mode) "
"processes, and not tied to a specific user-level process. For example, the "
"Graphics micro-Controller (GuC) and Display Engine (if present) utilize this "
"Global address space."
msgstr ""

#: ../../../gpu/xe/xe_mm:13: drivers/gpu/drm/xe/xe_ggtt.c:44
msgid ""
"The Global GTT (GGTT) translates from the Global virtual address to a "
"physical address that can be accessed by HW. The GGTT is a flat, single-"
"level table."
msgstr ""

#: ../../../gpu/xe/xe_mm:13: drivers/gpu/drm/xe/xe_ggtt.c:47
msgid ""
"Xe implements a simplified version of the GGTT specifically managing only a "
"certain range of it that goes from the Write Once Protected Content Memory "
"(WOPCM) Layout to a predefined GUC_GGTT_TOP. This approach avoids "
"complications related to the GuC (Graphics Microcontroller) hardware "
"limitations. The GuC address space is limited on both ends of the GGTT, "
"because the GuC shim HW redirects accesses to those addresses to other HW "
"areas instead of going through the GGTT. On the bottom end, the GuC can't "
"access offsets below the WOPCM size, while on the top side the limit is "
"fixed at GUC_GGTT_TOP. To keep things simple, instead of checking each "
"object to see if they are accessed by GuC or not, we just exclude those "
"areas from the allocator. Additionally, to simplify the driver load, we use "
"the maximum WOPCM size in this logic instead of the programmed one, so we "
"don't need to wait until the actual size to be programmed is determined "
"(which requires FW fetch) before initializing the GGTT. These "
"simplifications might waste space in the GGTT (about 20-25 MBs depending on "
"the platform) but we can live with this. Another benefit of this is the GuC "
"bootrom can't access anything below the WOPCM max size so anything the "
"bootrom needs to access (e.g. a RSA key) needs to be placed in the GGTT "
"above the WOPCM max size. Starting the GGTT allocations above the WOPCM max "
"give us the correct placement for free."
msgstr ""

#: ../../../gpu/xe/xe_mm.rst:17
msgid "GGTT Internal API"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:17
msgid "Main GGTT struct"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:21
#: drivers/gpu/drm/xe/xe_ggtt_types.h:59 drivers/gpu/drm/xe/xe_ggtt_types.h:77
msgid "**Definition**::"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:37
#: drivers/gpu/drm/xe/xe_ggtt_types.h:68 drivers/gpu/drm/xe/xe_ggtt_types.h:84
msgid "**Members**"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:23
msgid "``tile``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:24
msgid "Back pointer to tile where this GGTT belongs"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:25
msgid "``size``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:26
msgid "Total size of this GGTT"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:30
msgid "``flags``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:31
msgid ""
"Flags for this GGTT Acceptable flags: - ``XE_GGTT_FLAGS_64K`` - if PTE size "
"is 64K. Otherwise, regular is 4K."
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:35
msgid "``scratch``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:36
msgid "Internal object allocation used as a scratch page"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:37
msgid "``lock``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:38
msgid "Mutex lock to protect GGTT data"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:40
msgid "``gsm``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:41
msgid ""
"The iomem pointer to the actual location of the translation table located in "
"the GSM for easy PTE manipulation"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:44
msgid "``pt_ops``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:45
msgid "Page Table operations per platform"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:46
msgid "``mm``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:47
msgid "The memory manager used to manage individual GGTT allocations"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:48
msgid "``access_count``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:49
msgid "counts GGTT writes"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:50
msgid "``wq``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:51
msgid "Dedicated unordered work queue to process node removals"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:54
#: drivers/gpu/drm/xe/xe_ggtt_types.h:72 ../../../gpu/xe/xe_mm:22:
#: drivers/gpu/drm/xe/xe_ggtt.c:166 drivers/gpu/drm/xe/xe_ggtt.c:253
#: drivers/gpu/drm/xe/xe_ggtt.c:481 drivers/gpu/drm/xe/xe_ggtt.c:515
#: drivers/gpu/drm/xe/xe_ggtt.c:545 drivers/gpu/drm/xe/xe_ggtt.c:587
#: drivers/gpu/drm/xe/xe_ggtt.c:605 drivers/gpu/drm/xe/xe_ggtt.c:628
#: drivers/gpu/drm/xe/xe_ggtt.c:654 drivers/gpu/drm/xe/xe_ggtt.c:721
#: drivers/gpu/drm/xe/xe_ggtt.c:900 drivers/gpu/drm/xe/xe_ggtt.c:938
#: drivers/gpu/drm/xe/xe_ggtt.c:978 drivers/gpu/drm/xe/xe_ggtt.c:992
msgid "**Description**"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:18
msgid ""
"In general, each tile can contains its own Global Graphics Translation Table "
"(GGTT) instance."
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:55
msgid "A node in GGTT."
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:62
msgid "``ggtt``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:63
msgid "Back pointer to xe_ggtt where this region will be inserted at"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:64
msgid "``base``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:65
msgid "A drm_mm_node"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:66
msgid "``delayed_removal_work``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:67
msgid "The work struct for the delayed removal"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:68
msgid "``invalidate_on_remove``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:69
msgid "If it needs invalidation upon removal"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:56
msgid ""
"This struct needs to be initialized (only-once) with xe_ggtt_node_init() "
"before any node insertion, reservation, or 'ballooning'. It will, then, be "
"finalized by either xe_ggtt_node_remove() or xe_ggtt_node_deballoon()."
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:73
msgid "GGTT Page table operations Which can vary from platform to platform."
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:77
msgid "``pte_encode_flags``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:78
msgid "Encode PTE flags for a given BO"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:79
msgid "``ggtt_set_pte``"
msgstr ""

#: ../../../gpu/xe/xe_mm:19: drivers/gpu/drm/xe/xe_ggtt_types.h:80
msgid "Directly write into GGTT's PTE"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:163
msgid "Allocate a GGTT for a given :c:type:`xe_tile`"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:167
#: drivers/gpu/drm/xe/xe_ggtt.c:254 drivers/gpu/drm/xe/xe_ggtt.c:375
#: drivers/gpu/drm/xe/xe_ggtt.c:401 drivers/gpu/drm/xe/xe_ggtt.c:480
#: drivers/gpu/drm/xe/xe_ggtt.c:516 drivers/gpu/drm/xe/xe_ggtt.c:545
#: drivers/gpu/drm/xe/xe_ggtt.c:585 drivers/gpu/drm/xe/xe_ggtt.c:604
#: drivers/gpu/drm/xe/xe_ggtt.c:629 drivers/gpu/drm/xe/xe_ggtt.c:655
#: drivers/gpu/drm/xe/xe_ggtt.c:668 drivers/gpu/drm/xe/xe_ggtt.c:682
#: drivers/gpu/drm/xe/xe_ggtt.c:721 drivers/gpu/drm/xe/xe_ggtt.c:790
#: drivers/gpu/drm/xe/xe_ggtt.c:806 drivers/gpu/drm/xe/xe_ggtt.c:820
#: drivers/gpu/drm/xe/xe_ggtt.c:839 drivers/gpu/drm/xe/xe_ggtt.c:900
#: drivers/gpu/drm/xe/xe_ggtt.c:917 drivers/gpu/drm/xe/xe_ggtt.c:937
#: drivers/gpu/drm/xe/xe_ggtt.c:977 drivers/gpu/drm/xe/xe_ggtt.c:992
msgid "**Parameters**"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:169
msgid "``struct xe_tile *tile``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:164
msgid ":c:type:`xe_tile`"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:165
msgid "Allocates a :c:type:`xe_ggtt` for a given tile."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:167
#: drivers/gpu/drm/xe/xe_ggtt.c:257 drivers/gpu/drm/xe/xe_ggtt.c:400
#: drivers/gpu/drm/xe/xe_ggtt.c:483 drivers/gpu/drm/xe/xe_ggtt.c:589
#: drivers/gpu/drm/xe/xe_ggtt.c:606 drivers/gpu/drm/xe/xe_ggtt.c:634
#: drivers/gpu/drm/xe/xe_ggtt.c:667 drivers/gpu/drm/xe/xe_ggtt.c:793
#: drivers/gpu/drm/xe/xe_ggtt.c:807 drivers/gpu/drm/xe/xe_ggtt.c:840
#: drivers/gpu/drm/xe/xe_ggtt.c:917 drivers/gpu/drm/xe/xe_ggtt.c:939
msgid "**Return**"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:168
msgid ":c:type:`xe_ggtt` on success, or NULL when out of memory."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:250
msgid "Early GGTT initialization"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:256
#: drivers/gpu/drm/xe/xe_ggtt.c:403 drivers/gpu/drm/xe/xe_ggtt.c:547
#: drivers/gpu/drm/xe/xe_ggtt.c:631 drivers/gpu/drm/xe/xe_ggtt.c:684
#: drivers/gpu/drm/xe/xe_ggtt.c:723 drivers/gpu/drm/xe/xe_ggtt.c:792
#: drivers/gpu/drm/xe/xe_ggtt.c:808 drivers/gpu/drm/xe/xe_ggtt.c:822
#: drivers/gpu/drm/xe/xe_ggtt.c:841 drivers/gpu/drm/xe/xe_ggtt.c:919
#: drivers/gpu/drm/xe/xe_ggtt.c:939 drivers/gpu/drm/xe/xe_ggtt.c:979
#: drivers/gpu/drm/xe/xe_ggtt.c:994
msgid "``struct xe_ggtt *ggtt``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:251
#: drivers/gpu/drm/xe/xe_ggtt.c:398
msgid "the :c:type:`xe_ggtt` to be initialized"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:252
msgid ""
"It allows to create new mappings usable by the GuC. Mappings are not usable "
"by the HW engines, as it doesn't have scratch nor initial clear done to it "
"yet. That will happen in the regular, non-early GGTT initialization."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:258
#: drivers/gpu/drm/xe/xe_ggtt.c:400 drivers/gpu/drm/xe/xe_ggtt.c:484
#: drivers/gpu/drm/xe/xe_ggtt.c:590 drivers/gpu/drm/xe/xe_ggtt.c:607
#: drivers/gpu/drm/xe/xe_ggtt.c:793 drivers/gpu/drm/xe/xe_ggtt.c:807
#: drivers/gpu/drm/xe/xe_ggtt.c:917
msgid "0 on success or a negative error code on failure."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:371
msgid "Remove a :c:type:`xe_ggtt_node` from the GGTT"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:377
#: drivers/gpu/drm/xe/xe_ggtt.c:482 drivers/gpu/drm/xe/xe_ggtt.c:518
#: drivers/gpu/drm/xe/xe_ggtt.c:587 drivers/gpu/drm/xe/xe_ggtt.c:606
#: drivers/gpu/drm/xe/xe_ggtt.c:657 drivers/gpu/drm/xe/xe_ggtt.c:681
msgid "``struct xe_ggtt_node *node``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:372
msgid "the :c:type:`xe_ggtt_node` to be removed"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:374
msgid "``bool invalidate``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:373
msgid "if node needs invalidation upon removal"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:397
msgid "Regular non-early GGTT initialization"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:476
msgid "prevent allocation of specified GGTT addresses"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:477
msgid "the :c:type:`xe_ggtt_node` to hold reserved GGTT node"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:479
#: drivers/gpu/drm/xe/xe_ggtt.c:790
msgid "``u64 start``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:478
msgid "the starting GGTT address of the reserved region"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:480
#: drivers/gpu/drm/xe/xe_ggtt.c:791
msgid "``u64 end``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:479
msgid "then end GGTT address of the reserved region"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:480
msgid ""
"To be used in cases where ggtt->lock is already taken. Use "
"xe_ggtt_node_remove_balloon_locked() to release a reserved GGTT node."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:512
msgid "release a reserved GGTT region"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:513
msgid "the :c:type:`xe_ggtt_node` with reserved GGTT region"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:514
msgid ""
"To be used in cases where ggtt->lock is already taken. See "
"xe_ggtt_node_insert_balloon_locked() for details."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:541
msgid "Shift GGTT nodes to adjust for a change in usable address range."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:542
msgid "the :c:type:`xe_ggtt` struct instance"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:544
msgid "``s64 shift``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:543
msgid "change to the location of area provisioned for current VF"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:544
msgid ""
"This function moves all nodes from the GGTT VM, to a temp list. These nodes "
"are expected to represent allocations in range formerly assigned to current "
"VF, before the range changed. When the GGTT VM is completely clear of any "
"nodes, they are re-added with shifted offsets."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:548
msgid ""
"The function has no ability of failing - because it shifts existing nodes, "
"without any additional processing. If the nodes were successfully existing "
"at the old address, they will do the same at the new one. A fail inside this "
"function would indicate that the list of nodes was either already damaged, "
"or that the shift brings the address range outside of valid bounds. Both "
"cases justify an assert rather than error code."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:581
msgid "Locked version to insert a :c:type:`xe_ggtt_node` into the GGTT"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:582
#: drivers/gpu/drm/xe/xe_ggtt.c:601
msgid "the :c:type:`xe_ggtt_node` to be inserted"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:584
#: drivers/gpu/drm/xe/xe_ggtt.c:603
msgid "``u32 size``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:583
#: drivers/gpu/drm/xe/xe_ggtt.c:602
msgid "size of the node"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:585
#: drivers/gpu/drm/xe/xe_ggtt.c:604
msgid "``u32 align``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:584
#: drivers/gpu/drm/xe/xe_ggtt.c:603
msgid "alignment constrain of the node"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:586
msgid "``u32 mm_flags``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:585
msgid "flags to control the node behavior"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:586
msgid ""
"It cannot be called without first having called xe_ggtt_init() once. To be "
"used in cases where ggtt->lock is already taken."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:600
msgid "Insert a :c:type:`xe_ggtt_node` into the GGTT"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:604
msgid "It cannot be called without first having called xe_ggtt_init() once."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:625
msgid "Initialize ``xe_ggtt_node`` struct"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:626
msgid ""
"the :c:type:`xe_ggtt` where the new node will later be inserted/reserved."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:627
msgid ""
"This function will allocate the struct ``xe_ggtt_node`` and return its "
"pointer. This struct will then be freed after the node removal upon "
"xe_ggtt_node_remove() or xe_ggtt_node_remove_balloon_locked(). Having "
"``xe_ggtt_node`` struct allocated doesn't mean that the node is already "
"allocated in GGTT. Only the xe_ggtt_node_insert(), "
"xe_ggtt_node_insert_locked(), xe_ggtt_node_insert_balloon_locked() will "
"ensure the node is inserted or reserved in GGTT."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:635
msgid "A pointer to ``xe_ggtt_node`` struct on success. An ERR_PTR otherwise."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:651
msgid "Forcebly finalize ``xe_ggtt_node`` struct"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:652
msgid "the :c:type:`xe_ggtt_node` to be freed"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:653
msgid ""
"If anything went wrong with either xe_ggtt_node_insert(), "
"xe_ggtt_node_insert_locked(), or xe_ggtt_node_insert_balloon_locked(); and "
"this **node** is not going to be reused, then, this function needs to be "
"called to free the ``xe_ggtt_node`` struct"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:664
msgid "Check if node is allocated in GGTT"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:670
#: drivers/gpu/drm/xe/xe_ggtt.c:902
msgid "``const struct xe_ggtt_node *node``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:665
msgid "the :c:type:`xe_ggtt_node` to be inspected"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:667
msgid "True if allocated, False otherwise."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:678
msgid "Map the BO into GGTT"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:679
#: drivers/gpu/drm/xe/xe_ggtt.c:718
msgid "the :c:type:`xe_ggtt` where node will be mapped"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:680
msgid "the :c:type:`xe_ggtt_node` where this BO is mapped"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:682
#: drivers/gpu/drm/xe/xe_ggtt.c:720 drivers/gpu/drm/xe/xe_ggtt.c:789
#: drivers/gpu/drm/xe/xe_ggtt.c:805 drivers/gpu/drm/xe/xe_ggtt.c:819
#: drivers/gpu/drm/xe/xe_ggtt.c:976
msgid "``struct xe_bo *bo``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:681
#: drivers/gpu/drm/xe/xe_ggtt.c:719
msgid "the :c:type:`xe_bo` to be mapped"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:683
#: drivers/gpu/drm/xe/xe_ggtt.c:977
msgid "``u16 pat_index``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:682
msgid "Which pat_index to use."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:717
msgid "Restore a mapping of a BO into GGTT"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:720
msgid "This is used to restore a GGTT mapping after suspend."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:786
msgid "Insert BO at a specific GGTT space"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:787
#: drivers/gpu/drm/xe/xe_ggtt.c:803
msgid "the :c:type:`xe_ggtt` where bo will be inserted"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:788
#: drivers/gpu/drm/xe/xe_ggtt.c:804
msgid "the :c:type:`xe_bo` to be inserted"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:789
msgid "address where it will be inserted"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:790
msgid "end of the range where it will be inserted"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:792
#: drivers/gpu/drm/xe/xe_ggtt.c:806
msgid "``struct drm_exec *exec``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:791
#: drivers/gpu/drm/xe/xe_ggtt.c:805
msgid "The drm_exec transaction to use for exhaustive eviction."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:802
msgid "Insert BO into GGTT"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:816
msgid "Remove a BO from the GGTT"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:817
msgid "the :c:type:`xe_ggtt` where node will be removed"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:818
msgid "the :c:type:`xe_bo` to be removed"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:835
msgid "Largest GGTT hole"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:836
msgid "the :c:type:`xe_ggtt` that will be inspected"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:838
#: drivers/gpu/drm/xe/xe_ggtt.c:936
msgid "``u64 alignment``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:837
msgid "minimum alignment"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:839
msgid "``u64 *spare``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:838
msgid ""
"If not NULL: in: desired memory size to be spared / out: Adjusted possible "
"spare"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:840
msgid "size of the largest continuous GGTT region"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:896
msgid "assign a GGTT region to the VF"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:897
msgid "the :c:type:`xe_ggtt_node` to update"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:899
msgid "``u16 vfid``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:898
msgid "the VF identifier"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:899
msgid ""
"This function is used by the PF driver to assign a GGTT region to the VF. In "
"addition to PTE's VFID bits 11:2 also PRESENT bit 0 is set as on some "
"platforms VFs can't modify that either."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:913
msgid "Dump GGTT for debug"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:914
msgid "the :c:type:`xe_ggtt` to be dumped"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:916
#: drivers/gpu/drm/xe/xe_ggtt.c:937
msgid "``struct drm_printer *p``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:915
msgid ""
"the :c:type:`drm_mm_printer` helper handle to be used to dump the information"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:933
msgid "Print holes"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:934
msgid "the :c:type:`xe_ggtt` to be inspected"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:935
msgid "min alignment"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:936
msgid "the :c:type:`drm_printer`"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:937
msgid "Print GGTT ranges that are available and return total size available."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:940
msgid "Total available size."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:973
msgid "Get PTE encoding flags for BO"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:974
#: drivers/gpu/drm/xe/xe_ggtt.c:989
msgid ":c:type:`xe_ggtt`"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:975
msgid ":c:type:`xe_bo`"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:976
msgid "The pat_index for the PTE."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:977
msgid ""
"This function returns the pte_flags for a given BO, without  address. It's "
"used for DPT to fill a GGTT mapped BO with a linear lookup table."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:988
msgid "Read a PTE from the GGTT"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:991
msgid "``u64 offset``"
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:990
msgid "the offset for which the mapping should be read."
msgstr ""

#: ../../../gpu/xe/xe_mm:22: drivers/gpu/drm/xe/xe_ggtt.c:991
msgid "Used by testcases, and by display reading out an inherited bios FB."
msgstr ""

#: ../../../gpu/xe/xe_mm.rst:26
msgid "Pagetable building"
msgstr ""

#: ../../../gpu/xe/xe_mm:28: drivers/gpu/drm/xe/xe_pt.c:244
msgid ""
"Below we use the term \"page-table\" for both page-directories, containing "
"pointers to lower level page-directories or page-tables, and level 0 page-"
"tables that contain only page-table-entries pointing to memory pages."
msgstr ""

#: ../../../gpu/xe/xe_mm:28: drivers/gpu/drm/xe/xe_pt.c:248
msgid ""
"When inserting an address range in an already existing page-table tree there "
"will typically be a set of page-tables that are shared with other address "
"ranges, and a set that are private to this address range. The set of shared "
"page-tables can be at most two per level, and those can't be updated "
"immediately because the entries of those page-tables may still be in use by "
"the gpu for other mappings. Therefore when inserting entries into those, we "
"instead stage those insertions by adding insertion data into struct "
"xe_vm_pgtable_update structures. This data, (subtrees for the cpu and page-"
"table-entries for the gpu) is then added in a separate commit step. CPU-data "
"is committed while still under the vm lock, the object lock and for userptr, "
"the notifier lock in read mode. The GPU async data is committed either by "
"the GPU or CPU after fulfilling relevant dependencies. For non-shared page-"
"tables (and, in fact, for shared ones that aren't existing at the time of "
"staging), we add the data in-place without the special update structures. "
"This private part of the page-table tree will remain disconnected from the "
"vm page-table tree until data is committed to the shared page tables of the "
"vm tree in the commit phase."
msgstr ""
