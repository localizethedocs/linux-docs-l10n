# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-10 08:33+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../gpu/driver-uapi.rst:3
msgid "DRM Driver uAPI"
msgstr ""

#: ../../../gpu/driver-uapi.rst:6
msgid "drm/i915 uAPI"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3
msgid "**uevents generated by i915 on its device node**"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:41
msgid ""
"I915_L3_PARITY_UEVENT - Generated when the driver receives a parity mismatch"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:42
msgid ""
"event from the GPU L3 cache. Additional information supplied is ROW, BANK, "
"SUBBANK, SLICE of the affected cacheline. Userspace should keep track of "
"these events, and if a specific cache-line seems to have a persistent error, "
"remap it with the L3 remapping tool supplied in intel-gpu-tools.  The value "
"supplied with the event is always 1."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:48
msgid "I915_ERROR_UEVENT - Generated upon error detection, currently only via"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:49
msgid ""
"hangcheck. The error detection event is a good indicator of when things "
"began to go badly. The value supplied with the event is a 1 upon error "
"detection, and a 0 upon reset completion, signifying no more error exists. "
"NOTE: Disabling hangcheck or reset via module parameter will cause the "
"related events to not be seen."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:55
msgid ""
"I915_RESET_UEVENT - Event is generated just before an attempt to reset the"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:56
msgid ""
"GPU. The value supplied with the event is always 1. NOTE: Disable reset via "
"module parameter will cause this event to not be seen."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:168
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:66
msgid "Base class for defining a chain of extensions"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:228
#: include/uapi/drm/nouveau_drm.h:257 include/uapi/drm/nouveau_drm.h:280
#: include/uapi/drm/nouveau_drm.h:340 include/uapi/drm/nouveau_drm.h:384
#: include/uapi/drm/nouveau_drm.h:406 ../../../gpu/driver-uapi:24:
#: include/uapi/drm/panthor_drm.h:158 include/uapi/drm/panthor_drm.h:214
#: include/uapi/drm/panthor_drm.h:253 include/uapi/drm/panthor_drm.h:340
#: include/uapi/drm/panthor_drm.h:374 include/uapi/drm/panthor_drm.h:393
#: include/uapi/drm/panthor_drm.h:410 include/uapi/drm/panthor_drm.h:438
#: include/uapi/drm/panthor_drm.h:471 include/uapi/drm/panthor_drm.h:529
#: include/uapi/drm/panthor_drm.h:584 include/uapi/drm/panthor_drm.h:625
#: include/uapi/drm/panthor_drm.h:648 include/uapi/drm/panthor_drm.h:684
#: include/uapi/drm/panthor_drm.h:698 include/uapi/drm/panthor_drm.h:740
#: include/uapi/drm/panthor_drm.h:818 include/uapi/drm/panthor_drm.h:829
#: include/uapi/drm/panthor_drm.h:881 include/uapi/drm/panthor_drm.h:923
#: include/uapi/drm/panthor_drm.h:946 include/uapi/drm/panthor_drm.h:993
#: include/uapi/drm/panthor_drm.h:1008 include/uapi/drm/panthor_drm.h:1026
#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:172
#: include/uapi/drm/xe_drm.h:202 include/uapi/drm/xe_drm.h:225
#: include/uapi/drm/xe_drm.h:259 include/uapi/drm/xe_drm.h:270
#: include/uapi/drm/xe_drm.h:300 include/uapi/drm/xe_drm.h:376
#: include/uapi/drm/xe_drm.h:392 include/uapi/drm/xe_drm.h:436
#: include/uapi/drm/xe_drm.h:495 include/uapi/drm/xe_drm.h:511
#: include/uapi/drm/xe_drm.h:567 include/uapi/drm/xe_drm.h:618
#: include/uapi/drm/xe_drm.h:649 include/uapi/drm/xe_drm.h:682
#: include/uapi/drm/xe_drm.h:769 include/uapi/drm/xe_drm.h:884
#: include/uapi/drm/xe_drm.h:931 include/uapi/drm/xe_drm.h:975
#: include/uapi/drm/xe_drm.h:989 include/uapi/drm/xe_drm.h:1160
#: include/uapi/drm/xe_drm.h:1231 include/uapi/drm/xe_drm.h:1328
#: include/uapi/drm/xe_drm.h:1342 include/uapi/drm/xe_drm.h:1366
#: include/uapi/drm/xe_drm.h:1440 include/uapi/drm/xe_drm.h:1492
#: include/uapi/drm/xe_drm.h:1601 include/uapi/drm/xe_drm.h:1660
#: include/uapi/drm/xe_drm.h:1694 include/uapi/drm/xe_drm.h:1861
#: include/uapi/drm/xe_drm.h:1885 include/uapi/drm/xe_drm.h:1906
#: include/uapi/drm/xe_drm.h:1977 include/uapi/drm/xe_drm.h:2012
#: include/uapi/drm/xe_drm.h:2139 include/uapi/drm/xe_drm.h:2197
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:105
#: include/uapi/drm/asahi_drm.h:223 include/uapi/drm/asahi_drm.h:244
#: include/uapi/drm/asahi_drm.h:276 include/uapi/drm/asahi_drm.h:305
#: include/uapi/drm/asahi_drm.h:327 include/uapi/drm/asahi_drm.h:368
#: include/uapi/drm/asahi_drm.h:406 include/uapi/drm/asahi_drm.h:455
#: include/uapi/drm/asahi_drm.h:558 include/uapi/drm/asahi_drm.h:592
#: include/uapi/drm/asahi_drm.h:615 include/uapi/drm/asahi_drm.h:638
#: include/uapi/drm/asahi_drm.h:696 include/uapi/drm/asahi_drm.h:749
#: include/uapi/drm/asahi_drm.h:812 include/uapi/drm/asahi_drm.h:846
#: include/uapi/drm/asahi_drm.h:868 include/uapi/drm/asahi_drm.h:885
#: include/uapi/drm/asahi_drm.h:918 include/uapi/drm/asahi_drm.h:948
#: include/uapi/drm/asahi_drm.h:1117 include/uapi/drm/asahi_drm.h:1154
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:70
#: include/uapi/drm/i915_drm.h:230 include/uapi/drm/i915_drm.h:822
#: include/uapi/drm/i915_drm.h:1008 include/uapi/drm/i915_drm.h:1064
#: include/uapi/drm/i915_drm.h:1323 include/uapi/drm/i915_drm.h:1351
#: include/uapi/drm/i915_drm.h:1386 include/uapi/drm/i915_drm.h:1648
#: include/uapi/drm/i915_drm.h:1951 include/uapi/drm/i915_drm.h:1992
#: include/uapi/drm/i915_drm.h:2384 include/uapi/drm/i915_drm.h:2599
#: include/uapi/drm/i915_drm.h:2619 include/uapi/drm/i915_drm.h:2699
#: include/uapi/drm/i915_drm.h:2994 include/uapi/drm/i915_drm.h:3056
#: include/uapi/drm/i915_drm.h:3125 include/uapi/drm/i915_drm.h:3166
#: include/uapi/drm/i915_drm.h:3345 include/uapi/drm/i915_drm.h:3375
#: include/uapi/drm/i915_drm.h:3392 include/uapi/drm/i915_drm.h:3468
#: include/uapi/drm/i915_drm.h:3479 include/uapi/drm/i915_drm.h:3571
#: include/uapi/drm/i915_drm.h:3628 include/uapi/drm/i915_drm.h:3652
#: include/uapi/drm/i915_drm.h:3766 include/uapi/drm/i915_drm.h:3836
#: include/uapi/drm/i915_drm.h:3877
msgid "**Definition**::"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:239
#: include/uapi/drm/nouveau_drm.h:264 include/uapi/drm/nouveau_drm.h:295
#: include/uapi/drm/nouveau_drm.h:353 include/uapi/drm/nouveau_drm.h:393
#: include/uapi/drm/nouveau_drm.h:418 ../../../gpu/driver-uapi:24:
#: include/uapi/drm/panthor_drm.h:166 include/uapi/drm/panthor_drm.h:222
#: include/uapi/drm/panthor_drm.h:293 include/uapi/drm/panthor_drm.h:351
#: include/uapi/drm/panthor_drm.h:382 include/uapi/drm/panthor_drm.h:400
#: include/uapi/drm/panthor_drm.h:418 include/uapi/drm/panthor_drm.h:446
#: include/uapi/drm/panthor_drm.h:478 include/uapi/drm/panthor_drm.h:540
#: include/uapi/drm/panthor_drm.h:592 include/uapi/drm/panthor_drm.h:632
#: include/uapi/drm/panthor_drm.h:658 include/uapi/drm/panthor_drm.h:692
#: include/uapi/drm/panthor_drm.h:706 include/uapi/drm/panthor_drm.h:756
#: include/uapi/drm/panthor_drm.h:825 include/uapi/drm/panthor_drm.h:840
#: include/uapi/drm/panthor_drm.h:889 include/uapi/drm/panthor_drm.h:932
#: include/uapi/drm/panthor_drm.h:959 include/uapi/drm/panthor_drm.h:1000
#: include/uapi/drm/panthor_drm.h:1016 include/uapi/drm/panthor_drm.h:1032
#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:180
#: include/uapi/drm/xe_drm.h:212 include/uapi/drm/xe_drm.h:240
#: include/uapi/drm/xe_drm.h:266 include/uapi/drm/xe_drm.h:278
#: include/uapi/drm/xe_drm.h:313 include/uapi/drm/xe_drm.h:384
#: include/uapi/drm/xe_drm.h:408 include/uapi/drm/xe_drm.h:455
#: include/uapi/drm/xe_drm.h:503 include/uapi/drm/xe_drm.h:525
#: include/uapi/drm/xe_drm.h:578 include/uapi/drm/xe_drm.h:633
#: include/uapi/drm/xe_drm.h:656 include/uapi/drm/xe_drm.h:703
#: include/uapi/drm/xe_drm.h:790 include/uapi/drm/xe_drm.h:895
#: include/uapi/drm/xe_drm.h:943 include/uapi/drm/xe_drm.h:983
#: include/uapi/drm/xe_drm.h:1023 include/uapi/drm/xe_drm.h:1178
#: include/uapi/drm/xe_drm.h:1249 include/uapi/drm/xe_drm.h:1336
#: include/uapi/drm/xe_drm.h:1353 include/uapi/drm/xe_drm.h:1384
#: include/uapi/drm/xe_drm.h:1453 include/uapi/drm/xe_drm.h:1515
#: include/uapi/drm/xe_drm.h:1610 include/uapi/drm/xe_drm.h:1678
#: include/uapi/drm/xe_drm.h:1703 include/uapi/drm/xe_drm.h:1870
#: include/uapi/drm/xe_drm.h:1897 include/uapi/drm/xe_drm.h:1914
#: include/uapi/drm/xe_drm.h:1990 include/uapi/drm/xe_drm.h:2052
#: include/uapi/drm/xe_drm.h:2160 include/uapi/drm/xe_drm.h:2210
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:126
#: include/uapi/drm/asahi_drm.h:232 include/uapi/drm/asahi_drm.h:253
#: include/uapi/drm/asahi_drm.h:283 include/uapi/drm/asahi_drm.h:315
#: include/uapi/drm/asahi_drm.h:335 include/uapi/drm/asahi_drm.h:378
#: include/uapi/drm/asahi_drm.h:416 include/uapi/drm/asahi_drm.h:468
#: include/uapi/drm/asahi_drm.h:568 include/uapi/drm/asahi_drm.h:599
#: include/uapi/drm/asahi_drm.h:623 include/uapi/drm/asahi_drm.h:647
#: include/uapi/drm/asahi_drm.h:709 include/uapi/drm/asahi_drm.h:758
#: include/uapi/drm/asahi_drm.h:821 include/uapi/drm/asahi_drm.h:853
#: include/uapi/drm/asahi_drm.h:875 include/uapi/drm/asahi_drm.h:893
#: include/uapi/drm/asahi_drm.h:925 include/uapi/drm/asahi_drm.h:985
#: include/uapi/drm/asahi_drm.h:1129 include/uapi/drm/asahi_drm.h:1161
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:79
#: include/uapi/drm/i915_drm.h:239 include/uapi/drm/i915_drm.h:829
#: include/uapi/drm/i915_drm.h:1023 include/uapi/drm/i915_drm.h:1072
#: include/uapi/drm/i915_drm.h:1333 include/uapi/drm/i915_drm.h:1361
#: include/uapi/drm/i915_drm.h:1430 include/uapi/drm/i915_drm.h:1658
#: include/uapi/drm/i915_drm.h:1964 include/uapi/drm/i915_drm.h:2019
#: include/uapi/drm/i915_drm.h:2397 include/uapi/drm/i915_drm.h:2606
#: include/uapi/drm/i915_drm.h:2627 include/uapi/drm/i915_drm.h:2711
#: include/uapi/drm/i915_drm.h:3006 include/uapi/drm/i915_drm.h:3075
#: include/uapi/drm/i915_drm.h:3133 include/uapi/drm/i915_drm.h:3180
#: include/uapi/drm/i915_drm.h:3360 include/uapi/drm/i915_drm.h:3383
#: include/uapi/drm/i915_drm.h:3404 include/uapi/drm/i915_drm.h:3475
#: include/uapi/drm/i915_drm.h:3495 include/uapi/drm/i915_drm.h:3579
#: include/uapi/drm/i915_drm.h:3637 include/uapi/drm/i915_drm.h:3665
#: include/uapi/drm/i915_drm.h:3775 include/uapi/drm/i915_drm.h:3843
#: include/uapi/drm/i915_drm.h:3885
msgid "**Members**"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:172
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:104
msgid "``next_extension``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:105
msgid "Pointer to the next struct i915_user_extension, or zero if the end."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:179
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:110
msgid "``name``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:180
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:111
msgid "Name of the extension."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:182
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:113
msgid "Note that the name here is just some integer."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:115
msgid ""
"Also note that the name space for this is not global for the whole driver, "
"but rather its scope/meaning is limited to the specific piece of uAPI which "
"has embedded the struct i915_user_extension."
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:231
#: include/uapi/drm/nouveau_drm.h:302 include/uapi/drm/nouveau_drm.h:344
#: include/uapi/drm/nouveau_drm.h:395 ../../../gpu/driver-uapi:24:
#: include/uapi/drm/panthor_drm.h:213 include/uapi/drm/panthor_drm.h:437
#: include/uapi/drm/panthor_drm.h:528 include/uapi/drm/panthor_drm.h:586
#: include/uapi/drm/panthor_drm.h:655 ../../../gpu/driver-uapi:29:
#: include/uapi/drm/xe_drm.h:837 include/uapi/drm/xe_drm.h:916
#: include/uapi/drm/xe_drm.h:960 include/uapi/drm/xe_drm.h:1137
#: include/uapi/drm/xe_drm.h:1304 include/uapi/drm/xe_drm.h:1407
#: include/uapi/drm/xe_drm.h:1534 ../../../gpu/driver-uapi:34:
#: include/uapi/drm/asahi_drm.h:307 include/uapi/drm/asahi_drm.h:330
#: include/uapi/drm/asahi_drm.h:367 include/uapi/drm/asahi_drm.h:458
#: include/uapi/drm/asahi_drm.h:558 include/uapi/drm/asahi_drm.h:719
#: include/uapi/drm/asahi_drm.h:766 include/uapi/drm/asahi_drm.h:973
#: include/uapi/drm/asahi_drm.h:1120 include/uapi/drm/asahi_drm.h:1153
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:120
#: include/uapi/drm/i915_drm.h:1026 include/uapi/drm/i915_drm.h:1332
#: include/uapi/drm/i915_drm.h:1429 include/uapi/drm/i915_drm.h:1954
#: include/uapi/drm/i915_drm.h:2478 include/uapi/drm/i915_drm.h:2639
#: include/uapi/drm/i915_drm.h:2720 include/uapi/drm/i915_drm.h:3091
#: include/uapi/drm/i915_drm.h:3148 include/uapi/drm/i915_drm.h:3169
#: include/uapi/drm/i915_drm.h:3352 include/uapi/drm/i915_drm.h:3428
#: include/uapi/drm/i915_drm.h:3693 include/uapi/drm/i915_drm.h:3868
msgid "``flags``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:938
#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:191
#: include/uapi/drm/xe_drm.h:211 include/uapi/drm/xe_drm.h:251
#: include/uapi/drm/xe_drm.h:276 include/uapi/drm/xe_drm.h:382
#: include/uapi/drm/xe_drm.h:417 include/uapi/drm/xe_drm.h:453
#: include/uapi/drm/xe_drm.h:485 include/uapi/drm/xe_drm.h:501
#: include/uapi/drm/xe_drm.h:626 include/uapi/drm/xe_drm.h:638
#: include/uapi/drm/xe_drm.h:873 include/uapi/drm/xe_drm.h:978
#: include/uapi/drm/xe_drm.h:1093 include/uapi/drm/xe_drm.h:1149
#: include/uapi/drm/xe_drm.h:1197 include/uapi/drm/xe_drm.h:1214
#: include/uapi/drm/xe_drm.h:1331 include/uapi/drm/xe_drm.h:1481
#: include/uapi/drm/xe_drm.h:1538 include/uapi/drm/xe_drm.h:1566
#: include/uapi/drm/xe_drm.h:1680 include/uapi/drm/xe_drm.h:1719
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:226
#: include/uapi/drm/asahi_drm.h:268 include/uapi/drm/asahi_drm.h:279
#: include/uapi/drm/asahi_drm.h:319 include/uapi/drm/asahi_drm.h:419
#: include/uapi/drm/asahi_drm.h:477 include/uapi/drm/asahi_drm.h:559
#: include/uapi/drm/asahi_drm.h:596 include/uapi/drm/asahi_drm.h:741
#: include/uapi/drm/asahi_drm.h:764 include/uapi/drm/asahi_drm.h:767
#: include/uapi/drm/asahi_drm.h:1121 ../../../gpu/driver-uapi:8:
#: include/uapi/drm/i915_drm.h:121 include/uapi/drm/i915_drm.h:127
#: include/uapi/drm/i915_drm.h:3381 include/uapi/drm/i915_drm.h:3487
#: include/uapi/drm/i915_drm.h:3512 include/uapi/drm/i915_drm.h:3617
#: include/uapi/drm/i915_drm.h:3820
msgid "MBZ"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:193
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:123
msgid "All undefined bits must be zero."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:126
#: include/uapi/drm/i915_drm.h:3380 include/uapi/drm/i915_drm.h:3616
#: include/uapi/drm/i915_drm.h:3905
msgid "``rsvd``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:129
msgid "Reserved for future use; must be zero."
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:249
#: include/uapi/drm/nouveau_drm.h:274 include/uapi/drm/nouveau_drm.h:334
#: include/uapi/drm/nouveau_drm.h:399 ../../../gpu/driver-uapi:24:
#: include/uapi/drm/panthor_drm.h:175 include/uapi/drm/panthor_drm.h:180
#: include/uapi/drm/panthor_drm.h:246 include/uapi/drm/panthor_drm.h:335
#: include/uapi/drm/panthor_drm.h:368 include/uapi/drm/panthor_drm.h:388
#: include/uapi/drm/panthor_drm.h:405 include/uapi/drm/panthor_drm.h:876
#: include/uapi/drm/panthor_drm.h:941 include/uapi/drm/panthor_drm.h:1042
#: include/uapi/drm/panthor_drm.h:1049 ../../../gpu/driver-uapi:29:
#: include/uapi/drm/xe_drm.h:220 include/uapi/drm/xe_drm.h:254
#: include/uapi/drm/xe_drm.h:281 include/uapi/drm/xe_drm.h:387
#: include/uapi/drm/xe_drm.h:431 include/uapi/drm/xe_drm.h:490
#: include/uapi/drm/xe_drm.h:506 include/uapi/drm/xe_drm.h:562
#: include/uapi/drm/xe_drm.h:612 include/uapi/drm/xe_drm.h:644
#: include/uapi/drm/xe_drm.h:677 include/uapi/drm/xe_drm.h:764
#: include/uapi/drm/xe_drm.h:879 include/uapi/drm/xe_drm.h:926
#: include/uapi/drm/xe_drm.h:970 include/uapi/drm/xe_drm.h:1155
#: include/uapi/drm/xe_drm.h:1226 include/uapi/drm/xe_drm.h:1323
#: include/uapi/drm/xe_drm.h:1361 include/uapi/drm/xe_drm.h:1435
#: include/uapi/drm/xe_drm.h:1487 include/uapi/drm/xe_drm.h:1572
#: include/uapi/drm/xe_drm.h:1615 include/uapi/drm/xe_drm.h:1637
#: include/uapi/drm/xe_drm.h:1727 include/uapi/drm/xe_drm.h:1813
#: include/uapi/drm/xe_drm.h:1879 include/uapi/drm/xe_drm.h:1930
#: include/uapi/drm/xe_drm.h:1956 include/uapi/drm/xe_drm.h:2006
#: include/uapi/drm/xe_drm.h:2134 include/uapi/drm/xe_drm.h:2192
#: include/uapi/drm/xe_drm.h:2271 ../../../gpu/driver-uapi:34:
#: include/uapi/drm/asahi_drm.h:93 include/uapi/drm/asahi_drm.h:195
#: include/uapi/drm/asahi_drm.h:215 include/uapi/drm/asahi_drm.h:547
#: include/uapi/drm/asahi_drm.h:627 include/uapi/drm/asahi_drm.h:690
#: include/uapi/drm/asahi_drm.h:770 include/uapi/drm/asahi_drm.h:840
#: include/uapi/drm/asahi_drm.h:863 include/uapi/drm/asahi_drm.h:880
#: include/uapi/drm/asahi_drm.h:912 include/uapi/drm/asahi_drm.h:942
#: include/uapi/drm/asahi_drm.h:1112 include/uapi/drm/asahi_drm.h:1149
#: include/uapi/drm/asahi_drm.h:1166 ../../../gpu/driver-uapi:8:
#: include/uapi/drm/i915_drm.h:132 include/uapi/drm/i915_drm.h:195
#: include/uapi/drm/i915_drm.h:249 include/uapi/drm/i915_drm.h:1058
#: include/uapi/drm/i915_drm.h:1112 include/uapi/drm/i915_drm.h:1342
#: include/uapi/drm/i915_drm.h:1380 include/uapi/drm/i915_drm.h:1716
#: include/uapi/drm/i915_drm.h:2495 include/uapi/drm/i915_drm.h:2646
#: include/uapi/drm/i915_drm.h:2762 include/uapi/drm/i915_drm.h:3048
#: include/uapi/drm/i915_drm.h:3117 include/uapi/drm/i915_drm.h:3158
#: include/uapi/drm/i915_drm.h:3267 include/uapi/drm/i915_drm.h:3370
#: include/uapi/drm/i915_drm.h:3387 include/uapi/drm/i915_drm.h:3450
#: include/uapi/drm/i915_drm.h:3563 include/uapi/drm/i915_drm.h:3623
#: include/uapi/drm/i915_drm.h:3757 include/uapi/drm/i915_drm.h:3830
#: include/uapi/drm/i915_drm.h:3872 include/uapi/drm/i915_drm.h:3909
msgid "**Description**"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:131
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:67
msgid ""
"Many interfaces need to grow over time. In most cases we can simply extend "
"the struct and have userspace pass in more data. Another option, as "
"demonstrated by Vulkan's approach to providing extensions for forward and "
"backward compatibility, is to use a list of optional structs to provide "
"those extra details."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:137
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:73
msgid ""
"The key advantage to using an extension chain is that it allows us to "
"redefine the interface more easily than an ever growing struct of increasing "
"complexity, and for large parts of that interface to be entirely optional. "
"The downside is more pointer chasing; chasing across the __user boundary "
"with pointers encapsulated inside u64."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:143
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:79
msgid "Example chaining:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:96
msgid ""
"Typically the struct i915_user_extension would be embedded in some uAPI "
"struct, and in this case we would feed it the head of the chain(i.e ext1), "
"which would then apply all of the above extensions."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:158
msgid "uapi engine type enumeration"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:191
#: include/uapi/drm/panthor_drm.h:232 include/uapi/drm/panthor_drm.h:482
#: include/uapi/drm/panthor_drm.h:573 include/uapi/drm/panthor_drm.h:598
#: include/uapi/drm/panthor_drm.h:640 include/uapi/drm/panthor_drm.h:715
#: include/uapi/drm/panthor_drm.h:895 ../../../gpu/driver-uapi:29:
#: include/uapi/drm/xe_drm.h:286 include/uapi/drm/xe_drm.h:1577
#: include/uapi/drm/xe_drm.h:1587 include/uapi/drm/xe_drm.h:1620
#: include/uapi/drm/xe_drm.h:1643 include/uapi/drm/xe_drm.h:1733
#: include/uapi/drm/xe_drm.h:1752 include/uapi/drm/xe_drm.h:1921
#: include/uapi/drm/xe_drm.h:1941 ../../../gpu/driver-uapi:34:
#: include/uapi/drm/asahi_drm.h:57 include/uapi/drm/asahi_drm.h:201
#: include/uapi/drm/asahi_drm.h:287 include/uapi/drm/asahi_drm.h:342
#: include/uapi/drm/asahi_drm.h:433 include/uapi/drm/asahi_drm.h:444
#: include/uapi/drm/asahi_drm.h:485 include/uapi/drm/asahi_drm.h:529
#: include/uapi/drm/asahi_drm.h:604 ../../../gpu/driver-uapi:8:
#: include/uapi/drm/i915_drm.h:162 include/uapi/drm/i915_drm.h:3458
msgid "**Constants**"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:164
msgid "``I915_ENGINE_CLASS_RENDER``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:165
msgid ""
"Render engines support instructions used for 3D, Compute (GPGPU), and "
"programmable media workloads.  These instructions fetch data and dispatch "
"individual work items to threads that operate in parallel. The threads run "
"small programs (called \"kernels\" or \"shaders\") on the GPU's execution "
"units (EUs)."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:171
msgid "``I915_ENGINE_CLASS_COPY``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:172
msgid ""
"Copy engines (also referred to as \"blitters\") support instructions that "
"move blocks of data from one location in memory to another, or that fill a "
"specified location of memory with fixed data. Copy engines can perform pre-"
"defined logical or bitwise operations on the source, destination, or pattern "
"data."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:178
msgid "``I915_ENGINE_CLASS_VIDEO``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:179
msgid ""
"Video engines (also referred to as \"bit stream decode\" (BSD) or \"vdbox\") "
"support instructions that perform fixed-function media decode and encode."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:183
msgid "``I915_ENGINE_CLASS_VIDEO_ENHANCE``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:184
msgid ""
"Video enhancement engines (also referred to as \"vebox\") support "
"instructions related to image enhancement."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:187
msgid "``I915_ENGINE_CLASS_COMPUTE``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:188
msgid ""
"Compute engines support a subset of the instructions available on render "
"engines:  compute engines support Compute (GPGPU) and programmable media "
"workloads, but do not support the 3D pipeline."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:192
msgid "``I915_ENGINE_CLASS_INVALID``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:193
msgid "Placeholder value to represent an invalid engine class assignment."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:159
msgid ""
"Different engines serve different roles, and there may be more than one "
"engine serving each role.  This enum provides a classification of the role "
"of the engine, which may be used when requesting operations to be performed "
"on a certain subset of engines, or for providing information about that "
"group."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:226
msgid "Engine class/instance identifier"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:244
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:236
msgid "``engine_class``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:237
msgid "Engine class from enum drm_i915_gem_engine_class"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:246
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:245
msgid "``engine_instance``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:246
msgid "Engine instance."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:227
msgid ""
"There may be more than one engine fulfilling any role within the system. "
"Each engine of a class is given a unique instance number and therefore any "
"engine can be specified by its class:instance tuplet. APIs that allow access "
"to any engine in the system will use struct i915_engine_class_instance for "
"this identification."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:236
msgid ""
"**perf_events exposed by i915 through /sys/bus/event_sources/drivers/i915**"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:818
msgid "Driver parameter query structure."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1611
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:821
#: include/uapi/drm/i915_drm.h:1997 include/uapi/drm/i915_drm.h:2603
msgid "``param``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:822
msgid "Driver parameter to query."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:213
#: include/uapi/drm/xe_drm.h:1354 include/uapi/drm/xe_drm.h:1540
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:825
#: include/uapi/drm/i915_drm.h:2177
msgid "``value``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:826
msgid "Address of memory where queried value should be put."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:828
msgid ""
"WARNING: Using pointers instead of fixed-size u64 means we need to write "
"compat32 code. Don't repeat this mistake."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:834
msgid "Driver parameter query structure. See struct drm_i915_getparam."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1004
msgid "Retrieve an offset so we can mmap this buffer object."
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:240
#: include/uapi/drm/nouveau_drm.h:312 ../../../gpu/driver-uapi:24:
#: include/uapi/drm/panthor_drm.h:216 include/uapi/drm/panthor_drm.h:669
#: include/uapi/drm/panthor_drm.h:683 include/uapi/drm/panthor_drm.h:973
#: include/uapi/drm/panthor_drm.h:993 include/uapi/drm/panthor_drm.h:1007
#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:853
#: include/uapi/drm/xe_drm.h:912 include/uapi/drm/xe_drm.h:1411
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:315
#: include/uapi/drm/asahi_drm.h:327 include/uapi/drm/asahi_drm.h:370
#: include/uapi/drm/asahi_drm.h:461 include/uapi/drm/asahi_drm.h:617
#: include/uapi/drm/asahi_drm.h:853 ../../../gpu/driver-uapi:8:
#: include/uapi/drm/i915_drm.h:1014 include/uapi/drm/i915_drm.h:1098
#: include/uapi/drm/i915_drm.h:1328 include/uapi/drm/i915_drm.h:1684
#: include/uapi/drm/i915_drm.h:2756 include/uapi/drm/i915_drm.h:3686
msgid "``handle``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:913
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:328
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1015
msgid "Handle for the object being mapped."
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:316
#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:328
#: include/uapi/drm/panthor_drm.h:364 include/uapi/drm/panthor_drm.h:401
#: include/uapi/drm/panthor_drm.h:473 include/uapi/drm/panthor_drm.h:675
#: include/uapi/drm/panthor_drm.h:686 include/uapi/drm/panthor_drm.h:703
#: include/uapi/drm/panthor_drm.h:769 include/uapi/drm/panthor_drm.h:820
#: include/uapi/drm/panthor_drm.h:869 include/uapi/drm/panthor_drm.h:883
#: include/uapi/drm/panthor_drm.h:937 include/uapi/drm/panthor_drm.h:999
#: include/uapi/drm/panthor_drm.h:1010 ../../../gpu/driver-uapi:29:
#: include/uapi/drm/xe_drm.h:190 include/uapi/drm/xe_drm.h:210
#: include/uapi/drm/xe_drm.h:250 include/uapi/drm/xe_drm.h:275
#: include/uapi/drm/xe_drm.h:381 include/uapi/drm/xe_drm.h:416
#: include/uapi/drm/xe_drm.h:452 include/uapi/drm/xe_drm.h:500
#: include/uapi/drm/xe_drm.h:625 include/uapi/drm/xe_drm.h:872
#: include/uapi/drm/xe_drm.h:977 include/uapi/drm/xe_drm.h:1092
#: include/uapi/drm/xe_drm.h:1196 include/uapi/drm/xe_drm.h:1330
#: include/uapi/drm/xe_drm.h:1480 include/uapi/drm/xe_drm.h:1537
#: include/uapi/drm/xe_drm.h:1718 ../../../gpu/driver-uapi:34:
#: include/uapi/drm/asahi_drm.h:225 include/uapi/drm/asahi_drm.h:267
#: include/uapi/drm/asahi_drm.h:278 include/uapi/drm/asahi_drm.h:318
#: include/uapi/drm/asahi_drm.h:418 include/uapi/drm/asahi_drm.h:476
#: include/uapi/drm/asahi_drm.h:595 include/uapi/drm/asahi_drm.h:740
#: include/uapi/drm/asahi_drm.h:763 ../../../gpu/driver-uapi:8:
#: include/uapi/drm/i915_drm.h:1016 include/uapi/drm/i915_drm.h:3819
msgid "``pad``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:331
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1017
msgid "Must be zero"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:689
#: include/uapi/drm/panthor_drm.h:1031 ../../../gpu/driver-uapi:29:
#: include/uapi/drm/xe_drm.h:919 ../../../gpu/driver-uapi:34:
#: include/uapi/drm/asahi_drm.h:333 include/uapi/drm/asahi_drm.h:374
#: include/uapi/drm/asahi_drm.h:467 include/uapi/drm/asahi_drm.h:859
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1019
msgid "``offset``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:920
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:334
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1020
msgid "The fake offset to use for subsequent mmap call"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1022
msgid "This is a fixed-size type for 32/64 compatibility."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1027
msgid "Flags for extended behaviour."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1029
msgid "It is mandatory that one of the `MMAP_OFFSET` types should be included:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1032
msgid ""
"`I915_MMAP_OFFSET_GTT`: Use mmap with the object bound to GTT. (Write-"
"Combined)"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1033
msgid "`I915_MMAP_OFFSET_WC`: Use Write-Combined caching."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1034
msgid "`I915_MMAP_OFFSET_WB`: Use Write-Back caching."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1035
msgid "`I915_MMAP_OFFSET_FIXED`: Use object placement to determine caching."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1037
msgid ""
"On devices with local memory `I915_MMAP_OFFSET_FIXED` is the only valid "
"type. On devices without local memory, this caching mode is invalid."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1040
msgid ""
"As caching mode when specifying `I915_MMAP_OFFSET_FIXED`, WC or WB will be "
"used, depending on the object placement on creation. WB will be used when "
"the object can only exist in system memory, WC otherwise."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:737
#: include/uapi/drm/xe_drm.h:815 include/uapi/drm/xe_drm.h:909
#: include/uapi/drm/xe_drm.h:954 include/uapi/drm/xe_drm.h:1036
#: include/uapi/drm/xe_drm.h:1183 include/uapi/drm/xe_drm.h:1291
#: include/uapi/drm/xe_drm.h:1344 include/uapi/drm/xe_drm.h:1397
#: include/uapi/drm/xe_drm.h:1456 include/uapi/drm/xe_drm.h:1516
#: include/uapi/drm/xe_drm.h:1605 include/uapi/drm/xe_drm.h:1659
#: include/uapi/drm/xe_drm.h:1714 include/uapi/drm/xe_drm.h:1864
#: include/uapi/drm/xe_drm.h:1887 include/uapi/drm/xe_drm.h:1906
#: include/uapi/drm/xe_drm.h:1980 include/uapi/drm/xe_drm.h:2035
#: include/uapi/drm/xe_drm.h:2152 include/uapi/drm/xe_drm.h:2246
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1052
#: include/uapi/drm/i915_drm.h:1972 include/uapi/drm/i915_drm.h:2636
#: include/uapi/drm/i915_drm.h:3737
msgid "``extensions``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1053
#: include/uapi/drm/i915_drm.h:1973 include/uapi/drm/i915_drm.h:2637
msgid "Zero-terminated chain of extensions."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1055
msgid "No current extensions defined; mbz."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1005
msgid ""
"This struct is passed as argument to the `DRM_IOCTL_I915_GEM_MMAP_OFFSET` "
"ioctl, and is used to retrieve the fake offset to mmap an object specified "
"by :c:type:`handle`."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1008
msgid ""
"The legacy way of using `DRM_IOCTL_I915_GEM_MMAP` is removed on gen12+. "
"`DRM_IOCTL_I915_GEM_MMAP_GTT` is an older supported alias to this struct, "
"but will behave as setting the :c:type:`extensions` to 0, and :c:type:"
"`flags` to `I915_MMAP_OFFSET_GTT`."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1060
msgid ""
"Adjust the objects write or read domain, in preparation for accessing the "
"pages via some CPU domain."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1099
msgid "Handle for the object."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1101
msgid "``read_domains``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1102
msgid "New read domains."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1105
msgid "``write_domain``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1106
msgid "New write domain."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1108
msgid ""
"Note that having something in the write domain implies it's in the read "
"domain, and only that read domain."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1061
msgid ""
"Specifying a new write or read domain will flush the object out of the "
"previous domain(if required), before then updating the objects domain "
"tracking with the new domain."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1065
msgid ""
"Note this might involve waiting for the object first if it is still active "
"on the GPU."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1068
msgid "Supported values for **read_domains** and **write_domain**:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1070
msgid "I915_GEM_DOMAIN_WC: Uncached write-combined domain"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1071
msgid "I915_GEM_DOMAIN_CPU: CPU cache domain"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1072
msgid "I915_GEM_DOMAIN_GTT: Mappable aperture domain"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1074
msgid "All other domains are rejected."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1076
msgid ""
"Note that for discrete, starting from DG1, this is no longer supported, and "
"is instead rejected. On such platforms the CPU domain is effectively static, "
"where we also only support a single :c:type:`drm_i915_gem_mmap_offset` cache "
"mode, which can't be set explicitly and instead depends on the object "
"placements, as per the below."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1082
#: include/uapi/drm/i915_drm.h:1659
msgid "Implicit caching rules, starting from DG1:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1084
#: include/uapi/drm/i915_drm.h:1661
msgid ""
"If any of the object placements (see :c:type:"
"`drm_i915_gem_create_ext_memory_regions`) contain I915_MEMORY_CLASS_DEVICE "
"then the object will be allocated and mapped as write-combined only."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1088
#: include/uapi/drm/i915_drm.h:1665
msgid ""
"Everything else is always allocated and mapped as write-back, with the "
"guarantee that everything is also coherent with the GPU."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1091
#: include/uapi/drm/i915_drm.h:1668
msgid ""
"Note that this is likely to change in the future again, where we might need "
"more flexibility on future devices, so making this all explicit as part of a "
"new :c:type:`drm_i915_gem_create_ext` extension is probable."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1319
msgid "An input or output fence for the execbuf ioctl."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1329
msgid "User's handle for a drm_syncobj to wait on or signal."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1333
#: include/uapi/drm/i915_drm.h:1955
msgid "Supported flags are:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1335
msgid ""
"I915_EXEC_FENCE_WAIT: Wait for the input fence before request submission."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1338
msgid "I915_EXEC_FENCE_SIGNAL: Return request completion fence as output"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1320
msgid "The request will wait for input fence to signal before submission."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1322
msgid ""
"The returned output fence will be signaled after the completion of the "
"request."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1347
msgid "Timeline fences for execbuf ioctl."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:204
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:819
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1356
#: include/uapi/drm/i915_drm.h:2451 include/uapi/drm/i915_drm.h:2599
#: include/uapi/drm/i915_drm.h:3816 include/uapi/drm/i915_drm.h:3866
#: include/uapi/drm/i915_drm.h:3896
msgid "``base``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1357
#: include/uapi/drm/i915_drm.h:2600 include/uapi/drm/i915_drm.h:3817
#: include/uapi/drm/i915_drm.h:3867 include/uapi/drm/i915_drm.h:3897
msgid "Extension link. See struct i915_user_extension."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1360
msgid "``fence_count``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1361
msgid "Number of elements in the **handles_ptr** & **value_ptr** arrays."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1366
msgid "``handles_ptr``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1367
msgid ""
"Pointer to an array of struct drm_i915_gem_exec_fence of length "
"**fence_count**."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1372
msgid "``values_ptr``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1373
msgid ""
"Pointer to an array of u64 values of length **fence_count**. Values must be "
"0 for a binary drm_syncobj. A Value of 0 for a timeline drm_syncobj is "
"invalid as it turns a drm_syncobj into a binary one."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1348
msgid ""
"This structure describes an array of drm_syncobj and associated points for "
"timeline variants of drm_syncobj. It is invalid to append this structure to "
"the execbuf if I915_EXEC_FENCE_ARRAY is set."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1382
msgid "Structure for DRM_I915_GEM_EXECBUFFER2 ioctl."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1386
msgid "``buffers_ptr``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1387
msgid "Pointer to a list of gem_exec_object2 structs"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1389
msgid "``buffer_count``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1390
msgid "Number of elements in **buffers_ptr** array"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1393
msgid "``batch_start_offset``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1394
msgid "Offset in the batchbuffer to start execution from."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1399
msgid "``batch_len``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1400
msgid ""
"Length in bytes of the batch buffer, starting from the "
"**batch_start_offset**. If 0, length is assumed to be the batch buffer "
"object size."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1405
msgid "``DR1``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1406
#: include/uapi/drm/i915_drm.h:1409
msgid "deprecated"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1408
msgid "``DR4``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1411
msgid "``num_cliprects``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1412
msgid "See **cliprects_ptr**"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1415
msgid "``cliprects_ptr``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1416
msgid "Kernel clipping was a DRI1 misfeature."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1418
msgid ""
"It is invalid to use this field if I915_EXEC_FENCE_ARRAY or "
"I915_EXEC_USE_EXTENSIONS flags are not set."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1421
msgid ""
"If I915_EXEC_FENCE_ARRAY is set, then this is a pointer to an array of :c:"
"type:`drm_i915_gem_exec_fence` and **num_cliprects** is the length of the "
"array."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1425
msgid ""
"If I915_EXEC_USE_EXTENSIONS is set, then this is a pointer to a single :c:"
"type:`i915_user_extension` and num_cliprects is 0."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1430
msgid "Execbuf flags"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1552
#: include/uapi/drm/i915_drm.h:3364 include/uapi/drm/i915_drm.h:3511
msgid "``rsvd1``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1553
#: include/uapi/drm/i915_drm.h:1992
msgid "Context id"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1556
#: include/uapi/drm/i915_drm.h:3366
msgid "``rsvd2``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1557
msgid "in and out sync_file file descriptors."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1559
msgid ""
"When I915_EXEC_FENCE_IN or I915_EXEC_FENCE_SUBMIT flag is set, the lower 32 "
"bits of this field will have the in sync_file fd (input)."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1562
msgid ""
"When I915_EXEC_FENCE_OUT flag is set, the upper 32 bits of this field will "
"have the out sync_file fd (output)."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1644
msgid "Set or get the caching for given object handle."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1685
msgid "Handle of the buffer to set/get the caching level."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1689
msgid "``caching``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1690
msgid "The GTT caching level to apply or possible return value."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1692
msgid "The supported **caching** values:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1694
msgid "I915_CACHING_NONE:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1696
msgid ""
"GPU access is not coherent with CPU caches.  Default for machines without an "
"LLC. This means manual flushing might be needed, if we want GPU access to be "
"coherent."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1700
msgid "I915_CACHING_CACHED:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1702
msgid ""
"GPU access is coherent with CPU caches and furthermore the data is cached in "
"last-level caches shared between CPU cores and the GPU GT."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1705
msgid "I915_CACHING_DISPLAY:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1707
msgid ""
"Special GPU caching mode which is coherent with the scanout engines. "
"Transparently falls back to I915_CACHING_NONE on platforms where no special "
"cache mode (like write-through or gfdt flushing) is available. The kernel "
"automatically sets this mode when using a buffer as a scanout target.  "
"Userspace can manually set this mode to avoid a costly stall and clflush in "
"the hotpath of drawing the first frame."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1645
msgid ""
"Allow userspace to control the GTT caching bits for a given object when the "
"object is later mapped through the ppGTT(or GGTT on older platforms lacking "
"ppGTT support, or if the object is used for scanout). Note that this might "
"require unbinding the object from the GTT first, if its current caching "
"value doesn't match."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1651
msgid ""
"Note that this all changes on discrete platforms, starting from DG1, the set/"
"get caching is no longer supported, and is now rejected.  Instead the CPU "
"caching attributes(WB vs WC) will become an immutable creation time property "
"for the object, along with the GTT caching level. For now we don't expose "
"any new uAPI for this, instead on DG1 this is all implicit, although this "
"largely shouldn't matter since DG1 is coherent by default(without any way of "
"controlling it)."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1672
msgid ""
"Side note: Part of the reason for this is that changing the at-allocation-"
"time CPU caching attributes for the pages might be required(and is "
"expensive) if we need to then CPU map the pages later with different caching "
"attributes. This inconsistent caching behaviour, while supported on x86, is "
"not universally supported on other architectures. So for simplicity we opt "
"for setting everything at creation time, whilst also making it immutable, on "
"discrete platforms."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1947
msgid "Structure for creating contexts."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1950
#: include/uapi/drm/i915_drm.h:1991
msgid "``ctx_id``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1951
msgid "Id of the created context (output)"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1957
msgid "I915_CONTEXT_CREATE_FLAGS_USE_EXTENSIONS:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1959
msgid ""
"Extensions may be appended to this structure and driver must check for "
"those. See **extensions**."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1962
msgid "I915_CONTEXT_CREATE_FLAGS_SINGLE_TIMELINE"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1964
msgid "Created context will have single timeline."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1975
msgid ""
"I915_CONTEXT_CREATE_EXT_SETPARAM: Context parameter to set or query during "
"context creation. See struct drm_i915_gem_context_create_ext_setparam."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1979
msgid ""
"I915_CONTEXT_CREATE_EXT_CLONE: This extension has been removed. On the off "
"chance someone somewhere has attempted to use it, never re-use this "
"extension number."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1988
msgid "Context parameter to set or query."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:413
#: include/uapi/drm/panthor_drm.h:550 include/uapi/drm/panthor_drm.h:648
#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:754
#: include/uapi/drm/xe_drm.h:819 ../../../gpu/driver-uapi:34:
#: include/uapi/drm/asahi_drm.h:232 include/uapi/drm/asahi_drm.h:304
#: include/uapi/drm/asahi_drm.h:644 include/uapi/drm/asahi_drm.h:760
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1994
#: include/uapi/drm/i915_drm.h:3659
msgid "``size``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1995
msgid "Size of the parameter **value**"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1998
msgid "Parameter to set or query"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2178
msgid "Context parameter value to be set or queried"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2184
msgid "**Virtual Engine uAPI**"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2241
msgid ""
"Virtual engine is a concept where userspace is able to configure a set of "
"physical engines, submit a batch buffer, and let the driver execute it on "
"any engine from the set as it sees fit."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2245
msgid ""
"This is primarily useful on parts which have multiple instances of a same "
"class engine, like for example GT3+ Skylake parts with their two VCS engines."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2248
msgid ""
"For instance userspace can enumerate all engines of a certain class using "
"the previously described `Engine Discovery uAPI`_. After that userspace can "
"create a GEM context with a placeholder slot for the virtual engine (using "
"`I915_ENGINE_CLASS_INVALID` and `I915_ENGINE_CLASS_INVALID_NONE` for class "
"and instance respectively) and finally using the "
"`I915_CONTEXT_ENGINES_EXT_LOAD_BALANCE` extension place a virtual engine in "
"the same reserved slot."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2256
msgid ""
"Example of creating a virtual engine and submitting a batch buffer to it:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2380
msgid "Configure engine for parallel submission."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2452
msgid "base user extension."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2456
msgid "``engine_index``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2457
msgid "slot for parallel engine"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:590
#: include/uapi/drm/xe_drm.h:1294 ../../../gpu/driver-uapi:8:
#: include/uapi/drm/i915_drm.h:2461
msgid "``width``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2462
msgid ""
"number of contexts per parallel engine or in other words the number of "
"batches in each submission"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2467
msgid "``num_siblings``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2468
msgid ""
"number of siblings per context or in other words the number of possible "
"placements for each submission"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2473
msgid "``mbz16``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2474
#: include/uapi/drm/i915_drm.h:2484
msgid "reserved for future use; must be zero"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2479
msgid "all undefined flags must be zero, currently not defined flags"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2483
msgid "``mbz64``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:277
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2488
#: include/uapi/drm/i915_drm.h:3383
msgid "``engines``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2489
msgid "2-d array of engine instances to configure parallel engine"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2491
msgid "length = width (i) * num_siblings (j) index = j + i * num_siblings"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2381
msgid ""
"Setup a slot in the context engine map to allow multiple BBs to be submitted "
"in a single execbuf IOCTL. Those BBs will then be scheduled to run on the "
"GPU in parallel. Multiple hardware contexts are created internally in the "
"i915 to run these BBs. Once a slot is configured for N BBs only N BBs can be "
"submitted in each execbuf IOCTL and this is implicit behavior e.g. The user "
"doesn't tell the execbuf IOCTL there are N BBs, the execbuf IOCTL knows how "
"many BBs there are based on the slot's configuration. The N BBs are the last "
"N buffer objects or first N if I915_EXEC_BATCH_FIRST is set."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2390
msgid ""
"The default placement behavior is to create implicit bonds between each "
"context if each context maps to more than 1 physical engine (e.g. context is "
"a virtual engine). Also we only allow contexts of same engine class and "
"these contexts must be in logically contiguous order. Examples of the "
"placement behavior are described below. Lastly, the default is to not allow "
"BBs to be preempted mid-batch. Rather insert coordinated preemption points "
"on all hardware contexts between each set of BBs. Flags could be added in "
"the future to change both of these default behaviors."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2399
msgid ""
"Returns -EINVAL if hardware context placement configuration is invalid or if "
"the placement configuration isn't supported on the platform / submission "
"interface. Returns -ENODEV if extension isn't supported on the platform / "
"submission interface."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2450
msgid "**Context Engine Map uAPI**"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2509
msgid ""
"Context engine map is a new way of addressing engines when submitting batch- "
"buffers, replacing the existing way of using identifiers like "
"`I915_EXEC_BLT` inside the flags field of `struct drm_i915_gem_execbuffer2`."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2513
msgid ""
"To use it created GEM contexts need to be configured with a list of engines "
"the user is intending to submit to. This is accomplished using the "
"`I915_CONTEXT_PARAM_ENGINES` parameter and `struct "
"i915_context_param_engines`."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2518
msgid ""
"For such contexts the `I915_EXEC_RING_MASK` field becomes an index into the "
"configured map."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2521
msgid "Example of creating such context and submitting against it:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2595
msgid "Context parameter to set or query during context creation."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2604
msgid ""
"Context parameter to set or query. See struct drm_i915_gem_context_param."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2615
msgid "Structure to create or destroy VM."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2640
#: include/uapi/drm/i915_drm.h:3869
msgid "reserved for future usage, currently MBZ"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:583
#: include/uapi/drm/panthor_drm.h:624 include/uapi/drm/panthor_drm.h:800
#: include/uapi/drm/panthor_drm.h:945 ../../../gpu/driver-uapi:29:
#: include/uapi/drm/xe_drm.h:843 include/uapi/drm/xe_drm.h:963
#: include/uapi/drm/xe_drm.h:974 include/uapi/drm/xe_drm.h:1186
#: include/uapi/drm/xe_drm.h:1300 include/uapi/drm/xe_drm.h:2044
#: include/uapi/drm/xe_drm.h:2249 ../../../gpu/driver-uapi:34:
#: include/uapi/drm/asahi_drm.h:264 include/uapi/drm/asahi_drm.h:275
#: include/uapi/drm/asahi_drm.h:311 include/uapi/drm/asahi_drm.h:406
#: include/uapi/drm/asahi_drm.h:464 include/uapi/drm/asahi_drm.h:561
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2642
msgid "``vm_id``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2643
msgid "Id of the VM created or to be destroyed"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2616
msgid "DRM_I915_GEM_VM_CREATE -"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2618
msgid ""
"Create a new virtual memory address space (ppGTT) for use within a context "
"on the same file. Extensions can be provided to configure exactly how the "
"address space is setup upon creation."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2622
msgid ""
"The id of new VM (bound to the fd) for use with I915_CONTEXT_PARAM_VM is "
"returned in the outparam **id**."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2625
msgid ""
"An extension chain maybe provided, starting with **extensions**, and "
"terminated by the **next_extension** being 0. Currently, no extensions are "
"defined."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2628
msgid "DRM_I915_GEM_VM_DESTROY -"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2630
msgid "Destroys a previously created VM id, specified in **vm_id**."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2632
msgid "No extensions or flags are allowed currently, and so must be zero."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2695
msgid "Create GEM object from user allocated memory."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2702
msgid "``user_ptr``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2703
msgid "The pointer to the allocated memory."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2705
msgid "Needs to be aligned to PAGE_SIZE."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2709
msgid "``user_size``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2710
msgid ""
"The size in bytes for the allocated memory. This will also become the object "
"size."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2713
msgid ""
"Needs to be aligned to PAGE_SIZE, and should be at least PAGE_SIZE, or "
"larger."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2721
msgid "Supported flags:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2723
msgid "I915_USERPTR_READ_ONLY:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2725
msgid ""
"Mark the object as readonly, this also means GPU access can only be "
"readonly. This is only supported on HW which supports readonly access "
"through the GTT. If the HW can't support readonly access, an error is "
"returned."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2730
msgid "I915_USERPTR_PROBE:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2732
msgid ""
"Probe the provided **user_ptr** range and validate that the **user_ptr** is "
"indeed pointing to normal memory and that the range is also valid. For "
"example if some garbage address is given to the kernel, then this should "
"complain."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2737
msgid "Returns -EFAULT if the probe failed."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2739
msgid ""
"Note that this doesn't populate the backing pages, and also doesn't "
"guarantee that the object will remain valid when the object is eventually "
"used."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2743
msgid ""
"The kernel supports this feature if I915_PARAM_HAS_USERPTR_PROBE returns a "
"non-zero value."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2746
msgid "I915_USERPTR_UNSYNCHRONIZED:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2748
msgid "NOT USED. Setting this flag will result in an error."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:670
#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:854
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2757
#: include/uapi/drm/i915_drm.h:3687
msgid "Returned handle for the object."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:672
#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:856
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2759
#: include/uapi/drm/i915_drm.h:3689
msgid "Object handles are nonzero."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2696
msgid ""
"Userptr objects have several restrictions on what ioctls can be used with "
"the object handle."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1867
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2996
#: include/uapi/drm/i915_drm.h:3415
msgid "``uuid``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1868
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2997
msgid "String formatted like \"%\\08x-%\\04x-%\\04x-%\\04x-%\\012x\""
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3003
msgid "``n_mux_regs``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3004
msgid "Number of mux regs in :c:type:`mux_regs_ptr`."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3010
msgid "``n_boolean_regs``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3011
msgid "Number of boolean regs in :c:type:`boolean_regs_ptr`."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3017
msgid "``n_flex_regs``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3018
msgid "Number of flex regs in :c:type:`flex_regs_ptr`."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3024
msgid "``mux_regs_ptr``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3025
msgid ""
"Pointer to tuples of u32 values (register address, value) for mux "
"registers.  Expected length of buffer is (2 * sizeof(u32) * :c:type:"
"`n_mux_regs`)."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3033
msgid "``boolean_regs_ptr``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3034
msgid ""
"Pointer to tuples of u32 values (register address, value) for mux "
"registers.  Expected length of buffer is (2 * sizeof(u32) * :c:type:"
"`n_boolean_regs`)."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3042
msgid "``flex_regs_ptr``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3043
msgid ""
"Pointer to tuples of u32 values (register address, value) for mux "
"registers.  Expected length of buffer is (2 * sizeof(u32) * :c:type:"
"`n_flex_regs`)."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2991
msgid "Structure to upload perf dynamic configuration into the kernel."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3052
msgid "An individual query for the kernel to process."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3059
msgid "``query_id``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3060
msgid "The id for this query.  Currently accepted query IDs are:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3061
msgid ""
"``DRM_I915_QUERY_TOPOLOGY_INFO`` (see struct drm_i915_query_topology_info)"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3062
msgid "``DRM_I915_QUERY_ENGINE_INFO`` (see struct drm_i915_engine_info)"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3063
msgid "``DRM_I915_QUERY_PERF_CONFIG`` (see struct drm_i915_query_perf_config)"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3064
msgid ""
"``DRM_I915_QUERY_MEMORY_REGIONS`` (see struct drm_i915_query_memory_regions)"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3065
msgid "``DRM_I915_QUERY_HWCONFIG_BLOB`` (see `GuC HWCONFIG blob uAPI`)"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3066
msgid ""
"``DRM_I915_QUERY_GEOMETRY_SUBSLICES`` (see struct "
"drm_i915_query_topology_info)"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3067
msgid ""
"``DRM_I915_QUERY_GUC_SUBMISSION_VERSION`` (see struct "
"drm_i915_query_guc_submission_version)"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3081
msgid "``length``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3082
msgid ""
"When set to zero by userspace, this is filled with the size of the data to "
"be written at the **data_ptr** pointer. The kernel sets this value to a "
"negative value to signal an error on a particular query item."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3092
msgid "When :c:type:`query_id` == ``DRM_I915_QUERY_TOPOLOGY_INFO``, must be 0."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3094
msgid ""
"When :c:type:`query_id` == ``DRM_I915_QUERY_PERF_CONFIG``, must be one of "
"the following:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3097
msgid "``DRM_I915_QUERY_PERF_CONFIG_LIST``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3098
msgid "``DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_UUID``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3099
msgid "``DRM_I915_QUERY_PERF_CONFIG_FOR_UUID``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3101
msgid ""
"When :c:type:`query_id` == ``DRM_I915_QUERY_GEOMETRY_SUBSLICES`` must "
"contain a struct i915_engine_class_instance that references a render engine."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3111
msgid "``data_ptr``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3112
msgid ""
"Data will be written at the location pointed by **data_ptr** when the value "
"of **length** matches the length of the data to be written by the kernel."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3053
msgid ""
"The behaviour is determined by the **query_id**. Note that exactly what "
"**data_ptr** is also depends on the specific **query_id**."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3121
msgid ""
"Supply an array of struct drm_i915_query_item for the kernel to fill out."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3144
msgid "``num_items``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3145
msgid "The number of elements in the **items_ptr** array"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3149
#: include/uapi/drm/i915_drm.h:3170 include/uapi/drm/i915_drm.h:3429
msgid "Unused for now. Must be cleared to zero."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3153
msgid "``items_ptr``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3154
msgid ""
"Pointer to an array of struct drm_i915_query_item. The number of array "
"elements is **num_items**."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3122
msgid ""
"Note that this is generally a two step process for each struct "
"drm_i915_query_item in the array:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3125
msgid ""
"Call the DRM_IOCTL_I915_QUERY, giving it our array of struct "
"drm_i915_query_item, with :c:type:`drm_i915_query_item.length "
"<drm_i915_query_item>` set to zero. The kernel will then fill in the size, "
"in bytes, which tells userspace how memory it needs to allocate for the "
"blob(say for an array of properties)."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3130
msgid ""
"Next we call DRM_IOCTL_I915_QUERY again, this time with the :c:type:"
"`drm_i915_query_item.data_ptr <drm_i915_query_item>` equal to our newly "
"allocated blob. Note that the :c:type:`drm_i915_query_item.length "
"<drm_i915_query_item>` should still be the same as what the kernel "
"previously set. At this point the kernel can fill in the blob."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3135
msgid ""
"Note that for some query items it can make sense for userspace to just pass "
"in a buffer/blob equal to or larger than the required size. In this case "
"only a single ioctl call is needed. For some smaller query items this can "
"work quite well."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3176
msgid "``max_slices``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3177
msgid "The number of bits used to express the slice mask."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3183
msgid "``max_subslices``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3184
msgid "The number of bits used to express the subslice mask."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3190
msgid "``max_eus_per_subslice``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3191
msgid ""
"The number of bits in the EU mask that correspond to a single subslice's EUs."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3198
msgid "``subslice_offset``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3199
msgid "Offset in data[] at which the subslice masks are stored."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3205
msgid "``subslice_stride``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3206
msgid "Stride at which each of the subslice masks for each slice are stored."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3213
msgid "``eu_offset``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3214
msgid "Offset in data[] at which the EU masks are stored."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3220
msgid "``eu_stride``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3221
msgid "Stride at which each of the EU masks for each subslice are stored."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:757
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:902
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3227
#: include/uapi/drm/i915_drm.h:3435
msgid "``data``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3228
msgid "Contains 3 pieces of information :"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3230
msgid ""
"The slice mask with one bit per slice telling whether a slice is available. "
"The availability of slice X can be queried with the following formula :"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3238
msgid ""
"Starting with Xe_HP platforms, Intel hardware no longer has traditional "
"slices so i915 will always report a single slice (hardcoded slicemask = 0x1) "
"which contains all of the platform's subslices.  I.e., the mask here does "
"not reflect any of the newer hardware concepts such as \"gslices\" or "
"\"cslices\" since userspace is capable of inferring those from the subslice "
"mask."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3245
msgid ""
"The subslice mask for each slice with one bit per subslice telling whether a "
"subslice is available.  Starting with Gen12 we use the term \"subslice\" to "
"refer to what the hardware documentation describes as a \"dual-subslices.\"  "
"The availability of subslice Y in slice X can be queried with the following "
"formula :"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3255
msgid ""
"The EU mask for each subslice in each slice, with one bit per EU telling "
"whether an EU is available. The availability of EU Z in subslice Y in slice "
"X can be queried with the following formula :"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3163
msgid ""
"Describes slice/subslice/EU information queried by "
"``DRM_I915_QUERY_TOPOLOGY_INFO``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3169
msgid "**Engine Discovery uAPI**"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3271
msgid ""
"Engine discovery uAPI is a way of enumerating physical engines present in a "
"GPU associated with an open i915 DRM file descriptor. This supersedes the "
"old way of using `DRM_IOCTL_I915_GETPARAM` and engine identifiers like "
"`I915_PARAM_HAS_BLT`."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3276
msgid ""
"The need for this interface came starting with Icelake and newer GPUs, which "
"started to establish a pattern of having multiple engines of a same class, "
"where not all instances were always completely functionally equivalent."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3280
msgid ""
"Entry point for this uapi is `DRM_IOCTL_I915_QUERY` with the "
"`DRM_I915_QUERY_ENGINE_INFO` as the queried item id."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3283
msgid "Example for getting the list of engines:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3326
msgid ""
"Each of the enumerated engines, apart from being defined by its class and "
"instance (see `struct i915_engine_class_instance`), also can have flags and "
"capabilities defined as documented in i915_drm.h."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3330
msgid ""
"For instance video engines which support HEVC encoding will have the "
"`I915_VIDEO_CLASS_CAPABILITY_HEVC` capability bit set."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3333
msgid ""
"Engine discovery only fully comes to its own when combined with the new way "
"of addressing engines when submitting batch buffers using contexts with "
"engine maps configured."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3346
msgid "``engine``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3347
msgid "Engine class and instance."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3349
#: include/uapi/drm/i915_drm.h:3486
msgid "``rsvd0``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3350
msgid "Reserved field."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3353
msgid "Engine flags."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1668
#: include/uapi/drm/xe_drm.h:1983 ../../../gpu/driver-uapi:8:
#: include/uapi/drm/i915_drm.h:3356
msgid "``capabilities``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3357
msgid "Capabilities of this engine."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3361
msgid "``logical_instance``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3362
msgid "Logical instance of engine"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3365
#: include/uapi/drm/i915_drm.h:3367
msgid "Reserved fields."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3342
msgid "Describes one engine and its capabilities as known to the driver."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:273
#: include/uapi/drm/xe_drm.h:1682 ../../../gpu/driver-uapi:8:
#: include/uapi/drm/i915_drm.h:3377
msgid "``num_engines``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3378
msgid "Number of struct drm_i915_engine_info structs following."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3384
msgid "Marker for drm_i915_engine_info structures."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3372
msgid ""
"Engine info query enumerates all engines known to the driver by filling in "
"an array of struct drm_i915_engine_info structures."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1
msgid "``{unnamed_union}``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:2
msgid "anonymous"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3396
msgid "``n_configs``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3397
msgid ""
"When :c:type:`drm_i915_query_item.flags <drm_i915_query_item>` == "
"``DRM_I915_QUERY_PERF_CONFIG_LIST``, i915 sets this fields to the number of "
"configurations available."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3405
msgid "``config``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3406
msgid ""
"When :c:type:`drm_i915_query_item.flags <drm_i915_query_item>` == "
"``DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_ID``, i915 will use the value in this "
"field as configuration identifier to decide what data to write into "
"config_ptr."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3416
msgid ""
"When :c:type:`drm_i915_query_item.flags <drm_i915_query_item>` == "
"``DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_UUID``, i915 will use the value in "
"this field as configuration identifier to decide what data to write into "
"config_ptr."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3421
msgid "String formatted like \"``08x-````04x-````04x-````04x-````012x``\""
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3436
msgid ""
"When :c:type:`drm_i915_query_item.flags <drm_i915_query_item>` == "
"``DRM_I915_QUERY_PERF_CONFIG_LIST``, i915 will write an array of __u64 of "
"configuration identifiers."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3439
msgid ""
"When :c:type:`drm_i915_query_item.flags <drm_i915_query_item>` == "
"``DRM_I915_QUERY_PERF_CONFIG_DATA``, i915 will write a struct "
"drm_i915_perf_oa_config. If the following fields of struct "
"drm_i915_perf_oa_config are not set to 0, i915 will write into the "
"associated pointers the values of submitted when the configuration was "
"created :"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3445
msgid ":c:type:`drm_i915_perf_oa_config.n_mux_regs <drm_i915_perf_oa_config>`"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3446
msgid ""
":c:type:`drm_i915_perf_oa_config.n_boolean_regs <drm_i915_perf_oa_config>`"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3447
msgid ":c:type:`drm_i915_perf_oa_config.n_flex_regs <drm_i915_perf_oa_config>`"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3389
msgid ""
"Data written by the kernel with query ``DRM_I915_QUERY_PERF_CONFIG`` and "
"``DRM_I915_QUERY_GEOMETRY_SUBSLICES``."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3454
msgid "Supported memory classes"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3460
msgid "``I915_MEMORY_CLASS_SYSTEM``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3461
msgid "System memory"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3463
msgid "``I915_MEMORY_CLASS_DEVICE``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3464
msgid "Device local-memory"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3464
msgid "Identify particular memory region"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3467
msgid "``memory_class``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3468
msgid "See enum drm_i915_gem_memory_class"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3470
msgid "``memory_instance``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3471
msgid "Which instance"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3475
msgid "Describes one region as known to the driver."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3483
msgid "``region``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3484
msgid "The class:instance pair encoding"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3490
msgid "``probed_size``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3491
msgid "Memory probed by the driver"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3493
msgid ""
"Note that it should not be possible to ever encounter a zero value here, "
"also note that no current region type will ever return -1 here. Although for "
"future region types, this might be a possibility. The same applies to the "
"other size fields."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3500
msgid "``unallocated_size``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3501
msgid "Estimate of memory remaining"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3503
msgid ""
"Requires CAP_PERFMON or CAP_SYS_ADMIN to get reliable accounting. Without "
"this (or if this is an older kernel) the value here will always equal the "
"**probed_size**. Note this is only currently tracked for "
"I915_MEMORY_CLASS_DEVICE regions (for other types the value here will always "
"equal the **probed_size**)."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:1
msgid "``{unnamed_struct}``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3515
msgid "``probed_cpu_visible_size``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3516
msgid "Memory probed by the driver that is CPU accessible."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3519
msgid ""
"This will be always be <= **probed_size**, and the remainder (if there is "
"any) will not be CPU accessible."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3523
msgid ""
"On systems without small BAR, the **probed_size** will always equal the "
"**probed_cpu_visible_size**, since all of it will be CPU accessible."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3527
msgid ""
"Note this is only tracked for I915_MEMORY_CLASS_DEVICE regions (for other "
"types the value here will always equal the **probed_size**)."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3531
msgid ""
"Note that if the value returned here is zero, then this must be an old "
"kernel which lacks the relevant small-bar uAPI support (including "
"I915_GEM_CREATE_EXT_FLAG_NEEDS_CPU_ACCESS), but on such systems we should "
"never actually end up with a small BAR configuration, assuming we are able "
"to load the kernel module. Hence it should be safe to treat this the same as "
"when **probed_cpu_visible_size** == **probed_size**."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3543
msgid "``unallocated_cpu_visible_size``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3544
msgid "Estimate of CPU visible memory remaining."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3547
msgid ""
"Note this is only tracked for I915_MEMORY_CLASS_DEVICE regions (for other "
"types the value here will always equal the **probed_cpu_visible_size**)."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3552
msgid ""
"Requires CAP_PERFMON or CAP_SYS_ADMIN to get reliable accounting.  Without "
"this the value here will always equal the **probed_cpu_visible_size**. Note "
"this is only currently tracked for I915_MEMORY_CLASS_DEVICE regions (for "
"other types the value here will also always equal the "
"**probed_cpu_visible_size**)."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3559
msgid ""
"If this is an older kernel the value here will be zero, see also "
"**probed_cpu_visible_size**."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3476
msgid ""
"Note this is using both struct drm_i915_query_item and struct "
"drm_i915_query. For this new query we are adding the new query id "
"DRM_I915_QUERY_MEMORY_REGIONS at :c:type:`drm_i915_query_item.query_id "
"<drm_i915_query_item>`."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3613
#: include/uapi/drm/i915_drm.h:3821
msgid "``num_regions``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3614
msgid "Number of supported regions"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3619
#: include/uapi/drm/i915_drm.h:3824
msgid "``regions``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3620
msgid "Info about each supported region"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3568
msgid ""
"The region info query enumerates all regions known to the driver by filling "
"in an array of struct drm_i915_memory_region_info structures."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3571
msgid "Example for getting the list of supported regions:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3624
msgid "query GuC submission interface version"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3627
msgid "``branch``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3628
msgid "Firmware branch version."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3629
msgid "``major``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3630
msgid "Firmware major version."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3631
msgid "``minor``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3632
msgid "Firmware minor version."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3633
msgid "``patch``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3634
msgid "Firmware patch version."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3640
msgid "**GuC HWCONFIG blob uAPI**"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3638
msgid ""
"The GuC produces a blob with information about the current device. i915 "
"reads this blob from GuC and makes it available via this uAPI."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3641
msgid ""
"The format and meaning of the blob content are documented in the "
"Programmer's Reference Manual."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3648
msgid ""
"Existing gem_create behaviour, with added extension support using struct "
"i915_user_extension."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3660
msgid "Requested size for the object."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:651
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3662
msgid "The (page-aligned) allocated size for the object will be returned."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3664
msgid ""
"On platforms like DG2/ATS the kernel will always use 64K or larger pages for "
"I915_MEMORY_CLASS_DEVICE. The kernel also requires a minimum of 64K GTT "
"alignment for such objects."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3668
msgid ""
"NOTE: Previously the ABI here required a minimum GTT alignment of 2M on DG2/"
"ATS, due to how the hardware implemented 64K GTT page support, where we had "
"the following complications:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3672
msgid ""
"1) The entire PDE (which covers a 2MB virtual address range), must contain "
"only 64K PTEs, i.e mixing 4K and 64K PTEs in the same PDE is forbidden by "
"the hardware."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3676
msgid ""
"2) We still need to support 4K PTEs for I915_MEMORY_CLASS_SYSTEM objects."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3679
msgid ""
"However on actual production HW this was completely changed to now allow "
"setting a TLB hint at the PTE level (see PS64), which is a lot more flexible "
"than the above. With this the 2M restriction was dropped where we now only "
"require 64K."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3694
msgid "Optional flags."
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:286
#: include/uapi/drm/nouveau_drm.h:305 include/uapi/drm/nouveau_drm.h:347
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3696
msgid "Supported values:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3698
msgid ""
"I915_GEM_CREATE_EXT_FLAG_NEEDS_CPU_ACCESS - Signal to the kernel that the "
"object will need to be accessed via the CPU."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3701
msgid ""
"Only valid when placing objects in I915_MEMORY_CLASS_DEVICE, and only "
"strictly required on configurations where some subset of the device memory "
"is directly visible/mappable through the CPU (which we also call small BAR), "
"like on some DG2+ systems. Note that this is quite undesirable, but due to "
"various factors like the client CPU, BIOS etc it's something we can expect "
"to see in the wild. See :c:type:`drm_i915_memory_region_info."
"probed_cpu_visible_size <drm_i915_memory_region_info>` for how to determine "
"if this system applies."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3710
msgid ""
"Note that one of the placements MUST be I915_MEMORY_CLASS_SYSTEM, to ensure "
"the kernel can always spill the allocation to system memory, if the object "
"can't be allocated in the mappable part of I915_MEMORY_CLASS_DEVICE."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3715
msgid ""
"Also note that since the kernel only supports flat-CCS on objects that can "
"*only* be placed in I915_MEMORY_CLASS_DEVICE, we therefore don't support "
"I915_GEM_CREATE_EXT_FLAG_NEEDS_CPU_ACCESS together with flat-CCS."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3720
msgid ""
"Without this hint, the kernel will assume that non-mappable "
"I915_MEMORY_CLASS_DEVICE is preferred for this object. Note that the kernel "
"can still migrate the object to the mappable part, as a last resort, if "
"userspace ever CPU faults this object, but this might be expensive, and so "
"ideally should be avoided."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3726
msgid ""
"On older kernels which lack the relevant small-bar uAPI support (see also :c:"
"type:`drm_i915_memory_region_info.probed_cpu_visible_size "
"<drm_i915_memory_region_info>`), usage of the flag will result in an error, "
"but it should NEVER be possible to end up with a small BAR configuration, "
"assuming we can also successfully load the i915 kernel module. In such cases "
"the entire I915_MEMORY_CLASS_DEVICE region will be CPU accessible, and as "
"such there are zero restrictions on where the object can be placed."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3738
msgid "The chain of extensions to apply to this object."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3740
msgid ""
"This will be useful in the future when we need to support several different "
"extensions, and we need to apply more than one when creating the object. See "
"struct i915_user_extension."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3744
msgid ""
"If we don't supply any extensions then we get the same old gem_create "
"behaviour."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3747
msgid ""
"For I915_GEM_CREATE_EXT_MEMORY_REGIONS usage see struct "
"drm_i915_gem_create_ext_memory_regions."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3750
msgid ""
"For I915_GEM_CREATE_EXT_PROTECTED_CONTENT usage see struct "
"drm_i915_gem_create_ext_protected_content."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3753
msgid ""
"For I915_GEM_CREATE_EXT_SET_PAT usage see struct "
"drm_i915_gem_create_ext_set_pat."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3649
msgid ""
"Note that new buffer flags should be added here, at least for the stuff that "
"is immutable. Previously we would have two ioctls, one to create the object "
"with gem_create, and another to apply various parameters, however this "
"creates some ambiguity for the params which are considered immutable. Also "
"in general we're phasing out the various SET/GET ioctls."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3762
msgid "The I915_GEM_CREATE_EXT_MEMORY_REGIONS extension."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3822
msgid "Number of elements in the **regions** array."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3825
msgid "The regions/placements array."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3827
msgid "An array of struct drm_i915_gem_memory_class_instance."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3763
msgid ""
"Set the object with the desired set of placements/regions in priority order. "
"Each entry must be unique and supported by the device."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3766
msgid ""
"This is provided as an array of struct drm_i915_gem_memory_class_instance, "
"or an equivalent layout of class:instance pair encodings. See struct "
"drm_i915_query_memory_regions and DRM_I915_QUERY_MEMORY_REGIONS for how to "
"query the supported regions for a device."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3771
msgid ""
"As an example, on discrete devices, if we wish to set the placement as "
"device local-memory we can do something like:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3793
msgid ""
"At which point we get the object handle in :c:type:`drm_i915_gem_create_ext."
"handle <drm_i915_gem_create_ext>`, along with the final object size in :c:"
"type:`drm_i915_gem_create_ext.size <drm_i915_gem_create_ext>`, which should "
"account for any rounding up, if required."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3797
msgid ""
"Note that userspace has no means of knowing the current backing region for "
"objects where **num_regions** is larger than one. The kernel will only "
"ensure that the priority order of the **regions** array is honoured, either "
"when initially placing the object, or when moving memory around due to "
"memory pressure"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3803
msgid ""
"On Flat-CCS capable HW, compression is supported for the objects residing in "
"I915_MEMORY_CLASS_DEVICE. When such objects (compressed) have other memory "
"class in **regions** and migrated (by i915, due to memory constraints) to "
"the non I915_MEMORY_CLASS_DEVICE region, then i915 needs to decompress the "
"content. But i915 doesn't have the required information to decompress the "
"userspace compressed objects."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3810
msgid ""
"So i915 supports Flat-CCS, on the objects which can reside only on "
"I915_MEMORY_CLASS_DEVICE regions."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3832
msgid "The I915_OBJECT_PARAM_PROTECTED_CONTENT extension."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3833
msgid ""
"If this extension is provided, buffer contents are expected to be protected "
"by PXP encryption and require decryption for scan out and processing. This "
"is only possible on platforms that have PXP enabled, on all other scenarios "
"using this extension will cause the ioctl to fail and return -ENODEV. The "
"flags parameter is reserved for future expansion and must currently be set "
"to zero."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3840
msgid ""
"The buffer contents are considered invalid after a PXP session teardown."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3842
msgid ""
"The encryption is guaranteed to be processed correctly only if the object is "
"submitted with a context created using the "
"I915_CONTEXT_PARAM_PROTECTED_CONTENT flag. This will also enable extra "
"checks at submission time on the validity of the objects involved."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3847
msgid "Below is an example on how to create a protected object:"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3873
msgid "The I915_GEM_CREATE_EXT_SET_PAT extension."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1045
#: include/uapi/drm/xe_drm.h:2114 include/uapi/drm/xe_drm.h:2179
#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3899
msgid "``pat_index``"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3900
msgid ""
"PAT index to be set PAT index is a bit field in Page Table Entry to control "
"caching behaviors for GPU accesses. The definition of PAT index is platform "
"dependent and can be found in hardware specifications,"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1898
#: include/uapi/drm/xe_drm.h:1913 ../../../gpu/driver-uapi:8:
#: include/uapi/drm/i915_drm.h:3906
msgid "reserved for future use"
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3874
msgid ""
"If this extension is provided, the specified caching policy (PAT index) is "
"applied to the buffer object."
msgstr ""

#: ../../../gpu/driver-uapi:8: include/uapi/drm/i915_drm.h:3877
msgid ""
"Below is an example on how to create an object with specific caching policy:"
msgstr ""

#: ../../../gpu/driver-uapi.rst:11
msgid "drm/nouveau uAPI"
msgstr ""

#: ../../../gpu/driver-uapi.rst:14
msgid "VM_BIND / EXEC uAPI"
msgstr ""

#: ../../../gpu/driver-uapi:16: drivers/gpu/drm/nouveau/nouveau_exec.c:16
msgid ""
"Nouveau's VM_BIND / EXEC UAPI consists of three ioctls: DRM_NOUVEAU_VM_INIT, "
"DRM_NOUVEAU_VM_BIND and DRM_NOUVEAU_EXEC."
msgstr ""

#: ../../../gpu/driver-uapi:16: drivers/gpu/drm/nouveau/nouveau_exec.c:19
msgid ""
"In order to use the UAPI firstly a user client must initialize the VA space "
"using the DRM_NOUVEAU_VM_INIT ioctl specifying which region of the VA space "
"should be managed by the kernel and which by the UMD."
msgstr ""

#: ../../../gpu/driver-uapi:16: drivers/gpu/drm/nouveau/nouveau_exec.c:23
msgid ""
"The DRM_NOUVEAU_VM_BIND ioctl provides clients an interface to manage the "
"userspace-managable portion of the VA space. It provides operations to map "
"and unmap memory. Mappings may be flagged as sparse. Sparse mappings are not "
"backed by a GEM object and the kernel will ignore GEM handles provided "
"alongside a sparse mapping."
msgstr ""

#: ../../../gpu/driver-uapi:16: drivers/gpu/drm/nouveau/nouveau_exec.c:29
msgid ""
"Userspace may request memory backed mappings either within or outside of the "
"bounds (but not crossing those bounds) of a previously mapped sparse "
"mapping. Subsequently requested memory backed mappings within a sparse "
"mapping will take precedence over the corresponding range of the sparse "
"mapping. If such memory backed mappings are unmapped the kernel will make "
"sure that the corresponding sparse mapping will take their place again. "
"Requests to unmap a sparse mapping that still contains memory backed "
"mappings will result in those memory backed mappings being unmapped first."
msgstr ""

#: ../../../gpu/driver-uapi:16: drivers/gpu/drm/nouveau/nouveau_exec.c:38
msgid ""
"Unmap requests are not bound to the range of existing mappings and can even "
"overlap the bounds of sparse mappings. For such a request the kernel will "
"make sure to unmap all memory backed mappings within the given range, "
"splitting up memory backed mappings which are only partially contained "
"within the given range. Unmap requests with the sparse flag set must match "
"the range of a previously mapped sparse mapping exactly though."
msgstr ""

#: ../../../gpu/driver-uapi:16: drivers/gpu/drm/nouveau/nouveau_exec.c:45
msgid ""
"While the kernel generally permits arbitrary sequences and ranges of memory "
"backed mappings being mapped and unmapped, either within a single or "
"multiple VM_BIND ioctl calls, there are some restrictions for sparse "
"mappings."
msgstr ""

#: ../../../gpu/driver-uapi:16: drivers/gpu/drm/nouveau/nouveau_exec.c:49
msgid "The kernel does not permit to:"
msgstr ""

#: ../../../gpu/driver-uapi:16: drivers/gpu/drm/nouveau/nouveau_exec.c:50
msgid "unmap non-existent sparse mappings"
msgstr ""

#: ../../../gpu/driver-uapi:16: drivers/gpu/drm/nouveau/nouveau_exec.c:51
msgid ""
"unmap a sparse mapping and map a new sparse mapping overlapping the range of "
"the previously unmapped sparse mapping within the same VM_BIND ioctl"
msgstr ""

#: ../../../gpu/driver-uapi:16: drivers/gpu/drm/nouveau/nouveau_exec.c:53
msgid ""
"unmap a sparse mapping and map new memory backed mappings overlapping the "
"range of the previously unmapped sparse mapping within the same VM_BIND ioctl"
msgstr ""

#: ../../../gpu/driver-uapi:16: drivers/gpu/drm/nouveau/nouveau_exec.c:57
msgid ""
"When using the VM_BIND ioctl to request the kernel to map memory to a given "
"virtual address in the GPU's VA space there is no guarantee that the actual "
"mappings are created in the GPU's MMU. If the given memory is swapped out at "
"the time the bind operation is executed the kernel will stash the mapping "
"details into it's internal allocator and create the actual MMU mappings once "
"the memory is swapped back in. While this is transparent for userspace, it "
"is guaranteed that all the backing memory is swapped back in and all the "
"memory mappings, as requested by userspace previously, are actually mapped "
"once the DRM_NOUVEAU_EXEC ioctl is called to submit an exec job."
msgstr ""

#: ../../../gpu/driver-uapi:16: drivers/gpu/drm/nouveau/nouveau_exec.c:67
msgid ""
"A VM_BIND job can be executed either synchronously or asynchronously. If "
"executed asynchronously, userspace may provide a list of syncobjs this job "
"will wait for and/or a list of syncobj the kernel will signal once the "
"VM_BIND job finished execution. If executed synchronously the ioctl will "
"block until the bind job is finished. For synchronous jobs the kernel will "
"not permit any syncobjs submitted to the kernel."
msgstr ""

#: ../../../gpu/driver-uapi:16: drivers/gpu/drm/nouveau/nouveau_exec.c:74
msgid ""
"To execute a push buffer the UAPI provides the DRM_NOUVEAU_EXEC ioctl. EXEC "
"jobs are always executed asynchronously, and, equal to VM_BIND jobs, provide "
"the option to synchronize them with syncobjs."
msgstr ""

#: ../../../gpu/driver-uapi:16: drivers/gpu/drm/nouveau/nouveau_exec.c:78
msgid ""
"Besides that, EXEC jobs can be scheduled for a specified channel to execute "
"on."
msgstr ""

#: ../../../gpu/driver-uapi:16: drivers/gpu/drm/nouveau/nouveau_exec.c:80
msgid ""
"Since VM_BIND jobs update the GPU's VA space on job submit, EXEC jobs do "
"have an up to date view of the VA space. However, the actual mappings might "
"still be pending. Hence, EXEC jobs require to have the particular fences - "
"of the corresponding VM_BIND jobs they depend on - attached to them."
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:224
#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1362
msgid "sync object"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:232
msgid "the flags for a sync object"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:234
msgid "The first 8 bits are used to determine the type of the sync object."
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:241
msgid "the handle of the sync object"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:244
#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:220
#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1426
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:620
msgid "``timeline_value``"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:245
msgid ""
"The timeline point of the sync object in case the syncobj is of type "
"DRM_NOUVEAU_SYNC_TIMELINE_SYNCOBJ."
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:225
msgid ""
"This structure serves as synchronization mechanism for (potentially) "
"asynchronous operations such as EXEC or VM_BIND."
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:253
msgid "GPU VA space init structure"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:264
msgid "``kernel_managed_addr``"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:265
msgid "start address of the kernel managed VA space region"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:269
msgid "``kernel_managed_size``"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:270
msgid "size of the kernel managed VA space region in bytes"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:254
msgid ""
"Used to initialize the GPU's VA space for a user client, telling the kernel "
"which portion of the VA space is managed by the UMD and kernel respectively."
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:257
msgid ""
"For the UMD to use the VM_BIND uAPI, this must be called before any BOs or "
"channels are created; if called afterwards DRM_IOCTL_NOUVEAU_VM_INIT fails "
"with -ENOSYS."
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:276
msgid "VM_BIND operation"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:283
#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1127
#: include/uapi/drm/xe_drm.h:1530 ../../../gpu/driver-uapi:34:
#: include/uapi/drm/asahi_drm.h:455
msgid "``op``"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:284
msgid "the operation type"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:288
msgid ""
"``DRM_NOUVEAU_VM_BIND_OP_MAP`` - Map a GEM object to the GPU's VA space. "
"Optionally, the :c:type:`DRM_NOUVEAU_VM_BIND_SPARSE` flag can be passed to "
"instruct the kernel to create sparse mappings for the given range."
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:293
msgid ""
"``DRM_NOUVEAU_VM_BIND_OP_UNMAP`` - Unmap an existing mapping in the GPU's VA "
"space. If the region the mapping is located in is a sparse region, new "
"sparse mappings are created where the unmapped (memory backed) mapping was "
"mapped previously. To remove a sparse region the :c:type:"
"`DRM_NOUVEAU_VM_BIND_SPARSE` must be set."
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:303
msgid "the flags for a :c:type:`drm_nouveau_vm_bind_op`"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:307
msgid ""
"``DRM_NOUVEAU_VM_BIND_SPARSE`` - Indicates that an allocated VA space region "
"should be sparse."
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:313
msgid "the handle of the DRM GEM object to map"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:317
msgid "32 bit padding, should be 0"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:320
#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1119
#: include/uapi/drm/xe_drm.h:1415 include/uapi/drm/xe_drm.h:1520
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:394
msgid "``addr``"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:321
msgid ""
"the address the VA space region or (memory backed) mapping should be mapped "
"to"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:326
#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:538
msgid "``bo_offset``"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:327
msgid "the offset within the BO backing the mapping"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:330
#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1115
#: include/uapi/drm/xe_drm.h:2041 include/uapi/drm/xe_drm.h:2258
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:387
#: include/uapi/drm/asahi_drm.h:470
msgid "``range``"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:331
msgid "the size of the requested mapping in bytes"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:277
msgid ""
"This structure represents a single VM_BIND operation. UMDs should pass an "
"array of this structure via struct drm_nouveau_vm_bind's :c:type:`op_ptr` "
"field."
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:336
msgid "structure for DRM_IOCTL_NOUVEAU_VM_BIND"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:340
msgid "``op_count``"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:341
msgid "the number of :c:type:`drm_nouveau_vm_bind_op`"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:345
msgid "the flags for a :c:type:`drm_nouveau_vm_bind` ioctl"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:349
msgid ""
"``DRM_NOUVEAU_VM_BIND_RUN_ASYNC`` - Indicates that the given VM_BIND "
"operation should be executed asynchronously by the kernel."
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:352
msgid ""
"If this flag is not supplied the kernel executes the associated operations "
"synchronously and doesn't accept any :c:type:`drm_nouveau_sync` objects."
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:358
#: include/uapi/drm/nouveau_drm.h:414
msgid "``wait_count``"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:359
#: include/uapi/drm/nouveau_drm.h:415
msgid "the number of wait :c:type:`drm_nouveau_syncs`"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:362
#: include/uapi/drm/nouveau_drm.h:418
msgid "``sig_count``"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:363
#: include/uapi/drm/nouveau_drm.h:419
msgid "the number of :c:type:`drm_nouveau_syncs` to signal when finished"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:366
#: include/uapi/drm/nouveau_drm.h:422
msgid "``wait_ptr``"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:367
#: include/uapi/drm/nouveau_drm.h:423
msgid "pointer to :c:type:`drm_nouveau_syncs` to wait for"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:370
#: include/uapi/drm/nouveau_drm.h:426
msgid "``sig_ptr``"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:371
#: include/uapi/drm/nouveau_drm.h:427
msgid "pointer to :c:type:`drm_nouveau_syncs` to signal when finished"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:374
msgid "``op_ptr``"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:375
msgid "pointer to the :c:type:`drm_nouveau_vm_bind_ops` to execute"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:380
msgid "EXEC push operation"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:387
#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:544
msgid "``va``"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:388
msgid "the virtual address of the push buffer mapping"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:391
msgid "``va_len``"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:392
msgid "the length of the push buffer mapping"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:396
msgid "the flags for this push buffer mapping"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:381
msgid ""
"This structure represents a single EXEC push operation. UMDs should pass an "
"array of this structure via struct drm_nouveau_exec's :c:type:`push_ptr` "
"field."
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:402
msgid "structure for DRM_IOCTL_NOUVEAU_EXEC"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:406
msgid "``channel``"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:407
msgid "the channel to execute the push buffer in"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:410
msgid "``push_count``"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:411
msgid "the number of :c:type:`drm_nouveau_exec_push` ops"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:430
msgid "``push_ptr``"
msgstr ""

#: ../../../gpu/driver-uapi:19: include/uapi/drm/nouveau_drm.h:431
msgid "pointer to :c:type:`drm_nouveau_exec_push` ops"
msgstr ""

#: ../../../gpu/driver-uapi.rst:22
msgid "drm/panthor uAPI"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:3
msgid "**Introduction**"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:13
msgid "This documentation describes the Panthor IOCTLs."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:15
msgid "Just a few generic rules about the data passed to the Panthor IOCTLs:"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:17
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:22
msgid ""
"Structures must be aligned on 64-bit/8-byte. If the object is not naturally "
"aligned, a padding field must be added."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:19
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:24
msgid ""
"Fields must be explicitly aligned to their natural type alignment with "
"pad[0..N] fields."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:21
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:26
msgid ""
"All padding fields will be checked by the driver to make sure they are "
"zeroed."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:23
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:28
msgid "Flags can be added, but not removed/replaced."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:24
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:29
msgid ""
"New fields can be added to the main structures (the structures directly "
"passed to the ioctl). Those fields can be added at the end of the structure, "
"or replace existing padding fields. Any new field being added must preserve "
"the behavior that existed before those fields were added when a value of "
"zero is passed."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:29
msgid ""
"New fields can be added to indirect objects (objects pointed by the main "
"structure), iff those objects are passed a size to reflect the size known by "
"the userspace driver (see drm_panthor_obj_array::stride or "
"drm_panthor_dev_query::size)."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:33
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:38
msgid ""
"If the kernel driver is too old to know some fields, those will be ignored "
"if zero, and otherwise rejected (and so will be zero on output)."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:35
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:40
msgid ""
"If userspace is too old to know some fields, those will be zeroed (input) "
"before the structure is parsed by the kernel driver."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:37
msgid ""
"Each new flag/field addition must come with a driver version update so the "
"userspace driver doesn't have to trial and error to know which flags are "
"supported."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:40
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:44
msgid ""
"Structures should not contain unions, as this would defeat the extensibility "
"of such structures."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:42
msgid ""
"IOCTLs can't be removed or replaced. New IOCTL IDs should be placed at the "
"end of the drm_panthor_ioctl_id enum."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:48
msgid "**MMIO regions exposed to userspace.**"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:51
msgid ""
"File offset for all MMIO regions being exposed to userspace. Don't use this "
"value directly, use DRM_PANTHOR_USER_<name>_OFFSET values instead. pgoffset "
"passed to mmap2() is an unsigned long, which forces us to use a different "
"offset on 32-bit and 64-bit systems."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:58
msgid ""
"File offset for the LATEST_FLUSH_ID register. The Userspace driver controls "
"GPU cache flushing through CS instructions, but the flush reduction "
"mechanism requires a flush_id. This flush_id could be queried with an ioctl, "
"but Arm provides a well-isolated register page containing only this read-"
"only register, so let's expose this page through a static mmap offset and "
"allow direct mapping of this MMIO region so we can avoid the user <-> kernel "
"round-trip."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:69
msgid "**IOCTL IDs**"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:76
msgid "enum drm_panthor_ioctl_id - IOCTL IDs"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:78
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:54
msgid ""
"Place new ioctls at the end, don't re-order, don't replace or remove entries."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:80
msgid ""
"These IDs are not meant to be used directly. Use the DRM_IOCTL_PANTHOR_xxx "
"definitions instead."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:86
msgid "**IOCTL arguments**"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:154
msgid "Object array."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:165
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:413
#: include/uapi/drm/asahi_drm.h:829
msgid "``stride``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:166
msgid "Stride of object struct. Used for versioning."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:168
msgid "``count``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:169
msgid "Number of objects in the array."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:171
msgid "``array``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:172
msgid "User pointer to an array of objects."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:155
msgid ""
"This object is used to pass an array of objects whose size is subject to "
"changes in future versions of the driver. In order to support this "
"mutability, we pass a stride describing the size of the object as known by "
"userspace."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:159
msgid ""
"You shouldn't fill drm_panthor_obj_array fields directly. You should instead "
"use the DRM_PANTHOR_OBJ_ARRAY() macro that takes care of initializing the "
"stride to the object size."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:178
msgid "``DRM_PANTHOR_OBJ_ARRAY (cnt, ptr)``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:176
msgid "Initialize a drm_panthor_obj_array field."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:180
#: include/uapi/drm/panthor_drm.h:1048 ../../../gpu/driver-uapi:34:
#: include/uapi/drm/asahi_drm.h:1165
msgid "**Parameters**"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:182
msgid "``cnt``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:177
msgid "Number of elements in the array."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:179
msgid "``ptr``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:178
msgid "Pointer to the array to pass to the kernel."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:179
msgid ""
"Macro initializing a drm_panthor_obj_array based on the object size as known "
"by userspace."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:187
msgid "Synchronization operation flags."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:193
msgid "``DRM_PANTHOR_SYNC_OP_HANDLE_TYPE_MASK``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:194
msgid "Synchronization handle type mask."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:196
msgid "``DRM_PANTHOR_SYNC_OP_HANDLE_TYPE_SYNCOBJ``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:197
msgid "Synchronization object type."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:199
msgid "``DRM_PANTHOR_SYNC_OP_HANDLE_TYPE_TIMELINE_SYNCOBJ``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:200
msgid "Timeline synchronization object type."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:203
msgid "``DRM_PANTHOR_SYNC_OP_WAIT``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:204
msgid "Wait operation."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:206
msgid "``DRM_PANTHOR_SYNC_OP_SIGNAL``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:207
msgid "Signal operation."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:210
msgid "Synchronization operation."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:214
msgid ""
"Synchronization operation flags. Combination of DRM_PANTHOR_SYNC_OP values."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:217
msgid "Sync handle."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:221
msgid ""
"MBZ if (flags & DRM_PANTHOR_SYNC_OP_HANDLE_TYPE_MASK) != "
"DRM_PANTHOR_SYNC_OP_HANDLE_TYPE_TIMELINE_SYNCOBJ."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:228
msgid "Query type"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:234
msgid "``DRM_PANTHOR_DEV_QUERY_GPU_INFO``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:235
msgid "Query GPU information."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:237
msgid "``DRM_PANTHOR_DEV_QUERY_CSIF_INFO``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:238
msgid "Query command-stream interface information."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:240
msgid "``DRM_PANTHOR_DEV_QUERY_TIMESTAMP_INFO``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:241
msgid "Query timestamp information."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:243
msgid "``DRM_PANTHOR_DEV_QUERY_GROUP_PRIORITIES_INFO``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:244
msgid "Query allowed group priorities information."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:229
msgid "Place new types at the end, don't re-order, don't remove or replace."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:249
msgid "GPU information"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:254
msgid "``gpu_id``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:255
msgid "GPU ID."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:264
msgid "``gpu_rev``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:265
msgid "GPU revision."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:267
msgid "``csf_id``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:268
msgid "Command stream frontend ID."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:276
msgid "``l2_features``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:277
msgid "L2-cache features."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:279
msgid "``tiler_features``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:280
msgid "Tiler features."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:282
msgid "``mem_features``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:283
msgid "Memory features."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:285
msgid "``mmu_features``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:286
msgid "MMU features."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:289
msgid "``thread_features``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:290
msgid "Thread features."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:292
msgid "``max_threads``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:293
msgid "Maximum number of threads."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:295
msgid "``thread_max_workgroup_size``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:296
msgid "Maximum workgroup size."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:299
msgid "``thread_max_barrier_size``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:300
msgid "Maximum number of threads that can wait simultaneously on a barrier."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:304
msgid "``coherency_features``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:305
msgid "Coherency features."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:307
msgid "``texture_features``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:308
msgid "Texture features."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:310
msgid "``as_present``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:311
msgid "Bitmask encoding the number of address-space exposed by the MMU."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:313
msgid "``pad0``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:314
#: include/uapi/drm/panthor_drm.h:329 include/uapi/drm/panthor_drm.h:474
#: include/uapi/drm/panthor_drm.h:676 include/uapi/drm/panthor_drm.h:687
#: include/uapi/drm/panthor_drm.h:870 include/uapi/drm/panthor_drm.h:884
#: include/uapi/drm/panthor_drm.h:1011 ../../../gpu/driver-uapi:34:
#: include/uapi/drm/asahi_drm.h:1154
msgid "MBZ."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:316
msgid "``shader_present``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:317
msgid "Bitmask encoding the shader cores exposed by the GPU."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:319
msgid "``l2_present``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:320
msgid "Bitmask encoding the L2 caches exposed by the GPU."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:322
msgid "``tiler_present``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:323
msgid "Bitmask encoding the tiler units exposed by the GPU."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:325
msgid "``core_features``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:326
msgid "Used to discriminate core variants when they exist."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:331
msgid "``gpu_features``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:332
msgid "Bitmask describing supported GPU-wide features"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:250
msgid "Structure grouping all queryable information relating to the GPU."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:336
msgid "Command stream interface information"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:341
msgid "``csg_slot_count``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:342
msgid "Number of command stream group slots exposed by the firmware."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:344
msgid "``cs_slot_count``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:345
msgid "Number of command stream slots per group."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:347
msgid "``cs_reg_count``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:348
msgid "Number of command stream registers."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:350
msgid "``scoreboard_slot_count``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:351
msgid "Number of scoreboard slots."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:354
msgid "``unpreserved_cs_reg_count``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:355
msgid ""
"Number of command stream registers reserved by the kernel driver to call a "
"userspace command stream."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:358
msgid ""
"All registers can be used by a userspace command stream, but the "
"[cs_slot_count - unpreserved_cs_reg_count .. cs_slot_count] registers are "
"used by the kernel when DRM_PANTHOR_IOCTL_GROUP_SUBMIT is called."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:365
msgid "Padding field, set to zero."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:337
msgid ""
"Structure grouping all queryable information relating to the command stream "
"interface."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:370
msgid "Timestamp information"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:376
msgid "``timestamp_frequency``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:377
msgid "The frequency of the timestamp timer or 0 if unknown."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:381
msgid "``current_timestamp``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:382
msgid "The current timestamp."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:384
msgid "``timestamp_offset``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:385
msgid "The offset of the timestamp timer."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:371
msgid ""
"Structure grouping all queryable information relating to the GPU timestamp."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:389
msgid "Group priorities information"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:395
msgid "``allowed_mask``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:396
msgid "Bitmask of the allowed group priorities."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:398
msgid "Each bit represents a variant of the enum drm_panthor_group_priority."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:402
#: include/uapi/drm/panthor_drm.h:704
msgid "Padding fields, MBZ."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:390
msgid ""
"Structure grouping all queryable information relating to the allowed group "
"priorities."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:406
msgid "Arguments passed to DRM_PANTHOR_IOCTL_DEV_QUERY"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:409
#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:446
#: include/uapi/drm/xe_drm.h:552 include/uapi/drm/xe_drm.h:1403
#: include/uapi/drm/xe_drm.h:2050
msgid "``type``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:410
msgid "the query type (see drm_panthor_dev_query_type)."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:414
msgid "size of the type being queried."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:416
msgid ""
"If pointer is NULL, size is updated by the driver to provide the output "
"structure size. If pointer is not NULL, the driver will only copy min(size, "
"actual_structure_size) bytes to the pointer, and update the size "
"accordingly. This allows us to extend query types without breaking userspace."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:424
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:228
#: include/uapi/drm/asahi_drm.h:757
msgid "``pointer``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:425
msgid "user pointer to a query type struct."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:427
msgid ""
"Pointer can be NULL, in which case, nothing is copied, but the actual "
"structure size is returned. If not NULL, it must point to a location that's "
"large enough to hold size bytes."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:434
msgid "Arguments passed to DRM_PANTHOR_IOCTL_VM_CREATE"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:438
msgid "VM flags, MBZ."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:440
#: include/uapi/drm/panthor_drm.h:470
msgid "``id``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:441
msgid "Returned VM ID."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:444
msgid "``user_va_range``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:445
msgid "Size of the VA space reserved for user objects."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:447
msgid ""
"The kernel will pick the remaining space to map kernel-only objects to the "
"VM (heap chunks, heap context, ring buffers, kernel synchronization "
"objects, ...). If the space left for kernel objects is too small, kernel "
"object allocation will fail further down the road. One can use "
"drm_panthor_gpu_info::mmu_features to extract the total virtual address "
"range, and chose a user_va_range that leaves some space to the kernel."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:454
msgid ""
"If user_va_range is zero, the kernel will pick a sensible value based on "
"TASK_SIZE and the virtual range supported by the GPU MMU (the kernel/user "
"split should leave enough VA space for userspace processes to support SVM, "
"while still allowing the kernel to map some amount of kernel objects in the "
"kernel VA range). The value chosen by the driver will be returned in "
"**user_va_range**."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:461
msgid ""
"User VA space always starts at 0x0, kernel VA space is always placed after "
"the user VA range."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:467
msgid "Arguments passed to DRM_PANTHOR_IOCTL_VM_DESTROY"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:471
msgid "ID of the VM to destroy."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:478
msgid "VM bind operation flags"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:484
msgid "``DRM_PANTHOR_VM_BIND_OP_MAP_READONLY``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:485
msgid "Map the memory read-only."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:487
#: include/uapi/drm/panthor_drm.h:492 include/uapi/drm/panthor_drm.h:497
msgid "Only valid with DRM_PANTHOR_VM_BIND_OP_TYPE_MAP."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:489
msgid "``DRM_PANTHOR_VM_BIND_OP_MAP_NOEXEC``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:490
msgid "Map the memory not-executable."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:494
msgid "``DRM_PANTHOR_VM_BIND_OP_MAP_UNCACHED``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:495
msgid "Map the memory uncached."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:499
msgid "``DRM_PANTHOR_VM_BIND_OP_TYPE_MASK``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:500
msgid "Mask used to determine the type of operation."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:502
msgid "``DRM_PANTHOR_VM_BIND_OP_TYPE_MAP``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:503
msgid "Map operation."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:505
msgid "``DRM_PANTHOR_VM_BIND_OP_TYPE_UNMAP``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:506
msgid "Unmap operation."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:508
msgid "``DRM_PANTHOR_VM_BIND_OP_TYPE_SYNC_ONLY``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:509
msgid "No VM operation."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:511
msgid "Just serves as a synchronization point on a VM queue."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:513
msgid ""
"Only valid if ``DRM_PANTHOR_VM_BIND_ASYNC`` is set in drm_panthor_vm_bind::"
"flags, and drm_panthor_vm_bind_op::syncs contains at least one element."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:525
msgid "VM bind operation"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:529
msgid "Combination of drm_panthor_vm_bind_op_flags flags."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:532
msgid "``bo_handle``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:533
msgid ""
"Handle of the buffer object to map. MBZ for unmap or sync-only operations."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:539
msgid "Buffer object offset. MBZ for unmap or sync-only operations."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:545
msgid "Virtual address to map/unmap. MBZ for sync-only operations."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:551
msgid "Size to map/unmap. MBZ for sync-only operations."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:556
#: include/uapi/drm/panthor_drm.h:872 ../../../gpu/driver-uapi:29:
#: include/uapi/drm/xe_drm.h:1219 include/uapi/drm/xe_drm.h:1465
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:696
msgid "``syncs``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:557
msgid "Array of struct drm_panthor_sync_op synchronization operations."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:560
msgid ""
"This array must be empty if ``DRM_PANTHOR_VM_BIND_ASYNC`` is not set on the "
"drm_panthor_vm_bind object containing this VM bind operation."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:563
msgid "This array shall not be empty for sync-only operations."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:569
msgid "VM bind flags"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:575
msgid "``DRM_PANTHOR_VM_BIND_ASYNC``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:576
msgid ""
"VM bind operations are queued to the VM queue instead of being executed "
"synchronously."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:580
msgid "Arguments passed to DRM_IOCTL_PANTHOR_VM_BIND"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:584
msgid "VM targeted by the bind request."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:587
msgid "Combination of drm_panthor_vm_bind_flags flags."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:589
msgid "``ops``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:590
msgid "Array of struct drm_panthor_vm_bind_op bind operations."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:594
msgid "VM states."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:600
msgid "``DRM_PANTHOR_VM_STATE_USABLE``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:601
msgid "VM is usable."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:603
msgid "New VM operations will be accepted on this VM."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:605
msgid "``DRM_PANTHOR_VM_STATE_UNUSABLE``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:606
msgid "VM is unusable."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:608
msgid ""
"Something put the VM in an unusable state (like an asynchronous VM_BIND "
"request failing for any reason)."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:611
msgid ""
"Once the VM is in this state, all new MAP operations will be rejected, and "
"any GPU job targeting this VM will fail. UNMAP operations are still accepted."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:615
msgid ""
"The only way to recover from an unusable VM is to create a new VM, and "
"destroy the old one."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:621
msgid "Get VM state."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:625
msgid "VM targeted by the get_state request."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:628
#: include/uapi/drm/panthor_drm.h:929
msgid "``state``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:629
msgid "state returned by the driver."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:631
msgid "Must be one of the enum drm_panthor_vm_state values."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:636
msgid "Buffer object flags, passed at creation time."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:642
msgid "``DRM_PANTHOR_BO_NO_MMAP``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:643
msgid "The buffer object will never be CPU-mapped in userspace."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:644
msgid "Arguments passed to DRM_IOCTL_PANTHOR_BO_CREATE."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:649
msgid "Requested size for the object"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:656
msgid "Flags. Must be a combination of drm_panthor_bo_flags flags."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:660
msgid "``exclusive_vm_id``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:661
msgid "Exclusive VM this buffer object will be mapped to."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:663
msgid "If not zero, the field must refer to a valid VM ID, and implies that:"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:664
msgid "the buffer object will only ever be bound to that VM"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:665
msgid "cannot be exported as a PRIME fd"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:680
msgid "Arguments passed to DRM_IOCTL_PANTHOR_BO_MMAP_OFFSET."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:684
msgid "Handle of the object we want an mmap offset for."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:690
msgid "The fake offset to use for subsequent mmap calls."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:694
msgid "Queue creation arguments."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:698
#: include/uapi/drm/panthor_drm.h:766 ../../../gpu/driver-uapi:34:
#: include/uapi/drm/asahi_drm.h:564
msgid "``priority``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:699
msgid ""
"Defines the priority of queues inside a group. Goes from 0 to 15, 15 being "
"the highest priority."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:706
msgid "``ringbuf_size``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:707
msgid "Size of the ring buffer to allocate to this queue."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:711
msgid "Scheduling group priority"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:717
msgid "``PANTHOR_GROUP_PRIORITY_LOW``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:718
msgid "Low priority group."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:720
msgid "``PANTHOR_GROUP_PRIORITY_MEDIUM``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:721
msgid "Medium priority group."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:723
msgid "``PANTHOR_GROUP_PRIORITY_HIGH``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:724
msgid "High priority group."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:726
#: include/uapi/drm/panthor_drm.h:731
msgid "Requires CAP_SYS_NICE or DRM_MASTER."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:728
msgid "``PANTHOR_GROUP_PRIORITY_REALTIME``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:729
msgid "Realtime priority group."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:736
msgid "Arguments passed to DRM_IOCTL_PANTHOR_GROUP_CREATE"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:739
msgid "``queues``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:740
msgid "Array of drm_panthor_queue_create elements."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:743
msgid "``max_compute_cores``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:744
msgid ""
"Maximum number of cores that can be used by compute jobs across CS queues "
"bound to this group."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:747
msgid ""
"Must be less or equal to the number of bits set in **compute_core_mask**."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:751
msgid "``max_fragment_cores``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:752
msgid ""
"Maximum number of cores that can be used by fragment jobs across CS queues "
"bound to this group."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:755
msgid ""
"Must be less or equal to the number of bits set in **fragment_core_mask**."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:759
msgid "``max_tiler_cores``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:760
msgid ""
"Maximum number of tilers that can be used by tiler jobs across CS queues "
"bound to this group."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:763
msgid "Must be less or equal to the number of bits set in **tiler_core_mask**."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:767
msgid "Group priority (see enum drm_panthor_group_priority)."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:770
#: include/uapi/drm/panthor_drm.h:821 include/uapi/drm/panthor_drm.h:1000
msgid "Padding field, MBZ."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:773
msgid "``compute_core_mask``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:774
msgid "Mask encoding cores that can be used for compute jobs."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:776
msgid "This field must have at least **max_compute_cores** bits set."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:778
#: include/uapi/drm/panthor_drm.h:787
msgid ""
"The bits set here should also be set in drm_panthor_gpu_info::shader_present."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:782
msgid "``fragment_core_mask``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:783
msgid "Mask encoding cores that can be used for fragment jobs."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:785
msgid "This field must have at least **max_fragment_cores** bits set."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:791
msgid "``tiler_core_mask``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:792
msgid "Mask encoding cores that can be used for tiler jobs."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:794
msgid "This field must have at least **max_tiler_cores** bits set."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:796
msgid ""
"The bits set here should also be set in drm_panthor_gpu_info::tiler_present."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:801
msgid "VM ID to bind this group to."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:803
msgid "All submission to queues bound to this group will use this VM."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:807
#: include/uapi/drm/panthor_drm.h:817 include/uapi/drm/panthor_drm.h:880
#: include/uapi/drm/panthor_drm.h:925
msgid "``group_handle``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:808
msgid ""
"Returned group handle. Passed back when submitting jobs or destroying a "
"group."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:814
msgid "Arguments passed to DRM_IOCTL_PANTHOR_GROUP_DESTROY"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:818
msgid "Group to destroy"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:825
msgid "Job submission arguments."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:832
msgid "``queue_index``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:833
msgid "Index of the queue inside a group."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:836
msgid "``stream_size``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:837
msgid "Size of the command stream to execute."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:839
msgid "Must be 64-bit/8-byte aligned (the size of a CS instruction)"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:841
msgid "Can be zero if stream_addr is zero too."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:843
msgid ""
"When the stream size is zero, the queue submit serves as a synchronization "
"point."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:848
msgid "``stream_addr``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:849
msgid "GPU address of the command stream to execute."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:851
msgid "Must be aligned on 64-byte."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:853
msgid "Can be zero is stream_size is zero too."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:857
msgid "``latest_flush``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:858
msgid "FLUSH_ID read at the time the stream was built."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:860
msgid ""
"This allows cache flush elimination for the automatic flush+invalidate(all) "
"done at submission time, which is needed to ensure the GPU doesn't get "
"garbage when reading the indirect command stream buffers. If you want the "
"cache flush to happen unconditionally, pass a zero here."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:866
msgid "Ignored when stream_size is zero."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:873
msgid "Array of struct drm_panthor_sync_op sync operations."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:826
msgid ""
"This is describing the userspace command stream to call from the kernel "
"command stream ring-buffer. Queue submission is always part of a group "
"submission, taking one or more jobs to submit to the underlying queues."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:877
msgid "Arguments passed to DRM_IOCTL_PANTHOR_GROUP_SUBMIT"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:881
msgid "Handle of the group to queue jobs to."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:886
msgid "``queue_submits``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:887
msgid "Array of drm_panthor_queue_submit objects."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:891
msgid "Group state flags"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:897
msgid "``DRM_PANTHOR_GROUP_STATE_TIMEDOUT``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:898
msgid "Group had unfinished jobs."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:900
#: include/uapi/drm/panthor_drm.h:905
msgid ""
"When a group ends up with this flag set, no jobs can be submitted to its "
"queues."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:902
msgid "``DRM_PANTHOR_GROUP_STATE_FATAL_FAULT``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:903
msgid "Group had fatal faults."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:907
msgid "``DRM_PANTHOR_GROUP_STATE_INNOCENT``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:908
msgid "Group was killed during a reset caused by other groups."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:911
msgid ""
"This flag can only be set if DRM_PANTHOR_GROUP_STATE_TIMEDOUT is set and "
"DRM_PANTHOR_GROUP_STATE_FATAL_FAULT is not."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:919
msgid "Arguments passed to DRM_IOCTL_PANTHOR_GROUP_GET_STATE"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:926
msgid "Handle of the group to query state on"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:930
msgid ""
"Combination of DRM_PANTHOR_GROUP_STATE_* flags encoding the group state."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:934
msgid "``fatal_queues``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:935
msgid "Bitmask of queues that faced fatal faults."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:920
msgid ""
"Used to query the state of a group and decide whether a new group should be "
"created to replace it."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:942
msgid "Arguments passed to DRM_IOCTL_PANTHOR_TILER_HEAP_CREATE"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:946
msgid "VM ID the tiler heap should be mapped to"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:948
msgid "``initial_chunk_count``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:949
msgid "Initial number of chunks to allocate. Must be at least one."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:952
msgid "``chunk_size``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:953
msgid "Chunk size."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:955
msgid "Must be page-aligned and lie in the [128k:8M] range."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:959
msgid "``max_chunks``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:960
msgid "Maximum number of chunks that can be allocated."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:962
msgid "Must be at least **initial_chunk_count**."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:966
msgid "``target_in_flight``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:967
msgid "Maximum number of in-flight render passes."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:969
msgid ""
"If the heap has more than tiler jobs in-flight, the FW will wait for render "
"passes to finish before queuing new tiler jobs."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:974
msgid "Returned heap handle. Passed back to DESTROY_TILER_HEAP."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:976
msgid "``tiler_heap_ctx_gpu_va``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:977
msgid "Returned heap GPU virtual address returned"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:980
msgid "``first_heap_chunk_gpu_va``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:981
msgid "First heap chunk."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:983
msgid ""
"The tiler heap is formed of heap chunks forming a single-link list. This is "
"the first element in the list."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:989
msgid "Arguments passed to DRM_IOCTL_PANTHOR_TILER_HEAP_DESTROY"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:994
msgid "Handle of the tiler heap to destroy."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:996
msgid ""
"Must be a valid heap handle returned by DRM_IOCTL_PANTHOR_TILER_HEAP_CREATE."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:1004
msgid "Arguments passed to DRM_IOCTL_PANTHOR_BO_SET_LABEL"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:1008
msgid "Handle of the buffer object to label."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:1014
msgid "``label``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:1015
msgid "User pointer to a NUL-terminated string"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:1017
msgid "Length cannot be greater than 4096"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:1022
msgid "Arguments passed to DRM_IOCTL_PANTHOR_SET_USER_MMIO_OFFSET"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:1032
msgid "User MMIO offset to use."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:1034
msgid ""
"Must be either DRM_PANTHOR_USER_MMIO_OFFSET_32BIT or "
"DRM_PANTHOR_USER_MMIO_OFFSET_64BIT."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:1037
msgid ""
"Use DRM_PANTHOR_USER_MMIO_OFFSET (which selects OFFSET_32BIT or OFFSET_64BIT "
"based on the size of an unsigned long) unless you have a very good reason to "
"overrule this decision."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:1023
msgid ""
"This ioctl is only really useful if you want to support userspace CPU "
"emulation environments where the size of an unsigned long differs between "
"the host and the guest architectures."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:1046
msgid "``DRM_IOCTL_PANTHOR (__access, __id, __type)``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:1044
msgid "Build a Panthor IOCTL number"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:1050
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1167
msgid "``__access``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:1045
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1162
msgid "Access type. Must be R, W or RW."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:1047
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1164
msgid "``__id``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:1046
msgid "One of the DRM_PANTHOR_xxx id."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:1048
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1165
msgid "``__type``"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:1047
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1164
msgid "Suffix of the type being passed to the IOCTL."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:1048
msgid ""
"Don't use this macro directly, use the DRM_IOCTL_PANTHOR_xxx values instead."
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:1051
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1168
msgid "**Return**"
msgstr ""

#: ../../../gpu/driver-uapi:24: include/uapi/drm/panthor_drm.h:1052
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1169
msgid "An IOCTL number to be passed to ioctl() from userspace."
msgstr ""

#: ../../../gpu/driver-uapi.rst:27
msgid "drm/xe uAPI"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:3
msgid "**Xe Device Block Diagram**"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:26
msgid ""
"The diagram below represents a high-level simplification of a discrete GPU "
"supported by the Xe driver. It shows some device components which are "
"necessary to understand this API, as well as how their relations to each "
"other. This diagram does not represent real hardware::"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:64
msgid "**Xe uAPI Overview**"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:65
msgid ""
"This section aims to describe the Xe's IOCTL entries, its structs, and other "
"Xe related uAPI such as uevents and PMU (Platform Monitoring Unit) related "
"entries and usage."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:69
msgid "List of supported IOCTLs:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:70
msgid ":c:type:`DRM_IOCTL_XE_DEVICE_QUERY`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:71
msgid ":c:type:`DRM_IOCTL_XE_GEM_CREATE`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:72
msgid ":c:type:`DRM_IOCTL_XE_GEM_MMAP_OFFSET`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:73
msgid ":c:type:`DRM_IOCTL_XE_VM_CREATE`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:74
msgid ":c:type:`DRM_IOCTL_XE_VM_DESTROY`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:75
msgid ":c:type:`DRM_IOCTL_XE_VM_BIND`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:76
msgid ":c:type:`DRM_IOCTL_XE_EXEC_QUEUE_CREATE`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:77
msgid ":c:type:`DRM_IOCTL_XE_EXEC_QUEUE_DESTROY`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:78
msgid ":c:type:`DRM_IOCTL_XE_EXEC_QUEUE_GET_PROPERTY`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:79
msgid ":c:type:`DRM_IOCTL_XE_EXEC`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:80
msgid ":c:type:`DRM_IOCTL_XE_WAIT_USER_FENCE`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:81
msgid ":c:type:`DRM_IOCTL_XE_OBSERVATION`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:82
msgid ":c:type:`DRM_IOCTL_XE_MADVISE`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:83
msgid ":c:type:`DRM_IOCTL_XE_VM_QUERY_MEM_RANGE_ATTRS`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:88
msgid "**Xe IOCTL Extensions**"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:128
msgid ""
"Before detailing the IOCTLs and its structs, it is important to highlight "
"that every IOCTL in Xe is extensible."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:160
msgid ""
"Typically the struct drm_xe_user_extension would be embedded in some uAPI "
"struct, and in this case we would feed it the head of the chain(i.e ext1), "
"which would then apply all of the above extensions."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:173
msgid "Pointer to the next struct drm_xe_user_extension, or zero if the end."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:184
msgid ""
"Also note that the name space for this is not global for the whole driver, "
"but rather its scope/meaning is limited to the specific piece of uAPI which "
"has embedded the struct drm_xe_user_extension."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:198
msgid "Generic set property extension"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:205
msgid "base user extension"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:207
#: include/uapi/drm/xe_drm.h:1351
msgid "``property``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:208
msgid "property to set"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:214
#: include/uapi/drm/xe_drm.h:1355
msgid "property value"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:216
#: include/uapi/drm/xe_drm.h:261 include/uapi/drm/xe_drm.h:367
#: include/uapi/drm/xe_drm.h:486 include/uapi/drm/xe_drm.h:640
#: include/uapi/drm/xe_drm.h:760 include/uapi/drm/xe_drm.h:875
#: include/uapi/drm/xe_drm.h:922 include/uapi/drm/xe_drm.h:966
#: include/uapi/drm/xe_drm.h:980 include/uapi/drm/xe_drm.h:1151
#: include/uapi/drm/xe_drm.h:1222 include/uapi/drm/xe_drm.h:1319
#: include/uapi/drm/xe_drm.h:1333 include/uapi/drm/xe_drm.h:1357
#: include/uapi/drm/xe_drm.h:1431 include/uapi/drm/xe_drm.h:1483
#: include/uapi/drm/xe_drm.h:1568 include/uapi/drm/xe_drm.h:1679
#: include/uapi/drm/xe_drm.h:1897 include/uapi/drm/xe_drm.h:1912
#: include/uapi/drm/xe_drm.h:1993 include/uapi/drm/xe_drm.h:2130
#: include/uapi/drm/xe_drm.h:2188 include/uapi/drm/xe_drm.h:2267
msgid "``reserved``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:217
#: include/uapi/drm/xe_drm.h:262 include/uapi/drm/xe_drm.h:368
#: include/uapi/drm/xe_drm.h:487 include/uapi/drm/xe_drm.h:641
#: include/uapi/drm/xe_drm.h:761 include/uapi/drm/xe_drm.h:876
#: include/uapi/drm/xe_drm.h:923 include/uapi/drm/xe_drm.h:967
#: include/uapi/drm/xe_drm.h:981 include/uapi/drm/xe_drm.h:1152
#: include/uapi/drm/xe_drm.h:1223 include/uapi/drm/xe_drm.h:1320
#: include/uapi/drm/xe_drm.h:1334 include/uapi/drm/xe_drm.h:1358
#: include/uapi/drm/xe_drm.h:1432 include/uapi/drm/xe_drm.h:1484
#: include/uapi/drm/xe_drm.h:1569 include/uapi/drm/xe_drm.h:1994
#: include/uapi/drm/xe_drm.h:2131 include/uapi/drm/xe_drm.h:2189
#: include/uapi/drm/xe_drm.h:2268
msgid "Reserved"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:199
msgid ""
"A generic struct that allows any of the Xe's IOCTL to be extended with a "
"set_property operation."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:221
msgid "instance of an engine class"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:245
msgid "engine class id"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:247
msgid "engine instance id"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:248
#: include/uapi/drm/xe_drm.h:450 include/uapi/drm/xe_drm.h:544
msgid "``gt_id``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:249
#: include/uapi/drm/xe_drm.h:451
msgid "Unique ID of this GT within the PCI Device"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:222
msgid ""
"It is returned as part of the **drm_xe_engine**, but it also is used as the "
"input of engine selection for both **drm_xe_exec_queue_create** and "
"**drm_xe_query_engine_cycles**"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:226
msgid "The **engine_class** can be:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:227
msgid "``DRM_XE_ENGINE_CLASS_RENDER``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:228
msgid "``DRM_XE_ENGINE_CLASS_COPY``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:229
msgid "``DRM_XE_ENGINE_CLASS_VIDEO_DECODE``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:230
msgid "``DRM_XE_ENGINE_CLASS_VIDEO_ENHANCE``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:231
msgid "``DRM_XE_ENGINE_CLASS_COMPUTE``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:232
msgid ""
"``DRM_XE_ENGINE_CLASS_VM_BIND`` - Kernel only classes (not actual hardware "
"engine class). Used for creating ordered queues of VM bind operations."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:255
msgid "describe hardware engine"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:258
#: include/uapi/drm/xe_drm.h:307
msgid "``instance``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:259
msgid "The **drm_xe_engine_class_instance**"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:266
msgid "describe engines"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:274
msgid "number of engines returned in **engines**"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:278
msgid "The returned engines for this device"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:267
msgid ""
"If a query is made with a struct **drm_xe_device_query** where .query is "
"equal to ``DRM_XE_DEVICE_QUERY_ENGINES``, then the reply uses an array of "
"struct **drm_xe_query_engines** in .data."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:282
msgid "Supported memory classes."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:288
msgid "``DRM_XE_MEM_REGION_CLASS_SYSMEM``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:289
msgid "Represents system memory."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:291
msgid "``DRM_XE_MEM_REGION_CLASS_VRAM``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:292
msgid ""
"On discrete platforms, this represents the memory that is local to the "
"device, which we call VRAM. Not valid on integrated platforms."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:296
msgid "Describes some region as known to the driver."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:301
msgid "``mem_class``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:302
msgid "The memory class describing this region."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:304
msgid "See enum drm_xe_memory_class for supported values."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:308
msgid ""
"The unique ID for this region, which serves as the index in the placement "
"bitmask used as argument for :c:type:`DRM_IOCTL_XE_GEM_CREATE`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:313
msgid "``min_page_size``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:314
msgid "Min page-size in bytes for this region."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:316
msgid ""
"When the kernel allocates memory for this region, the underlying pages will "
"be at least **min_page_size** in size. Buffer objects with an allowable "
"placement in this region must be created with a size aligned to this value. "
"GPU virtual address mappings of (parts of) buffer objects that may be placed "
"in this region must also have their GPU virtual address and range aligned to "
"this value. Affected IOCTLS will return ``-EINVAL`` if alignment "
"restrictions are not met."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:327
msgid "``total_size``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:328
msgid "The usable size in bytes for this region."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:331
msgid "``used``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:332
msgid "Estimate of the memory used in bytes for this region."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:334
msgid ""
"Requires CAP_PERFMON or CAP_SYS_ADMIN to get reliable accounting.  Without "
"this the value here will always equal zero."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:339
msgid "``cpu_visible_size``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:340
msgid "How much of this region can be CPU accessed, in bytes."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:343
msgid ""
"This will always be <= **total_size**, and the remainder (if any) will not "
"be CPU accessible. If the CPU accessible part is smaller than **total_size** "
"then this is referred to as a small BAR system."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:348
msgid ""
"On systems without small BAR (full BAR), the probed_size will always equal "
"the **total_size**, since all of it will be CPU accessible."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:352
msgid ""
"Note this is only tracked for DRM_XE_MEM_REGION_CLASS_VRAM regions (for "
"other types the value here will always equal zero)."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:357
msgid "``cpu_visible_used``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:358
msgid "Estimate of CPU visible memory used, in bytes."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:361
msgid ""
"Requires CAP_PERFMON or CAP_SYS_ADMIN to get reliable accounting. Without "
"this the value here will always equal zero.  Note this is only currently "
"tracked for DRM_XE_MEM_REGION_CLASS_VRAM regions (for other types the value "
"here will always be zero)."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:372
msgid "describe memory regions"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:379
msgid "``num_mem_regions``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:380
msgid "number of memory regions returned in **mem_regions**"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:383
msgid "``mem_regions``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:384
msgid "The returned memory regions for this device"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:373
msgid ""
"If a query is made with a struct drm_xe_device_query where .query is equal "
"to DRM_XE_DEVICE_QUERY_MEM_REGIONS, then the reply uses struct "
"drm_xe_query_mem_regions in .data."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:388
msgid "describe the device configuration"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:413
msgid "``num_params``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:414
msgid "number of parameters returned in info"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:427
msgid "``info``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:428
msgid "array of elements containing the config info"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:389
msgid ""
"If a query is made with a struct drm_xe_device_query where .query is equal "
"to DRM_XE_DEVICE_QUERY_CONFIG, then the reply uses struct "
"drm_xe_query_config in .data."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:393
msgid "The index in **info** can be:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:394
msgid ""
"``DRM_XE_QUERY_CONFIG_REV_AND_DEVICE_ID`` - Device ID (lower 16 bits) and "
"the device revision (next 8 bits)"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:396
msgid ""
"``DRM_XE_QUERY_CONFIG_FLAGS`` - Flags describing the device configuration, "
"see list below"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:399
msgid ""
"``DRM_XE_QUERY_CONFIG_FLAG_HAS_VRAM`` - Flag is set if the device has usable "
"VRAM"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:401
msgid ""
"``DRM_XE_QUERY_CONFIG_FLAG_HAS_LOW_LATENCY`` - Flag is set if the device has "
"low latency hint support"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:403
msgid ""
"``DRM_XE_QUERY_CONFIG_FLAG_HAS_CPU_ADDR_MIRROR`` - Flag is set if the device "
"has CPU address mirroring support"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:405
msgid ""
"``DRM_XE_QUERY_CONFIG_MIN_ALIGNMENT`` - Minimal memory alignment required by "
"this device, typically SZ_4K or SZ_64K"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:407
msgid "``DRM_XE_QUERY_CONFIG_VA_BITS`` - Maximum bits of a virtual address"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:408
msgid ""
"``DRM_XE_QUERY_CONFIG_MAX_EXEC_QUEUE_PRIORITY`` - Value of the highest "
"available exec queue priority"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:432
msgid "describe an individual GT."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:447
msgid "GT type: Main or Media"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:448
msgid "``tile_id``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:449
msgid "Tile ID where this GT lives (Information only)"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:454
msgid "``reference_clock``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:455
msgid "A clock frequency for timestamp"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:457
msgid "``near_mem_regions``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:458
msgid ""
"Bit mask of instances from drm_xe_query_mem_regions that are nearest to the "
"current engines of this GT. Each index in this mask refers directly to the "
"struct drm_xe_query_mem_regions' instance, no assumptions should be made "
"about order. The type of each region is described by struct "
"drm_xe_query_mem_regions' mem_class."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:467
msgid "``far_mem_regions``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:468
msgid ""
"Bit mask of instances from drm_xe_query_mem_regions that are far from the "
"engines of this GT. In general, they have extra indirections when compared "
"to the **near_mem_regions**. For a discrete device this could mean system "
"memory and memory living in a different tile. Each index in this mask refers "
"directly to the struct drm_xe_query_mem_regions' instance, no assumptions "
"should be made about order. The type of each region is described by struct "
"drm_xe_query_mem_regions' mem_class."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:478
msgid "``ip_ver_major``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:479
msgid "Graphics/media IP major version on GMD_ID platforms"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:480
msgid "``ip_ver_minor``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:481
msgid "Graphics/media IP minor version on GMD_ID platforms"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:482
msgid "``ip_ver_rev``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:483
msgid "Graphics/media IP revision version on GMD_ID platforms"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:484
#: include/uapi/drm/xe_drm.h:637 include/uapi/drm/xe_drm.h:1148
#: include/uapi/drm/xe_drm.h:1213 include/uapi/drm/xe_drm.h:1565
msgid "``pad2``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:433
msgid ""
"To be used with drm_xe_query_gt_list, which will return a list with all the "
"existing GT individual descriptions. Graphics Technology (GT) is a subset of "
"a GPU/tile that is responsible for implementing graphics and/or media "
"operations."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:438
msgid "The index in **type** can be:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:439
msgid "``DRM_XE_QUERY_GT_TYPE_MAIN``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:440
msgid "``DRM_XE_QUERY_GT_TYPE_MEDIA``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:491
msgid "A list with GT description items."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:498
msgid "``num_gt``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:499
msgid "number of GT items returned in gt_list"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:502
msgid "``gt_list``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:503
msgid "The GT list returned for this device"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:492
msgid ""
"If a query is made with a struct drm_xe_device_query where .query is equal "
"to DRM_XE_DEVICE_QUERY_GT_LIST, then the reply uses struct "
"drm_xe_query_gt_list in .data."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:507
msgid "describe the topology mask of a GT"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:545
msgid "GT ID the mask is associated with"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:553
msgid "type of mask"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:555
msgid "``num_bytes``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:556
msgid "number of bytes in requested mask"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:558
#: include/uapi/drm/xe_drm.h:1543
msgid "``mask``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:559
msgid "little-endian mask of **num_bytes**"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:508
msgid ""
"This is the hardware topology which reflects the internal physical structure "
"of the GPU."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:511
msgid ""
"If a query is made with a struct drm_xe_device_query where .query is equal "
"to DRM_XE_DEVICE_QUERY_GT_TOPOLOGY, then the reply uses struct "
"drm_xe_query_topology_mask in .data."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:515
#: include/uapi/drm/xe_drm.h:1363
msgid "The **type** can be:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:516
msgid ""
"``DRM_XE_TOPO_DSS_GEOMETRY`` - To query the mask of Dual Sub Slices (DSS) "
"available for geometry operations. For example a query response containing "
"the following in mask: ``DSS_GEOMETRY    ff ff ff ff 00 00 00 00`` means 32 "
"DSS are available for geometry."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:521
msgid ""
"``DRM_XE_TOPO_DSS_COMPUTE`` - To query the mask of Dual Sub Slices (DSS) "
"available for compute operations. For example a query response containing "
"the following in mask: ``DSS_COMPUTE    ff ff ff ff 00 00 00 00`` means 32 "
"DSS are available for compute."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:526
msgid ""
"``DRM_XE_TOPO_L3_BANK`` - To query the mask of enabled L3 banks.  This type "
"may be omitted if the driver is unable to query the mask from the hardware."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:529
msgid ""
"``DRM_XE_TOPO_EU_PER_DSS`` - To query the mask of Execution Units (EU) "
"available per Dual Sub Slices (DSS). For example a query response containing "
"the following in mask: ``EU_PER_DSS    ff ff 00 00 00 00 00 00`` means each "
"DSS has 16 SIMD8 EUs. This type may be omitted if device doesn't have SIMD8 "
"EUs."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:535
msgid ""
"``DRM_XE_TOPO_SIMD16_EU_PER_DSS`` - To query the mask of SIMD16 Execution "
"Units (EU) available per Dual Sub Slices (DSS). For example a query response "
"containing the following in mask: ``SIMD16_EU_PER_DSS    ff ff 00 00 00 00 "
"00 00`` means each DSS has 16 SIMD16 EUs. This type may be omitted if device "
"doesn't have SIMD16 EUs."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:563
msgid "correlate CPU and GPU timestamps"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:577
#: include/uapi/drm/xe_drm.h:1685
msgid "``eci``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:578
msgid ""
"This is input by the user and is the engine for which command streamer "
"cycles is queried."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:583
msgid "``clockid``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:584
msgid ""
"This is input by the user and is the reference clock id for CPU timestamp. "
"For definition, see clock_gettime(2) and perf_event_open(2). Supported clock "
"ids are CLOCK_MONOTONIC, CLOCK_MONOTONIC_RAW, CLOCK_REALTIME, "
"CLOCK_BOOTTIME, CLOCK_TAI."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:591
msgid "Width of the engine cycle counter in bits."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:594
msgid "``engine_cycles``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:595
msgid "Engine cycles as read from its register at 0x358 offset."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:600
msgid "``cpu_timestamp``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:601
msgid ""
"CPU timestamp in ns. The timestamp is captured before reading the "
"engine_cycles register using the reference clockid set by the user."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:607
msgid "``cpu_delta``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:608
msgid ""
"Time delta in ns captured around reading the lower dword of the "
"engine_cycles register."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:564
msgid ""
"If a query is made with a struct drm_xe_device_query where .query is equal "
"to DRM_XE_DEVICE_QUERY_ENGINE_CYCLES, then the reply uses struct "
"drm_xe_query_engine_cycles in .data. struct drm_xe_query_engine_cycles is "
"allocated by the user and .data points to this allocated structure."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:569
msgid ""
"The query returns the engine cycles, which along with GT's "
"**reference_clock**, can be used to calculate the engine timestamp. In "
"addition the query returns a set of cpu timestamps that indicate when the "
"command streamer cycle count was captured."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:614
msgid "query a micro-controller firmware version"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:620
msgid "``uc_type``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:621
msgid "The micro-controller type to query firmware version"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:628
msgid "``branch_ver``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:629
msgid "branch uc fw version"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:630
msgid "``major_ver``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:631
msgid "major uc fw version"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:632
msgid "``minor_ver``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:633
msgid "minor uc fw version"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:634
msgid "``patch_ver``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:635
msgid "patch uc fw version"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:615
msgid ""
"Given a uc_type this will return the branch, major, minor and patch version "
"of the micro-controller firmware."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:645
msgid "query if PXP is ready"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:670
msgid "``status``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:671
msgid "current PXP status"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:673
msgid "``supported_session_types``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:674
msgid "bitmask of supported PXP session types"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:646
msgid ""
"If PXP is enabled and no fatal error has occurred, the status will be set to "
"one of the following values: 0: PXP init still in progress 1: PXP init "
"complete"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:651
msgid ""
"If PXP is not enabled or something has gone wrong, the query will be failed "
"with one of the following error codes: -ENODEV: PXP not supported or "
"disabled; -EIO: fatal error occurred during init, so PXP will never be "
"enabled; -EINVAL: incorrect value provided as part of the query; -EFAULT: "
"error copying the memory between kernel and userspace."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:658
msgid ""
"The status can only be 0 in the first few seconds after driver load. If "
"everything works as expected, the status will transition to init complete in "
"less than 1 second, while in case of errors the driver might take longer to "
"start returning an error code, but it should still take less than 10 seconds."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:663
msgid ""
"The supported session type bitmask is based on the values in enum "
"drm_xe_pxp_session_type. TYPE_NONE is always supported and therefore is not "
"reported in the bitmask."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:678
msgid ""
"Input of :c:type:`DRM_IOCTL_XE_DEVICE_QUERY` - main structure to query "
"device information"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:738
#: include/uapi/drm/xe_drm.h:816 include/uapi/drm/xe_drm.h:910
#: include/uapi/drm/xe_drm.h:955 include/uapi/drm/xe_drm.h:1037
#: include/uapi/drm/xe_drm.h:1184 include/uapi/drm/xe_drm.h:1292
#: include/uapi/drm/xe_drm.h:1345 include/uapi/drm/xe_drm.h:1398
#: include/uapi/drm/xe_drm.h:1457 include/uapi/drm/xe_drm.h:1517
#: include/uapi/drm/xe_drm.h:1606 include/uapi/drm/xe_drm.h:1660
#: include/uapi/drm/xe_drm.h:1715 include/uapi/drm/xe_drm.h:1865
#: include/uapi/drm/xe_drm.h:1888 include/uapi/drm/xe_drm.h:1907
#: include/uapi/drm/xe_drm.h:1981 include/uapi/drm/xe_drm.h:2036
#: include/uapi/drm/xe_drm.h:2153 include/uapi/drm/xe_drm.h:2247
msgid "Pointer to the first extension struct, if any"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:751
msgid "``query``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:752
msgid "The type of data to query"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:755
msgid "Size of the queried data"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:758
msgid "Queried data is placed here"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:679
msgid ""
"The user selects the type of data to query among DRM_XE_DEVICE_QUERY_* and "
"sets the value in the query member. This determines the type of the "
"structure provided by the driver in data, among struct drm_xe_query_*."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:683
msgid "The **query** can be:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:684
msgid "``DRM_XE_DEVICE_QUERY_ENGINES``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:685
msgid "``DRM_XE_DEVICE_QUERY_MEM_REGIONS``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:686
msgid "``DRM_XE_DEVICE_QUERY_CONFIG``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:687
msgid "``DRM_XE_DEVICE_QUERY_GT_LIST``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:688
msgid ""
"``DRM_XE_DEVICE_QUERY_HWCONFIG`` - Query type to retrieve the hardware "
"configuration of the device such as information on slices, memory, caches, "
"and so on. It is provided as a table of key / value attributes."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:692
msgid "``DRM_XE_DEVICE_QUERY_GT_TOPOLOGY``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:693
msgid "``DRM_XE_DEVICE_QUERY_ENGINE_CYCLES``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:694
msgid "``DRM_XE_DEVICE_QUERY_PXP_STATUS``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:696
msgid ""
"If size is set to 0, the driver fills it with the required size for the "
"requested type of data to query. If size is equal to the required size, the "
"queried information is copied into data. If size is set to a value different "
"from 0 and different from the required size, the IOCTL call returns -EINVAL."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:702
msgid ""
"For example the following code snippet allows retrieving and printing "
"information about the device engines with DRM_XE_DEVICE_QUERY_ENGINES:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:765
msgid ""
"Input of :c:type:`DRM_IOCTL_XE_GEM_CREATE` - A structure for gem creation"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:820
msgid ""
"Size of the object to be created, must match region (system or vram) minimum "
"alignment (:c:type:`min_page_size`)."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:825
msgid "``placement``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:826
msgid ""
"A mask of memory instances of where BO can be placed. Each index in this "
"mask refers directly to the struct drm_xe_query_mem_regions' instance, no "
"assumptions should be made about order. The type of each region is described "
"by struct drm_xe_query_mem_regions' mem_class."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:838
msgid "Flags, currently a mask of memory instances of where BO can be placed"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:844
msgid "Attached VM, if any"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:846
msgid "If a VM is specified, this BO must:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:848
msgid "Only ever be bound to that VM."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:849
msgid "Cannot be exported as a PRIME fd."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:862
msgid "``cpu_caching``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:863
msgid ""
"The CPU caching mode to select for this object. If mmaping the object the "
"mode selected here will also be used. The exception is when mapping system "
"memory (including data evicted to system) on discrete GPUs. The caching mode "
"selected will then be overridden to DRM_XE_GEM_CPU_CACHING_WB, and coherency "
"between GPU- and CPU is guaranteed. The caching mode of existing CPU-"
"mappings will be updated transparently to user-space clients."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:766
#: include/uapi/drm/xe_drm.h:881 include/uapi/drm/xe_drm.h:928
msgid "The **flags** can be:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:767
msgid ""
"``DRM_XE_GEM_CREATE_FLAG_DEFER_BACKING`` - Modify the GEM object allocation "
"strategy by deferring physical memory allocation until the object is either "
"bound to a virtual memory region via VM_BIND or accessed by the CPU. As a "
"result, no backing memory is reserved at the time of GEM object creation."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:772
msgid "``DRM_XE_GEM_CREATE_FLAG_SCANOUT``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:773
msgid ""
"``DRM_XE_GEM_CREATE_FLAG_NEEDS_VISIBLE_VRAM`` - When using VRAM as a "
"possible placement, ensure that the corresponding VRAM allocation will "
"always use the CPU accessible part of VRAM. This is important for small-bar "
"systems (on full-bar systems this gets turned into a noop). Note1: System "
"memory can be used as an extra placement if the kernel should spill the "
"allocation to system memory, if space can't be made available in the CPU "
"accessible part of VRAM (giving the same behaviour as the i915 interface, "
"see I915_GEM_CREATE_EXT_FLAG_NEEDS_CPU_ACCESS). Note2: For clear-color CCS "
"surfaces the kernel needs to read the clear-color value stored in the "
"buffer, and on discrete platforms we need to use VRAM for display surfaces, "
"therefore the kernel requires setting this flag for such objects, otherwise "
"an error is thrown on small-bar systems."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:789
msgid "**cpu_caching** supports the following values:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:790
msgid ""
"``DRM_XE_GEM_CPU_CACHING_WB`` - Allocate the pages with write-back caching. "
"On iGPU this can't be used for scanout surfaces. Currently not allowed for "
"objects placed in VRAM."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:793
msgid ""
"``DRM_XE_GEM_CPU_CACHING_WC`` - Allocate the pages as write-combined. This "
"is uncached. Scanout surfaces should likely use this. All objects that can "
"be placed in VRAM must use this."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:797
msgid ""
"This ioctl supports setting the following properties via the "
"``DRM_XE_GEM_CREATE_EXTENSION_SET_PROPERTY`` extension, which uses the "
"generic **drm_xe_ext_set_property** struct:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:801
msgid ""
"``DRM_XE_GEM_CREATE_SET_PROPERTY_PXP_TYPE`` - set the type of PXP session "
"this object will be used with. Valid values are listed in enum "
"drm_xe_pxp_session_type. ``DRM_XE_PXP_TYPE_NONE`` is the default behavior, "
"so there is no need to explicitly set that. Objects used with session of "
"type ``DRM_XE_PXP_TYPE_HWDRM`` will be marked as invalid if a PXP "
"invalidation event occurs after their creation. Attempting to flip an "
"invalid object will cause a black frame to be displayed instead. Submissions "
"with invalid objects mapped in the VM will be rejected."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:880
msgid "Input of :c:type:`DRM_IOCTL_XE_GEM_MMAP_OFFSET`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:917
#: include/uapi/drm/xe_drm.h:961
msgid "Flags"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:882
msgid ""
"``DRM_XE_MMAP_OFFSET_FLAG_PCI_BARRIER`` - For user to query special offset "
"for use in mmap ioctl. Writing to the returned mmap address will generate a "
"PCI memory barrier with low overhead (avoiding IOCTL call as well as writing "
"to VRAM which would also add overhead), acting like an MI_MEM_FENCE "
"instruction."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:888
#: include/uapi/drm/xe_drm.h:1026
msgid "**Note**"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:889
msgid ""
"The mmap size can be at most 4K, due to HW limitations. As a result this "
"interface is only supported on CPU architectures that support 4K page size. "
"The mmap_offset ioctl will detect this and gracefully return an error, where "
"userspace is expected to have a different fallback method for triggering a "
"barrier."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:895
msgid "Roughly the usage would be as follows:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:927
msgid "Input of :c:type:`DRM_IOCTL_XE_VM_CREATE`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:964
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:265
msgid "Returned VM ID"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:929
msgid ""
"``DRM_XE_VM_CREATE_FLAG_SCRATCH_PAGE`` - Map the whole virtual address space "
"of the VM to scratch page. A vm_bind would overwrite the scratch page "
"mapping. This flag is mutually exclusive with the "
"``DRM_XE_VM_CREATE_FLAG_FAULT_MODE`` flag, with an exception of on x2 and "
"xe3 platform."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:934
msgid ""
"``DRM_XE_VM_CREATE_FLAG_LR_MODE`` - An LR, or Long Running VM accepts exec "
"submissions to its exec_queues that don't have an upper time limit on the "
"job execution time. But exec submissions to these don't allow any of the "
"sync types DRM_XE_SYNC_TYPE_SYNCOBJ, DRM_XE_SYNC_TYPE_TIMELINE_SYNCOBJ, used "
"as out-syncobjs, that is, together with sync flag DRM_XE_SYNC_FLAG_SIGNAL. "
"LR VMs can be created in recoverable page-fault mode using "
"DRM_XE_VM_CREATE_FLAG_FAULT_MODE, if the device supports it. If that flag is "
"omitted, the UMD can not rely on the slightly different per-VM overcommit "
"semantics that are enabled by DRM_XE_VM_CREATE_FLAG_FAULT_MODE (see below), "
"but KMD may still enable recoverable pagefaults if supported by the device."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:946
msgid ""
"``DRM_XE_VM_CREATE_FLAG_FAULT_MODE`` - Requires also "
"DRM_XE_VM_CREATE_FLAG_LR_MODE. It allows memory to be allocated on demand "
"when accessed, and also allows per-VM overcommit of memory. The xe driver "
"internally uses recoverable pagefaults to implement this."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:971
msgid "Input of :c:type:`DRM_IOCTL_XE_VM_DESTROY`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:975
msgid "VM ID"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:985
msgid "run bind operations"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1040
msgid "``obj``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1041
msgid "GEM object to operate on, MBZ for MAP_USERPTR, MBZ for UNMAP"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1046
msgid ""
"The platform defined **pat_index** to use for this mapping. The index "
"basically maps to some predefined memory attributes, including things like "
"caching, coherency, compression etc.  The exact meaning of the pat_index is "
"platform specific and defined in the Bspec and PRMs.  When the KMD sets up "
"the binding the index here is encoded into the ppGTT PTE."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1053
msgid ""
"For coherency the **pat_index** needs to be at least 1way coherent when "
"drm_xe_gem_create.cpu_caching is DRM_XE_GEM_CPU_CACHING_WB. The KMD will "
"extract the coherency mode from the **pat_index** and reject if there is a "
"mismatch (see note below for pre-MTL platforms)."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1058
msgid ""
"Note: On pre-MTL platforms there is only a caching mode and no explicit "
"coherency mode, but on such hardware there is always a shared-LLC (or is "
"dgpu) so all GT memory accesses are coherent with CPU caches even with the "
"caching mode set as uncached.  It's only the display engine that is "
"incoherent (on dgpu it must be in VRAM which is always mapped as WC on the "
"CPU). However to keep the uapi somewhat consistent with newer platforms the "
"KMD groups the different cache levels into the following coherency buckets "
"on all pre-MTL platforms:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1067
msgid ""
"ppGTT UC -> COH_NONE ppGTT WC -> COH_NONE ppGTT WT -> COH_NONE ppGTT WB -> "
"COH_AT_LEAST_1WAY"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1072
msgid ""
"In practice UC/WC/WT should only ever used for scanout surfaces on such "
"platforms (or perhaps in general for dma-buf if shared with another device) "
"since it is only the display engine that is actually incoherent.  Everything "
"else should typically use WB given that we have a shared-LLC.  On MTL+ this "
"completely changes and the HW defines the coherency mode as part of the "
"**pat_index**, where incoherent GT access is possible."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1080
msgid ""
"Note: For userptr and externally imported dma-buf the kernel expects either "
"1WAY or 2WAY for the **pat_index**."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1083
msgid ""
"For DRM_XE_VM_BIND_FLAG_NULL bindings there are no KMD restrictions on the "
"**pat_index**. For such mappings there is no actual memory being mapped (the "
"address in the PTE is invalid), so the various PAT memory attributes likely "
"do not apply.  Simply leaving as zero is one option (still a valid "
"pat_index). Same applies to DRM_XE_VM_BIND_FLAG_CPU_ADDR_MIRROR bindings as "
"for such mapping there is no actual memory being mapped."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1097
msgid "``obj_offset``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1098
msgid "Offset into the object, MBZ for CLEAR_RANGE, ignored for unbind"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1102
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:422
msgid "``userptr``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1103
msgid "user pointer to bind on"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1106
msgid "``cpu_addr_mirror_offset``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1107
msgid ""
"Offset from GPU **addr** to create CPU address mirror mappings. MBZ with "
"current level of support (e.g. 1 to 1 mapping between GPU and CPU mappings "
"only supported)."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1116
msgid "Number of bytes from the object to bind to addr, MBZ for UNMAP_ALL"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1120
msgid "Address to operate on, MBZ for UNMAP_ALL"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1128
msgid "Bind operation to perform"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1138
msgid "Bind flags"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1142
msgid "``prefetch_mem_region_instance``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1143
msgid ""
"Memory region to prefetch VMA to. It is a region instance, not a mask. To be "
"used only with ``DRM_XE_VM_BIND_OP_PREFETCH`` operation."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:986
#: include/uapi/drm/xe_drm.h:1496
msgid "The **op** can be:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:987
msgid "``DRM_XE_VM_BIND_OP_MAP``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:988
msgid "``DRM_XE_VM_BIND_OP_UNMAP``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:989
msgid "``DRM_XE_VM_BIND_OP_MAP_USERPTR``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:990
msgid "``DRM_XE_VM_BIND_OP_UNMAP_ALL``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:991
msgid "``DRM_XE_VM_BIND_OP_PREFETCH``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:993
#: include/uapi/drm/xe_drm.h:1368 include/uapi/drm/xe_drm.h:1504
msgid "and the **flags** can be:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:994
msgid ""
"``DRM_XE_VM_BIND_FLAG_READONLY`` - Setup the page tables as read-only to "
"ensure write protection"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:996
msgid ""
"``DRM_XE_VM_BIND_FLAG_IMMEDIATE`` - On a faulting VM, do the MAP operation "
"immediately rather than deferring the MAP to the page fault handler. This is "
"implied on a non-faulting VM as there is no fault handler to defer to."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1000
msgid ""
"``DRM_XE_VM_BIND_FLAG_NULL`` - When the NULL flag is set, the page tables "
"are setup with a special bit which indicates writes are dropped and all "
"reads return zero. In the future, the NULL flags will only be valid for "
"DRM_XE_VM_BIND_OP_MAP operations, the BO handle MBZ, and the BO offset MBZ. "
"This flag is intended to implement VK sparse bindings."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1006
msgid ""
"``DRM_XE_VM_BIND_FLAG_CHECK_PXP`` - If the object is encrypted via PXP, "
"reject the binding if the encryption key is no longer valid. This flag has "
"no effect on BOs that are not marked as using PXP."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1009
msgid ""
"``DRM_XE_VM_BIND_FLAG_CPU_ADDR_MIRROR`` - When the CPU address mirror flag "
"is set, no mappings are created rather the range is reserved for CPU address "
"mirroring which will be populated on GPU page faults or prefetches. Only "
"valid on VMs with DRM_XE_VM_CREATE_FLAG_FAULT_MODE set. The CPU address "
"mirror flag are only valid for DRM_XE_VM_BIND_OP_MAP operations, the BO "
"handle MBZ, and the BO offset MBZ."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1015
msgid ""
"``DRM_XE_VM_BIND_FLAG_MADVISE_AUTORESET`` - Can be used in combination with "
"``DRM_XE_VM_BIND_FLAG_CPU_ADDR_MIRROR`` to reset madvises when the "
"underlying CPU address space range is unmapped (typically with munmap(2) or "
"brk(2)). The madvise values set with :c:type:`DRM_IOCTL_XE_MADVISE` are "
"reset to the values that were present immediately after the :c:type:"
"`DRM_IOCTL_XE_VM_BIND`. The reset GPU virtual address range is the "
"intersection of the range bound using :c:type:`DRM_IOCTL_XE_VM_BIND` and the "
"virtual CPU address space range unmapped. This functionality is present to "
"mimic the behaviour of CPU address space madvises set using madvise(2), "
"which are typically reset on unmap."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1026
msgid "free(3) may or may not call munmap(2) and/or brk(2), and may thus"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1027
msgid ""
"not invoke autoreset. Neither will stack variables going out of scope. "
"Therefore it's recommended to always explicitly reset the madvises when "
"freeing the memory backing a region used in a :c:type:`DRM_IOCTL_XE_MADVISE` "
"call."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1031
msgid ""
"The **prefetch_mem_region_instance** for ``DRM_XE_VM_BIND_OP_PREFETCH`` can "
"also be:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1032
msgid ""
"``DRM_XE_CONSULT_MEM_ADVISE_PREF_LOC``, which ensures prefetching occurs in "
"the memory region advised by madvise."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1156
msgid "Input of :c:type:`DRM_IOCTL_XE_VM_BIND`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1187
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:407
msgid "The ID of the VM to bind to"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1190
#: include/uapi/drm/xe_drm.h:1307 include/uapi/drm/xe_drm.h:1327
#: include/uapi/drm/xe_drm.h:1347 include/uapi/drm/xe_drm.h:1459
#: include/uapi/drm/xe_drm.h:1562
msgid "``exec_queue_id``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1191
msgid ""
"exec_queue_id, must be of class DRM_XE_ENGINE_CLASS_VM_BIND and exec queue "
"must have same vm_id. If zero, the default VM bind engine is used."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1199
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:409
msgid "``num_binds``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1200
msgid "number of binds in this IOCTL"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1203
msgid "``bind``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1204
msgid "used if num_binds == 1"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1207
msgid "``vector_of_binds``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1208
msgid "userptr to array of struct drm_xe_vm_bind_op if num_binds > 1"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1216
#: include/uapi/drm/xe_drm.h:1462
msgid "``num_syncs``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1217
msgid "amount of syncs to wait on"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1220
msgid "pointer to struct drm_xe_sync array"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1157
msgid ""
"Below is an example of a minimal use of **drm_xe_vm_bind** to asynchronously "
"bind the buffer `data` at address `BIND_ADDRESS` to illustrate `userptr`. It "
"can be synchronized by using the example provided for **drm_xe_sync**."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1227
msgid "Input of :c:type:`DRM_IOCTL_XE_EXEC_QUEUE_CREATE`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1295
msgid "submission width (number BB per exec) for this exec queue"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1297
msgid "``num_placements``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1298
msgid "number of valid placements for this exec queue"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1301
msgid "VM to use for this exec queue"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1305
msgid "flags to use for this exec queue"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1308
msgid "Returned exec queue ID"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1311
msgid "``instances``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1312
msgid "user pointer to a 2-d array of struct drm_xe_engine_class_instance"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1315
msgid "length = width (i) * num_placements (j) index = j + i * width"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1228
msgid ""
"This ioctl supports setting the following properties via the "
"``DRM_XE_EXEC_QUEUE_EXTENSION_SET_PROPERTY`` extension, which uses the "
"generic **drm_xe_ext_set_property** struct:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1232
msgid ""
"``DRM_XE_EXEC_QUEUE_SET_PROPERTY_PRIORITY`` - set the queue priority. "
"CAP_SYS_NICE is required to set a value above normal."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1234
msgid ""
"``DRM_XE_EXEC_QUEUE_SET_PROPERTY_TIMESLICE`` - set the queue timeslice "
"duration in microseconds."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1236
msgid ""
"``DRM_XE_EXEC_QUEUE_SET_PROPERTY_PXP_TYPE`` - set the type of PXP session "
"this queue will be used with. Valid values are listed in enum "
"drm_xe_pxp_session_type. ``DRM_XE_PXP_TYPE_NONE`` is the default behavior, "
"so there is no need to explicitly set that. When a queue of type "
"``DRM_XE_PXP_TYPE_HWDRM`` is created, the PXP default HWDRM session "
"(``XE_PXP_HWDRM_DEFAULT_SESSION``) will be started, if isn't already "
"running. The user is expected to query the PXP status via the query ioctl "
"(see ``DRM_XE_DEVICE_QUERY_PXP_STATUS``) and to wait for PXP to be ready "
"before attempting to create a queue with this property. When a queue is "
"created before PXP is ready, the ioctl will return -EBUSY if init is still "
"in progress or -EIO if init failed. Given that going into a power-saving "
"state kills PXP HWDRM sessions, runtime PM will be blocked while queues of "
"this type are alive. All PXP queues will be killed if a PXP invalidation "
"event occurs."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1251
msgid ""
"The example below shows how to use **drm_xe_exec_queue_create** to create a "
"simple exec_queue (no parallel submission) of class :c:type:"
"`DRM_XE_ENGINE_CLASS_RENDER`."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1324
msgid "Input of :c:type:`DRM_IOCTL_XE_EXEC_QUEUE_DESTROY`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1328
#: include/uapi/drm/xe_drm.h:1348
msgid "Exec queue ID"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1338
msgid "Input of :c:type:`DRM_IOCTL_XE_EXEC_QUEUE_GET_PROPERTY`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1352
msgid "property to get"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1339
msgid "The **property** can be:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1340
msgid "``DRM_XE_EXEC_QUEUE_GET_PROPERTY_BAN``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1404
msgid "Type of the this sync object"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1408
msgid "Sync Flags"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1412
msgid "Handle for the object"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1416
msgid ""
"Address of user fence. When sync is passed in via exec IOCTL this is a GPU "
"address in the VM. When sync passed in via VM bind IOCTL this is a user "
"pointer. In either case, it is the users responsibility that this address is "
"present and mapped when the user fence is signalled. Must be qword aligned."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1427
msgid ""
"Input for the timeline sync object. Needs to be different than 0 when used "
"with ``DRM_XE_SYNC_TYPE_TIMELINE_SYNCOBJ``."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1364
msgid "``DRM_XE_SYNC_TYPE_SYNCOBJ``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1365
msgid "``DRM_XE_SYNC_TYPE_TIMELINE_SYNCOBJ``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1366
msgid "``DRM_XE_SYNC_TYPE_USER_FENCE``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1369
msgid "``DRM_XE_SYNC_FLAG_SIGNAL``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1371
msgid "A minimal use of **drm_xe_sync** looks like this:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1436
msgid "Input of :c:type:`DRM_IOCTL_XE_EXEC`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1460
msgid "Exec queue ID for the batch buffer"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1463
msgid "Amount of struct drm_xe_sync in array."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1466
msgid "Pointer to struct drm_xe_sync array."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1469
msgid "``address``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1470
msgid ""
"address of batch buffer if num_batch_buffer == 1 or an array of batch buffer "
"addresses"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1475
msgid "``num_batch_buffer``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1476
msgid "number of batch buffer in this exec, must match the width of the engine"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1437
msgid ""
"This is an example to use **drm_xe_exec** for execution of the object at "
"BIND_ADDRESS (see example in **drm_xe_vm_bind**) by an exec_queue (see "
"example in **drm_xe_exec_queue_create**). It can be synchronized by using "
"the example provided for **drm_xe_sync**."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1488
msgid "Input of :c:type:`DRM_IOCTL_XE_WAIT_USER_FENCE`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1521
msgid "user pointer address to wait on, must qword aligned"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1531
msgid "wait operation (type of comparison)"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1535
msgid "wait flags"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1541
msgid "compare value"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1544
msgid "comparison mask"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1547
msgid "``timeout``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1548
msgid ""
"how long to wait before bailing, value in nanoseconds. Without "
"DRM_XE_UFENCE_WAIT_FLAG_ABSTIME flag set (relative timeout) it contains "
"timeout expressed in nanoseconds to wait (fence will expire at now() + "
"timeout). When DRM_XE_UFENCE_WAIT_FLAG_ABSTIME flat is set (absolute "
"timeout) wait will end at timeout (uses system MONOTONIC_CLOCK). Passing "
"negative timeout leads to neverending wait."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1556
msgid ""
"On relative timeout this value is updated with timeout left (for restarting "
"the call in case of signal delivery). On absolute timeout this value stays "
"intact (restarted call still expire at the same point of time)."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1563
msgid "exec_queue_id returned from xe_exec_queue_create_ioctl"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1489
msgid ""
"Wait on user fence, XE will wake-up on every HW engine interrupt in the "
"instances list and check if user fence is complete::"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1494
msgid "Returns to user on user fence completion or timeout."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1497
msgid "``DRM_XE_UFENCE_WAIT_OP_EQ``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1498
msgid "``DRM_XE_UFENCE_WAIT_OP_NEQ``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1499
msgid "``DRM_XE_UFENCE_WAIT_OP_GT``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1500
msgid "``DRM_XE_UFENCE_WAIT_OP_GTE``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1501
msgid "``DRM_XE_UFENCE_WAIT_OP_LT``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1502
msgid "``DRM_XE_UFENCE_WAIT_OP_LTE``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1505
msgid "``DRM_XE_UFENCE_WAIT_FLAG_ABSTIME``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1506
msgid "``DRM_XE_UFENCE_WAIT_FLAG_SOFT_OP``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1508
msgid "The **mask** values can be for example:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1509
msgid "0xffu for u8"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1510
msgid "0xffffu for u16"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1511
msgid "0xffffffffu for u32"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1512
msgid "0xffffffffffffffffu for u64"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1573
msgid "Observation stream types"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1579
msgid "``DRM_XE_OBSERVATION_TYPE_OA``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1580
msgid "OA observation stream type"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1582
msgid "``DRM_XE_OBSERVATION_TYPE_EU_STALL``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1583
msgid "EU stall sampling observation stream type"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1583
msgid "Observation stream ops"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1589
msgid "``DRM_XE_OBSERVATION_OP_STREAM_OPEN``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1590
msgid "Open an observation stream"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1592
msgid "``DRM_XE_OBSERVATION_OP_ADD_CONFIG``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1593
msgid "Add observation stream config"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1595
msgid "``DRM_XE_OBSERVATION_OP_REMOVE_CONFIG``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1596
msgid "Remove observation stream config"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1597
msgid "Input of :c:type:`DRM_XE_OBSERVATION`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1607
msgid "``observation_type``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1608
msgid "observation stream type, of enum **drm_xe_observation_type**"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1609
msgid "``observation_op``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1610
msgid "observation stream op, of enum **drm_xe_observation_op**"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1612
msgid "Pointer to actual stream params"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1598
msgid ""
"The observation layer enables multiplexing observation streams of multiple "
"types. The actual params for a particular stream operation are supplied via "
"the **param** pointer (use __copy_from_user to get these params)."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1616
msgid "Observation stream fd ioctl's"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1622
msgid "``DRM_XE_OBSERVATION_IOCTL_ENABLE``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1623
msgid "Enable data capture for an observation stream"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1625
msgid "``DRM_XE_OBSERVATION_IOCTL_DISABLE``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1626
msgid "Disable data capture for a observation stream"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1628
msgid "``DRM_XE_OBSERVATION_IOCTL_CONFIG``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1629
msgid "Change observation stream configuration"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1631
msgid "``DRM_XE_OBSERVATION_IOCTL_STATUS``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1632
msgid "Return observation stream status"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1634
msgid "``DRM_XE_OBSERVATION_IOCTL_INFO``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1635
msgid "Return observation stream info"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1617
msgid ""
"Information exchanged between userspace and kernel for observation fd "
"ioctl's is stream type specific"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1639
msgid "OA unit types"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1645
msgid "``DRM_XE_OA_UNIT_TYPE_OAG``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1646
msgid ""
"OAG OA unit. OAR/OAC are considered sub-types of OAG. For OAR/OAC, use OAG."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1649
msgid "``DRM_XE_OA_UNIT_TYPE_OAM``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1650
msgid "OAM OA unit"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1652
msgid "``DRM_XE_OA_UNIT_TYPE_OAM_SAG``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1653
msgid "OAM_SAG OA unit"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1656
msgid "describe OA unit"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1662
msgid "``oa_unit_id``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1663
msgid "OA unit ID"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1665
msgid "``oa_unit_type``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1666
msgid "OA unit type of **drm_xe_oa_unit_type**"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1669
msgid "OA capabilities bit-mask"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1676
msgid "``oa_timestamp_freq``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1677
msgid "OA timestamp freq"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1683
msgid "number of engines in **eci** array"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1686
msgid "engines attached to this OA unit"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1690
msgid "describe OA units"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1716
msgid "``num_oa_units``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1717
msgid "number of OA units returned in oau[]"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1721
msgid "``oa_units``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1722
msgid ""
"struct **drm_xe_oa_unit** array returned for this device. Written below as a "
"u64 array to avoid problems with nested flexible arrays with some compilers"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1691
msgid ""
"If a query is made with a struct drm_xe_device_query where .query is equal "
"to DRM_XE_DEVICE_QUERY_OA_UNITS, then the reply uses struct "
"drm_xe_query_oa_units in .data."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1695
msgid ""
"OA unit properties for all OA units can be accessed using a code block such "
"as the one below:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1729
msgid "OA format types as specified in PRM/Bspec 52198/60942"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1735
msgid "``DRM_XE_OA_FMT_TYPE_OAG``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1736
msgid "OAG report format"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1738
msgid "``DRM_XE_OA_FMT_TYPE_OAR``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1739
msgid "OAR report format"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1741
msgid "``DRM_XE_OA_FMT_TYPE_OAM``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1742
msgid "OAM report format"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1744
msgid "``DRM_XE_OA_FMT_TYPE_OAC``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1745
msgid "OAC report format"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1747
msgid "``DRM_XE_OA_FMT_TYPE_OAM_MPEC``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1748
msgid "OAM SAMEDIA or OAM MPEC report format"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1750
msgid "``DRM_XE_OA_FMT_TYPE_PEC``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1751
msgid "PEC report format"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1748
msgid "OA stream property id's"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1754
msgid "``DRM_XE_OA_PROPERTY_OA_UNIT_ID``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1755
msgid ""
"ID of the OA unit on which to open the OA stream, see **oa_unit_id** in "
"'struct drm_xe_query_oa_units'. Defaults to 0 if not provided."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1759
msgid "``DRM_XE_OA_PROPERTY_SAMPLE_OA``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1760
msgid ""
"A value of 1 requests inclusion of raw OA unit reports or stream samples in "
"a global buffer attached to an OA unit."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1764
msgid "``DRM_XE_OA_PROPERTY_OA_METRIC_SET``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1765
msgid ""
"OA metrics defining contents of OA reports, previously added via "
"**DRM_XE_OBSERVATION_OP_ADD_CONFIG**."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1768
msgid "``DRM_XE_OA_PROPERTY_OA_FORMAT``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1769
msgid "OA counter report format"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1771
msgid "``DRM_XE_OA_PROPERTY_OA_PERIOD_EXPONENT``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1772
msgid ""
"Requests periodic OA unit sampling with sampling frequency proportional to "
"2^(period_exponent + 1)"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1775
msgid "``DRM_XE_OA_PROPERTY_OA_DISABLED``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1776
msgid ""
"A value of 1 will open the OA stream in a DISABLED state (see "
"**DRM_XE_OBSERVATION_IOCTL_ENABLE**)."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1779
msgid "``DRM_XE_OA_PROPERTY_EXEC_QUEUE_ID``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1780
msgid ""
"Open the stream for a specific **exec_queue_id**. OA queries can be executed "
"on this exec queue."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1783
msgid "``DRM_XE_OA_PROPERTY_OA_ENGINE_INSTANCE``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1784
msgid ""
"Optional engine instance to pass along with "
"**DRM_XE_OA_PROPERTY_EXEC_QUEUE_ID** or will default to 0."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1787
msgid "``DRM_XE_OA_PROPERTY_NO_PREEMPT``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1788
msgid ""
"Allow preemption and timeslicing to be disabled for the stream exec queue."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1791
msgid "``DRM_XE_OA_PROPERTY_NUM_SYNCS``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1792
msgid ""
"Number of syncs in the sync array specified in **DRM_XE_OA_PROPERTY_SYNCS**"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1795
msgid "``DRM_XE_OA_PROPERTY_SYNCS``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1796
msgid ""
"Pointer to struct **drm_xe_sync** array with array size specified via "
"**DRM_XE_OA_PROPERTY_NUM_SYNCS**. OA configuration will wait till input "
"fences signal. Output fences will signal after the new OA configuration "
"takes effect. For **DRM_XE_SYNC_TYPE_USER_FENCE**, **addr** is a user "
"pointer, similar to the VM bind case."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1803
msgid "``DRM_XE_OA_PROPERTY_OA_BUFFER_SIZE``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1804
msgid ""
"Size of OA buffer to be allocated by the driver in bytes. Supported sizes "
"are powers of 2 from 128 KiB to 128 MiB. When not specified, a 16 MiB OA "
"buffer is allocated by default."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1809
msgid "``DRM_XE_OA_PROPERTY_WAIT_NUM_REPORTS``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1810
msgid "Number of reports to wait for before unblocking poll or read"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1749
msgid ""
"Stream params are specified as a chain of **drm_xe_ext_set_property** "
"struct's, with **property** values from enum **drm_xe_oa_property_id** and "
"**drm_xe_user_extension** base.name set to "
"**DRM_XE_OA_EXTENSION_SET_PROPERTY**. **param** field in struct "
"**drm_xe_observation_param** points to the first **drm_xe_ext_set_property** "
"struct."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1755
msgid ""
"Exactly the same mechanism is also used for stream reconfiguration using the "
"**DRM_XE_OBSERVATION_IOCTL_CONFIG** observation stream fd ioctl, though only "
"a subset of properties below can be specified for stream reconfiguration."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1857
msgid "OA metric configuration"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1870
msgid "``n_regs``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1871
msgid "Number of regs in **regs_ptr**"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1874
msgid "``regs_ptr``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1875
msgid ""
"Pointer to (register address, value) pairs for OA config registers. Expected "
"length of buffer is: (2 * sizeof(u32) * **n_regs**)."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1858
msgid ""
"Multiple OA configs can be added using **DRM_XE_OBSERVATION_OP_ADD_CONFIG**. "
"A particular config can be specified when opening an OA stream using "
"**DRM_XE_OA_PROPERTY_OA_METRIC_SET** property."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1881
msgid ""
"OA stream status returned from **DRM_XE_OBSERVATION_IOCTL_STATUS** "
"observation stream fd ioctl. Userspace can call the ioctl to query stream "
"status in response to EIO errno from observation fd read()."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1890
msgid "``oa_status``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1891
msgid "OA stream status (see Bspec 46717/61226)"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1902
msgid ""
"OA stream info returned from **DRM_XE_OBSERVATION_IOCTL_INFO** observation "
"stream fd ioctl"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1909
msgid "``oa_buf_size``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1910
msgid "OA buffer size"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1917
msgid "Supported PXP session types."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1923
msgid "``DRM_XE_PXP_TYPE_NONE``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1924
msgid "PXP not used"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1926
msgid "``DRM_XE_PXP_TYPE_HWDRM``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1927
msgid "HWDRM sessions are used for content that ends up on the display."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1918
msgid ""
"We currently only support HWDRM sessions, which are used for protected "
"content that ends up being displayed, but the HW supports multiple types, so "
"we might extend support in the future."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1937
msgid "EU stall sampling input property ids."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1943
msgid "``DRM_XE_EU_STALL_PROP_GT_ID``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1944
msgid "**gt_id** of the GT on which EU stall data will be captured."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1947
msgid "``DRM_XE_EU_STALL_PROP_SAMPLE_RATE``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1948
msgid ""
"Sampling rate in GPU cycles from **sampling_rates** in struct "
"**drm_xe_query_eu_stall**"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1951
msgid "``DRM_XE_EU_STALL_PROP_WAIT_NUM_REPORTS``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1952
msgid ""
"Minimum number of EU stall data reports to be present in the kernel buffer "
"before unblocking a blocked poll or read."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1938
msgid ""
"These properties are passed to the driver at open as a chain of "
"**drm_xe_ext_set_property** structures with **property** set to these "
"properties' enums and **value** set to the corresponding values of these "
"properties. **drm_xe_user_extension** base.name should be set to "
"**DRM_XE_EU_STALL_EXTENSION_SET_PROPERTY**."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1944
msgid ""
"With the file descriptor obtained from open, user space must enable the EU "
"stall stream fd with **DRM_XE_OBSERVATION_IOCTL_ENABLE** before calling "
"read(). EIO errno from read() indicates HW dropped data due to full buffer."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1973
msgid "Information about EU stall sampling."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1984
msgid "EU stall capabilities bit-mask"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1987
msgid "``record_size``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1988
msgid "size of each EU stall data record"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1990
msgid "``per_xecore_buf_size``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1991
msgid "internal per XeCore buffer size"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1996
msgid "``num_sampling_rates``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1997
msgid "Number of sampling rates in **sampling_rates** array"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2000
msgid "``sampling_rates``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2001
msgid ""
"Flexible array of sampling rates sorted in the fastest to slowest order. "
"Sampling rates are specified in GPU clock cycles."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:1974
msgid ""
"If a query is made with a struct **drm_xe_device_query** where .query is "
"equal to **DRM_XE_DEVICE_QUERY_EU_STALL**, then the reply uses struct "
"**drm_xe_query_eu_stall** in .data."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2008
msgid "Input of :c:type:`DRM_IOCTL_XE_MADVISE`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2038
#: include/uapi/drm/xe_drm.h:2155 include/uapi/drm/xe_drm.h:2255
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:873
msgid "``start``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2039
#: include/uapi/drm/xe_drm.h:2256
msgid "start of the virtual address range"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2042
#: include/uapi/drm/xe_drm.h:2259
msgid "size of the virtual address range"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2045
#: include/uapi/drm/xe_drm.h:2250
msgid "vm_id of the virtual range"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2051
msgid "type of attribute"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2055
#: include/uapi/drm/xe_drm.h:2161
msgid "``preferred_mem_loc``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2056
#: include/uapi/drm/xe_drm.h:2162
msgid "preferred memory location"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2058
msgid "Used when **type** == DRM_XE_MEM_RANGE_ATTR_PREFERRED_LOC"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2060
msgid "Supported values for **preferred_mem_loc.devmem_fd**:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2061
msgid ""
"DRM_XE_PREFERRED_LOC_DEFAULT_DEVICE: set vram of fault tile as preferred loc"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2062
msgid "DRM_XE_PREFERRED_LOC_DEFAULT_SYSTEM: set smem as preferred loc"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2064
msgid "Supported values for **preferred_mem_loc.migration_policy**:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2065
msgid "DRM_XE_MIGRATE_ALL_PAGES"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2066
msgid "DRM_XE_MIGRATE_ONLY_SYSTEM_PAGES"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2086
#: include/uapi/drm/xe_drm.h:2170
msgid "``atomic``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2087
#: include/uapi/drm/xe_drm.h:2171
msgid "Atomic access policy"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2089
msgid "Used when **type** == DRM_XE_MEM_RANGE_ATTR_ATOMIC."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2091
msgid "Supported values for **atomic.val**:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2092
msgid ""
"DRM_XE_ATOMIC_UNDEFINED: Undefined or default behaviour. Support both GPU "
"and CPU atomic operations for system allocator. Support GPU atomic "
"operations for normal(bo) allocator."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2095
msgid "DRM_XE_ATOMIC_DEVICE: Support GPU atomic operations."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2096
msgid "DRM_XE_ATOMIC_GLOBAL: Support both GPU and CPU atomic operations."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2097
msgid "DRM_XE_ATOMIC_CPU: Support CPU atomic only, no GPU atomics supported."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2115
#: include/uapi/drm/xe_drm.h:2180
msgid "Page attribute table index"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2117
msgid "Used when **type** == DRM_XE_MEM_RANGE_ATTR_PAT."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2009
msgid ""
"This structure is used to set memory attributes for a virtual address range "
"in a VM. The type of attribute is specified by **type**, and the "
"corresponding union member is used to provide additional parameters for "
"**type**."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2013
msgid "Supported attribute types:"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2014
msgid "DRM_XE_MEM_RANGE_ATTR_PREFERRED_LOC: Set preferred memory location."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2015
msgid "DRM_XE_MEM_RANGE_ATTR_ATOMIC: Set atomic access policy."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2016
msgid "DRM_XE_MEM_RANGE_ATTR_PAT: Set page attribute table index."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2018
#: include/uapi/drm/xe_drm.h:2210
msgid "**Example**"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2135
msgid "Output of :c:type:`DRM_IOCTL_XE_VM_QUERY_MEM_RANGES_ATTRS`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2156
msgid "start of the memory range"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2158
#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:876
msgid "``end``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2159
msgid "end of the memory range"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2136
msgid ""
"This structure is provided by userspace and filled by KMD in response to the "
"DRM_IOCTL_XE_VM_QUERY_MEM_RANGES_ATTRS ioctl. It describes memory attributes "
"of a memory ranges within a user specified address range in a VM."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2140
msgid ""
"The structure includes information such as atomic access policy, page "
"attribute table (PAT) index, and preferred memory location. Userspace "
"allocates an array of these structures and passes a pointer to the ioctl to "
"retrieve attributes for each memory ranges"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2193
msgid "Input of :c:type:`DRM_IOCTL_XE_VM_QUERY_MEM_ATTRIBUTES`"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2252
msgid "``num_mem_ranges``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2253
msgid "number of mem_ranges in range"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2261
msgid "``sizeof_mem_range_attr``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2262
msgid "size of struct drm_xe_mem_range_attr"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2264
msgid "``vector_of_mem_attr``"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2265
msgid "userptr to array of struct drm_xe_mem_range_attr"
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2194
msgid ""
"This structure is used to query memory attributes of memory regions within a "
"user specified address range in a VM. It provides detailed information about "
"each memory range, including atomic access policy, page attribute table "
"(PAT) index, and preferred memory location."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2199
msgid ""
"Userspace first calls the ioctl with **num_mem_ranges** = 0, "
"**sizeof_mem_ranges_attr** = 0 and **vector_of_vma_mem_attr** = NULL to "
"retrieve the number of memory regions and size of each memory range "
"attribute. Then, it allocates a buffer of that size and calls the ioctl "
"again to fill the buffer with memory range attributes."
msgstr ""

#: ../../../gpu/driver-uapi:29: include/uapi/drm/xe_drm.h:2205
msgid ""
"If second call fails with -ENOSPC, it means memory ranges changed between "
"first call and now, retry IOCTL again with **num_mem_ranges** = 0, "
"**sizeof_mem_ranges_attr** = 0 and **vector_of_vma_mem_attr** = NULL "
"followed by Second ioctl call."
msgstr ""

#: ../../../gpu/driver-uapi.rst:32
msgid "drm/asahi uAPI"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:3
msgid "**Introduction to the Asahi UAPI**"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:17
msgid "This documentation describes the Asahi IOCTLs."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:19
msgid ""
"Just a few generic rules about the data passed to the Asahi IOCTLs (cribbed "
"from Panthor):"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:34
msgid ""
"New fields can be added to indirect objects (objects pointed by the main "
"structure), iff those objects are passed a size to reflect the size known by "
"the userspace driver (see drm_asahi_cmd_header::size)."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:42
msgid ""
"Each new flag/field addition must come with a driver version update so the "
"userspace driver doesn't have to guess which flags are supported."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:46
msgid ""
"IOCTLs can't be removed or replaced. New IOCTL IDs should be placed at the "
"end of the drm_asahi_ioctl_id enum."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:53
msgid "IOCTL IDs"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:59
msgid "``DRM_ASAHI_GET_PARAMS``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:60
msgid "Query device properties."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:62
msgid "``DRM_ASAHI_GET_TIME``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:63
msgid "Query device time."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:65
msgid "``DRM_ASAHI_VM_CREATE``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:66
msgid "Create a GPU VM address space."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:68
msgid "``DRM_ASAHI_VM_DESTROY``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:69
msgid "Destroy a VM."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:71
msgid "``DRM_ASAHI_VM_BIND``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:72
msgid "Bind/unbind memory to a VM."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:74
msgid "``DRM_ASAHI_GEM_CREATE``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:75
msgid "Create a buffer object."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:77
msgid "``DRM_ASAHI_GEM_MMAP_OFFSET``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:78
msgid "Get offset to pass to mmap() to map a given GEM handle."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:81
msgid "``DRM_ASAHI_GEM_BIND_OBJECT``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:82
msgid "Bind memory as a special object"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:84
msgid "``DRM_ASAHI_QUEUE_CREATE``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:85
msgid "Create a scheduling queue."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:87
msgid "``DRM_ASAHI_QUEUE_DESTROY``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:88
msgid "Destroy a scheduling queue."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:90
msgid "``DRM_ASAHI_SUBMIT``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:91
msgid "Submit commands to a queue."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:56
msgid ""
"These IDs are not meant to be used directly. Use the DRM_IOCTL_ASAHI_xxx "
"definitions instead."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:101
msgid "Global parameters."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:106
msgid "``features``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:107
msgid "Feature bits from drm_asahi_feature"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:109
msgid "``gpu_generation``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:110
msgid "GPU generation, e.g. 13 for G13G"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:112
msgid "``gpu_variant``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:113
msgid "GPU variant as a character, e.g. 'C' for G13C"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:116
msgid "``gpu_revision``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:117
msgid "GPU revision in BCD, e.g. 0x00 for 'A0' or 0x21 for 'C1'"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:121
msgid "``chip_id``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:122
msgid "Chip ID in BCD, e.g. 0x8103 for T8103"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:124
msgid "``num_dies``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:125
msgid "Number of dies in the SoC"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:127
msgid "``num_clusters_total``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:128
msgid "Number of GPU clusters (across all dies)"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:131
msgid "``num_cores_per_cluster``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:132
msgid "Number of logical cores per cluster (including inactive/nonexistent)"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:136
msgid "``max_frequency_khz``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:137
msgid "Maximum GPU core clock frequency"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:139
msgid "``core_masks``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:140
msgid "Bitmask of present/enabled cores per cluster"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:143
msgid "``vm_start``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:144
msgid ""
"VM range start VMA. Together with **vm_end**, this defines the window of "
"valid GPU VAs. Userspace is expected to subdivide VAs out of this window."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:148
msgid ""
"This window contains all virtual addresses that userspace needs to know "
"about. There may be kernel-internal GPU VAs outside this range, but that "
"detail is not relevant here."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:153
msgid "``vm_end``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:154
msgid "VM range end VMA"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:157
msgid "``vm_kernel_min_size``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:158
msgid "Minimum kernel VMA window size."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:160
msgid ""
"When creating a VM, userspace is required to carve out a section of virtual "
"addresses (within the range given by **vm_start** and **vm_end**). The "
"kernel will allocate various internal structures within the specified VA "
"range."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:165
msgid ""
"Allowing userspace to choose the VA range for the kernel, rather than the "
"kernel reserving VAs and requiring userspace to cope, can assist in "
"implementing SVM."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:171
msgid "``max_commands_per_submission``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:172
msgid ""
"Maximum number of supported commands per submission. This mirrors firmware "
"limits. Userspace must split up larger command buffers, which may require "
"inserting additional synchronization."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:179
msgid "``max_attachments``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:180
msgid "Maximum number of drm_asahi_attachment's per command"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:185
msgid "``command_timestamp_frequency_hz``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:186
msgid ""
"Timebase frequency for timestamps written during command execution, "
"specified via drm_asahi_timestamp structures. As this rate is controlled by "
"the firmware, it is a queryable parameter."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:191
msgid ""
"Userspace must divide by this frequency to convert timestamps to seconds, "
"rather than hardcoding a particular firmware's rate."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:102
msgid "This struct may be queried by drm_asahi_get_params."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:197
msgid "Feature bits"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:203
msgid "``DRM_ASAHI_FEATURE_SOFT_FAULTS``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:204
msgid ""
"GPU has \"soft fault\" enabled. Shader loads of unmapped memory will return "
"zero. Shader stores to unmapped memory will be silently discarded. Note that "
"only shader load/store is affected. Other hardware units are not affected, "
"notably including texture sampling."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:210
msgid ""
"Soft fault is set when initializing the GPU and cannot be runtime toggled. "
"Therefore, it is exposed as a feature bit and not a userspace-settable flag "
"on the VM. When soft fault is enabled, userspace can speculate memory "
"accesses more aggressively."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:198
msgid ""
"This covers only features that userspace cannot infer from the architecture "
"version. Most features don't need to be here."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:219
msgid "Arguments passed to DRM_IOCTL_ASAHI_GET_PARAMS"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:222
msgid "``param_group``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:223
msgid "Parameter group to fetch (MBZ)"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:229
msgid "User pointer to write parameter struct"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:233
msgid ""
"Size of the user buffer. In case of older userspace, this may be less than "
"sizeof(struct drm_asahi_params_global). The kernel will not write past the "
"length specified here, allowing extensibility."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:240
msgid "Arguments passed to DRM_IOCTL_ASAHI_VM_CREATE"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:244
msgid "``kernel_start``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:245
msgid ""
"Start of the kernel-reserved address range. See drm_asahi_params_global::"
"vm_kernel_min_size."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:248
msgid ""
"Both **kernel_start** and **kernel_end** must be within the range of valid "
"VAs given by drm_asahi_params_global::vm_start and drm_asahi_params_global::"
"vm_end. The size of the kernel range (**kernel_end** - **kernel_start**) "
"must be at least drm_asahi_params_global::vm_kernel_min_size."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:254
msgid ""
"Userspace must not bind any memory on this VM into this reserved range, it "
"is for kernel use only."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:259
msgid "``kernel_end``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:260
msgid "End of the kernel-reserved address range. See **kernel_start**."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:272
msgid "Arguments passed to DRM_IOCTL_ASAHI_VM_DESTROY"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:276
msgid "VM ID to be destroyed"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:283
msgid "Flags for GEM creation"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:289
msgid "``DRM_ASAHI_GEM_WRITEBACK``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:290
msgid "BO should be CPU-mapped as writeback."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:292
msgid ""
"Map as writeback instead of write-combine. This optimizes for CPU reads."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:295
msgid "``DRM_ASAHI_GEM_VM_PRIVATE``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:296
msgid "BO is private to this GPU VM (no exports)."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:301
msgid "Arguments passed to DRM_IOCTL_ASAHI_GEM_CREATE"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:305
msgid "Size of the BO"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:308
msgid "Combination of drm_asahi_gem_flags flags."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:312
msgid "VM ID to assign to the BO, if DRM_ASAHI_GEM_VM_PRIVATE is set"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:316
msgid "Returned GEM handle for the BO"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:323
msgid "Arguments passed to DRM_IOCTL_ASAHI_GEM_MMAP_OFFSET"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:338
msgid "Flags for GEM binding"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:344
msgid "``DRM_ASAHI_BIND_UNBIND``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:345
msgid ""
"Instead of binding a GEM object to the range, simply unbind the GPU VMA "
"range."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:348
msgid "``DRM_ASAHI_BIND_READ``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:349
msgid "Map BO with GPU read permission"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:351
msgid "``DRM_ASAHI_BIND_WRITE``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:352
msgid "Map BO with GPU write permission"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:354
msgid "``DRM_ASAHI_BIND_SINGLE_PAGE``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:355
msgid "Map a single page of the BO repeatedly across the VA range."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:358
msgid ""
"This is useful to fill a VA range with scratch pages or zero pages. It is "
"intended as a mechanism to accelerate sparse."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:364
msgid "Description of a single GEM bind operation."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:368
msgid "Combination of drm_asahi_bind_flags flags."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:371
msgid "GEM object to bind (except for UNBIND)"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:375
msgid "Offset into the object (except for UNBIND)."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:377
msgid ""
"For a regular bind, this is the beginning of the region of the GEM object to "
"bind."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:380
msgid ""
"For a single-page bind, this is the offset to the single page that will be "
"repeatedly bound."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:383
#: include/uapi/drm/asahi_drm.h:390 include/uapi/drm/asahi_drm.h:397
msgid "Must be page-size aligned."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:388
msgid "Number of bytes to bind/unbind to **addr**."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:395
msgid "Address to bind to."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:402
msgid "Arguments passed to DRM_IOCTL_ASAHI_VM_BIND"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:410
msgid "number of binds in this IOCTL."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:414
msgid ""
"Stride in bytes between consecutive binds. This allows extensibility of "
"drm_asahi_gem_bind_op."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:423
msgid ""
"User pointer to an array of **num_binds** structures of type "
"**drm_asahi_gem_bind_op** and size **stride** bytes."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:429
msgid "Special object bind operation"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:435
msgid "``DRM_ASAHI_BIND_OBJECT_OP_BIND``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:436
msgid "Bind a BO as a special GPU object"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:438
msgid "``DRM_ASAHI_BIND_OBJECT_OP_UNBIND``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:439
msgid "Unbind a special GPU object"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:440
msgid "Special object bind flags"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:446
msgid "``DRM_ASAHI_BIND_OBJECT_USAGE_TIMESTAMPS``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:447
msgid "Map a BO as a timestamp buffer."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:451
msgid "Arguments passed to DRM_IOCTL_ASAHI_GEM_BIND_OBJECT"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:456
msgid "Bind operation (enum drm_asahi_bind_object_op)"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:459
msgid "Combination of drm_asahi_bind_object_flags flags."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:462
msgid "GEM object to bind/unbind (BIND)"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:465
msgid "The ID of the VM to operate on (MBZ currently)"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:468
msgid "Offset into the object (BIND only)"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:471
msgid "Number of bytes to bind/unbind (BIND only)"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:473
msgid "``object_handle``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:474
msgid "Object handle (out for BIND, in for UNBIND)"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:481
msgid "Command type"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:487
msgid "``DRM_ASAHI_CMD_RENDER``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:488
msgid ""
"Render command, executing on the render subqueue. Combined vertex and "
"fragment operation."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:491
msgid "Followed by a **drm_asahi_cmd_render** payload."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:493
msgid "``DRM_ASAHI_CMD_COMPUTE``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:494
msgid "Compute command on the compute subqueue."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:496
msgid "Followed by a **drm_asahi_cmd_compute** payload."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:498
msgid "``DRM_ASAHI_SET_VERTEX_ATTACHMENTS``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:499
msgid ""
"Software command to set attachments for subsequent vertex shaders in the "
"same submit."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:502
#: include/uapi/drm/asahi_drm.h:508 include/uapi/drm/asahi_drm.h:514
msgid "Followed by (possibly multiple) **drm_asahi_attachment** payloads."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:504
msgid "``DRM_ASAHI_SET_FRAGMENT_ATTACHMENTS``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:505
msgid ""
"Software command to set attachments for subsequent fragment shaders in the "
"same submit."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:510
msgid "``DRM_ASAHI_SET_COMPUTE_ATTACHMENTS``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:511
msgid ""
"Software command to set attachments for subsequent compute shaders in the "
"same submit."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:525
msgid "Scheduling queue priority."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:531
msgid "``DRM_ASAHI_PRIORITY_LOW``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:532
msgid "Low priority queue."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:534
msgid "``DRM_ASAHI_PRIORITY_MEDIUM``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:535
msgid "Medium priority queue."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:537
msgid "``DRM_ASAHI_PRIORITY_HIGH``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:538
msgid "High priority queue."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:540
#: include/uapi/drm/asahi_drm.h:545
msgid "Reserved for future extension."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:542
msgid "``DRM_ASAHI_PRIORITY_REALTIME``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:543
msgid "Real-time priority queue."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:526
msgid ""
"These priorities are forwarded to the firmware to influence firmware "
"scheduling. The exact policy is ultimately decided by firmware, but these "
"enums allow userspace to communicate the intentions."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:554
msgid "Arguments passed to DRM_IOCTL_ASAHI_QUEUE_CREATE"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:562
msgid "The ID of the VM this queue is bound to"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:565
msgid "One of drm_asahi_priority"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:567
#: include/uapi/drm/asahi_drm.h:592 include/uapi/drm/asahi_drm.h:722
msgid "``queue_id``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:568
msgid "The returned queue ID"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:571
msgid "``usc_exec_base``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:572
msgid ""
"GPU base address for all USC binaries (shaders) on this queue. USC addresses "
"are 32-bit relative to this 64-bit base."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:575
msgid "This sets the following registers on all queue commands:"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:577
msgid ""
"USC_EXEC_BASE_TA  (vertex) USC_EXEC_BASE_ISP (fragment) USC_EXEC_BASE_CP  "
"(compute)"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:581
msgid ""
"While the hardware lets us configure these independently per command, we do "
"not have a use case for this. Instead, we expect userspace to fix a 4GiB VA "
"carveout for USC memory and pass its base address here."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:588
msgid "Arguments passed to DRM_IOCTL_ASAHI_QUEUE_DESTROY"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:593
msgid "The queue ID to be destroyed"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:600
msgid "Sync item type"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:606
msgid "``DRM_ASAHI_SYNC_SYNCOBJ``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:607
msgid "Binary sync object"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:609
msgid "``DRM_ASAHI_SYNC_TIMELINE_SYNCOBJ``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:610
msgid "Timeline sync object"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:611
msgid "Sync item"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:614
msgid "``sync_type``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:615
msgid "One of drm_asahi_sync_type"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:618
msgid "The sync object handle"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:621
msgid "Timeline value for timeline sync objects"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:627
msgid "``DRM_ASAHI_BARRIER_NONE``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:625
msgid "Command index for no barrier"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:626
msgid ""
"This special value may be passed in to drm_asahi_command::vdm_barrier or "
"drm_asahi_command::cdm_barrier to indicate that the respective subqueue "
"should not wait on any previous work."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:634
msgid "Top level command structure"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:640
msgid "``cmd_type``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:641
msgid "One of drm_asahi_cmd_type"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:645
msgid "Size of this command, not including this header."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:647
msgid ""
"For hardware commands, this enables extensibility of commands without "
"requiring extra command types. Passing a command that is shorter than "
"expected is explicitly allowed for backwards-compatibility. Truncated fields "
"will be zeroed."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:652
msgid ""
"For the synthetic attachment setting commands, this implicitly encodes the "
"number of attachments. These commands take multiple fixed-size "
"**drm_asahi_attachment** structures as their payload, so size equals number "
"of attachments * sizeof(struct drm_asahi_attachment)."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:659
msgid "``vdm_barrier``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:660
msgid "VDM (render) command index to wait on."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:662
msgid ""
"Barriers are indices relative to the beginning of a given submit. A barrier "
"of 0 waits on commands submitted to the respective subqueue in previous "
"submit ioctls. A barrier of N waits on N previous commands on the subqueue "
"within the current submit ioctl. As a special case, passing "
"**DRM_ASAHI_BARRIER_NONE** avoids waiting on any commands in the subqueue."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:669
msgid "Examples:"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:671
msgid "0: This waits on all previous work."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:673
msgid "NONE: This does not wait for anything on this subqueue."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:675
msgid ""
"1: This waits on the first render command in the submit. This is valid only "
"if there are multiple render commands in the same submit."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:679
msgid ""
"Barriers are valid only for hardware commands. Synthetic software commands "
"to set attachments must pass NONE here."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:684
msgid "``cdm_barrier``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:685
msgid "CDM (compute) command index to wait on."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:687
msgid "See **vdm_barrier**, and replace VDM/render with CDM/compute."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:635
msgid ""
"This struct is core to the command buffer definition and therefore is not "
"extensible."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:692
msgid "Arguments passed to DRM_IOCTL_ASAHI_SUBMIT"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:697
msgid ""
"An optional pointer to an array of drm_asahi_sync. The first "
"**in_sync_count** elements are in-syncs, then the remaining "
"**out_sync_count** elements are out-syncs. Using a single array with "
"explicit partitioning simplifies handling."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:704
msgid "``cmdbuf``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:705
msgid "Pointer to the command buffer to submit."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:707
msgid ""
"This is a flat command buffer. By design, it contains no CPU pointers, which "
"makes it suitable for a virtgpu wire protocol without requiring any "
"serializing/deserializing step."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:711
msgid ""
"It consists of a series of commands. Each command begins with a fixed-size "
"**drm_asahi_cmd_header** header and is followed by a variable-length payload "
"according to the type and size in the header."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:715
msgid ""
"The combined count of \"real\" hardware commands must be nonzero and at most "
"drm_asahi_params_global::max_commands_per_submission."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:720
msgid "Flags for command submission (MBZ)"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:723
msgid "The queue ID to be submitted to"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:726
msgid "``in_sync_count``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:727
msgid "Number of sync objects to wait on before starting this job."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:732
msgid "``out_sync_count``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:733
msgid "Number of sync objects to signal upon completion of this job."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:737
msgid "``cmdbuf_size``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:738
msgid "Command buffer size in bytes"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:745
msgid "Describe an \"attachment\"."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:758
msgid "Base address of the attachment"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:761
msgid "Size of the attachment in bytes"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:746
msgid ""
"Attachments are any memory written by shaders, notably including render "
"target attachments written by the end-of-tile program. This is purely a hint "
"about the accessed memory regions. It is optional to specify, which is "
"fortunate as it cannot be specified precisely with bindless access anyway. "
"But where possible, it's probably a good idea for userspace to include these "
"hints, forwarded to the firmware."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:753
msgid "This struct is implicitly sized and therefore is not extensible."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:808
msgid "Describe a depth or stencil buffer."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:820
msgid "Base address of the buffer"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:823
msgid "``comp_base``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:824
msgid ""
"If the load buffer is compressed, address of the compression metadata "
"section."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:830
msgid ""
"If layered rendering is enabled, the number of bytes between each layer of "
"the buffer."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:835
msgid "``comp_stride``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:836
msgid ""
"If layered rendering is enabled, the number of bytes between each layer of "
"the compression metadata."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:809
msgid ""
"These fields correspond to hardware registers in the ZLS (Z Load/Store) "
"unit. There are three hardware registers for each field respectively for "
"loads, stores, and partial renders. In practice, it makes sense to set all "
"to the same values, except in exceptional cases not yet implemented in "
"userspace, so we do not duplicate here for simplicity/efficiency."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:815
#: include/uapi/drm/asahi_drm.h:848 include/uapi/drm/asahi_drm.h:869
#: include/uapi/drm/asahi_drm.h:888 include/uapi/drm/asahi_drm.h:922
msgid ""
"This struct is embedded in other structs and therefore is not extensible."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:842
msgid "Describe a timestamp write."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:854
msgid ""
"Handle of the timestamp buffer, or 0 to skip this timestamp. If nonzero, "
"this must equal the value returned in drm_asahi_gem_bind_object::"
"object_handle."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:860
msgid "Offset to write into the timestamp buffer"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:843
msgid ""
"The firmware can optionally write the GPU timestamp at render pass "
"granularities, but it needs to be mapped specially via "
"DRM_IOCTL_ASAHI_GEM_BIND_OBJECT. This structure therefore describes where to "
"write as a handle-offset pair, rather than a GPU address like normal."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:864
msgid "Describe timestamp writes."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:874
msgid "Timestamp recorded at the start of the operation"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:877
msgid "Timestamp recorded at the end of the operation"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:865
msgid ""
"Each operation that can be timestamped, can be timestamped at the start and "
"end. Therefore, drm_asahi_timestamp structs always come in pairs, bundled "
"together into drm_asahi_timestamps."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:881
msgid "Describe helper program configuration."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:893
msgid "``binary``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:894
msgid ""
"USC address to the helper program binary. This is a tagged pointer with "
"configuration in the bottom bits."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:898
msgid "``cfg``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:899
msgid "Additional configuration bits for the helper program."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:903
msgid ""
"Data passed to the helper program. This value is not interpreted by the "
"kernel, firmware, or hardware in any way. It is simply a sideband for "
"userspace, set with the submit ioctl and read via special registers inside "
"the helper program."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:908
msgid ""
"In practice, userspace will pass a 64-bit GPU VA here pointing to the actual "
"arguments, which presumably don't fit in 64-bits."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:882
msgid ""
"The helper program is a compute-like kernel required for various hardware "
"functionality. Its most important role is dynamically allocating scratch/"
"stack memory for individual subgroups, by partitioning a static allocation "
"shared for the whole device. It is supplied by userspace via "
"drm_asahi_helper_program and internally dispatched by the hardware as needed."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:914
msgid "Describe a background or end-of-tile program."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:927
msgid "``usc``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:928
msgid ""
"USC address of the hardware USC words binding resources (including images "
"and uniforms) and the program itself. Note this is an additional layer of "
"indirection compared to the helper program, avoiding the need for a sideband "
"for data. This is a tagged pointer with additional configuration in the "
"bottom bits."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:936
msgid "``rsrc_spec``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:937
msgid ""
"Resource specifier for the program. This is a packed hardware data structure "
"describing the required number of registers, uniforms, bound textures, and "
"bound samplers."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:915
msgid ""
"The background and end-of-tile programs are dispatched by the hardware at "
"the beginning and end of rendering. As the hardware \"tilebuffer\" is simply "
"local memory, these programs are necessary to implement API-level render "
"targets. The fragment-like background program is responsible for loading "
"either the clear colour or the existing render target contents, while the "
"compute-like end-of-tile program stores the tilebuffer contents to memory."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:944
msgid "Command to submit 3D"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:974
msgid "Combination of drm_asahi_render_flags flags."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:977
msgid "``isp_zls_pixels``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:978
msgid ""
"ISP_ZLS_PIXELS register value. This contains the depth/stencil width/height, "
"which may differ from the framebuffer width/height."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:984
msgid "``vdm_ctrl_stream_base``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:985
msgid ""
"VDM_CTRL_STREAM_BASE register value. GPU address to the beginning of the VDM "
"control stream."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:989
msgid "``vertex_helper``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:990
msgid "Helper program used for the vertex shader"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:992
msgid "``fragment_helper``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:993
msgid "Helper program used for the fragment shader"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:996
msgid "``isp_scissor_base``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:997
msgid ""
"ISP_SCISSOR_BASE register value. GPU address of an array of scissor "
"descriptors indexed in the render pass."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1002
msgid "``isp_dbias_base``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1003
msgid ""
"ISP_DBIAS_BASE register value. GPU address of an array of depth bias values "
"indexed in the render pass."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1008
msgid "``isp_oclqry_base``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1009
msgid ""
"ISP_OCLQRY_BASE register value. GPU address of an array of occlusion query "
"results written by the render pass."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1013
msgid "``depth``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1014
msgid "Depth buffer"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1016
msgid "``stencil``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1017
msgid "Stencil buffer"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1019
msgid "``zls_ctrl``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1020
msgid "ZLS_CTRL register value"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1022
msgid "``ppp_multisamplectl``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1023
msgid "PPP_MULTISAMPLECTL register value"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1026
#: include/uapi/drm/asahi_drm.h:1139
msgid "``sampler_heap``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1027
msgid ""
"Base address of the sampler heap. This heap is used for both vertex shaders "
"and fragment shaders. The registers are per-stage, but there is no known use "
"case for separate heaps."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1032
msgid "``ppp_ctrl``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1033
msgid "PPP_CTRL register value"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1035
msgid "``width_px``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1036
msgid "Framebuffer width in pixels"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1038
msgid "``height_px``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1039
msgid "Framebuffer height in pixels"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1041
msgid "``layers``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1042
msgid "Number of layers in the framebuffer"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1044
#: include/uapi/drm/asahi_drm.h:1123
msgid "``sampler_count``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1045
#: include/uapi/drm/asahi_drm.h:1124
msgid "Number of samplers in the sampler heap."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1047
msgid "``utile_width_px``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1048
msgid "Width of a logical tilebuffer tile in pixels"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1050
msgid "``utile_height_px``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1051
msgid "Height of a logical tilebuffer tile in pixels"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1053
msgid "``samples``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1054
msgid "# of samples in the framebuffer. Must be 1, 2, or 4."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1056
msgid "``sample_size_B``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1057
msgid "# of bytes in the tilebuffer required per sample."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1060
msgid "``isp_merge_upper_x``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1061
msgid ""
"32-bit float used in the hardware triangle merging. Calculate as: tan(60 "
"deg) * width."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1064
msgid ""
"Making these values UAPI avoids requiring floating-point calculations in the "
"kernel in the hot path."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1069
msgid "``isp_merge_upper_y``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1070
msgid ""
"32-bit float. Calculate as: tan(60 deg) * height. See **isp_merge_upper_x**."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1074
msgid "``bg``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1075
msgid "Background program run for each tile at the start"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1077
msgid "``eot``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1078
msgid "End-of-tile program ran for each tile at the end"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1081
msgid "``partial_bg``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1082
msgid ""
"Background program ran at the start of each tile when resuming the render "
"pass during a partial render."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1087
msgid "``partial_eot``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1088
msgid ""
"End-of-tile program ran at the end of each tile when pausing the render pass "
"during a partial render."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1093
msgid "``isp_bgobjdepth``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1094
msgid ""
"ISP_BGOBJDEPTH register value. This is the depth buffer clear value, encoded "
"in the depth buffer's format: either a 32-bit float or a 16-bit unorm (with "
"upper bits zeroed)."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1100
msgid "``isp_bgobjvals``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1101
msgid ""
"ISP_BGOBJVALS register value. The bottom 8-bits contain the stencil buffer "
"clear value."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1105
msgid "``ts_vtx``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1106
msgid "Timestamps for the vertex portion of the render"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1108
msgid "``ts_frag``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1109
msgid "Timestamps for the fragment portion of the render"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:945
msgid ""
"This command submits a single render pass. The hardware control stream may "
"include many draws and subpasses, but within the command, the framebuffer "
"dimensions and attachments are fixed."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:949
msgid ""
"The hardware requires the firmware to set a large number of Control "
"Registers setting up state at render pass granularity before each command "
"rendering 3D. The firmware bundles this state into data structures. "
"Unfortunately, we cannot expose either any of that directly to userspace, "
"because the kernel-firmware ABI is not stable. Although we can guarantee the "
"firmware updates in tandem with the kernel, we cannot break old userspace "
"when upgrading the firmware and kernel. Therefore, we need to abstract well "
"the data structures to avoid tying our hands with future firmwares."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:958
msgid ""
"The bulk of drm_asahi_cmd_render therefore consists of values of hardware "
"control registers, marshalled via the firmware interface."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:961
msgid ""
"The framebuffer/tilebuffer dimensions are also specified here. In addition "
"to being passed to the firmware/hardware, the kernel requires these "
"dimensions to calculate various essential tiling-related data structures. It "
"is unfortunate that our submits are heavier than on vendors with saner "
"hardware-software interfaces. The upshot is all of this information is "
"readily available to userspace with all current APIs."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:968
msgid ""
"It looks odd - but it's not overly burdensome and it ensures we can remain "
"compatible with old userspace."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1113
msgid "Command to submit compute"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1127
msgid "``cdm_ctrl_stream_base``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1128
msgid ""
"CDM_CTRL_STREAM_BASE register value. GPU address to the beginning of the CDM "
"control stream."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1133
msgid "``cdm_ctrl_stream_end``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1134
msgid ""
"GPU base address to the end of the hardware control stream. Note this only "
"considers the first contiguous segment of the control stream, as the stream "
"might jump elsewhere."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1140
msgid "Base address of the sampler heap."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1142
msgid "``helper``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1143
msgid "Helper program used for this compute command"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1145
msgid "``ts``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1146
msgid "Timestamps for the compute command"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1114
msgid ""
"This command submits a control stream consisting of compute dispatches. "
"There is essentially no limit on how many compute dispatches may be included "
"in a single compute command, although timestamps are at command granularity."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1150
msgid "Arguments passed to DRM_IOCTL_ASAHI_GET_TIME"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1156
msgid "``gpu_timestamp``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1157
msgid "On return, the GPU timestamp in nanoseconds."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1163
msgid "``DRM_IOCTL_ASAHI (__access, __id, __type)``"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1161
msgid "Build an Asahi IOCTL number"
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1163
msgid "One of the DRM_ASAHI_xxx id."
msgstr ""

#: ../../../gpu/driver-uapi:34: include/uapi/drm/asahi_drm.h:1165
msgid ""
"Don't use this macro directly, use the DRM_IOCTL_ASAHI_xxx values instead."
msgstr ""
