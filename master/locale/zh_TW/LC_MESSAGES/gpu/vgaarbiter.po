# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../gpu/vgaarbiter.rst:3
msgid "VGA Arbiter"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:5
msgid ""
"Graphic devices are accessed through ranges in I/O or memory space. While "
"most modern devices allow relocation of such ranges, some \"Legacy\" VGA "
"devices implemented on PCI will typically have the same \"hard-decoded\" "
"addresses as they did on ISA. For more details see \"PCI Bus Binding to IEEE "
"Std 1275-1994 Standard for Boot (Initialization Configuration) Firmware "
"Revision 2.1\" Section 7, Legacy Devices."
msgstr ""

#: ../../../gpu/vgaarbiter.rst:12
msgid ""
"The Resource Access Control (RAC) module inside the X server [0] existed for "
"the legacy VGA arbitration task (besides other bus management tasks) when "
"more than one legacy device co-exist on the same machine. But the problem "
"happens when these devices are trying to be accessed by different userspace "
"clients (e.g. two servers in parallel). Their address assignments conflict. "
"Moreover, ideally, being a userspace application, it is not the role of the "
"X server to control bus resources. Therefore an arbitration scheme outside "
"of the X server is needed to control the sharing of these resources. This "
"document introduces the operation of the VGA arbiter implemented for the "
"Linux kernel."
msgstr ""

#: ../../../gpu/vgaarbiter.rst:23
msgid "vgaarb kernel/userspace ABI"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:25
msgid ""
"The vgaarb is a module of the Linux Kernel. When it is initially loaded, it "
"scans all PCI devices and adds the VGA ones inside the arbitration. The "
"arbiter then enables/disables the decoding on different devices of the VGA "
"legacy instructions. Devices which do not want/need to use the arbiter may "
"explicitly tell it by calling vga_set_legacy_decoding()."
msgstr ""

#: ../../../gpu/vgaarbiter.rst:31
msgid ""
"The kernel exports a char device interface (/dev/vga_arbiter) to the "
"clients, which has the following semantics:"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:34
msgid "open"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:35
msgid ""
"Opens a user instance of the arbiter. By default, it's attached to the "
"default VGA device of the system."
msgstr ""

#: ../../../gpu/vgaarbiter.rst:38
msgid "close"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:39
msgid "Close a user instance. Release locks made by the user"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:41
msgid "read"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:42
msgid "Return a string indicating the status of the target like:"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:44
msgid ""
"\"<card_ID>,decodes=<io_state>,owns=<io_state>,locks=<io_state> (ic,mc)\""
msgstr ""

#: ../../../gpu/vgaarbiter.rst:46
msgid ""
"An IO state string is of the form {io,mem,io+mem,none}, mc and ic are "
"respectively mem and io lock counts (for debugging/ diagnostic only). "
"\"decodes\" indicate what the card currently decodes, \"owns\" indicates "
"what is currently enabled on it, and \"locks\" indicates what is locked by "
"this card. If the card is unplugged, we get \"invalid\" then for card_ID and "
"an -ENODEV error is returned for any command until a new card is targeted."
msgstr ""

#: ../../../gpu/vgaarbiter.rst:55
msgid "write"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:56
msgid "Write a command to the arbiter. List of commands:"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:58
msgid "target <card_ID>"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:59
msgid "switch target to card <card_ID> (see below)"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:60
msgid "lock <io_state>"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:61
msgid "acquires locks on target (\"none\" is an invalid io_state)"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:62
msgid "trylock <io_state>"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:63
msgid "non-blocking acquire locks on target (returns EBUSY if unsuccessful)"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:65
msgid "unlock <io_state>"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:66
msgid "release locks on target"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:67
msgid "unlock all"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:68
msgid "release all locks on target held by this user (not implemented yet)"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:70
msgid "decodes <io_state>"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:71
msgid "set the legacy decoding attributes for the card"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:73
msgid "poll"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:74
msgid "event if something changes on any card (not just the target)"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:76
msgid ""
"card_ID is of the form \"PCI:domain:bus:dev.fn\". It can be set to "
"\"default\" to go back to the system default card (TODO: not implemented "
"yet). Currently, only PCI is supported as a prefix, but the userland API may "
"support other bus types in the future, even if the current kernel "
"implementation doesn't."
msgstr ""

#: ../../../gpu/vgaarbiter.rst:81
msgid "Note about locks:"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:83
msgid ""
"The driver keeps track of which user has which locks on which card. It "
"supports stacking, like the kernel one. This complexifies the implementation "
"a bit, but makes the arbiter more tolerant to user space problems and able "
"to properly cleanup in all cases when a process dies. Currently, a max of 16 "
"cards can have locks simultaneously issued from user space for a given user "
"(file descriptor instance) of the arbiter."
msgstr ""

#: ../../../gpu/vgaarbiter.rst:90
msgid ""
"In the case of devices hot-{un,}plugged, there is a hook - pci_notify() - to "
"notify them being added/removed in the system and automatically added/"
"removed in the arbiter."
msgstr ""

#: ../../../gpu/vgaarbiter.rst:94
msgid ""
"There is also an in-kernel API of the arbiter in case DRM, vgacon, or other "
"drivers want to use it."
msgstr ""

#: ../../../gpu/vgaarbiter.rst:98
msgid "In-kernel interface"
msgstr ""

#: ../../../gpu/vgaarbiter:100: include/linux/vgaarb.h:73
#: include/linux/vgaarb.h:88 ../../../gpu/vgaarbiter:103:
#: drivers/pci/vgaarb.c:121 drivers/pci/vgaarb.c:152 drivers/pci/vgaarb.c:405
#: drivers/pci/vgaarb.c:532 drivers/pci/vgaarb.c:945 drivers/pci/vgaarb.c:962
msgid "**Parameters**"
msgstr ""

#: ../../../gpu/vgaarbiter:100: include/linux/vgaarb.h:75
#: include/linux/vgaarb.h:90 ../../../gpu/vgaarbiter:103:
#: drivers/pci/vgaarb.c:154 drivers/pci/vgaarb.c:407 drivers/pci/vgaarb.c:534
#: drivers/pci/vgaarb.c:947 drivers/pci/vgaarb.c:964
msgid "``struct pci_dev *pdev``"
msgstr ""

#: ../../../gpu/vgaarbiter:100: include/linux/vgaarb.h:70
#: include/linux/vgaarb.h:85
msgid "pci device of the VGA card or NULL for the system default"
msgstr ""

#: ../../../gpu/vgaarbiter:100: include/linux/vgaarb.h:72
#: include/linux/vgaarb.h:87 ../../../gpu/vgaarbiter:103:
#: drivers/pci/vgaarb.c:404 drivers/pci/vgaarb.c:531
msgid "``unsigned int rsrc``"
msgstr ""

#: ../../../gpu/vgaarbiter:100: include/linux/vgaarb.h:71
#: include/linux/vgaarb.h:86 ../../../gpu/vgaarbiter:103:
#: drivers/pci/vgaarb.c:403
msgid "bit mask of resources to acquire and lock"
msgstr ""

#: ../../../gpu/vgaarbiter:100: include/linux/vgaarb.h:73
#: include/linux/vgaarb.h:88 ../../../gpu/vgaarbiter:103:
#: drivers/pci/vgaarb.c:3 drivers/pci/vgaarb.c:156 drivers/pci/vgaarb.c:406
#: drivers/pci/vgaarb.c:532 drivers/pci/vgaarb.c:945 drivers/pci/vgaarb.c:962
msgid "**Description**"
msgstr ""

#: ../../../gpu/vgaarbiter:100: include/linux/vgaarb.h:72
msgid "Shortcut to vga_get with interruptible set to true."
msgstr ""

#: ../../../gpu/vgaarbiter:100: include/linux/vgaarb.h:74
#: include/linux/vgaarb.h:89 ../../../gpu/vgaarbiter:103:
#: drivers/pci/vgaarb.c:427
msgid "On success, release the VGA resource again with vga_put()."
msgstr ""

#: ../../../gpu/vgaarbiter:100: include/linux/vgaarb.h:84
msgid "shortcut to vga_get()"
msgstr ""

#: ../../../gpu/vgaarbiter:100: include/linux/vgaarb.h:87
msgid "Shortcut to vga_get with interruptible set to false."
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:117
msgid "return the default VGA device, for vgacon"
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:123
msgid "``void``"
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:1
msgid "no arguments"
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:118
msgid ""
"This can be defined by the platform. The default implementation is rather "
"dumb and will probably only work properly on single VGA card setups and/or "
"x86 platforms."
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:122
msgid ""
"If your VGA default device is not PCI, you'll have to return NULL here. In "
"this case, I assume it will not conflict with any PCI card. If this is not "
"true, I'll have to define two arch hooks for enabling/disabling the VGA "
"default device if that is possible. This may be a problem with real _ISA_ "
"VGA cards, in addition to a PCI one. I don't know at this point how to deal "
"with that card. Can their IOs be disabled at all? If not, then I suppose "
"it's a matter of having the proper arch hook telling us about it, so we "
"basically never allow anybody to succeed a vga_get()."
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:148
msgid "deactivate VGA console"
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:154
msgid "PCI device."
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:149
msgid ""
"Unbind and unregister vgacon in case pdev is the default VGA device. Can be "
"called by GPU drivers on initialization to make sure VGA register access "
"done by vgacon will not disturb the device."
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:401
msgid "acquire & lock VGA resources"
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:402
msgid "PCI device of the VGA card or NULL for the system default"
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:405
msgid "``int interruptible``"
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:404
msgid "blocking should be interruptible by signals ?"
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:405
msgid ""
"Acquire VGA resources for the given card and mark those resources locked. If "
"the resources requested are \"normal\" (and not legacy) resources, the "
"arbiter will first check whether the card is doing legacy decoding for that "
"type of resource. If yes, the lock is \"converted\" into a legacy resource "
"lock."
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:411
msgid ""
"The arbiter will first look for all VGA cards that might conflict and "
"disable their IOs and/or Memory access, including VGA forwarding on P2P "
"bridges if necessary, so that the requested resources can be used. Then, the "
"card is marked as locking these resources and the IO and/or Memory accesses "
"are enabled on the card (including VGA forwarding on parent P2P bridges if "
"any)."
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:417
msgid ""
"This function will block if some conflicting card is already locking one of "
"the required resources (or any resource on a different bus segment, since "
"P2P bridges don't differentiate VGA memory and IO afaik). You can indicate "
"whether this blocking should be interruptible by a signal (for userland "
"interface) or not."
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:423
msgid ""
"Must not be called at interrupt time or in atomic context.  If the card "
"already owns the resources, the function succeeds.  Nested calls are "
"supported (a per-resource counter is maintained)"
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:430
msgid "0 on success, negative error code on failure."
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:528
msgid "release lock on legacy VGA resources"
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:529
msgid "PCI device of VGA card or NULL for system default"
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:530
msgid "bit mask of resource to release"
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:531
msgid ""
"Release resources previously locked by vga_get() or vga_tryget().  The "
"resources aren't disabled right away, so that a subsequent vga_get() on the "
"same card will succeed immediately.  Resources have a counter, so locks are "
"only released if the counter reaches 0."
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:942
msgid "PCI device of the VGA card"
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:944
msgid "``unsigned int decodes``"
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:943
msgid "bit mask of what legacy regions the card decodes"
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:944
msgid ""
"Indicate to the arbiter if the card decodes legacy VGA IOs, legacy VGA "
"Memory, both, or none. All cards default to both, the card driver (fbdev for "
"example) should tell the arbiter if it has disabled legacy decoding, so the "
"card can be left out of the arbitration process (and can be safe to take "
"interrupts at any time."
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:958
msgid "register or unregister a VGA arbitration client"
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:959
msgid "PCI device of the VGA client"
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:961
msgid "``unsigned int (*set_decode)(struct pci_dev *pdev, bool decode)``"
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:960
msgid "VGA decode change callback"
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:961
msgid "Clients have two callback mechanisms they can use."
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:963
msgid ""
"**set_decode** callback: If a client can disable its GPU VGA resource, it "
"will get a callback from this to set the encode/decode state."
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:966
msgid ""
"Rationale: we cannot disable VGA decode resources unconditionally because "
"some single GPU laptops seem to require ACPI or BIOS access to the VGA "
"registers to control things like backlights etc. Hopefully newer multi-GPU "
"laptops do something saner, and desktops won't have any special ACPI for "
"this. The driver will get a callback when VGA arbitration is first used by "
"userspace since some older X servers have issues."
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:974
msgid ""
"Does not check whether a client for **pdev** has been registered already."
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:976
msgid "To unregister, call vga_client_unregister()."
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:978
msgid "**Return**"
msgstr ""

#: ../../../gpu/vgaarbiter:103: drivers/pci/vgaarb.c:979
msgid "0 on success, -ENODEV on failure"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:107
msgid "libpciaccess"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:109
msgid ""
"To use the vga arbiter char device, an API was implemented inside the "
"libpciaccess library. One field was added to struct pci_device (each device "
"on the system)::"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:116
msgid "Besides it, in pci_system were added::"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:123
msgid ""
"The vga_count is used to track how many cards are being arbitrated, so for "
"instance, if there is only one card, then it can completely escape "
"arbitration."
msgstr ""

#: ../../../gpu/vgaarbiter.rst:126
msgid ""
"These functions below acquire VGA resources for the given card and mark "
"those resources as locked. If the resources requested are \"normal\" (and "
"not legacy) resources, the arbiter will first check whether the card is "
"doing legacy decoding for that type of resource. If yes, the lock is "
"\"converted\" into a legacy resource lock. The arbiter will first look for "
"all VGA cards that might conflict and disable their IOs and/or Memory "
"access, including VGA forwarding on P2P bridges if necessary, so that the "
"requested resources can be used. Then, the card is marked as locking these "
"resources and the IO and/or Memory access is enabled on the card (including "
"VGA forwarding on parent P2P bridges if any). In the case of vga_arb_lock(), "
"the function will block if some conflicting card is already locking one of "
"the required resources (or any resource on a different bus segment, since "
"P2P bridges don't differentiate VGA memory and IO afaik). If the card "
"already owns the resources, the function succeeds.  vga_arb_trylock() will "
"return (-EBUSY) instead of blocking. Nested calls are supported (a per-"
"resource counter is maintained)."
msgstr ""

#: ../../../gpu/vgaarbiter.rst:142
msgid "Set the target device of this client. ::"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:146
msgid ""
"For instance, in x86 if two devices on the same bus want to lock different "
"resources, both will succeed (lock). If devices are in different buses and "
"trying to lock different resources, only the first who tried succeeds. ::"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:153
msgid "Unlock resources of device. ::"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:157
msgid ""
"Indicates to the arbiter if the card decodes legacy VGA IOs, legacy VGA "
"Memory, both, or none. All cards default to both, the card driver (fbdev for "
"example) should tell the arbiter if it has disabled legacy decoding, so the "
"card can be left out of the arbitration process (and can be safe to take "
"interrupts at any time. ::"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:165
msgid "Connects to the arbiter device, allocates the struct ::"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:169
msgid "Close the connection ::"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:174
msgid "xf86VGAArbiter (X server implementation)"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:176
msgid ""
"X server basically wraps all the functions that touch VGA registers somehow."
msgstr ""

#: ../../../gpu/vgaarbiter.rst:179
msgid "References"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:181
msgid ""
"Benjamin Herrenschmidt (IBM?) started this work when he discussed such "
"design with the Xorg community in 2005 [1, 2]. In the end of 2007, Paulo "
"Zanoni and Tiago Vignatti (both of C3SL/Federal University of Paraná) "
"proceeded his work enhancing the kernel code to adapt as a kernel module and "
"also did the implementation of the user space side [3]. Now (2009) Tiago "
"Vignatti and Dave Airlie finally put this work in shape and queued to Jesse "
"Barnes' PCI tree."
msgstr ""

#: ../../../gpu/vgaarbiter.rst:188
msgid ""
"https://cgit.freedesktop.org/xorg/xserver/commit/?"
"id=4b42448a2388d40f257774fbffdccaea87bd0347"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:189
msgid "https://lists.freedesktop.org/archives/xorg/2005-March/006663.html"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:190
msgid "https://lists.freedesktop.org/archives/xorg/2005-March/006745.html"
msgstr ""

#: ../../../gpu/vgaarbiter.rst:191
msgid "https://lists.freedesktop.org/archives/xorg/2007-October/029507.html"
msgstr ""
