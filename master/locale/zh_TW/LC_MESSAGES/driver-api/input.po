# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-24 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/input.rst:2
msgid "Input Subsystem"
msgstr ""

#: ../../../driver-api/input.rst:5
msgid "Input core"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:27
msgid "input value representation"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:27
#: include/linux/input/mt.h:39 include/linux/input/mt.h:120
#: ../../../driver-api/input:31: include/linux/input/matrix_keypad.h:28
#: ../../../driver-api/input:37: include/linux/input/sparse-keymap.h:21
#: ../../../driver-api/input:45: include/linux/libps2.h:39
#: ../../../driver-api/input:7: include/linux/input.h:31
#: include/linux/input.h:50 include/linux/input.h:275 include/linux/input.h:344
#: include/linux/input.h:538
msgid "**Definition**::"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:35
#: include/linux/input/mt.h:51 include/linux/input/mt.h:126
#: ../../../driver-api/input:31: include/linux/input/matrix_keypad.h:35
#: ../../../driver-api/input:37: include/linux/input/sparse-keymap.h:35
#: ../../../driver-api/input:45: include/linux/libps2.h:53
#: ../../../driver-api/input:7: include/linux/input.h:39
#: include/linux/input.h:104 include/linux/input.h:295
#: include/linux/input.h:357 include/linux/input.h:555
msgid "**Members**"
msgstr ""

#: ../../../driver-api/input:37: include/linux/input/sparse-keymap.h:18
#: ../../../driver-api/input:7: include/linux/input.h:28
msgid "``type``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:29
msgid "type of value (EV_KEY, EV_ABS, etc)"
msgstr ""

#: ../../../driver-api/input:37: include/linux/input/sparse-keymap.h:21
#: ../../../driver-api/input:7: include/linux/input.h:29
msgid "``code``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:30
msgid "the value code"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:30
msgid "``value``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:31
msgid "the value"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:46
msgid "represents an input device"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:47
#: include/linux/input.h:296 include/linux/input.h:344
msgid "``name``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:48
msgid "name of the device"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:48
msgid "``phys``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:49
msgid "physical path to the device in the system hierarchy"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:49
msgid "``uniq``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:50
msgid "unique identification code for the device (if device has it)"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:50
msgid "``id``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:51
msgid "id of the device (struct input_id)"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:51
msgid "``propbit``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:52
msgid "bitmap of device properties and quirks"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:52
msgid "``evbit``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:53
msgid ""
"bitmap of types of events supported by the device (EV_KEY, EV_REL, etc.)"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:54
msgid "``keybit``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:55
msgid "bitmap of keys/buttons this device has"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:55
msgid "``relbit``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:56
msgid "bitmap of relative axes for the device"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:56
msgid "``absbit``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:57
msgid "bitmap of absolute axes for the device"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:57
msgid "``mscbit``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:58
msgid "bitmap of miscellaneous events supported by the device"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:58
msgid "``ledbit``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:59
msgid "bitmap of leds present on the device"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:59
msgid "``sndbit``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:60
msgid "bitmap of sound effects supported by the device"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:60
#: include/linux/input.h:543
msgid "``ffbit``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:61
msgid "bitmap of force feedback effects supported by the device"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:61
msgid "``swbit``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:62
msgid "bitmap of switches present on the device"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:62
msgid "``hint_events_per_packet``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:63
msgid ""
"average number of events generated by the device in a packet (between EV_SYN/"
"SYN_REPORT events). Used by event handlers to estimate size of the buffer "
"needed to hold events."
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:66
msgid "``keycodemax``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:67
msgid "size of keycode table"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:67
msgid "``keycodesize``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:68
msgid "size of elements in keycode table"
msgstr ""

#: ../../../driver-api/input:37: include/linux/input/sparse-keymap.h:22
#: ../../../driver-api/input:7: include/linux/input.h:68
msgid "``keycode``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:69
msgid "map of scancodes to keycodes for this device"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:70
msgid "``setkeycode``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:71
msgid ""
"optional method to alter current keymap, used to implement sparse keymaps. "
"If not supplied default mechanism will be used. The method is being called "
"while holding event_lock and thus must not sleep"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:69
msgid "``getkeycode``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:70
msgid "optional legacy method to retrieve current keymap."
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:74
msgid "``ff``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:75
msgid ""
"force feedback structure associated with the device if device supports force "
"feedback effects"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:76
msgid "``poller``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:77
msgid ""
"poller structure associated with the device if device is set up to use "
"polling mode"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:78
msgid "``repeat_key``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:79
msgid ""
"stores key code of the last key pressed; used to implement software "
"autorepeat"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:80
msgid "``timer``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:81
msgid "timer for software autorepeat"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:81
msgid "``rep``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:82
msgid "current values for autorepeat parameters (delay, rate)"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:82
msgid "``mt``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:83
msgid "pointer to multitouch state"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:83
msgid "``absinfo``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:84
msgid ""
"array of :c:type:`struct input_absinfo <input_absinfo>` elements holding "
"information about absolute axes (current value, min, max, flat, fuzz, "
"resolution)"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:26
#: ../../../driver-api/input:7: include/linux/input.h:86
msgid "``key``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:87
msgid "reflects current state of device's keys/buttons"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:87
msgid "``led``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:88
msgid "reflects current state of device's LEDs"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:88
msgid "``snd``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:89
msgid "reflects current state of sound effects"
msgstr ""

#: ../../../driver-api/input:37: include/linux/input/sparse-keymap.h:23
#: ../../../driver-api/input:7: include/linux/input.h:89
msgid "``sw``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:90
msgid "reflects current state of device's switches"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:90
#: include/linux/input.h:342
msgid "``open``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:91
msgid ""
"this method is called when the very first user calls input_open_device(). "
"The driver must prepare the device to start generating events (start polling "
"thread, request an IRQ, submit URB, etc.). The meaning of open() is to start "
"providing events to the input core."
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:95
msgid "``close``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:96
msgid ""
"this method is called when the very last user calls input_close_device(). "
"The meaning of close() is to stop providing events to the input core."
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:98
msgid "``flush``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:99
msgid ""
"purges the device. Most commonly used to get rid of force feedback effects "
"loaded into the device when disconnecting from it"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:101
#: include/linux/input.h:273
msgid "``event``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:102
msgid ""
"event handler for events sent _to_ the device, like EV_LED or EV_SND. The "
"device is expected to carry out the requested action (turn on a LED, play "
"sound, etc.) The call is protected by **event_lock** and must not sleep"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:105
msgid "``grab``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:106
msgid ""
"input handle that currently has the device grabbed (via EVIOCGRAB ioctl). "
"When a handle grabs a device it becomes sole recipient for all input events "
"coming from the device"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:108
msgid "``event_lock``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:109
msgid ""
"this spinlock is taken when input core receives and processes a new event "
"for the device (in input_event()). Code that accesses and/or modifies "
"parameters of a device (such as keymap or absmin, absmax, absfuzz, etc.) "
"after device has been registered with input core must take this lock."
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:113
#: include/linux/input.h:545
msgid "``mutex``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:114
msgid "serializes calls to open(), close() and flush() methods"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:114
msgid "``users``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:115
msgid ""
"stores number of users (input handlers) that opened this device. It is used "
"by input_open_device() and input_close_device() to make sure that dev-"
">open() is only called when the first user opens device and dev->close() is "
"called when the very last user closes the device"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:119
msgid "``going_away``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:120
msgid ""
"marks devices that are in a middle of unregistering and causes "
"input_open_device*() fail with -ENODEV."
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:121
#: include/linux/input.h:345
msgid "``dev``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:122
msgid "driver model's view of this device"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:122
#: include/linux/input.h:299
msgid "``h_list``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:123
msgid ""
"list of input handles associated with the device. When accessing the list "
"dev->mutex must be held"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:124
#: include/linux/input.h:300
msgid "``node``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:125
msgid "used to place the device onto input_dev_list"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:125
msgid "``num_vals``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:126
msgid "number of values queued in the current frame"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:126
msgid "``max_vals``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:127
msgid "maximum number of values queued in a frame"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:127
msgid "``vals``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:128
msgid "array of values queued in the current frame"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:128
msgid "``devres_managed``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:129
msgid ""
"indicates that devices is managed with devres framework and needs not be "
"explicitly unregistered or freed."
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:130
msgid "``timestamp``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:131
msgid "storage for a timestamp set by input_set_timestamp called by a driver"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:132
msgid "``inhibited``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:133
msgid ""
"indicates that the input device is inhibited. If that is the case then input "
"core ignores any events generated by the device. Device's close() is called "
"when it is being inhibited and its open() is called when it is being "
"uninhibited."
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:271
msgid "implements one of interfaces for input devices"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:272
#: include/linux/input.h:341 include/linux/input.h:542
msgid "``private``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:273
msgid "driver-specific data"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:274
msgid ""
"event handler. This method is being called by input core with interrupts "
"disabled and dev->event_lock spinlock held and so it may not sleep"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:276
msgid "``events``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:277
msgid ""
"event sequence handler. This method is being called by input core with "
"interrupts disabled and dev->event_lock spinlock held and so it may not "
"sleep. The method must return number of events passed to it."
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:280
msgid "``filter``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:281
msgid "similar to **event**; separates normal event handlers from \"filters\"."
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:282
msgid "``match``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:283
msgid ""
"called after comparing device's id with handler's id_table to perform fine-"
"grained matching between device and handler"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:284
msgid "``connect``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:285
msgid "called when attaching a handler to an input device"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:285
msgid "``disconnect``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:286
msgid "disconnects a handler from input device"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:286
msgid "``start``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:287
msgid ""
"starts handler for given handle. This function is called by input core right "
"after connect() method and also when a process that \"grabbed\" a device "
"releases it"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:289
msgid "``passive_observer``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:290
msgid ""
"set to ``true`` by drivers only interested in observing data stream from "
"devices if there are other users present. Such drivers will not result in "
"starting underlying hardware device when input_open_device() is called for "
"their handles"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:293
msgid "``legacy_minors``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:294
msgid "set to ``true`` by drivers using legacy minor ranges"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:294
msgid "``minor``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:295
msgid ""
"beginning of range of 32 legacy minors for devices this driver can provide"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:297
msgid "name of the handler, to be shown in /proc/bus/input/handlers"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:297
msgid "``id_table``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:298
msgid "pointer to a table of input_device_ids this driver can handle"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:300
msgid "list of input handles associated with the handler"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:301
msgid "for placing the driver onto input_handler_list"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:3
#: drivers/input/input.c:381 drivers/input/input.c:408
#: drivers/input/input.c:434 drivers/input/input.c:482
#: drivers/input/input.c:516 drivers/input/input.c:557
#: drivers/input/input.c:575 drivers/input/input.c:639
#: drivers/input/input.c:727 drivers/input/input.c:870
#: drivers/input/input.c:886 drivers/input/input.c:1723
#: drivers/input/input.c:1955 drivers/input/input.c:1999
#: drivers/input/input.c:2028 drivers/input/input.c:2049
#: drivers/input/input.c:2068 drivers/input/input.c:2242
#: drivers/input/input.c:2293 drivers/input/input.c:2402
#: drivers/input/input.c:2448 drivers/input/input.c:2480
#: drivers/input/input.c:2505 drivers/input/input.c:2602
#: drivers/input/input.c:2649 drivers/input/input.c:2677
#: drivers/input/input.c:2707 ../../../driver-api/input:13:
#: drivers/input/ff-core.c:199 drivers/input/ff-core.c:285
#: drivers/input/ff-core.c:340 ../../../driver-api/input:25:
#: drivers/input/input-mt.c:30 drivers/input/input-mt.c:108
#: drivers/input/input-mt.c:127 drivers/input/input-mt.c:169
#: drivers/input/input-mt.c:190 drivers/input/input-mt.c:284
#: drivers/input/input-mt.c:328 drivers/input/input-mt.c:469
#: drivers/input/input-mt.c:507 ../../../driver-api/input:31:
#: include/linux/input/matrix_keypad.h:31 ../../../driver-api/input:37:
#: include/linux/input/sparse-keymap.h:31 ../../../driver-api/input:40:
#: drivers/input/sparse-keymap.c:59 drivers/input/sparse-keymap.c:80
#: drivers/input/sparse-keymap.c:162 drivers/input/sparse-keymap.c:231
#: drivers/input/sparse-keymap.c:269 ../../../driver-api/input:48:
#: drivers/input/serio/libps2.c:103 drivers/input/serio/libps2.c:125
#: drivers/input/serio/libps2.c:261 drivers/input/serio/libps2.c:421
#: drivers/input/serio/libps2.c:458 drivers/input/serio/libps2.c:593
#: ../../../driver-api/input:7: include/linux/input.h:304
#: include/linux/input.h:479 include/linux/input.h:553
msgid "**Description**"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:301
msgid ""
"Input handlers attach to input devices and create input handles. There are "
"likely several handlers attached to any given input device at the same time. "
"All of them will get their copy of input event generated by the device."
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:306
msgid ""
"The very same structure is used to implement input filters. Input core "
"allows filters to run first and will not pass event to regular handlers if "
"any of the filters indicate that the event should be filtered (by returning "
"``true`` from their filter() method)."
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:311
msgid ""
"Note that input core serializes calls to connect() and disconnect() methods."
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:340
msgid "links input device with an input handler"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:342
msgid "handler-specific data"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:343
msgid ""
"counter showing whether the handle is 'open', i.e. should deliver events "
"from its device"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:345
msgid "name given to the handle by handler that created it"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:346
msgid "input device the handle is attached to"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:346
msgid "``handler``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:347
msgid "handler that works with the device through this handle"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:347
msgid "``handle_events``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:348
msgid ""
"event sequence handler. It is set up by the input core according to event "
"handling method specified in the **handler**. See "
"input_handle_setup_event_handler(). This method is being called by the input "
"core with interrupts disabled and dev->event_lock spinlock held and so it "
"may not sleep."
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:352
msgid "``d_node``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:353
msgid "used to put the handle on device's list of attached handles"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:353
msgid "``h_node``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:354
msgid ""
"used to put the handle on handler's list of handles from which it gets events"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:475
msgid "tell handlers about the driver event rate"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:379
#: drivers/input/input.c:406 drivers/input/input.c:435
#: drivers/input/input.c:480 drivers/input/input.c:517
#: drivers/input/input.c:558 drivers/input/input.c:576
#: drivers/input/input.c:640 drivers/input/input.c:726
#: drivers/input/input.c:870 drivers/input/input.c:886
#: drivers/input/input.c:1724 drivers/input/input.c:1881
#: drivers/input/input.c:1956 drivers/input/input.c:2000
#: drivers/input/input.c:2027 drivers/input/input.c:2050
#: drivers/input/input.c:2067 drivers/input/input.c:2241
#: drivers/input/input.c:2294 drivers/input/input.c:2403
#: drivers/input/input.c:2449 drivers/input/input.c:2481
#: drivers/input/input.c:2504 drivers/input/input.c:2603
#: drivers/input/input.c:2650 drivers/input/input.c:2676
#: drivers/input/input.c:2708 ../../../driver-api/input:13:
#: drivers/input/ff-core.c:90 drivers/input/ff-core.c:198
#: drivers/input/ff-core.c:245 drivers/input/ff-core.c:285
#: drivers/input/ff-core.c:341 ../../../driver-api/input:16:
#: drivers/input/ff-memless.c:503 ../../../driver-api/input:25:
#: drivers/input/input-mt.c:29 drivers/input/input-mt.c:109
#: drivers/input/input-mt.c:126 drivers/input/input-mt.c:169
#: drivers/input/input-mt.c:190 drivers/input/input-mt.c:285
#: drivers/input/input-mt.c:329 drivers/input/input-mt.c:466
#: drivers/input/input-mt.c:507 ../../../driver-api/input:40:
#: drivers/input/sparse-keymap.c:59 drivers/input/sparse-keymap.c:80
#: drivers/input/sparse-keymap.c:159 drivers/input/sparse-keymap.c:227
#: drivers/input/sparse-keymap.c:265 ../../../driver-api/input:48:
#: drivers/input/serio/libps2.c:102 drivers/input/serio/libps2.c:126
#: drivers/input/serio/libps2.c:141 drivers/input/serio/libps2.c:153
#: drivers/input/serio/libps2.c:182 drivers/input/serio/libps2.c:256
#: drivers/input/serio/libps2.c:395 drivers/input/serio/libps2.c:421
#: drivers/input/serio/libps2.c:456 drivers/input/serio/libps2.c:591
#: ../../../driver-api/input:7: include/linux/input.h:479
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:381
#: drivers/input/input.c:437 drivers/input/input.c:872
#: drivers/input/input.c:888 drivers/input/input.c:1726
#: drivers/input/input.c:2002 drivers/input/input.c:2029
#: drivers/input/input.c:2052 drivers/input/input.c:2069
#: drivers/input/input.c:2243 drivers/input/input.c:2296
#: drivers/input/input.c:2405 ../../../driver-api/input:13:
#: drivers/input/ff-core.c:92 drivers/input/ff-core.c:200
#: drivers/input/ff-core.c:247 drivers/input/ff-core.c:287
#: drivers/input/ff-core.c:343 ../../../driver-api/input:16:
#: drivers/input/ff-memless.c:505 ../../../driver-api/input:25:
#: drivers/input/input-mt.c:31 drivers/input/input-mt.c:111
#: drivers/input/input-mt.c:128 drivers/input/input-mt.c:171
#: drivers/input/input-mt.c:192 drivers/input/input-mt.c:287
#: drivers/input/input-mt.c:331 drivers/input/input-mt.c:468
#: drivers/input/input-mt.c:509 ../../../driver-api/input:40:
#: drivers/input/sparse-keymap.c:61 drivers/input/sparse-keymap.c:82
#: drivers/input/sparse-keymap.c:161 drivers/input/sparse-keymap.c:229
#: drivers/input/sparse-keymap.c:267 ../../../driver-api/input:7:
#: include/linux/input.h:481
msgid "``struct input_dev *dev``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:476
msgid "the input device used by the driver"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:478
msgid "``int n_events``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:477
msgid "the average number of events between calls to input_sync()"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:478
msgid ""
"If the event rate sent from a device is unusually large, use this function "
"to set the expected event rate. This will allow handlers to set up an "
"appropriate buffer size for the event stream, in order to minimize "
"information loss."
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:534
msgid "force-feedback part of an input device"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:535
msgid "``upload``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:536
msgid "Called to upload an new effect into device"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:536
msgid "``erase``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:537
msgid "Called to erase an effect from device"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:537
msgid "``playback``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:538
msgid "Called to request device to start playing specified effect"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:538
msgid "``set_gain``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:539
msgid "Called to set specified gain"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:539
msgid "``set_autocenter``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:540
msgid "Called to auto-center device"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:540
msgid "``destroy``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:541
msgid "called by input core when parent input device is being destroyed"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:543
msgid "driver-specific data, will be freed automatically"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:544
msgid ""
"bitmap of force feedback capabilities truly supported by device (not "
"emulated like ones in input_dev->ffbit)"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:546
msgid "mutex for serializing access to the device"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:546
msgid "``max_effects``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:547
msgid "maximum number of effects supported by device"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:547
msgid "``effects``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:548
msgid "pointer to an array of effects currently loaded into device"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:548
msgid "``effect_owners``"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:549
msgid ""
"array of effect owners; when file handle owning an effect gets closed the "
"effect is automatically erased"
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:550
msgid ""
"Every force-feedback device must implement upload() and playback() methods; "
"erase() is optional. set_gain() and set_autocenter() need only be "
"implemented if driver sets up FF_GAIN and FF_AUTOCENTER bits."
msgstr ""

#: ../../../driver-api/input:7: include/linux/input.h:555
msgid ""
"Note that playback(), set_gain() and set_autocenter() are called with dev-"
">event_lock spinlock held and interrupts off and thus may not sleep."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:375
msgid "report new input event"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:376
msgid "device that generated the event"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:378
#: drivers/input/input.c:405 drivers/input/input.c:2066
#: ../../../driver-api/input:13: drivers/input/ff-core.c:244
msgid "``unsigned int type``"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:377
#: drivers/input/input.c:404
msgid "type of the event"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:379
#: drivers/input/input.c:406 drivers/input/input.c:2067
#: ../../../driver-api/input:13: drivers/input/ff-core.c:245
#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:58
#: drivers/input/sparse-keymap.c:264
msgid "``unsigned int code``"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:378
#: drivers/input/input.c:405 drivers/input/input.c:2066
#: ../../../driver-api/input:13: drivers/input/ff-core.c:244
msgid "event code"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:380
#: drivers/input/input.c:407 ../../../driver-api/input:13:
#: drivers/input/ff-core.c:246
msgid "``int value``"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:379
#: drivers/input/input.c:406
msgid "value of the event"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:380
msgid ""
"This function should be used by drivers implementing various input devices "
"to report input events. See also input_inject_event()."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:383
#: drivers/input/input.c:1880 drivers/input/input.c:1965
#: drivers/input/input.c:2005
msgid "**NOTE**"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:384
msgid ""
"input_event() may be safely used right after input device was allocated with "
"input_allocate_device(), even before it is registered with "
"input_register_device(), but the event will not reach any of the input "
"handlers. Such early invocation of input_event() may be used to 'seed' "
"initial state of a switch or initial position of absolute axis, etc."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:402
msgid "send input event from input handler"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:408
#: drivers/input/input.c:519 drivers/input/input.c:560
#: drivers/input/input.c:578 drivers/input/input.c:642
#: drivers/input/input.c:2605 drivers/input/input.c:2652
msgid "``struct input_handle *handle``"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:403
msgid "input handle to send event through"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:407
msgid ""
"Similar to input_event() but will ignore event if device is \"grabbed\" and "
"handle injecting event is not the one that owns the device."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:431
msgid "allocates array of input_absinfo structs"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:432
msgid "the input device emitting absolute events"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:433
msgid ""
"If the absinfo struct the caller asked for is already allocated, this "
"functions will not do anything."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:476
msgid "Copy absinfo from one input_dev to another"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:482
msgid "``struct input_dev *dst``"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:477
msgid "Destination input device to copy the abs settings to"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:479
msgid "``unsigned int dst_axis``"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:478
msgid "ABS_* value selecting the destination axis"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:480
msgid "``const struct input_dev *src``"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:479
msgid "Source input device to copy the abs settings from"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:481
msgid "``unsigned int src_axis``"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:480
msgid "ABS_* value selecting the source axis"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:481
msgid ""
"Set absinfo for the selected destination axis by copying it from the "
"specified source input device's source axis. This is useful to e.g. setup a "
"pen/stylus input-device for combined touchscreen/pen hardware where the pen "
"uses the same coordinates as the touchscreen."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:513
msgid "grabs device for exclusive use"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:514
msgid "input handle that wants to own the device"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:515
msgid ""
"When a device is grabbed by an input handle all events generated by the "
"device are delivered only to this handle. Also events injected by other "
"input handles are ignored while device is grabbed."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:554
msgid "release previously grabbed device"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:555
msgid "input handle that owns the device"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:556
msgid ""
"Releases previously grabbed device so that other input handles can start "
"receiving input events. Upon release all handlers attached to the device "
"have their start() method called so they have a change to synchronize device "
"state with the rest of the system."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:572
msgid "open input device"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:573
#: drivers/input/input.c:637
msgid "handle through which device is being accessed"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:574
msgid ""
"This function should be called by input handlers when they want to start "
"receive events from given input device."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:636
msgid "close input device"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:638
msgid ""
"This function should be called by input handlers when they want to stop "
"receive events from given input device."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:722
msgid ""
"converts scancode in :c:type:`struct input_keymap_entry <input_keymap_entry>`"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:728
#: drivers/input/input.c:885
msgid "``const struct input_keymap_entry *ke``"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:723
msgid "keymap entry containing scancode to be converted."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:725
msgid "``unsigned int *scancode``"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:724
msgid "pointer to the location where converted scancode should be stored."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:726
msgid ""
"This function is used to convert scancode stored in :c:type:`struct "
"keymap_entry <keymap_entry>` into scalar form understood by legacy keymap "
"handling methods. These methods expect scancodes to be represented as "
"'unsigned int'."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:866
msgid "retrieve keycode currently mapped to a given scancode"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:867
msgid "input device which keymap is being queried"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:869
msgid "``struct input_keymap_entry *ke``"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:868
msgid "keymap entry"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:869
msgid ""
"This function should be called by anyone interested in retrieving current "
"keymap. Presently evdev handlers use it."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:882
msgid "attribute a keycode to a given scancode"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:883
msgid "input device which keymap is being updated"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:884
msgid "new keymap entry"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:885
msgid ""
"This function should be called by anyone needing to update current keymap. "
"Presently keyboard and evdev handlers use it."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:1720
msgid "reset/restore the state of input device"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:1721
msgid "input device whose state needs to be reset"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:1722
msgid ""
"This function tries to reset the state of an opened input device and bring "
"internal state and state if the hardware in sync with each other. We mark "
"all keys as released, restore LED state, repeat rate, etc."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:1877
msgid "allocate memory for new input device"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:1883
msgid "``void``"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:1
msgid "no arguments"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:1878
#: drivers/input/input.c:1954
msgid "Returns prepared struct input_dev or ``NULL``."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:1881
msgid ""
"Use input_free_device() to free devices that have not been registered; "
"input_unregister_device() should be used for already registered devices."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:1952
msgid "allocate managed input device"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:1958
msgid "``struct device *dev``"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:1953
msgid "device owning the input device being created"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:1956
msgid ""
"Managed input devices do not need to be explicitly unregistered or freed as "
"it will be done automatically when owner device unbinds from its driver (or "
"binding fails). Once managed input device is allocated, it is ready to be "
"set up and registered in the same fashion as regular input device. There are "
"no special devm_input_device_[un]register() variants, regular ones work with "
"both managed and unmanaged devices, should you need them. In most cases "
"however, managed input device need not be explicitly unregistered or freed."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:1966
msgid ""
"the owner device is set up as parent of input device and users should not "
"override it."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:1996
msgid "free memory occupied by input_dev structure"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:1997
msgid "input device to free"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:1998
msgid ""
"This function should only be used if input_register_device() was not called "
"yet or if it failed. Once device was registered use "
"input_unregister_device() and memory will be freed once last reference to "
"the device is dropped."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2003
msgid "Device should be allocated by input_allocate_device()."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2006
msgid ""
"If there are references to the input device then memory will not be freed "
"until last reference is dropped."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2023
msgid "set timestamp for input events"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2024
msgid "input device to set timestamp for"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2026
msgid "``ktime_t timestamp``"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2025
msgid "the time at which the event has occurred in CLOCK_MONOTONIC"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2027
msgid ""
"This function is intended to provide to the input system a more accurate "
"time of when an event actually occurred. The driver should call this "
"function as soon as a timestamp is acquired ensuring clock conversions in "
"input_set_timestamp are done correctly."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2032
msgid ""
"The system entering suspend state between timestamp acquisition and calling "
"input_set_timestamp can result in inaccurate conversions."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2046
msgid "get timestamp for input events"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2047
msgid "input device to get timestamp from"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2048
msgid "A valid timestamp is a timestamp of non-zero value."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2063
msgid "mark device as capable of a certain event"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2064
msgid "device that is capable of emitting or accepting event"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2065
msgid "type of the event (EV_KEY, EV_REL, etc...)"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2067
msgid ""
"In addition to setting up corresponding bit in appropriate capability bitmap "
"the function also adjusts dev->evbit."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2237
msgid "enable software autorepeat"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2238
#: ../../../driver-api/input:13: drivers/input/ff-core.c:87
msgid "input device"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2240
msgid "``int delay``"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2239
msgid "repeat delay"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2241
msgid "``int period``"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2240
msgid "repeat period"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2241
msgid "Enable software autorepeat on the input device."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2290
msgid "register device with input core"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2291
msgid "device to be registered"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2292
msgid ""
"This function registers device with input core. The device must be allocated "
"with input_allocate_device() and all it's capabilities set up before "
"registering. If function fails the device must be freed with "
"input_free_device(). Once device has been successfully registered it can be "
"unregistered with input_unregister_device(); input_free_device() should not "
"be called in this case."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2300
msgid ""
"Note that this function is also used to register managed input devices (ones "
"allocated with devm_input_allocate_device()). Such managed input devices "
"need not be explicitly unregistered or freed, their tear down is controlled "
"by the devres infrastructure. It is also worth noting that tear down of "
"managed input devices is internally a 2-step process: registered managed "
"input device is first unregistered, but stays in memory and can still handle "
"input_event() calls (although events will not be delivered anywhere). The "
"freeing of managed input device will happen later, when devres stack is "
"unwound to the point where device allocation was made."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2399
msgid "unregister previously registered device"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2400
msgid "device to be unregistered"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2401
msgid ""
"This function unregisters an input device. Once device is unregistered the "
"caller should not try to access it as it may get freed at any moment."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2445
msgid "register a new input handler"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2451
#: drivers/input/input.c:2483 drivers/input/input.c:2506
msgid "``struct input_handler *handler``"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2446
msgid "handler to be registered"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2447
msgid ""
"This function registers a new input handler (interface) for input devices in "
"the system and attaches it to all input devices that are compatible with the "
"handler."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2477
msgid "unregisters an input handler"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2478
msgid "handler to be unregistered"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2479
msgid ""
"This function disconnects a handler from its input devices and removes it "
"from lists of known handlers."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2500
msgid "handle iterator"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2501
msgid "input handler to iterate"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2503
#: ../../../driver-api/input:16: drivers/input/ff-memless.c:502
msgid "``void *data``"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2502
msgid "data for the callback"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2504
msgid "``int (*fn)(struct input_handle *, void *)``"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2503
msgid "function to be called for each handle"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2504
msgid ""
"Iterate over **bus**'s list of devices, and call **fn** for each, passing it "
"**data** and stop when **fn** returns a non-zero value. The function is "
"using RCU to traverse the list and therefore may be using in atomic "
"contexts. The **fn** callback is invoked from RCU critical section and thus "
"must not sleep."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2599
msgid "register a new input handle"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2600
msgid "handle to register"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2601
msgid ""
"This function puts a new input handle onto device's and handler's lists so "
"that events can flow through it once it is opened using input_open_device()."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2605
msgid "This function is supposed to be called from handler's connect() method."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2646
msgid "unregister an input handle"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2647
msgid "handle to unregister"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2648
msgid "This function removes input handle from device's and handler's lists."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2651
msgid ""
"This function is supposed to be called from handler's disconnect() method."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2672
msgid "allocates a new input minor number"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2678
msgid "``int legacy_base``"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2673
msgid "beginning or the legacy range to be searched"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2675
msgid "``unsigned int legacy_num``"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2674
msgid "size of legacy range"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2676
msgid "``bool allow_dynamic``"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2675
msgid "whether we can also take ID from the dynamic range"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2676
msgid ""
"This function allocates a new device minor for from input major namespace. "
"Caller can request legacy minor by specifying **legacy_base** and "
"**legacy_num** parameters and whether ID can be allocated from dynamic range "
"if there are no free IDs in legacy range."
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2704
msgid "release previously allocated minor"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2710
msgid "``unsigned int minor``"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2705
msgid "minor to be released"
msgstr ""

#: ../../../driver-api/input:10: drivers/input/input.c:2706
msgid ""
"This function releases previously allocated input minor so that it can be "
"reused later."
msgstr ""

#: ../../../driver-api/input:13: drivers/input/ff-core.c:86
msgid "upload effect into force-feedback device"
msgstr ""

#: ../../../driver-api/input:13: drivers/input/ff-core.c:89
msgid "``struct ff_effect *effect``"
msgstr ""

#: ../../../driver-api/input:13: drivers/input/ff-core.c:88
msgid "effect to be uploaded"
msgstr ""

#: ../../../driver-api/input:13: drivers/input/ff-core.c:90
#: drivers/input/ff-core.c:198
msgid "``struct file *file``"
msgstr ""

#: ../../../driver-api/input:13: drivers/input/ff-core.c:89
msgid "owner of the effect"
msgstr ""

#: ../../../driver-api/input:13: drivers/input/ff-core.c:194
msgid "erase a force-feedback effect from device"
msgstr ""

#: ../../../driver-api/input:13: drivers/input/ff-core.c:195
msgid "input device to erase effect from"
msgstr ""

#: ../../../driver-api/input:13: drivers/input/ff-core.c:197
msgid "``int effect_id``"
msgstr ""

#: ../../../driver-api/input:13: drivers/input/ff-core.c:196
msgid "id of the effect to be erased"
msgstr ""

#: ../../../driver-api/input:13: drivers/input/ff-core.c:197
msgid "purported owner of the request"
msgstr ""

#: ../../../driver-api/input:13: drivers/input/ff-core.c:198
msgid ""
"This function erases a force-feedback effect from specified device. The "
"effect will only be erased if it was uploaded through the same file handle "
"that is requesting erase."
msgstr ""

#: ../../../driver-api/input:13: drivers/input/ff-core.c:241
msgid "generic handler for force-feedback events"
msgstr ""

#: ../../../driver-api/input:13: drivers/input/ff-core.c:242
msgid "input device to send the effect to"
msgstr ""

#: ../../../driver-api/input:13: drivers/input/ff-core.c:243
msgid "event type (anything but EV_FF is ignored)"
msgstr ""

#: ../../../driver-api/input:13: drivers/input/ff-core.c:245
msgid "event value"
msgstr ""

#: ../../../driver-api/input:13: drivers/input/ff-core.c:281
msgid "create force-feedback device"
msgstr ""

#: ../../../driver-api/input:13: drivers/input/ff-core.c:282
#: ../../../driver-api/input:16: drivers/input/ff-memless.c:500
msgid "input device supporting force-feedback"
msgstr ""

#: ../../../driver-api/input:13: drivers/input/ff-core.c:284
msgid "``unsigned int max_effects``"
msgstr ""

#: ../../../driver-api/input:13: drivers/input/ff-core.c:283
msgid "maximum number of effects supported by the device"
msgstr ""

#: ../../../driver-api/input:13: drivers/input/ff-core.c:284
msgid ""
"This function allocates all necessary memory for a force feedback portion of "
"an input device and installs all default handlers. **dev->ffbit** should be "
"already set up before calling this function. Once ff device is created you "
"need to setup its upload, erase, playback and other handlers before "
"registering input device"
msgstr ""

#: ../../../driver-api/input:13: drivers/input/ff-core.c:337
msgid "frees force feedback portion of input device"
msgstr ""

#: ../../../driver-api/input:13: drivers/input/ff-core.c:338
msgid "input device supporting force feedback"
msgstr ""

#: ../../../driver-api/input:13: drivers/input/ff-core.c:339
msgid ""
"This function is only needed in error path as input core will automatically "
"free force feedback structures when device is destroyed."
msgstr ""

#: ../../../driver-api/input:16: drivers/input/ff-memless.c:499
msgid "create memoryless force-feedback device"
msgstr ""

#: ../../../driver-api/input:16: drivers/input/ff-memless.c:501
msgid "driver-specific data to be passed into **play_effect**"
msgstr ""

#: ../../../driver-api/input:16: drivers/input/ff-memless.c:503
msgid "``int (*play_effect)(struct input_dev *, void *, struct ff_effect *)``"
msgstr ""

#: ../../../driver-api/input:16: drivers/input/ff-memless.c:502
msgid "driver-specific method for playing FF effect"
msgstr ""

#: ../../../driver-api/input.rst:20
msgid "Multitouch Library"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:23
msgid "represents the state of an input MT slot"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:24
msgid "``abs``"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:25
msgid "holds current values of ABS_MT axes for this slot"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:25
#: include/linux/input/mt.h:40
msgid "``frame``"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:26
msgid "last frame at which input_mt_report_slot_state() was called"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:27
msgid "optional driver designation of this slot"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:35
msgid "state of tracked contacts"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:36
msgid "``trkid``"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:37
msgid "stores MT tracking ID for the next contact"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:37
msgid "``num_slots``"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:38
msgid "number of MT slots the device uses"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:38
msgid "``slot``"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:39
msgid "MT slot currently being transmitted"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:39
#: ../../../driver-api/input:45: include/linux/libps2.h:39
msgid "``flags``"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:40
msgid "input_mt operation flags"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:41
msgid "increases every time input_mt_sync_frame() is called"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:41
msgid "``red``"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:42
msgid "reduced cost matrix for in-kernel tracking"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:42
msgid "``slots``"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:43
msgid "array of slots holding current values of tracked contacts"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:116
msgid "contact position"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:117
msgid "``x``"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:118
msgid "horizontal coordinate"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:118
msgid "``y``"
msgstr ""

#: ../../../driver-api/input:22: include/linux/input/mt.h:119
msgid "vertical coordinate"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:25
msgid "initialize MT input slots"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:26
msgid "input device supporting MT events and finger tracking"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:28
msgid "``unsigned int num_slots``"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:27
msgid "number of slots used by the device"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:29
#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:591
msgid "``unsigned int flags``"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:28
msgid "mt tasks to handle in core"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:29
msgid ""
"This function allocates all necessary memory for MT slot handling in the "
"input device, prepares the ABS_MT_SLOT and ABS_MT_TRACKING_ID events for use "
"and sets up appropriate buffers. Depending on the flags set, it also "
"performs pointer emulation and frame synchronization."
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:35
msgid ""
"May be called repeatedly. Returns -EINVAL if attempting to reinitialize with "
"a different number of slots."
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:105
msgid "frees the MT slots of the input device"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:106
#: drivers/input/input-mt.c:123 drivers/input/input-mt.c:166
#: drivers/input/input-mt.c:187 drivers/input/input-mt.c:282
#: drivers/input/input-mt.c:326 drivers/input/input-mt.c:463
#: drivers/input/input-mt.c:504
msgid "input device with allocated MT slots"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:107
msgid ""
"This function is only needed in error path as the input core will "
"automatically free the MT slots when the device is destroyed."
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:122
msgid "report contact state"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:125
msgid "``unsigned int tool_type``"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:124
msgid "the tool type to use in this slot"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:126
msgid "``bool active``"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:125
msgid "true if contact is active, false otherwise"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:126
msgid ""
"Reports a contact via ABS_MT_TRACKING_ID, and optionally ABS_MT_TOOL_TYPE. "
"If active is true and the slot is currently inactive, or if the tool type is "
"changed, a new tracking id is assigned to the slot. The tool type is only "
"reported if the corresponding absbit field is set."
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:132
msgid "Returns true if contact is active."
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:165
msgid "report contact count"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:168
msgid "``int count``"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:167
msgid "the number of contacts"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:168
msgid ""
"Reports the contact count via BTN_TOOL_FINGER, BTN_TOOL_DOUBLETAP, "
"BTN_TOOL_TRIPLETAP and BTN_TOOL_QUADTAP."
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:171
msgid ""
"The input core ensures only the KEY events already setup for this device "
"will produce output."
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:186
msgid "common pointer emulation"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:189
msgid "``bool use_count``"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:188
msgid "report number of active contacts as finger count"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:189
msgid ""
"Performs legacy pointer emulation via BTN_TOUCH, ABS_X, ABS_Y and "
"ABS_PRESSURE. Touchpad finger count is emulated if use_count is true."
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:192
msgid ""
"The input core ensures only the KEY and ABS axes already setup for this "
"device will produce output."
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:281
msgid "Inactivate slots not seen in this frame"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:283
msgid "Lift all slots not seen since the last call to this function."
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:325
msgid "synchronize mt frame"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:327
msgid ""
"Close the frame and prepare the internal state for a new one. Depending on "
"the flags, marks unused slots as inactive and performs pointer emulation."
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:462
msgid "perform a best-match assignment"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:465
msgid "``int *slots``"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:464
msgid "the slot assignment to be filled"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:466
msgid "``const struct input_mt_pos *pos``"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:465
msgid "the position array to match"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:467
msgid "``int num_pos``"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:466
msgid "number of positions"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:468
msgid "``int dmax``"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:467
msgid "maximum ABS_MT_POSITION displacement (zero for infinite)"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:468
msgid ""
"Performs a best match against the current contacts and returns the slot "
"assignment list. New contacts are assigned to unused slots."
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:472
msgid ""
"The assignments are balanced so that all coordinate displacements are below "
"the euclidian distance dmax. If no such assignment can be found, some "
"contacts are assigned to unused slots."
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:476
msgid "Returns zero on success, or negative error in case of failure."
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:503
msgid "return slot matching key"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:506
msgid "``int key``"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:505
msgid "the key of the sought slot"
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:506
msgid ""
"Returns the slot of the given key, if it exists, otherwise set the key on "
"the first unused slot and return."
msgstr ""

#: ../../../driver-api/input:25: drivers/input/input-mt.c:509
msgid ""
"If no available slot can be found, -1 is returned. Note that for this "
"function to work properly, input_mt_sync_frame() has to be called at each "
"frame."
msgstr ""

#: ../../../driver-api/input.rst:29
msgid "Matrix keyboards/keypads"
msgstr ""

#: ../../../driver-api/input:31: include/linux/input/matrix_keypad.h:24
msgid "keymap for matrix keyboards"
msgstr ""

#: ../../../driver-api/input:31: include/linux/input/matrix_keypad.h:25
msgid "``keymap``"
msgstr ""

#: ../../../driver-api/input:31: include/linux/input/matrix_keypad.h:26
msgid ""
"pointer to array of uint32 values encoded with KEY() macro representing "
"keymap"
msgstr ""

#: ../../../driver-api/input:31: include/linux/input/matrix_keypad.h:27
msgid "``keymap_size``"
msgstr ""

#: ../../../driver-api/input:31: include/linux/input/matrix_keypad.h:28
msgid "number of entries (initialized) in this keymap"
msgstr ""

#: ../../../driver-api/input:31: include/linux/input/matrix_keypad.h:28
msgid ""
"This structure is supposed to be used by platform code to supply keymaps to "
"drivers that implement matrix-like keypads/keyboards."
msgstr ""

#: ../../../driver-api/input.rst:35
msgid "Sparse keymap support"
msgstr ""

#: ../../../driver-api/input:37: include/linux/input/sparse-keymap.h:17
msgid "keymap entry for use in sparse keymap"
msgstr ""

#: ../../../driver-api/input:37: include/linux/input/sparse-keymap.h:19
msgid ""
"Type of the key entry (KE_KEY, KE_SW, KE_VSW, KE_END); drivers are allowed "
"to extend the list with their own private definitions."
msgstr ""

#: ../../../driver-api/input:37: include/linux/input/sparse-keymap.h:22
msgid "Device-specific data identifying the button/switch"
msgstr ""

#: ../../../driver-api/input:37: include/linux/input/sparse-keymap.h:1
msgid "``{unnamed_union}``"
msgstr ""

#: ../../../driver-api/input:37: include/linux/input/sparse-keymap.h:2
msgid "anonymous"
msgstr ""

#: ../../../driver-api/input:37: include/linux/input/sparse-keymap.h:23
msgid "KEY_* code assigned to a key/button"
msgstr ""

#: ../../../driver-api/input:37: include/linux/input/sparse-keymap.h:24
msgid "struct with code/value used by KE_SW and KE_VSW"
msgstr ""

#: ../../../driver-api/input:37: include/linux/input/sparse-keymap.h:24
msgid "``sw.code``"
msgstr ""

#: ../../../driver-api/input:37: include/linux/input/sparse-keymap.h:25
msgid "SW_* code assigned to a switch"
msgstr ""

#: ../../../driver-api/input:37: include/linux/input/sparse-keymap.h:25
msgid "``sw.value``"
msgstr ""

#: ../../../driver-api/input:37: include/linux/input/sparse-keymap.h:26
msgid ""
"Value that should be sent in an input even when KE_SW switch is toggled. "
"KE_VSW switches ignore this field and expect driver to supply value for the "
"event."
msgstr ""

#: ../../../driver-api/input:37: include/linux/input/sparse-keymap.h:28
msgid ""
"This structure defines an entry in a sparse keymap used by some input "
"devices for which traditional table-based approach is not suitable."
msgstr ""

#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:55
#: drivers/input/sparse-keymap.c:76
msgid "perform sparse keymap lookup"
msgstr ""

#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:56
#: drivers/input/sparse-keymap.c:77 drivers/input/sparse-keymap.c:262
msgid "Input device using sparse keymap"
msgstr ""

#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:57
#: drivers/input/sparse-keymap.c:263
msgid "Scan code"
msgstr ""

#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:58
#: drivers/input/sparse-keymap.c:79
msgid ""
"This function is used to perform :c:type:`struct key_entry <key_entry>` "
"lookup in an input device using sparse keymap."
msgstr ""

#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:79
msgid "``unsigned int keycode``"
msgstr ""

#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:78
msgid "Key code"
msgstr ""

#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:155
msgid "set up sparse keymap for an input device"
msgstr ""

#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:156
msgid "Input device"
msgstr ""

#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:158
msgid "``const struct key_entry *keymap``"
msgstr ""

#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:157
msgid ""
"Keymap in form of array of :c:type:`key_entry` structures ending with "
"``KE_END`` type entry"
msgstr ""

#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:160
msgid "``int (*setup)(struct input_dev *, struct key_entry *)``"
msgstr ""

#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:159
msgid ""
"Function that can be used to adjust keymap entries depending on device's "
"needs, may be ``NULL``"
msgstr ""

#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:161
msgid ""
"The function calculates size and allocates copy of the original keymap after "
"which sets up input device event bits appropriately. The allocated copy of "
"the keymap is automatically freed when it is no longer needed."
msgstr ""

#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:223
msgid "report event corresponding to given key entry"
msgstr ""

#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:224
msgid "Input device for which event should be reported"
msgstr ""

#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:226
msgid "``const struct key_entry *ke``"
msgstr ""

#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:225
msgid "key entry describing event"
msgstr ""

#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:227
#: drivers/input/sparse-keymap.c:265
msgid "``unsigned int value``"
msgstr ""

#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:226
#: drivers/input/sparse-keymap.c:264
msgid "Value that should be reported (ignored by ``KE_SW`` entries)"
msgstr ""

#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:228
#: drivers/input/sparse-keymap.c:266
msgid "``bool autorelease``"
msgstr ""

#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:227
#: drivers/input/sparse-keymap.c:265
msgid ""
"Signals whether release event should be emitted for ``KE_KEY`` entries right "
"after reporting press event, ignored by all other entries"
msgstr ""

#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:230
msgid ""
"This function is used to report input event described by given :c:type:"
"`struct key_entry <key_entry>`."
msgstr ""

#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:261
msgid "report event corresponding to given scancode"
msgstr ""

#: ../../../driver-api/input:40: drivers/input/sparse-keymap.c:268
msgid ""
"This function is used to perform lookup in an input device using sparse "
"keymap and report corresponding event. Returns ``true`` if lookup was "
"successful and ``false`` otherwise."
msgstr ""

#: ../../../driver-api/input.rst:44
msgid "PS/2 protocol support"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:19
msgid "indicates how received byte should be handled"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:23
msgid "**Constants**"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:25
msgid "``PS2_PROCESS``"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:26
msgid "pass to the main protocol handler, process normally"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:28
msgid "``PS2_IGNORE``"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:29
msgid "skip the byte"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:31
msgid "``PS2_ERROR``"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:32
msgid "do not process the byte, abort command in progress"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:35
msgid "represents a device using PS/2 protocol"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:36
msgid "``serio``"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:37
msgid "a serio port used by the PS/2 device"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:37
msgid "``cmd_mutex``"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:38
msgid "a mutex ensuring that only one command is executing at a time"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:38
msgid "``wait``"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:39
msgid "a waitqueue used to signal completion from the serio interrupt handler"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:40
msgid "various internal flags indicating stages of PS/2 command execution"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:40
msgid "``cmdbuf``"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:41
msgid "buffer holding command response"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:41
msgid "``cmdcnt``"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:42
msgid "outstanding number of bytes of the command response"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:42
msgid "``nak``"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:43
msgid "a byte transmitted by the device when it refuses command"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:43
msgid "``pre_receive_handler``"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:44
msgid ""
"checks communication errors and returns disposition (:c:type:`enum "
"ps2_disposition <ps2_disposition>`) of the received data byte"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:45
msgid "``receive_handler``"
msgstr ""

#: ../../../driver-api/input:45: include/linux/libps2.h:46
msgid ""
"main handler of particular PS/2 protocol, such as keyboard or mouse protocol"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:98
msgid "sends a byte to the device and wait for acknowledgement"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:104
#: drivers/input/serio/libps2.c:128 drivers/input/serio/libps2.c:143
#: drivers/input/serio/libps2.c:155 drivers/input/serio/libps2.c:258
#: drivers/input/serio/libps2.c:397 drivers/input/serio/libps2.c:423
#: drivers/input/serio/libps2.c:458
msgid "``struct ps2dev *ps2dev``"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:99
msgid "a PS/2 device to send the data to"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:101
msgid "``u8 byte``"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:100
msgid "data to be sent to the device"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:102
#: drivers/input/serio/libps2.c:154
msgid "``unsigned int timeout``"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:101
msgid "timeout for sending the data and receiving an acknowledge"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:102
msgid ""
"The function doesn't handle retransmission, the caller is expected to handle "
"it when needed."
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:105
msgid "ps2_sendbyte() can only be called from a process context."
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:122
msgid "mark beginning of execution of a complex command"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:123
#: drivers/input/serio/libps2.c:138
msgid "a PS/2 device executing the command"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:124
msgid ""
"Serializes a complex/compound command. Once command is finished "
"ps2_end_command() should be called."
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:137
msgid "mark end of execution of a complex command"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:149
msgid ""
"waits for device to transmit requested number of bytes and discards them"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:151
msgid "the PS/2 device that should be drained"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:153
msgid "``size_t maxbytes``"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:152
msgid "maximum number of bytes to be drained"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:153
msgid "time to drain the device"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:178
msgid "checks received ID byte against the list of known keyboard IDs"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:184
msgid "``u8 id_byte``"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:180
msgid "data byte that should be checked"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:252
#: drivers/input/serio/libps2.c:391
msgid "send a command to PS/2 device"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:253
#: drivers/input/serio/libps2.c:392 drivers/input/serio/libps2.c:418
msgid "the PS/2 device that should execute the command"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:255
#: drivers/input/serio/libps2.c:394
msgid "``u8 *param``"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:254
#: drivers/input/serio/libps2.c:393
msgid ""
"a buffer containing parameters to be sent along with the command, or place "
"where the results of the command execution will be deposited, or both"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:258
#: drivers/input/serio/libps2.c:397
msgid "``unsigned int command``"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:257
#: drivers/input/serio/libps2.c:396
msgid ""
"command word that encodes the command itself, as well as number of "
"additional parameter bytes that should be sent to the device and expected "
"length of the command response"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:260
msgid ""
"Not serialized. Callers should use ps2_begin_command() and ps2_end_command() "
"to ensure proper serialization for complex commands."
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:400
msgid "**Note**"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:400
msgid ""
"ps2_command() serializes the command execution so that only one command can "
"be executed at a time for either individual port or the entire 8042 "
"controller."
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:417
msgid "sends an extended PS/2 command to a mouse"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:420
msgid "``u8 command``"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:419
msgid "command byte"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:420
msgid ""
"The command is sent using \"sliced\" syntax understood by advanced devices, "
"such as Logitech or Synaptics touchpads. The command is encoded as: 0xE6 "
"0xE8 rr 0xE8 ss 0xE8 tt 0xE8 uu where (rr*64)+(ss*16)+(tt*4)+uu is the "
"command."
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:452
msgid "initializes ps2dev structure"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:453
msgid "structure to be initialized"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:455
#: drivers/input/serio/libps2.c:593
msgid "``struct serio *serio``"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:454
msgid "serio port associated with the PS/2 device"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:456
msgid "``ps2_pre_receive_handler_t pre_receive_handler``"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:455
msgid "validation handler to check basic communication state"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:457
msgid "``ps2_receive_handler_t receive_handler``"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:456
msgid "main protocol handler"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:457
msgid "Prepares ps2dev structure for use in drivers for PS/2 devices."
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:587
msgid "common interrupt handler for PS/2 devices"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:588
msgid "serio port for the device"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:590
msgid "``u8 data``"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:589
msgid "a data byte received from the device"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:590
msgid ""
"flags such as ``SERIO_PARITY`` or ``SERIO_TIMEOUT`` indicating state of the "
"data transfer"
msgstr ""

#: ../../../driver-api/input:48: drivers/input/serio/libps2.c:592
msgid ""
"ps2_interrupt() invokes pre-receive handler, optionally handles command "
"acknowledgement and response from the device, and finally passes the data to "
"the main protocol handler for future processing."
msgstr ""
