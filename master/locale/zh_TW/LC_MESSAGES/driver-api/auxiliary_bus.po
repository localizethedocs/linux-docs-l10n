# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/auxiliary_bus.rst:7
msgid "Auxiliary Bus"
msgstr ""

#: ../../../driver-api/auxiliary_bus:9: drivers/base/auxiliary.c:21
msgid ""
"In some subsystems, the functionality of the core device (PCI/ACPI/other) is "
"too complex for a single device to be managed by a monolithic driver (e.g. "
"Sound Open Firmware), multiple devices might implement a common intersection "
"of functionality (e.g. NICs + RDMA), or a driver may want to export an "
"interface for another subsystem to drive (e.g. SIOV Physical Function export "
"Virtual Function management).  A split of the functionality into child- "
"devices representing sub-domains of functionality makes it possible to "
"compartmentalize, layer, and distribute domain-specific concerns via a Linux "
"device-driver model."
msgstr ""

#: ../../../driver-api/auxiliary_bus:9: drivers/base/auxiliary.c:31
msgid ""
"An example for this kind of requirement is the audio subsystem where a "
"single IP is handling multiple entities such as HDMI, Soundwire, local "
"devices such as mics/speakers etc. The split for the core's functionality "
"can be arbitrary or be defined by the DSP firmware topology and include "
"hooks for test/debug. This allows for the audio core device to be minimal "
"and focused on hardware-specific control and communication."
msgstr ""

#: ../../../driver-api/auxiliary_bus:9: drivers/base/auxiliary.c:38
msgid ""
"Each auxiliary_device represents a part of its parent functionality. The "
"generic behavior can be extended and specialized as needed by encapsulating "
"an auxiliary_device within other domain-specific structures and the use of ."
"ops callbacks. Devices on the auxiliary bus do not share any structures and "
"the use of a communication channel with the parent is domain-specific."
msgstr ""

#: ../../../driver-api/auxiliary_bus:9: drivers/base/auxiliary.c:44
msgid ""
"Note that ops are intended as a way to augment instance behavior within a "
"class of auxiliary devices, it is not the mechanism for exporting common "
"infrastructure from the parent. Consider EXPORT_SYMBOL_NS() to convey "
"infrastructure from the parent module to the auxiliary module(s)."
msgstr ""

#: ../../../driver-api/auxiliary_bus.rst:13
msgid "When Should the Auxiliary Bus Be Used"
msgstr ""

#: ../../../driver-api/auxiliary_bus:15: drivers/base/auxiliary.c:53
msgid ""
"The auxiliary bus is to be used when a driver and one or more kernel "
"modules, who share a common header file with the driver, need a mechanism to "
"connect and provide access to a shared object allocated by the "
"auxiliary_device's registering driver.  The registering driver for the "
"auxiliary_device(s) and the kernel module(s) registering auxiliary_drivers "
"can be from the same subsystem, or from multiple subsystems."
msgstr ""

#: ../../../driver-api/auxiliary_bus:15: drivers/base/auxiliary.c:60
msgid ""
"The emphasis here is on a common generic interface that keeps subsystem "
"customization out of the bus infrastructure."
msgstr ""

#: ../../../driver-api/auxiliary_bus:15: drivers/base/auxiliary.c:63
msgid ""
"One example is a PCI network device that is RDMA-capable and exports a child "
"device to be driven by an auxiliary_driver in the RDMA subsystem.  The PCI "
"driver allocates and registers an auxiliary_device for each physical "
"function on the NIC.  The RDMA driver registers an auxiliary_driver that "
"claims each of these auxiliary_devices.  This conveys data/ops published by "
"the parent PCI device/driver to the RDMA auxiliary_driver."
msgstr ""

#: ../../../driver-api/auxiliary_bus:15: drivers/base/auxiliary.c:70
msgid ""
"Another use case is for the PCI device to be split out into multiple sub "
"functions.  For each sub function an auxiliary_device is created.  A PCI sub "
"function driver binds to such devices that creates its own one or more class "
"devices.  A PCI sub function auxiliary device is likely to be contained in a "
"struct with additional attributes such as user defined sub function number "
"and optional attributes such as resources and a link to the parent device. "
"These attributes could be used by systemd/udev; and hence should be "
"initialized before a driver binds to an auxiliary_device."
msgstr ""

#: ../../../driver-api/auxiliary_bus:15: drivers/base/auxiliary.c:79
msgid ""
"A key requirement for utilizing the auxiliary bus is that there is no "
"dependency on a physical bus, device, register accesses or regmap support. "
"These individual devices split from the core cannot live on the platform bus "
"as they are not physical devices that are controlled by DT/ACPI.  The same "
"argument applies for not using MFD in this scenario as MFD relies on "
"individual function devices being physical devices."
msgstr ""

#: ../../../driver-api/auxiliary_bus.rst:20
msgid "Auxiliary Device Creation"
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:55
msgid "auxiliary device object."
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:59
#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:158
msgid "**Definition**::"
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:72
#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:171
msgid "**Members**"
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:56
msgid "``dev``"
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:57
msgid ""
"Device, The release and parent fields of the device structure must be filled "
"in"
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:59
#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:160
msgid "``name``"
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:60
msgid "Match name found by the auxiliary device driver,"
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:60
msgid "``id``"
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:61
msgid "unique identitier if multiple devices of the same name are exported,"
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:61
msgid "``sysfs``"
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:62
msgid "embedded struct which hold all sysfs related fields,"
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:62
msgid "``sysfs.irqs``"
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:63
msgid "irqs xarray contains irq indices which are used by the device,"
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:63
msgid "``sysfs.lock``"
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:64
msgid "Synchronize irq sysfs creation,"
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:64
msgid "``sysfs.irq_dir_exists``"
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:65
msgid "whether \"irqs\" directory exists,"
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:68
#: ../../../driver-api/auxiliary_bus:25: drivers/base/auxiliary.c:271
#: drivers/base/auxiliary.c:310 ../../../driver-api/auxiliary_bus:38:
#: include/linux/auxiliary_bus.h:166 include/linux/auxiliary_bus.h:278
#: ../../../driver-api/auxiliary_bus:41: drivers/base/auxiliary.c:354
msgid "**Description**"
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:65
msgid ""
"An auxiliary_device represents a part of its parent device's functionality. "
"It is given a name that, combined with the registering drivers "
"KBUILD_MODNAME, creates a match_name that is used for driver binding, and an "
"id that combined with the match_name provide a unique name to register with "
"the bus subsystem.  For example, a driver registering an auxiliary device is "
"named 'foo_mod.ko' and the subdevice is named 'foo_dev'.  The match name is "
"therefore 'foo_mod.foo_dev'."
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:73
msgid "Registering an auxiliary_device is a three-step process."
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:75
msgid ""
"First, a 'struct auxiliary_device' needs to be defined or allocated for each "
"sub-device desired.  The name, id, dev.release, and dev.parent fields of "
"this structure must be filled in as follows."
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:79
msgid ""
"The 'name' field is to be given a name that is recognized by the auxiliary "
"driver.  If two auxiliary_devices with the same match_name, eg \"foo_mod."
"foo_dev\", are registered onto the bus, they must have unique id values (e."
"g. \"x\" and \"y\") so that the registered devices names are \"foo_mod."
"foo_dev.x\" and \"foo_mod.foo_dev.y\".  If match_name + id are not unique, "
"then the device_add fails and generates an error message."
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:86
msgid ""
"The auxiliary_device.dev.type.release or auxiliary_device.dev.release must "
"be populated with a non-NULL pointer to successfully register the "
"auxiliary_device.  This release call is where resources associated with the "
"auxiliary device must be free'ed.  Because once the device is placed on the "
"bus the parent driver can not tell what other code may have a reference to "
"this data."
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:93
msgid ""
"The auxiliary_device.dev.parent should be set.  Typically to the registering "
"drivers device."
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:96
msgid ""
"Second, call auxiliary_device_init(), which checks several aspects of the "
"auxiliary_device struct and performs a device_initialize().  After this step "
"completes, any error state must have a call to auxiliary_device_uninit() in "
"its resolution path."
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:101
msgid ""
"The third and final step in registering an auxiliary_device is to perform a "
"call to auxiliary_device_add(), which sets the name of the device and adds "
"the device to the bus."
msgstr ""

#: ../../../driver-api/auxiliary_bus:22: include/linux/auxiliary_bus.h:132
msgid ""
"Unregistering an auxiliary_device is a two-step process to mirror the "
"register process.  First call auxiliary_device_delete(), then call "
"auxiliary_device_uninit()."
msgstr ""

#: ../../../driver-api/auxiliary_bus:25: drivers/base/auxiliary.c:268
msgid "check auxiliary_device and initialize"
msgstr ""

#: ../../../driver-api/auxiliary_bus:25: drivers/base/auxiliary.c:272
#: drivers/base/auxiliary.c:310 ../../../driver-api/auxiliary_bus:38:
#: include/linux/auxiliary_bus.h:279 ../../../driver-api/auxiliary_bus:41:
#: drivers/base/auxiliary.c:353 drivers/base/auxiliary.c:392
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/auxiliary_bus:25: drivers/base/auxiliary.c:274
#: drivers/base/auxiliary.c:312
msgid "``struct auxiliary_device *auxdev``"
msgstr ""

#: ../../../driver-api/auxiliary_bus:25: drivers/base/auxiliary.c:269
msgid "auxiliary device struct"
msgstr ""

#: ../../../driver-api/auxiliary_bus:25: drivers/base/auxiliary.c:270
msgid ""
"This is the second step in the three-step process to register an "
"auxiliary_device."
msgstr ""

#: ../../../driver-api/auxiliary_bus:25: drivers/base/auxiliary.c:273
msgid ""
"When this function returns an error code, then the device_initialize will "
"*not* have been performed, and the caller will be responsible to free any "
"memory allocated for the auxiliary_device in the error path directly."
msgstr ""

#: ../../../driver-api/auxiliary_bus:25: drivers/base/auxiliary.c:277
msgid ""
"It returns 0 on success.  On success, the device_initialize has been "
"performed.  After this point any error unwinding will need to include a call "
"to auxiliary_device_uninit().  In this post-initialize error scenario, a "
"call to the device's .release callback will be triggered, and all memory "
"clean-up is expected to be handled there."
msgstr ""

#: ../../../driver-api/auxiliary_bus:25: drivers/base/auxiliary.c:306
msgid "add an auxiliary bus device"
msgstr ""

#: ../../../driver-api/auxiliary_bus:25: drivers/base/auxiliary.c:307
msgid "auxiliary bus device to add to the bus"
msgstr ""

#: ../../../driver-api/auxiliary_bus:25: drivers/base/auxiliary.c:309
#: ../../../driver-api/auxiliary_bus:41: drivers/base/auxiliary.c:353
msgid "``const char *modname``"
msgstr ""

#: ../../../driver-api/auxiliary_bus:25: drivers/base/auxiliary.c:308
msgid "name of the parent device's driver module"
msgstr ""

#: ../../../driver-api/auxiliary_bus:25: drivers/base/auxiliary.c:309
msgid ""
"This is the third step in the three-step process to register an "
"auxiliary_device."
msgstr ""

#: ../../../driver-api/auxiliary_bus:25: drivers/base/auxiliary.c:312
msgid ""
"This function must be called after a successful call to "
"auxiliary_device_init(), which will perform the device_initialize.  This "
"means that if this returns an error code, then a call to "
"auxiliary_device_uninit() must be performed so that the .release callback "
"will be triggered to free the memory associated with the auxiliary_device."
msgstr ""

#: ../../../driver-api/auxiliary_bus:25: drivers/base/auxiliary.c:318
msgid ""
"The expectation is that users will call the \"auxiliary_device_add\" macro "
"so that the caller's KBUILD_MODNAME is automatically inserted for the "
"modname parameter.  Only if a user requires a custom name would this version "
"be called directly."
msgstr ""

#: ../../../driver-api/auxiliary_bus.rst:29
msgid "Auxiliary Device Memory Model and Lifespan"
msgstr ""

#: ../../../driver-api/auxiliary_bus:31: include/linux/auxiliary_bus.h:15
msgid ""
"The registering driver is the entity that allocates memory for the "
"auxiliary_device and registers it on the auxiliary bus.  It is important to "
"note that, as opposed to the platform bus, the registering driver is wholly "
"responsible for the management of the memory used for the device object."
msgstr ""

#: ../../../driver-api/auxiliary_bus:31: include/linux/auxiliary_bus.h:20
msgid ""
"To be clear the memory for the auxiliary_device is freed in the release() "
"callback defined by the registering driver.  The registering driver should "
"only call auxiliary_device_delete() and then auxiliary_device_uninit() when "
"it is done with the device.  The release() function is then automatically "
"called if and when other code releases their reference to the devices."
msgstr ""

#: ../../../driver-api/auxiliary_bus:31: include/linux/auxiliary_bus.h:26
msgid ""
"A parent object, defined in the shared header file, contains the "
"auxiliary_device.  It also contains a pointer to the shared object(s), which "
"also is defined in the shared header.  Both the parent object and the shared "
"object(s) are allocated by the registering driver.  This layout allows the "
"auxiliary_driver's registering module to perform a container_of() call to go "
"from the pointer to the auxiliary_device, that is passed during the call to "
"the auxiliary_driver's probe function, up to the parent object, and then "
"have access to the shared object(s)."
msgstr ""

#: ../../../driver-api/auxiliary_bus:31: include/linux/auxiliary_bus.h:35
msgid ""
"The memory for the shared object(s) must have a lifespan equal to, or "
"greater than, the lifespan of the memory for the auxiliary_device.  The "
"auxiliary_driver should only consider that the shared object is valid as "
"long as the auxiliary_device is still registered on the auxiliary bus.  It "
"is up to the registering driver to manage (e.g. free or keep available) the "
"memory for the shared object beyond the life of the auxiliary_device."
msgstr ""

#: ../../../driver-api/auxiliary_bus:31: include/linux/auxiliary_bus.h:42
msgid ""
"The registering driver must unregister all auxiliary devices before its own "
"driver.remove() is completed.  An easy way to ensure this is to use the "
"devm_add_action_or_reset() call to register a function against the parent "
"device which unregisters the auxiliary device object(s)."
msgstr ""

#: ../../../driver-api/auxiliary_bus:31: include/linux/auxiliary_bus.h:47
msgid ""
"Finally, any operations which operate on the auxiliary devices must continue "
"to function (if only to return an error) after the registering driver "
"unregisters the auxiliary device."
msgstr ""

#: ../../../driver-api/auxiliary_bus.rst:36
msgid "Auxiliary Drivers"
msgstr ""

#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:154
msgid "Definition of an auxiliary bus driver"
msgstr ""

#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:155
msgid "``probe``"
msgstr ""

#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:156
msgid "Called when a matching device is added to the bus."
msgstr ""

#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:156
msgid "``remove``"
msgstr ""

#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:157
msgid "Called when device is removed from the bus."
msgstr ""

#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:157
msgid "``shutdown``"
msgstr ""

#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:158
msgid "Called at shut-down time to quiesce the device."
msgstr ""

#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:158
msgid "``suspend``"
msgstr ""

#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:159
msgid "Called to put the device to sleep mode. Usually to a power state."
msgstr ""

#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:159
msgid "``resume``"
msgstr ""

#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:160
msgid "Called to bring a device from sleep mode."
msgstr ""

#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:161
msgid "Driver name."
msgstr ""

#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:161
msgid "``driver``"
msgstr ""

#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:162
msgid "Core driver structure."
msgstr ""

#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:162
msgid "``id_table``"
msgstr ""

#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:163
msgid "Table of devices this driver should match on the bus."
msgstr ""

#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:163
msgid ""
"Auxiliary drivers follow the standard driver model convention, where "
"discovery/enumeration is handled by the core, and drivers provide probe() "
"and remove() methods. They support power management and shutdown "
"notifications using the standard conventions."
msgstr ""

#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:168
msgid ""
"Auxiliary drivers register themselves with the bus by calling "
"auxiliary_driver_register(). The id_table contains the match_names of "
"auxiliary devices that a driver can bind with."
msgstr ""

#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:277
msgid "``module_auxiliary_driver (__auxiliary_driver)``"
msgstr ""

#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:275
msgid "Helper macro for registering an auxiliary driver"
msgstr ""

#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:281
msgid "``__auxiliary_driver``"
msgstr ""

#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:276
msgid "auxiliary driver struct"
msgstr ""

#: ../../../driver-api/auxiliary_bus:38: include/linux/auxiliary_bus.h:277
msgid ""
"Helper macro for auxiliary drivers which do not do anything special in "
"module init/exit. This eliminates a lot of boilerplate. Each module may only "
"use this macro once, and calling it replaces module_init() and module_exit()"
msgstr ""

#: ../../../driver-api/auxiliary_bus:41: drivers/base/auxiliary.c:349
msgid "register a driver for auxiliary bus devices"
msgstr ""

#: ../../../driver-api/auxiliary_bus:41: drivers/base/auxiliary.c:355
#: drivers/base/auxiliary.c:394
msgid "``struct auxiliary_driver *auxdrv``"
msgstr ""

#: ../../../driver-api/auxiliary_bus:41: drivers/base/auxiliary.c:350
#: drivers/base/auxiliary.c:389
msgid "auxiliary_driver structure"
msgstr ""

#: ../../../driver-api/auxiliary_bus:41: drivers/base/auxiliary.c:352
msgid "``struct module *owner``"
msgstr ""

#: ../../../driver-api/auxiliary_bus:41: drivers/base/auxiliary.c:351
msgid "owning module/driver"
msgstr ""

#: ../../../driver-api/auxiliary_bus:41: drivers/base/auxiliary.c:352
msgid "KBUILD_MODNAME for parent driver"
msgstr ""

#: ../../../driver-api/auxiliary_bus:41: drivers/base/auxiliary.c:353
msgid ""
"The expectation is that users will call the \"auxiliary_driver_register\" "
"macro so that the caller's KBUILD_MODNAME is automatically inserted for the "
"modname parameter.  Only if a user requires a custom name would this version "
"be called directly."
msgstr ""

#: ../../../driver-api/auxiliary_bus:41: drivers/base/auxiliary.c:388
msgid "unregister a driver"
msgstr ""

#: ../../../driver-api/auxiliary_bus.rst:45
msgid "Example Usage"
msgstr ""

#: ../../../driver-api/auxiliary_bus:47: drivers/base/auxiliary.c:90
msgid ""
"Auxiliary devices are created and registered by a subsystem-level core "
"device that needs to break up its functionality into smaller fragments. One "
"way to extend the scope of an auxiliary_device is to encapsulate it within a "
"domain-specific structure defined by the parent device. This structure "
"contains the auxiliary_device and any associated shared data/callbacks "
"needed to establish the connection with the parent."
msgstr ""

#: ../../../driver-api/auxiliary_bus:47: drivers/base/auxiliary.c:97
msgid "An example is:"
msgstr ""

#: ../../../driver-api/auxiliary_bus:47: drivers/base/auxiliary.c:108
msgid ""
"The parent device then registers the auxiliary_device by calling "
"auxiliary_device_init(), and then auxiliary_device_add(), with the pointer "
"to the auxdev member of the above structure. The parent provides a name for "
"the auxiliary_device that, combined with the parent's KBUILD_MODNAME, "
"creates a match_name that is be used for matching and binding with a driver."
msgstr ""

#: ../../../driver-api/auxiliary_bus:47: drivers/base/auxiliary.c:114
msgid ""
"Whenever an auxiliary_driver is registered, based on the match_name, the "
"auxiliary_driver's probe() is invoked for the matching devices.  The "
"auxiliary_driver can also be encapsulated inside custom drivers that make "
"the core device's functionality extensible by adding additional domain-"
"specific ops as follows:"
msgstr ""

#: ../../../driver-api/auxiliary_bus:47: drivers/base/auxiliary.c:133
msgid "An example of this type of usage is:"
msgstr ""

#: ../../../driver-api/auxiliary_bus:47: drivers/base/auxiliary.c:158
msgid ""
"Please note that such custom ops approach is valid, but it is hard to "
"implement it right without global locks per-device to protect from "
"auxiliary_drv removal during call to that ops. In addition, this "
"implementation lacks proper module dependency, which causes to load/unload "
"races between auxiliary parent and devices modules."
msgstr ""

#: ../../../driver-api/auxiliary_bus:47: drivers/base/auxiliary.c:164
msgid ""
"The most easiest way to provide these ops reliably without needing to have a "
"lock is to EXPORT_SYMBOL*() them and rely on already existing modules "
"infrastructure for validity and correct dependencies chains."
msgstr ""
