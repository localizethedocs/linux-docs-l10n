# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-06 15:47+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/nvdimm/nvdimm.rst:3
msgid "LIBNVDIMM: Non-Volatile Devices"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:5
msgid "libnvdimm - kernel / libndctl - userspace helper library"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:7
msgid "nvdimm@lists.linux.dev"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:9
msgid "Version 13"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:47
msgid "Glossary"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:49
msgid "PMEM:"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:50
msgid ""
"A system-physical-address range where writes are persistent.  A block device "
"composed of PMEM is capable of DAX.  A PMEM address range may span an "
"interleave of several DIMMs."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:54
msgid "DPA:"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:55
msgid ""
"DIMM Physical Address, is a DIMM-relative offset.  With one DIMM in the "
"system there would be a 1:1 system-physical-address:DPA association. Once "
"more DIMMs are added a memory controller interleave must be decoded to "
"determine the DPA associated with a given system-physical-address."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:61
msgid "DAX:"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:62
msgid ""
"File system extensions to bypass the page cache and block layer to mmap "
"persistent memory, from a PMEM block device, directly into a process address "
"space."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:66
msgid "DSM:"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:67
msgid ""
"Device Specific Method: ACPI method to control specific device - in this "
"case the firmware."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:70
msgid "DCR:"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:71
msgid ""
"NVDIMM Control Region Structure defined in ACPI 6 Section 5.2.25.5. It "
"defines a vendor-id, device-id, and interface format for a given DIMM."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:74
msgid "BTT:"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:75
msgid ""
"Block Translation Table: Persistent memory is byte addressable. Existing "
"software may have an expectation that the power-fail-atomicity of writes is "
"at least one sector, 512 bytes.  The BTT is an indirection table with atomic "
"update semantics to front a PMEM block device driver and present arbitrary "
"atomic sector sizes."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:81
msgid "LABEL:"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:82
msgid ""
"Metadata stored on a DIMM device that partitions and identifies "
"(persistently names) capacity allocated to different PMEM namespaces. It "
"also indicates whether an address abstraction like a BTT is applied to the "
"namespace.  Note that traditional partition tables, GPT/MBR, are layered on "
"top of a PMEM namespace, or an address abstraction like BTT if present, but "
"partition support is deprecated going forward."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:91
msgid "Overview"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:93
msgid ""
"The LIBNVDIMM subsystem provides support for PMEM described by platform "
"firmware or a device driver. On ACPI based systems the platform firmware "
"conveys persistent memory resource via the ACPI NFIT \"NVDIMM Firmware "
"Interface Table\" in ACPI 6. While the LIBNVDIMM subsystem implementation is "
"generic and supports pre-NFIT platforms, it was guided by the superset of "
"capabilities need to support this ACPI 6 definition for NVDIMM resources. "
"The original implementation supported the block-window-aperture capability "
"described in the NFIT, but that support has since been abandoned and never "
"shipped in a product."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:104
msgid "Supporting Documents"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:106
msgid "ACPI 6:"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:107
msgid "https://www.uefi.org/sites/default/files/resources/ACPI_6.0.pdf"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:108
msgid "NVDIMM Namespace:"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:109
msgid "https://pmem.io/documents/NVDIMM_Namespace_Spec.pdf"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:110
msgid "DSM Interface Example:"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:111
msgid "https://pmem.io/documents/NVDIMM_DSM_Interface_Example.pdf"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:112
msgid "Driver Writer's Guide:"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:113
msgid "https://pmem.io/documents/NVDIMM_Driver_Writers_Guide.pdf"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:116
msgid "Git Trees"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:118
msgid "LIBNVDIMM:"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:119
msgid "https://git.kernel.org/cgit/linux/kernel/git/nvdimm/nvdimm.git"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:120
msgid "LIBNDCTL:"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:121
msgid "https://github.com/pmem/ndctl.git"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:125
msgid "LIBNVDIMM PMEM"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:127
msgid ""
"Prior to the arrival of the NFIT, non-volatile memory was described to a "
"system in various ad-hoc ways.  Usually only the bare minimum was provided, "
"namely, a single system-physical-address range where writes are expected to "
"be durable after a system power loss.  Now, the NFIT specification "
"standardizes not only the description of PMEM, but also platform message-"
"passing entry points for control and configuration."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:134
msgid ""
"PMEM (nd_pmem.ko): Drives a system-physical-address range.  This range is "
"contiguous in system memory and may be interleaved (hardware memory "
"controller striped) across multiple DIMMs.  When interleaved the platform "
"may optionally provide details of which DIMMs are participating in the "
"interleave."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:139
msgid ""
"It is worth noting that when the labeling capability is detected (a EFI "
"namespace label index block is found), then no block device is created by "
"default as userspace needs to do at least one allocation of DPA to the PMEM "
"range.  In contrast ND_NAMESPACE_IO ranges, once registered, can be "
"immediately attached to nd_pmem. This latter mode is called label-less or "
"\"legacy\"."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:147
msgid "PMEM-REGIONs, Atomic Sectors, and DAX"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:149
msgid ""
"For the cases where an application or filesystem still needs atomic sector "
"update guarantees it can register a BTT on a PMEM device or partition.  See "
"LIBNVDIMM/NDCTL: Block Translation Table \"btt\""
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:155
msgid "Example NVDIMM Platform"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:157
msgid ""
"For the remainder of this document the following diagram will be referenced "
"for any example sysfs layouts::"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:176
msgid ""
"In this platform we have four DIMMs and two memory controllers in one "
"socket.  Each PMEM interleave set is identified by a region device with a "
"dynamically assigned id."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:180
msgid ""
"The first portion of DIMM0 and DIMM1 are interleaved as REGION0. A single "
"PMEM namespace is created in the REGION0-SPA-range that spans most of DIMM0 "
"and DIMM1 with a user-specified name of \"pm0.0\". Some of that interleaved "
"system-physical-address range is left free for another PMEM namespace to be "
"defined."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:186
msgid ""
"In the last portion of DIMM0 and DIMM1 we have an interleaved system-"
"physical-address range, REGION1, that spans those two DIMMs as well as DIMM2 "
"and DIMM3.  Some of REGION1 is allocated to a PMEM namespace named \"pm1.0\"."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:191
msgid ""
"This bus is provided by the kernel under the device /sys/devices/platform/"
"nfit_test.0 when the nfit_test.ko module from tools/testing/nvdimm is "
"loaded. This module is a unit test for LIBNVDIMM and the  acpi_nfit.ko "
"driver."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:198
msgid "LIBNVDIMM Kernel Device Model and LIBNDCTL Userspace API"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:200
msgid ""
"What follows is a description of the LIBNVDIMM sysfs layout and a "
"corresponding object hierarchy diagram as viewed through the LIBNDCTL API.  "
"The example sysfs paths and diagrams are relative to the Example NVDIMM "
"Platform which is also the LIBNVDIMM bus used in the LIBNDCTL unit test."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:207
msgid "LIBNDCTL: Context"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:209
msgid ""
"Every API call in the LIBNDCTL library requires a context that holds the "
"logging parameters and other library instance state.  The library is based "
"on the libabc template:"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:213
msgid "https://git.kernel.org/cgit/linux/kernel/git/kay/libabc.git"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:216
msgid "LIBNDCTL: instantiate a new library context example"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:228
msgid "LIBNVDIMM/LIBNDCTL: Bus"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:230
msgid ""
"A bus has a 1:1 relationship with an NFIT.  The current expectation for ACPI "
"based systems is that there is only ever one platform-global NFIT. That "
"said, it is trivial to register multiple NFITs, the specification does not "
"preclude it.  The infrastructure supports multiple buses and we use this "
"capability to test multiple NFIT configurations in the unit test."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:238
msgid "LIBNVDIMM: control class device in /sys/class"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:240
msgid ""
"This character device accepts DSM messages to be passed to DIMM identified "
"by its NFIT handle::"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:251
msgid "LIBNVDIMM: bus"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:280
msgid "LIBNDCTL: bus enumeration example"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:282
msgid ""
"Find the bus handle that describes the bus from Example NVDIMM Platform::"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:300
msgid "LIBNVDIMM/LIBNDCTL: DIMM (NMEM)"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:302
msgid ""
"The DIMM device provides a character device for sending commands to "
"hardware, and it is a container for LABELs.  If the DIMM is defined by NFIT "
"then an optional 'nfit' attribute sub-directory is available to add NFIT-"
"specifics."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:307
msgid ""
"Note that the kernel device name for \"DIMMs\" is \"nmemX\".  The NFIT "
"describes these devices via \"Memory Device to System Physical Address Range "
"Mapping Structure\", and there is no requirement that they actually be "
"physical DIMMs, so we use a more generic name."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:313
msgid "LIBNVDIMM: DIMM (NMEM)"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:347
msgid "LIBNDCTL: DIMM enumeration example"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:349
msgid ""
"Note, in this example we are assuming NFIT-defined DIMMs which are "
"identified by an \"nfit_handle\" a 32-bit value where:"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:352
msgid "Bit 3:0 DIMM number within the memory channel"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:353
msgid "Bit 7:4 memory channel number"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:354
msgid "Bit 11:8 memory controller ID"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:355
msgid ""
"Bit 15:12 socket ID (within scope of a Node controller if node controller is "
"present)"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:357
msgid "Bit 27:16 Node Controller ID"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:358
msgid "Bit 31:28 Reserved"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:381
msgid "LIBNVDIMM/LIBNDCTL: Region"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:383
msgid ""
"A generic REGION device is registered for each PMEM interleave-set / range. "
"Per the example there are 2 PMEM regions on the \"nfit_test.0\" bus. The "
"primary role of regions are to be a container of \"mappings\".  A mapping is "
"a tuple of <DIMM, DPA-start-offset, length>."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:388
msgid ""
"LIBNVDIMM provides a built-in driver for REGION devices.  This driver is "
"responsible for all parsing LABELs, if present, and then emitting NAMESPACE "
"devices for the nd_pmem driver to consume."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:392
msgid ""
"In addition to the generic attributes of \"mapping\"s, \"interleave_ways\" "
"and \"size\" the REGION device also exports some convenience attributes. "
"\"nstype\" indicates the integer type of namespace-device this region emits, "
"\"devtype\" duplicates the DEVTYPE variable stored by udev at the 'add' "
"event, \"modalias\" duplicates the MODALIAS variable stored by udev at the "
"'add' event, and finally, the optional \"spa_index\" is provided in the case "
"where the region is defined by a SPA."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:400
msgid "LIBNVDIMM: region::"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:433
msgid "LIBNDCTL: region enumeration example"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:435
msgid ""
"Sample region retrieval routines based on NFIT-unique data like "
"\"spa_index\" (interleave set id)."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:456
msgid "LIBNVDIMM/LIBNDCTL: Namespace"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:458
msgid ""
"A REGION, after resolving DPA aliasing and LABEL specified boundaries, "
"surfaces one or more \"namespace\" devices.  The arrival of a \"namespace\" "
"device currently triggers the nd_pmem driver to load and register a disk/"
"block device."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:463
msgid "LIBNVDIMM: namespace"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:465
msgid ""
"Here is a sample layout from the 2 major types of NAMESPACE where "
"namespace0.0 represents DIMM-info-backed PMEM (note that it has a 'uuid' "
"attribute), and namespace1.0 represents an anonymous PMEM namespace (note "
"that has no 'uuid' attribute due to not support a LABEL)"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:500
msgid "LIBNDCTL: namespace enumeration example"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:501
msgid ""
"Namespaces are indexed relative to their parent region, example below. These "
"indexes are mostly static from boot to boot, but subsystem makes no "
"guarantees in this regard.  For a static namespace identifier use its 'uuid' "
"attribute."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:521
msgid "LIBNDCTL: namespace creation example"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:523
msgid ""
"Idle namespaces are automatically created by the kernel if a given region "
"has enough available capacity to create a new namespace. Namespace "
"instantiation involves finding an idle namespace and configuring it.  For "
"the most part the setting of namespace attributes can occur in any order, "
"the only constraint is that 'uuid' must be set before 'size'.  This enables "
"the kernel to track DPA allocations internally with a static identifier::"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:552
msgid "Why the Term \"namespace\"?"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:554
msgid ""
"Why not \"volume\" for instance?  \"volume\" ran the risk of confusing ND "
"(libnvdimm subsystem) to a volume manager like device-mapper."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:557
msgid ""
"The term originated to describe the sub-devices that can be created within a "
"NVME controller (see the nvme specification: https://www.nvmexpress.org/"
"specifications/), and NFIT namespaces are meant to parallel the capabilities "
"and configurability of NVME-namespaces."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:565
msgid "LIBNVDIMM/LIBNDCTL: Block Translation Table \"btt\""
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:567
msgid ""
"A BTT (design document: https://pmem.io/2014/09/23/btt.html) is a "
"personality driver for a namespace that fronts entire namespace as an "
"'address abstraction'."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:572
msgid "LIBNVDIMM: btt layout"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:574
msgid ""
"Every region will start out with at least one BTT device which is the seed "
"device.  To activate it set the \"namespace\", \"uuid\", and \"sector_size\" "
"attributes and then bind the device to the nd_pmem or nd_blk driver "
"depending on the region type::"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:591
msgid "LIBNDCTL: btt creation example"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:593
msgid ""
"Similar to namespaces an idle BTT device is automatically created per "
"region.  Each time this \"seed\" btt device is configured and enabled a new "
"seed is created.  Creating a BTT configuration involves two steps of finding "
"and idle BTT and assigning it to consume a namespace."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:626
msgid ""
"Once instantiated a new inactive btt seed device will appear underneath the "
"region."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:629
msgid ""
"Once a \"namespace\" is removed from a BTT that instance of the BTT device "
"will be deleted or otherwise reset to default values.  This deletion is only "
"at the device model level.  In order to destroy a BTT the \"info block\" "
"needs to be destroyed.  Note, that to destroy a BTT the media needs to be "
"written in raw mode.  By default, the kernel will autodetect the presence of "
"a BTT and disable raw mode.  This autodetect behavior can be suppressed by "
"enabling raw mode for the namespace via the ndctl_namespace_set_raw_mode() "
"API."
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:640
msgid "Summary LIBNDCTL Diagram"
msgstr ""

#: ../../../driver-api/nvdimm/nvdimm.rst:642
msgid ""
"For the given example above, here is the view of the objects as seen by the "
"LIBNDCTL API::"
msgstr ""
