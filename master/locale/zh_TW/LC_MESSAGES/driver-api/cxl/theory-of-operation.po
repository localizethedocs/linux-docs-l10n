# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-06 06:05+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/cxl/theory-of-operation.rst:6
msgid "Compute Express Link Driver Theory of Operation"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:8
msgid ""
"A Compute Express Link Memory Device is a CXL component that implements the "
"CXL.mem protocol. It contains some amount of volatile memory, persistent "
"memory, or both. It is enumerated as a PCI device for configuration and "
"passing messages over an MMIO mailbox. Its contribution to the System "
"Physical Address space is handled via HDM (Host Managed Device Memory) "
"decoders that optionally define a device's contribution to an interleaved "
"address range across multiple devices underneath a host-bridge or "
"interleaved across host-bridges."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:18
msgid "The CXL Bus"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:19
msgid ""
"Similar to how a RAID driver takes disk objects and assembles them into a "
"new logical device, the CXL subsystem is tasked to take PCIe and ACPI "
"objects and assemble them into a CXL.mem decode topology. The need for "
"runtime configuration of the CXL.mem topology is also similar to RAID in "
"that different environments with the same hardware configuration may decide "
"to assemble the topology in contrasting ways. One may choose performance "
"(RAID0) striping memory across multiple Host Bridges and endpoints while "
"another may opt for fault tolerance and disable any striping in the CXL.mem "
"topology."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:28
msgid ""
"Platform firmware enumerates a menu of interleave options at the \"CXL root "
"port\" (Linux term for the top of the CXL decode topology). From there, PCIe "
"topology dictates which endpoints can participate in which Host Bridge "
"decode regimes. Each PCIe Switch in the path between the root and an "
"endpoint introduces a point at which the interleave can be split. For "
"example, platform firmware may say a given range only decodes to one Host "
"Bridge, but that Host Bridge may in turn interleave cycles across multiple "
"Root Ports. An intervening Switch between a port and an endpoint may "
"interleave cycles across multiple Downstream Switch Ports, etc."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:38
msgid ""
"Here is a sample listing of a CXL topology defined by 'cxl_test'. The "
"'cxl_test' module generates an emulated CXL topology of 2 Host Bridges each "
"with 2 Root Ports. Each of those Root Ports are connected to 2-way switches "
"with endpoints connected to those downstream ports for a total of 8 "
"endpoints::"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:183
msgid ""
"In that listing each \"root\", \"port\", and \"endpoint\" object correspond "
"a kernel 'struct cxl_port' object. A 'cxl_port' is a device that can decode "
"CXL.mem to its descendants. So \"root\" claims non-PCIe enumerable platform "
"decode ranges and decodes them to \"ports\", \"ports\" decode to "
"\"endpoints\", and \"endpoints\" represent the decode from SPA (System "
"Physical Address) to DPA (Device Physical Address)."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:190
msgid ""
"Continuing the RAID analogy, disks have both topology metadata and on-device "
"metadata that determine RAID set assembly. CXL Port topology and CXL Port "
"link status is metadata for CXL.mem set assembly. The CXL Port topology is "
"enumerated by the arrival of a CXL.mem device. I.e. unless and until the "
"PCIe core attaches the cxl_pci driver to a CXL Memory Expander there is no "
"role for CXL Port objects. Conversely for hot-unplug / removal scenarios, "
"there is no need for the Linux PCI core to tear down switch-level CXL "
"resources because the endpoint ->remove() event cleans up the port data that "
"was established to support that Memory Expander."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:200
msgid ""
"The port metadata and potential decode schemes that a given memory device "
"may participate can be determined via a command like::"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:249
msgid ""
"...which queries the CXL topology to ask \"given CXL Memory Expander with a "
"kernel device name of 'mem3' which platform level decode ranges may this "
"device participate\". A given expander can participate in multiple CXL.mem "
"interleave sets simultaneously depending on how many decoder resources it "
"has. In this example mem3 can participate in one or more of a PMEM "
"interleave that spans two Host Bridges, a PMEM interleave that targets a "
"single Host Bridge, a Volatile memory interleave that spans 2 Host Bridges, "
"and a Volatile memory interleave that only targets a single Host Bridge."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:258
msgid ""
"Conversely the memory devices that can participate in a given platform level "
"decode scheme can be determined via a command like the following::"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:312
msgid ""
"...where the naming scheme for decoders is \"decoder<port_id>."
"<instance_id>\"."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:315
msgid "Driver Infrastructure"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:317
msgid "This section covers the driver infrastructure for a CXL memory device."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:320
msgid "CXL Memory Device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:408: ../drivers/cxl/pci.c:21
msgid ""
"This implements the PCI exclusive functionality for a CXL device as it is "
"defined by the Compute Express Link specification. CXL devices may surface "
"certain functionality even if it isn't CXL enabled. While this driver is "
"focused around the PCI specific aspects of a CXL device, it binds to the "
"specific CXL memory device class code, and therefore the implementation of "
"cxl_pci is focused around CXL memory devices."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:408: ../drivers/cxl/pci.c:28
msgid "The driver has several responsibilities, mainly:"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:408: ../drivers/cxl/pci.c:29
msgid "Create the memX device and register on the CXL bus."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:408: ../drivers/cxl/pci.c:30
msgid "Enumerate device's register interface and map them."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:408: ../drivers/cxl/pci.c:31
msgid "Registers nvdimm bridge device with cxl_core."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:408: ../drivers/cxl/pci.c:32
msgid "Registers a CXL mailbox with cxl_core."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: ../drivers/cxl/pci.c:177
msgid "Execute a mailbox command"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: ../drivers/cxl/pci.c:181
#: ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:591 ../drivers/cxl/core/memdev.c:611
#: ../drivers/cxl/core/memdev.c:744 ../drivers/cxl/core/memdev.c:778
#: ../drivers/cxl/core/memdev.c:811
#: ../../../driver-api/cxl/theory-of-operation:436: ../drivers/cxl/acpi.c:825
#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:141 ../drivers/cxl/core/hdm.c:299
#: ../drivers/cxl/core/hdm.c:1164 ../drivers/cxl/core/hdm.c:1226
#: ../drivers/cxl/core/hdm.c:1258
#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:547 ../drivers/cxl/core/cdat.c:615
#: ../drivers/cxl/core/cdat.c:743 ../drivers/cxl/core/cdat.c:860
#: ../drivers/cxl/core/cdat.c:904 ../drivers/cxl/core/cdat.c:954
#: ../drivers/cxl/core/cdat.c:976
#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:926 ../drivers/cxl/core/port.c:1224
#: ../drivers/cxl/core/port.c:1255 ../drivers/cxl/core/port.c:1301
#: ../drivers/cxl/core/port.c:1910 ../drivers/cxl/core/port.c:1963
#: ../drivers/cxl/core/port.c:2017 ../drivers/cxl/core/port.c:2054
#: ../drivers/cxl/core/port.c:2087 ../drivers/cxl/core/port.c:2140
#: ../drivers/cxl/core/port.c:2182 ../drivers/cxl/core/port.c:2325
#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:48 ../drivers/cxl/core/pci.c:364
#: ../drivers/cxl/core/pci.c:563 ../drivers/cxl/core/pci.c:775
#: ../drivers/cxl/core/pci.c:966
#: ../../../driver-api/cxl/theory-of-operation:463:
#: ../drivers/cxl/core/pmem.c:59 ../drivers/cxl/core/pmem.c:123
#: ../drivers/cxl/core/pmem.c:243
#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:32 ../drivers/cxl/core/regs.c:116
#: ../drivers/cxl/core/regs.c:352 ../drivers/cxl/core/regs.c:372
#: ../drivers/cxl/core/regs.c:390
#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:232 ../drivers/cxl/core/mbox.c:315
#: ../drivers/cxl/core/mbox.c:482 ../drivers/cxl/core/mbox.c:571
#: ../drivers/cxl/core/mbox.c:744 ../drivers/cxl/core/mbox.c:832
#: ../drivers/cxl/core/mbox.c:1114 ../drivers/cxl/core/mbox.c:1140
#: ../drivers/cxl/core/mbox.c:1176 ../drivers/cxl/core/mbox.c:1275
#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:913 ../drivers/cxl/core/region.c:1111
#: ../drivers/cxl/core/region.c:1879 ../drivers/cxl/core/region.c:2578
#: ../drivers/cxl/core/region.c:2979 ../drivers/cxl/core/region.c:3378
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: ../drivers/cxl/pci.c:183
#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:234 ../drivers/cxl/core/mbox.c:481
#: ../drivers/cxl/core/mbox.c:573
msgid "``struct cxl_mailbox *cxl_mbox``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: ../drivers/cxl/pci.c:178
#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:428
#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:229 ../drivers/cxl/core/mbox.c:480
msgid "CXL mailbox context"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: ../drivers/cxl/pci.c:180
#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:231 ../drivers/cxl/core/mbox.c:484
#: ../drivers/cxl/core/mbox.c:570
msgid "``struct cxl_mbox_cmd *mbox_cmd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: ../drivers/cxl/pci.c:179
msgid "Command to send to the memory device."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: ../drivers/cxl/pci.c:181
#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2091 ../drivers/cxl/core/port.c:2141
#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:232
msgid "**Context**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: ../drivers/cxl/pci.c:181
msgid "Any context. Expects mbox_mutex to be held."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: ../drivers/cxl/pci.c:183
#: ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:747 ../drivers/cxl/core/memdev.c:782
#: ../drivers/cxl/core/memdev.c:814
#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:618 ../drivers/cxl/core/cdat.c:745
#: ../drivers/cxl/core/cdat.c:860 ../drivers/cxl/core/cdat.c:904
#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1963 ../drivers/cxl/core/port.c:2017
#: ../drivers/cxl/core/port.c:2053 ../drivers/cxl/core/port.c:2095
#: ../drivers/cxl/core/port.c:2326
#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:965
#: ../../../driver-api/cxl/theory-of-operation:463:
#: ../drivers/cxl/core/pmem.c:123 ../drivers/cxl/core/pmem.c:243
#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:355 ../drivers/cxl/core/regs.c:373
#: ../drivers/cxl/core/regs.c:391
#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:234 ../drivers/cxl/core/mbox.c:315
#: ../drivers/cxl/core/mbox.c:483 ../drivers/cxl/core/mbox.c:575
#: ../drivers/cxl/core/mbox.c:1145 ../drivers/cxl/core/mbox.c:1175
#: ../drivers/cxl/core/mbox.c:1275
#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:1885 ../drivers/cxl/core/region.c:2582
#: ../drivers/cxl/core/region.c:2981 ../drivers/cxl/core/region.c:3377
msgid "**Return**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: ../drivers/cxl/pci.c:182
msgid ""
"-ETIMEDOUT if timeout occurred waiting for completion. 0 on success. Caller "
"should check the return code in **mbox_cmd** to make sure it succeeded."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: ../drivers/cxl/pci.c:186
#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:261
#: ../drivers/cxl/cxlmem.h:432 ../drivers/cxl/cxlmem.h:491
#: ../drivers/cxl/cxlmem.h:796 ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:591 ../drivers/cxl/core/memdev.c:743
#: ../drivers/cxl/core/memdev.c:778 ../drivers/cxl/core/memdev.c:810
#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:415
#: ../drivers/cxl/cxl.h:489 ../../../driver-api/cxl/theory-of-operation:436:
#: ../drivers/cxl/acpi.c:824 ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:301 ../drivers/cxl/core/hdm.c:1225
#: ../drivers/cxl/core/hdm.c:1257
#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:620 ../drivers/cxl/core/cdat.c:748
#: ../drivers/cxl/core/cdat.c:976
#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1226 ../drivers/cxl/core/port.c:1257
#: ../drivers/cxl/core/port.c:1301 ../drivers/cxl/core/port.c:1910
#: ../drivers/cxl/core/port.c:2086 ../drivers/cxl/core/port.c:2139
#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:48 ../drivers/cxl/core/pci.c:365
#: ../drivers/cxl/core/pci.c:562 ../drivers/cxl/core/pci.c:967
#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:33 ../drivers/cxl/core/regs.c:117
#: ../drivers/cxl/core/regs.c:357 ../drivers/cxl/core/regs.c:375
#: ../drivers/cxl/core/regs.c:390
#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:240 ../drivers/cxl/core/mbox.c:318
#: ../drivers/cxl/core/mbox.c:490 ../drivers/cxl/core/mbox.c:583
#: ../drivers/cxl/core/mbox.c:745 ../drivers/cxl/core/mbox.c:831
#: ../drivers/cxl/core/mbox.c:1114 ../drivers/cxl/core/mbox.c:1139
#: ../drivers/cxl/core/mbox.c:1177 ../drivers/cxl/core/mbox.c:1282
#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:914 ../drivers/cxl/core/region.c:1113
#: ../drivers/cxl/core/region.c:1878 ../drivers/cxl/core/region.c:2580
#: ../drivers/cxl/core/region.c:2980
#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:123 ../include/uapi/linux/cxl_mem.h:156
#: ../include/uapi/linux/cxl_mem.h:205
msgid "**Description**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: ../drivers/cxl/pci.c:185
msgid ""
"This is a generic form of the CXL mailbox send command thus only using the "
"registers defined by the mailbox capability ID - CXL 2.0 8.2.8.4. Memory "
"devices, and perhaps other types of CXL devices may have further information "
"available upon error conditions. Driver facilities wishing to send mailbox "
"commands should use the wrapper command."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:411: ../drivers/cxl/pci.c:191
msgid ""
"The CXL spec allows for up to two mailboxes. The intention is for the "
"primary mailbox to be OS controlled and the secondary mailbox to be used by "
"system firmware. This allows the OS and firmware to communicate with the "
"device and not need to coordinate with each other. The driver only uses the "
"primary mailbox."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:414: ../drivers/cxl/mem.c:12
msgid ""
"CXL memory endpoint devices and switches are CXL capable devices that are "
"participating in CXL.mem protocol. Their functionality builds on top of the "
"CXL.io protocol that allows enumerating and configuring components via "
"standard PCI mechanisms."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:414: ../drivers/cxl/mem.c:17
msgid ""
"The cxl_mem driver owns kicking off the enumeration of this CXL.mem "
"capability. With the detection of a CXL capable endpoint, the driver will "
"walk up to find the platform specific port it is connected to, and determine "
"if there are intervening switches in the path. If there are switches, a "
"secondary action is to enumerate those (implemented in cxl_core). Finally "
"the cxl_mem driver adds the device it is bound to as a CXL endpoint-port for "
"use in higher level operations."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:38
msgid "CXL bus object representing a Type-3 Memory Device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:42
#: ../drivers/cxl/cxlmem.h:221 ../drivers/cxl/cxlmem.h:256
#: ../drivers/cxl/cxlmem.h:337 ../drivers/cxl/cxlmem.h:354
#: ../drivers/cxl/cxlmem.h:387 ../drivers/cxl/cxlmem.h:401
#: ../drivers/cxl/cxlmem.h:413 ../drivers/cxl/cxlmem.h:471
#: ../drivers/cxl/cxlmem.h:793 ../drivers/cxl/cxlmem.h:915
#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:276
#: ../drivers/cxl/cxl.h:355 ../drivers/cxl/cxl.h:394 ../drivers/cxl/cxl.h:412
#: ../drivers/cxl/cxl.h:431 ../drivers/cxl/cxl.h:441 ../drivers/cxl/cxl.h:481
#: ../drivers/cxl/cxl.h:533 ../drivers/cxl/cxl.h:601 ../drivers/cxl/cxl.h:650
#: ../drivers/cxl/cxl.h:684 ../drivers/cxl/cxl.h:710 ../drivers/cxl/cxl.h:723
#: ../drivers/cxl/cxl.h:841 ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:106 ../include/uapi/linux/cxl_mem.h:150
#: ../include/uapi/linux/cxl_mem.h:186
msgid "**Definition**::"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:59
#: ../drivers/cxl/cxlmem.h:228 ../drivers/cxl/cxlmem.h:265
#: ../drivers/cxl/cxlmem.h:347 ../drivers/cxl/cxlmem.h:365
#: ../drivers/cxl/cxlmem.h:396 ../drivers/cxl/cxlmem.h:409
#: ../drivers/cxl/cxlmem.h:434 ../drivers/cxl/cxlmem.h:490
#: ../drivers/cxl/cxlmem.h:802 ../drivers/cxl/cxlmem.h:926
#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:291
#: ../drivers/cxl/cxl.h:371 ../drivers/cxl/cxl.h:405 ../drivers/cxl/cxl.h:420
#: ../drivers/cxl/cxl.h:438 ../drivers/cxl/cxl.h:454 ../drivers/cxl/cxl.h:494
#: ../drivers/cxl/cxl.h:549 ../drivers/cxl/cxl.h:628 ../drivers/cxl/cxl.h:657
#: ../drivers/cxl/cxl.h:699 ../drivers/cxl/cxl.h:718 ../drivers/cxl/cxl.h:735
#: ../drivers/cxl/cxl.h:850 ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:118 ../include/uapi/linux/cxl_mem.h:158
#: ../include/uapi/linux/cxl_mem.h:211
msgid "**Members**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:39
#: ../drivers/cxl/cxlmem.h:415 ../../../driver-api/cxl/theory-of-operation:433:
#: ../drivers/cxl/cxl.h:352 ../drivers/cxl/cxl.h:530 ../drivers/cxl/cxl.h:600
msgid "``dev``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:40
msgid "driver core device object"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:40
msgid "``cdev``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:41
msgid "char dev core object for ioctl operations"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:41
#: ../drivers/cxl/cxlmem.h:473
msgid "``cxlds``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:42
msgid "The device state backing this device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:42
msgid "``detach_work``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:43
msgid "active memdev lost a port in its ancestry"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:43
#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:534
msgid "``cxl_nvb``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:44
msgid "coordinate removal of **cxl_nvd** if present"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:44
msgid "``cxl_nvd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:45
msgid "optional bridge to an nvdimm if the device supports pmem"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:45
msgid "``endpoint``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:46
msgid "connection to the CXL port topology for this memory device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:46
#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:353
#: ../drivers/cxl/cxl.h:531 ../drivers/cxl/cxl.h:603
#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:103 ../include/uapi/linux/cxl_mem.h:183
msgid "``id``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:47
msgid "id number of this memdev instance."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:47
#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:614
msgid "``depth``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:48
msgid "endpoint port depth"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:48
msgid "``scrub_cycle``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:49
msgid "current scrub cycle set for this device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:49
msgid "``scrub_region_id``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:50
msgid "id number of a backed region (if any) for which current scrub cycle set"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:50
msgid "``err_rec_array``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:51
msgid ""
"List of xarrarys to store the memdev error records to check attributes for a "
"memory repair operation are from current boot."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:217
msgid "Event log driver state"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:219
msgid "``buf``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:220
msgid "Buffer to receive event data"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:220
msgid "``log_lock``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:221
msgid "Serialize event_buf and log use"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:252
msgid "Driver poison state info"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:254
msgid "``max_errors``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:255
msgid "Maximum media error records held in device cache"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:255
#: ../drivers/cxl/cxlmem.h:353
msgid "``enabled_cmds``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:256
msgid "All poison commands enabled in the CEL"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:256
msgid "``list_out``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:257
msgid "The poison list payload returned by device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:257
msgid "``mutex``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:258
msgid "Protect reads of the poison list"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:258
msgid ""
"Reads of the poison list are synchronized to ensure that a reader does not "
"get an incomplete list because their request overlapped (was interrupted or "
"preceded by) another read request of the same DPA range. CXL Spec 3.0 "
"Section 8.2.9.8.4.1"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:333
msgid "Firmware upload / activation state"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:335
#: ../drivers/cxl/cxlmem.h:352 ../../../driver-api/cxl/theory-of-operation:433:
#: ../drivers/cxl/cxl.h:394 ../drivers/cxl/cxl.h:478
msgid "``state``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:336
msgid "fw_uploader state bitmask"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:336
msgid "``oneshot``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:337
msgid "whether the fw upload fits in a single transfer"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:337
msgid "``num_slots``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:338
msgid "Number of FW slots available"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:338
msgid "``cur_slot``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:339
msgid "Slot number currently active"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:339
msgid "``next_slot``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:340
msgid "Slot number for the new firmware"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:350
msgid "Device security state"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:353
msgid "state of last security operation"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:354
msgid "All security commands enabled in the CEL"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:354
msgid "``poll_tmo_secs``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:355
msgid "polling timeout"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:355
msgid "``sanitize_active``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:356
msgid "sanitize completion pending"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:356
msgid "``poll_dwork``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:357
msgid "polling work item"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:357
msgid "``sanitize_node``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:358
msgid "sanitation sysfs file to notify"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:383
msgid "DPA performance property entry"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:384
msgid "``dpa_range``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:385
msgid "range for DPA address"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:385
#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:538
#: ../drivers/cxl/cxl.h:688
msgid "``coord``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:386
msgid "QoS performance data (i.e. latency, bandwidth)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:386
msgid "``cdat_coord``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:387
msgid "raw QoS performance data from CDAT"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:387
#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:443
msgid "``qos_class``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:388
msgid "QoS Class cookies"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:397
msgid "DPA partition descriptor"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:398
#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:438
#: ../drivers/cxl/cxl.h:482
msgid "``res``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:399
msgid "shortcut to the partition in the DPA resource tree (cxlds->dpa_res)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:399
msgid "``perf``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:400
msgid "performance attributes of the partition from CDAT"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:400
#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:532
msgid "``mode``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:401
msgid "operation mode for the DPA capacity, e.g. ram, pmem, dynamic..."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:409
msgid "The driver device state"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:416
msgid "The device associated with this CXL state"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:416
msgid "``cxlmd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:417
msgid "The device representing the CXL.mem capabilities of **dev**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:417
#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:609
#: ../drivers/cxl/cxl.h:682
msgid "``reg_map``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:418
#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:610
#: ../drivers/cxl/cxl.h:683
msgid "component and ras register mapping parameters"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:418
#: ../drivers/cxl/cxlmem.h:912 ../../../driver-api/cxl/theory-of-operation:433:
#: ../drivers/cxl/cxl.h:687
msgid "``regs``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:419
msgid "Parsed register blocks"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:419
msgid "``cxl_dvsec``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:420
msgid "Offset to the PCIe device DVSEC"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:420
msgid "``rcd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:421
msgid "operating in RCD mode (CXL 3.0 9.11.8 CXL Devices Attached to an RCH)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:421
msgid "``media_ready``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:422
msgid "Indicate whether the device media is usable"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:422
#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:392
msgid "``dpa_res``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:423
msgid "Overall DPA resource tree for the device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:423
#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:395
msgid "``part``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:424
msgid "DPA partition array"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:424
msgid "``nr_partitions``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:425
msgid "Number of DPA partitions"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:425
msgid "``serial``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:426
msgid "PCIe Device Serial Number"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:426
#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:533
msgid "``type``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:427
msgid "Generic Memory Class device or Vendor Specific Memory device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:427
msgid "``cxl_mbox``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:428
msgid "``cxlfs``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:429
msgid "CXL features context"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:410
msgid ""
"cxl_dev_state represents the CXL driver/device state.  It provides an "
"interface to mailbox commands as well as some cached data about the device. "
"Currently only memory devices are represented."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:467
msgid "Generic Type-3 Memory Device Class driver data"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:474
msgid "Core driver state common across Type-2 and Type-3 devices"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:474
msgid "``lsa_size``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:475
msgid "Size of Label Storage Area (CXL 2.0 8.2.9.5.1.1 Identify Memory Device)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:476
msgid "``firmware_version``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:477
msgid "Firmware version for the memory device."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:477
msgid "``total_bytes``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:478
msgid "sum of all possible capacities"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:478
msgid "``volatile_only_bytes``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:479
msgid "hard volatile capacity"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:479
msgid "``persistent_only_bytes``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:480
msgid "hard persistent capacity"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:480
msgid "``partition_align_bytes``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:481
msgid "alignment size for partition-able capacity"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:481
msgid "``active_volatile_bytes``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:482
msgid "sum of hard + soft volatile"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:482
msgid "``active_persistent_bytes``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:483
msgid "sum of hard + soft persistent"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:483
msgid "``event``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:484
msgid "event log driver state"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:484
msgid "``poison``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:485
msgid "poison driver state info"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:485
msgid "``security``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:486
msgid "security driver state info"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:486
msgid "``fw``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:487
msgid "firmware upload / activation state"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:487
msgid "``mce_notifier``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:488
msgid "MCE notifier"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:468
msgid ""
"CXL 8.1.12.1 PCI Header - Class Code Register Memory Device defines common "
"memory device functionality like the presence of a mailbox and the "
"functionality related to that like Identify Memory Device and Get Partition "
"Info"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:473
msgid ""
"See CXL 3.0 8.2.9.8.2 Capacity Configuration and Label Storage for details "
"on capacity parameters."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:789
msgid "Driver representation of a memory device command"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:790
msgid "``info``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:791
msgid "Command information as it exists for the UAPI"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:791
msgid "``opcode``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:792
msgid "The actual bits used for the mailbox protocol"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:792
#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:359
#: ../drivers/cxl/cxl.h:536 ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:104 ../include/uapi/linux/cxl_mem.h:185
msgid "``flags``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:793
msgid "Set of flags effecting driver behavior."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:793
msgid ""
"``CXL_CMD_FLAG_FORCE_ENABLE``: In cases of error, commands with this flag "
"will be enabled by the driver regardless of what hardware may have "
"advertised."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:797
msgid ""
"The cxl_mem_command is the driver's internal representation of commands that "
"are supported by the driver. Some of these commands may not be supported by "
"the hardware. The driver will use **info** to validate the fields passed in "
"by the user then submit the **opcode** to the hardware."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:802
#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:162
msgid "See struct cxl_command_info."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:911
msgid "HDM Decoder registers and cached / decoded capabilities"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:913
msgid "mapped registers, see devm_cxl_setup_hdm()"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:913
msgid "``decoder_count``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:914
msgid "number of decoders for this port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:914
msgid "``target_count``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:915
msgid "for switch decoders, max downstream port targets"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:915
msgid "``interleave_mask``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:916
msgid "interleave granularity capability, see check_interleave_cap()"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:916
msgid "``iw_cap_mask``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:917
msgid "bitmask of supported interleave ways, see check_interleave_cap()"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:917
#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:648
#: ../drivers/cxl/cxl.h:686 ../drivers/cxl/cxl.h:720 ../drivers/cxl/cxl.h:840
msgid "``port``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:417: ../drivers/cxl/cxlmem.h:918
msgid "mapped cxl_port, see devm_cxl_setup_hdm()"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:587
msgid "atomically disable user cxl commands"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:593 ../drivers/cxl/core/memdev.c:613
#: ../drivers/cxl/core/memdev.c:746 ../drivers/cxl/core/memdev.c:780
#: ../drivers/cxl/core/memdev.c:813
#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:746 ../drivers/cxl/core/mbox.c:834
#: ../drivers/cxl/core/mbox.c:1116 ../drivers/cxl/core/mbox.c:1142
#: ../drivers/cxl/core/mbox.c:1178
msgid "``struct cxl_memdev_state *mds``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:588
msgid "The device state to operate on"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:590 ../drivers/cxl/core/memdev.c:610
msgid "``unsigned long *cmds``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:589
msgid "bitmap of commands to mark exclusive"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:590
msgid ""
"Grab the cxl_memdev_rwsem in write mode to flush in-flight invocations of "
"the ioctl path and then disable future execution of commands with the "
"command ids set in **cmds**."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:607
msgid "atomically enable user cxl commands"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:608
msgid "The device state to modify"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:609
msgid "bitmap of commands to mark available for userspace"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:740
msgid "Get Firmware info"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:741 ../drivers/cxl/core/memdev.c:775
#: ../drivers/cxl/core/memdev.c:808
msgid "The device data for the operation"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:742
msgid "Retrieve firmware info for the device specified."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:745
msgid "See CXL-3.0 8.2.9.3.1 Get FW Info"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:745 ../drivers/cxl/core/memdev.c:780
#: ../drivers/cxl/core/memdev.c:812
#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:1143
msgid "0 if no error: or the result of the mailbox command."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:774
msgid "Activate Firmware"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:777
msgid "``int slot``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:776
msgid "slot number to activate"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:777
msgid "Activate firmware in a given slot for the device specified."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:780
msgid "See CXL-3.0 8.2.9.3.3 Activate FW"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:807
msgid "Abort an in-progress FW transfer"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:809
msgid "Abort an in-progress firmware transfer for the device specified."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:420:
#: ../drivers/cxl/core/memdev.c:812
msgid "See CXL-3.0 8.2.9.3.2 Transfer FW"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:338
msgid "CXL Port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:425: ../drivers/cxl/port.c:11
msgid ""
"The port driver enumerates dport via PCI and scans for HDM (Host-managed-"
"Device-Memory) decoder resources via the **component_reg_phys** value passed "
"in by the agent that registered the port. All descendant ports of a CXL root "
"port (described by platform firmware) are managed in this drivers context. "
"Each driver instance is responsible for tearing down the driver context of "
"immediate descendant ports. The locking for this is validated by "
"CONFIG_PROVE_CXL_LOCKING."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:425: ../drivers/cxl/port.c:20
msgid ""
"The primary service this driver provides is presenting APIs to other drivers "
"to utilize the decoders, and indicating to userspace (via bind status) the "
"connectivity of the CXL.mem protocol throughout the PCIe topology."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:343
msgid "CXL Core"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:430: ../drivers/cxl/cxl.h:19
msgid ""
"The CXL core objects like ports, decoders, and regions are shared between "
"the subsystem drivers cxl_acpi, cxl_pci, and core drivers (port-driver, "
"region-driver, nvdimm object-drivers... etc)."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:272
msgid "DVSEC harvested register block mapping parameters"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:273
msgid "``host``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:274
msgid "device for devm operations and logging"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:274
msgid "``base``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:275
msgid "virtual base of the register-block-BAR + **block_offset**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:275
msgid "``resource``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:276
msgid "physical resource base of the register block"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:276
msgid "``max_size``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:277
msgid "maximum mapping size to perform register search"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:277
msgid "``reg_type``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:278
msgid "see enum cxl_regloc_type"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:1
#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:1
msgid "``{unnamed_union}``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:2
#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:2
msgid "anonymous"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:278
msgid "``component_map``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:279
msgid "cxl_reg_map for component registers"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:279
msgid "``device_map``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:280
msgid "cxl_reg_maps for device registers"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:280
msgid "``pmu_map``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:281
msgid "cxl_reg_maps for CXL Performance Monitoring Units"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:351
msgid "Common CXL HDM Decoder Attributes"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:353
msgid "this decoder's device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:354
msgid "kernel device name id"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:354
msgid "``hpa_range``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:355
msgid "Host physical address range mapped by this decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:355
#: ../drivers/cxl/cxl.h:480
msgid "``interleave_ways``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:356
msgid "number of cxl_dports in this decode"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:356
#: ../drivers/cxl/cxl.h:481
msgid "``interleave_granularity``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:357
msgid "data stride per dport"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:357
msgid "``target_type``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:358
msgid "accelerator vs expander (type2 vs type3) selector"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:358
#: ../drivers/cxl/cxl.h:722
msgid "``region``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:359
msgid "currently assigned region for this decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:360
msgid "memory type capabilities and locking"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:360
msgid "``target_map``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:361
msgid ""
"cached copy of hardware port-id list, available at init before all **dport** "
"objects have been instantiated. While dport id is 8bit, CFMWS interleave "
"targets are 32bits."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:363
msgid "``commit``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:364
msgid "device/decoder-type specific callback to commit settings to hw"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:364
msgid "``reset``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:365
msgid "device/decoder-type specific callback to reset hw settings"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:390
msgid "Endpoint / SPA to DPA decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:391
#: ../drivers/cxl/cxl.h:409
msgid "``cxld``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:392
msgid "base cxl_decoder_object"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:393
msgid "actively claimed DPA span of this decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:393
msgid "``skip``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:394
msgid "offset into **dpa_res** where **cxld.hpa_range** maps"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:395
msgid "autodiscovery state"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:396
msgid "partition index this decoder maps"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:396
msgid "``pos``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:397
msgid "interleave position in **cxld.region**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:408
msgid "Switch specific CXL HDM Decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:410
msgid "base cxl_decoder object"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:410
#: ../drivers/cxl/cxl.h:484 ../drivers/cxl/cxl.h:726
msgid "``nr_targets``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:411
msgid "number of elements in **target**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:411
msgid "``target``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:412
msgid "active ordered target list in current decoder configuration"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:412
msgid ""
"The 'switch' decoder type represents the decoder instances of cxl_port's "
"that route from the root of a CXL memory decode topology to the endpoints. "
"They come in two flavors, root-level decoders, statically defined by "
"platform firmware, and mid-level decoders, where interleave-granularity, "
"interleave-width, and the target list are mutable."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:427
msgid "CXL root decoder callback operations"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:428
msgid "``hpa_to_spa``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:429
msgid "Convert host physical address to system physical address"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:429
msgid "``spa_to_hpa``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:430
msgid "Convert system physical address to host physical address"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:437
msgid "Static platform CXL address decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:439
msgid "host / parent resource for region allocations"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:439
#: ../drivers/cxl/cxl.h:485
msgid "``cache_size``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:440
#: ../drivers/cxl/cxl.h:486
msgid "extended linear cache size if exists, otherwise zero."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:440
msgid "``region_id``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:441
msgid "region id for next region provisioning event"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:441
msgid "``platform_data``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:442
msgid "platform specific configuration data"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:442
msgid "``range_lock``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:443
msgid "sync region autodiscovery by address range"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:444
msgid "QoS performance class cookie"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:444
#: ../drivers/cxl/cxl.h:649
msgid "``ops``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:445
msgid "CXL root decoder operations"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:445
msgid "``cxlsd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:446
msgid "base cxl switch decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:477
msgid "region settings"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:479
msgid "allow the driver to lockdown further parameter changes"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:479
msgid "``uuid``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:480
msgid "unique id for persistent regions"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:481
msgid "number of endpoints in the region"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:482
msgid "capacity each endpoint contributes to a stripe"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:483
msgid "allocated iomem capacity for this region"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:483
msgid "``targets``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:484
msgid "active ordered targets in current decoder configuration"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:485
msgid "number of targets"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:486
msgid "State transitions are protected by cxl_rwsem.region"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:529
msgid "CXL region"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:531
msgid "This region's device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:532
msgid "This region's id. Id is globally unique across all regions"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:533
msgid "Operational mode of the mapped capacity"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:534
msgid "Endpoint decoder target type"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:535
msgid "nvdimm bridge for coordinating **cxlr_pmem** setup / shutdown"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:535
msgid "``cxlr_pmem``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:536
msgid "(for pmem regions) cached copy of the nvdimm bridge"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:537
msgid "Region state flags"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:537
msgid "``params``"
msgstr "``params``"

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:538
msgid "active + config params for the region"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:539
msgid "QoS access coordinates for the region"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:539
msgid "``node_notifier``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:540
msgid "notifier for setting the access coordinates to node"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:540
msgid "``adist_notifier``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:541
msgid "notifier for calculating the abstract distance of node"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:597
msgid ""
"logical collection of upstream port devices and downstream port devices to "
"construct a CXL memory decode hierarchy."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:601
msgid "this port's device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:601
msgid "``uport_dev``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:602
msgid "PCI or platform device implementing the upstream port capability"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:602
msgid "``host_bridge``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:603
msgid "Shortcut to the platform attach point for this port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:604
msgid "id for port device-name"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:604
msgid "``dports``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:605
msgid "cxl_dport instances referenced by decoders"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:605
#: ../drivers/cxl/cxl.h:723
msgid "``endpoints``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:606
msgid "cxl_ep instances, endpoints that are a descendant of this port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:606
msgid "``regions``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:607
msgid "cxl_region_ref instances, regions mapped by this port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:607
msgid "``parent_dport``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:608
msgid "dport that points to this port in the parent"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:608
msgid "``decoder_ida``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:609
msgid "allocator for decoder ids"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:610
msgid "``nr_dports``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:611
msgid "number of entries in **dports**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:611
msgid "``hdm_end``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:612
msgid "track last allocated HDM decoder instance for allocation ordering"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:612
msgid "``commit_end``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:613
msgid "cursor to track highest committed decoder for commit ordering"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:613
msgid "``dead``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:614
msgid "last ep has been removed, force port re-creation"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:615
msgid "How deep this port is relative to the root. depth 0 is the root."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:615
msgid "``cdat``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:616
msgid "Cached CDAT data"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:616
msgid "``cdat_available``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:617
msgid "Should a CDAT attribute be available in sysfs"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:617
msgid "``pci_latency``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:618
msgid "Upstream latency in picoseconds"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:618
msgid "``component_reg_phys``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:619
msgid "Physical address of component register"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:646
msgid "logical collection of root cxl_port items"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:649
msgid "cxl_port member"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:650
msgid "cxl root operations"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:680
msgid "CXL downstream port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:681
msgid "``dport_dev``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:682
msgid "PCI bridge or firmware device representing the downstream link"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:683
msgid "``port_id``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:684
msgid "unique hardware identifier for dport in decoder target list"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:684
msgid "``rcrb``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:685
msgid "Data about the Root Complex Register Block layout"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:685
msgid "``rch``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:686
msgid "Indicate whether this dport was enumerated in RCH or VH mode"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:687
msgid "reference to cxl_port that contains this downstream port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:688
msgid "Dport parsed register blocks"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:689
msgid "access coordinates (bandwidth and latency performance attributes)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:689
msgid "``link_latency``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:690
msgid "calculated PCIe downstream latency"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:690
msgid "``gpf_dvsec``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:691
msgid "Cached GPF port DVSEC"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:706
msgid "track an endpoint's interest in a port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:707
msgid "``ep``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:708
msgid "device that hosts a generic CXL endpoint (expander or accelerator)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:708
msgid "``dport``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:709
msgid "which dport routes to this endpoint on **port**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:709
msgid "``next``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:710
msgid ""
"cxl switch port across the link attached to **dport** NULL if attached to an "
"endpoint"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:719
msgid "track a region's interest in a port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:721
msgid "point in topology to install this reference"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:721
msgid "``decoder``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:722
msgid "decoder assigned for **region** in **port**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:723
msgid "region for this reference"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:724
msgid "cxl_ep references for region members beneath **port**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:724
msgid "``nr_targets_set``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:725
msgid "track how many targets have been programmed during setup"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:725
msgid "``nr_eps``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:726
msgid "number of endpoints beneath **port**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:727
msgid "number of distinct targets needed to reach **nr_eps**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:837
msgid "Cached DVSEC info"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:838
msgid "``mem_enabled``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:839
msgid "cached value of mem_enabled in the DVSEC at init time"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:839
msgid "``ranges``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:840
msgid "Number of active HDM ranges this device uses."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:841
msgid "endpoint port associated with this info instance"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:841
msgid "``dvsec_range``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:433: ../drivers/cxl/cxl.h:842
msgid "cached attributes of the ranges in the DVSEC, PCIE_DEVICE"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:436: ../drivers/cxl/acpi.c:821
msgid "reflect CXL fixed memory windows in iomem_resource"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:436: ../drivers/cxl/acpi.c:827
msgid "``struct resource *cxl_res``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:436: ../drivers/cxl/acpi.c:822
msgid "A standalone resource tree where each CXL window is a sibling"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:436: ../drivers/cxl/acpi.c:823
msgid ""
"Walk each CXL window in **cxl_res** and add it to iomem_resource potentially "
"expanding its boundaries to ensure that any conflicting resources become "
"children. If a window is expanded it may then conflict with a another window "
"entry and require the window to be truncated or trimmed. Consider this "
"situation::"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:436: ../drivers/cxl/acpi.c:832
msgid ""
"...where platform firmware has established as System RAM resource across 2 "
"windows, but has left some portion of window 1 for dynamic CXL region "
"provisioning. In this case \"Window 0\" will span the entirety of the "
"\"System RAM\" span, and \"CXL Window 1\" is truncated to the remaining tail "
"past the end of that \"System RAM\" resource."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:439:
#: ../drivers/cxl/core/hdm.c:11
msgid ""
"Compute Express Link Host Managed Device Memory, starting with the CXL 2.0 "
"specification, is managed by an array of HDM Decoder register instances per "
"CXL port and per CXL endpoint. Define common helpers for enumerating these "
"registers and capabilities."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:137
msgid "map HDM decoder component registers"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:143 ../drivers/cxl/core/hdm.c:1228
#: ../drivers/cxl/core/hdm.c:1260
#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1226 ../drivers/cxl/core/port.c:1257
#: ../drivers/cxl/core/port.c:1912 ../drivers/cxl/core/port.c:1965
#: ../drivers/cxl/core/port.c:2019 ../drivers/cxl/core/port.c:2056
#: ../drivers/cxl/core/port.c:2327
#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:50 ../drivers/cxl/core/pci.c:565
#: ../../../driver-api/cxl/theory-of-operation:463:
#: ../drivers/cxl/core/pmem.c:61 ../drivers/cxl/core/pmem.c:122
#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:915 ../drivers/cxl/core/region.c:1113
msgid "``struct cxl_port *port``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:138
msgid "cxl_port to map"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:140 ../drivers/cxl/core/hdm.c:1163
#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:364
msgid "``struct cxl_endpoint_dvsec_info *info``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:139 ../drivers/cxl/core/hdm.c:1162
msgid "cached DVSEC range register info"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:295
msgid "Track DPA 'skip' in **cxlds->dpa_res** resource tree"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:301
#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:366
msgid "``struct cxl_dev_state *cxlds``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:296
msgid "CXL.mem device context that parents **cxled**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:298
#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:614
#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:912 ../drivers/cxl/core/region.c:1111
#: ../drivers/cxl/core/region.c:1881
msgid "``struct cxl_endpoint_decoder *cxled``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:297
msgid "Endpoint decoder establishing new allocation that skips lower DPA"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:299
msgid "``const resource_size_t skip_base``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:298
msgid "DPA < start of new DPA allocation (DPAnew)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:300
msgid "``const resource_size_t skip_len``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:299
msgid "**skip_base** + **skip_len** == DPAnew"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:300
msgid ""
"DPA 'skip' arises from out-of-sequence DPA allocation events relative to "
"free capacity across multiple partitions. It is a wasteful event as usable "
"DPA gets thrown away, but if a deployment has, for example, a dual RAM+PMEM "
"device, wants to use PMEM, and has unallocated RAM DPA, the free RAM DPA "
"must be sacrificed to start allocating PMEM. See third \"Implementation "
"Note\" in CXL 3.1 8.2.4.19.13 \"Decoder Protection\" for more details."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:308
msgid ""
"A 'skip' always covers the last allocated DPA in a previous partition to the "
"start of the current partition to allocate.  Allocations never start in the "
"middle of a partition, and allocations are always de-allocated in reverse "
"order (see cxl_dpa_free(), or natural devm unwind order from forced in-order "
"allocation)."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:314
msgid ""
"If **cxlds->nr_partitions** was guaranteed to be <= 2 then the 'skip' would "
"always be contained to a single partition. Given **cxlds->nr_partitions** "
"may be > 2 it results in cases where the 'skip' might span \"tail capacity "
"of partition[0], all of partition[1], ..., all of partition[N-1]\" to "
"support allocating from partition[N]. That in turn interacts with the "
"partition 'struct resource' boundaries within **cxlds->dpa_res** whereby "
"'skip' requests need to be divided by partition. I.e. this is a quirk of "
"using a 'struct resource' tree to detect range conflicts while also tracking "
"partition boundaries in **cxlds->dpa_res**."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:1160
msgid "add decoder objects per HDM register set"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:1166
#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:363
msgid "``struct cxl_hdm *cxlhdm``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:1161
msgid "Structure to populate with HDM capabilities"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:1222
msgid "allocate and setup switch decoders"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:1223 ../drivers/cxl/core/hdm.c:1255
msgid "CXL port context"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:1224 ../drivers/cxl/core/hdm.c:1256
msgid "Return 0 or -errno on error"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:442:
#: ../drivers/cxl/core/hdm.c:1254
msgid "allocate and setup endpoint decoders"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:543
msgid "Combine the two input coordinates"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:549
msgid "``struct access_coordinate *out``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:545
msgid "Output coordinate of c1 and c2 combined"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:547
msgid "``struct access_coordinate *c1``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:546 ../drivers/cxl/core/cdat.c:547
msgid "input coordinates"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:548
msgid "``struct access_coordinate *c2``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:611
msgid "collect all the endpoint bandwidth in an xarray"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:617 ../drivers/cxl/core/cdat.c:745
#: ../drivers/cxl/core/cdat.c:956 ../drivers/cxl/core/cdat.c:978
#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:913 ../drivers/cxl/core/region.c:1110
#: ../drivers/cxl/core/region.c:3380
msgid "``struct cxl_region *cxlr``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:612
msgid "CXL region for the bandwidth calculation"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:613
msgid "endpoint decoder to start on"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:615
msgid "``struct xarray *usp_xa``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:614
msgid ""
"(output) the xarray that collects all the bandwidth coordinates indexed by "
"the upstream device with data of 'struct cxl_perf_ctx'."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:617 ../drivers/cxl/core/cdat.c:744
msgid "``bool *gp_is_root``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:616 ../drivers/cxl/core/cdat.c:743
msgid "(output) bool of whether the grandparent is cxl root."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:618
msgid "0 for success or -errno"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:619
msgid ""
"Collects aggregated endpoint bandwidth and store the bandwidth in an xarray "
"indexed by the upstream device of the switch or the RP device. Each endpoint "
"consists the minimum of the bandwidth from DSLBIS from the endpoint CDAT, "
"the endpoint upstream link bandwidth, and the bandwidth from the SSLBIS of "
"the switch CDAT for the switch upstream port to the downstream port that's "
"associated with the endpoint. If the device is directly connected to a RP, "
"then no SSLBIS is involved."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:739
msgid "collect all the bandwidth at switch level in an xarray"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:740 ../drivers/cxl/core/cdat.c:951
msgid "The region being operated on"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:742 ../drivers/cxl/core/cdat.c:953
msgid "``struct xarray *input_xa``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:741
msgid ""
"xarray indexed by upstream device of a switch with data of 'struct "
"cxl_perf_ctx'"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:745
msgid ""
"a xarray of resulting cxl_perf_ctx per parent switch or root port or "
"ERR_PTR(-errno)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:747
msgid ""
"Iterate through the xarray. Take the minimum of the downstream calculated "
"bandwidth, the upstream link bandwidth, and the SSLBIS of the upstream "
"switch if exists. Sum the resulting bandwidth under the switch upstream "
"device or a RP device. The function can be iterated over multiple switches "
"if the switches are present."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:856
msgid "handle the root port level bandwidth collection"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:862 ../drivers/cxl/core/cdat.c:906
msgid "``struct xarray *xa``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:857
msgid ""
"the xarray that holds the cxl_perf_ctx that has the bandwidth calculated "
"below each root port device."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:860
msgid "xarray that holds cxl_perf_ctx per host bridge or ERR_PTR(-errno)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:900
msgid "handle the host bridge level bandwidth collection"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:901
msgid ""
"the xarray that holds the cxl_perf_ctx that has the bandwidth calculated "
"below each host bridge."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:904
msgid "xarray that holds cxl_perf_ctx per ACPI0017 device or ERR_PTR(-errno)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:950
msgid "Update the bandwidth access coordinates of a region"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:952
msgid ""
"xarray holds cxl_perf_ctx with calculated bandwidth per ACPI0017 instance"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:972
msgid "Recalculate the bandwidth for the region"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:974
msgid "the cxl region to recalculate"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:445:
#: ../drivers/cxl/core/cdat.c:975
msgid ""
"The function walks the topology from bottom up and calculates the bandwidth. "
"It starts at the endpoints, processes at the switches if any, processes at "
"the rootport level, at the host bridge level, and finally aggregates at the "
"region."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:448:
#: ../drivers/cxl/core/port.c:20
msgid ""
"The CXL core provides a set of interfaces that can be consumed by CXL aware "
"drivers. The interfaces allow for creation, modification, and destruction of "
"regions, memory devices, ports, and decoders. CXL aware drivers must "
"register with the CXL core via these interfaces in order to be able to "
"participate in cross-device interleave coordination. The CXL core also "
"establishes and maintains the bridge to the nvdimm subsystem."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:448:
#: ../drivers/cxl/core/port.c:27
msgid ""
"CXL core introduces sysfs hierarchy to control the devices that are "
"instantiated by the core."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:922
msgid "register a cxl_port in CXL memory decode hierarchy"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:928
#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:774
#: ../../../driver-api/cxl/theory-of-operation:463:
#: ../drivers/cxl/core/pmem.c:125
msgid "``struct device *host``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:923
#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:773
msgid "host device for devm operations"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:925
msgid "``struct device *uport_dev``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:924
msgid "\"physical\" device implementing this upstream port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:926 ../drivers/cxl/core/port.c:1225
msgid "``resource_size_t component_reg_phys``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:925
msgid "(optional) for configurable cxl_port instances"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:927
msgid "``struct cxl_dport *parent_dport``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:926
msgid "next hop up in the CXL memory decode hierarchy"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1220
msgid "append VH downstream port data to a cxl_port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1221 ../drivers/cxl/core/port.c:1252
msgid "the cxl_port that references this dport"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1223 ../drivers/cxl/core/port.c:1254
#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:47
msgid "``struct device *dport_dev``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1222 ../drivers/cxl/core/port.c:1253
msgid "firmware or PCI device representing the dport"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1224 ../drivers/cxl/core/port.c:1255
msgid "``int port_id``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1223 ../drivers/cxl/core/port.c:1254
msgid "identifier for this dport in a decoder's target list"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1224
msgid "optional location of CXL component registers"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1225
msgid ""
"Note that dports are appended to the devm release action's of the either the "
"port's host (for root ports), or the port itself (for switch ports)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1251
msgid "append RCH downstream port data to a cxl_port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1256
msgid "``resource_size_t rcrb``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1255
msgid "mandatory location of a Root Complex Register Block"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1256
msgid "See CXL 3.0 9.11.8 CXL Devices Attached to an RCH"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1297
msgid "register an endpoint's interest in a port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1303
#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:777
msgid "``struct cxl_dport *dport``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1298
msgid "the dport that routes to **ep_dev**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1300
msgid "``struct device *ep_dev``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1299
msgid "device representing the endpoint"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1300
msgid ""
"Intermediate CXL ports are scanned based on the arrival of endpoints. When "
"those endpoints depart the port can be destroyed once all endpoints that "
"care about that port have been removed."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1906
msgid "Common decoder setup / initialization"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1907 ../drivers/cxl/core/port.c:2051
msgid "owning port of this decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1909 ../drivers/cxl/core/port.c:2089
#: ../drivers/cxl/core/port.c:2142
msgid "``struct cxl_decoder *cxld``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1908
msgid "common decoder properties to initialize"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1909
msgid ""
"A port may contain one or more decoders. Each of those decoders enable some "
"address space for CXL.mem utilization. A decoder is expected to be "
"configured by the caller before registering via cxl_decoder_add()"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1959
msgid "Allocate a root level decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1960
msgid "owning CXL root of this decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1962 ../drivers/cxl/core/port.c:2016
msgid "``unsigned int nr_targets``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1961
msgid "static number of downstream targets"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:1963
msgid ""
"A new cxl decoder to be registered by cxl_decoder_add(). A 'CXL root' "
"decoder is one that decodes from a top-level / static platform firmware "
"description of CXL resources into a CXL standard decode topology."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2013
msgid "Allocate a switch level decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2014
msgid "owning CXL switch port of this decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2015
msgid "max number of dynamically addressable downstream targets"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2017
msgid ""
"A new cxl decoder to be registered by cxl_decoder_add(). A 'switch' decoder "
"is any decoder that can be enumerated by PCIe topology and the HDM Decoder "
"Capability. This includes the decoders that sit between Switch Upstream "
"Ports / Switch Downstream Ports and Host Bridges / Root Ports."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2050
msgid "Allocate an endpoint decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2053
msgid "A new cxl decoder to be registered by cxl_decoder_add()"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2083 ../drivers/cxl/core/port.c:2136
msgid "Add a decoder with targets"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2084 ../drivers/cxl/core/port.c:2137
msgid "The cxl decoder allocated by cxl_<type>_decoder_alloc()"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2085
msgid ""
"Certain types of decoders may not have any targets. The main example of this "
"is an endpoint device. A more awkward example is a hostbridge whose root "
"ports get hot added (technically possible, though unlikely)."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2089
msgid "This is the locked variant of cxl_decoder_add()."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2092
msgid ""
"Process context. Expects the device lock of the port that owns the **cxld** "
"to be held."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2095
msgid ""
"Negative error code if the decoder wasn't properly configured; else returns "
"0."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2138
msgid ""
"This is the unlocked variant of cxl_decoder_add_locked(). See "
"cxl_decoder_add_locked()."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2142
msgid ""
"Process context. Takes and releases the device lock of the port that owns "
"the **cxld**."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2178
msgid "register a driver for the cxl bus"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2184
msgid "``struct cxl_driver *cxl_drv``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2179
msgid "cxl driver structure to attach"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2181
msgid "``struct module *owner``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2180
msgid "owning module/driver"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2182
msgid "``const char *modname``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2181
msgid "KBUILD_MODNAME for parent driver"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2321
msgid "Retrieve performance numbers stored in dports of CXL path"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2323
msgid "endpoint cxl_port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2325
msgid "``struct access_coordinate *coord``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2324
msgid "output performance data"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:451:
#: ../drivers/cxl/core/port.c:2326
msgid "errno on failure, 0 on success."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:454:
#: ../drivers/cxl/core/pci.c:17
msgid ""
"Compute Express Link protocols are layered on top of PCIe. CXL core provides "
"a set of helpers for CXL interactions which occur via PCIe."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:44
msgid "allocate a dport by dport device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:45
msgid "cxl_port that hosts the dport"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:46
msgid "'struct device' of the dport"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:47
msgid "Returns the allocated dport on success or ERR_PTR() of -errno on error"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:360
msgid "Setup HDM decoding for the endpoint"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:361
msgid "Device state"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:362
msgid "Mapped HDM decoder Capability"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:363
msgid "Cached DVSEC range registers info"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:364
msgid "Try to enable the endpoint's HDM Decoder Capability"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:559
msgid "Read the CDAT data on this port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:560
msgid "Port to read data from"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:561
msgid "This call will sleep waiting for responses from the DOE mailbox."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:771
msgid "Setup CXL RAS report on this dport"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:772
msgid "the cxl_dport that needs to be initialized"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:962
msgid "calculate the link latency for the PCIe link"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:968
#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:354 ../drivers/cxl/core/regs.c:374
#: ../drivers/cxl/core/regs.c:392
msgid "``struct pci_dev *pdev``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:963
msgid "PCI device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:965
msgid "calculated latency or 0 for no latency"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:457:
#: ../drivers/cxl/core/pci.c:966
msgid ""
"CXL Memory Device SW Guide v1.0 2.11.4 Link latency calculation Link latency "
"= LinkPropagationLatency + FlitLatency + RetimerLatency LinkProgationLatency "
"is negligible, so 0 will be used RetimerLatency is assumed to be negligible "
"and 0 will be used FlitLatency = FlitSize / LinkBandwidth FlitSize is "
"defined by spec. CXL rev3.0 4.2.1. 68B flit is used up to 32GT/s. >32GT/s, "
"256B flit size is used. The FlitLatency is converted to picoseconds."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:460:
#: ../drivers/cxl/core/pmem.c:11
msgid ""
"The core CXL PMEM infrastructure supports persistent memory provisioning and "
"serves as a bridge to the LIBNVDIMM subsystem. A CXL 'bridge' device is "
"added at the root of a CXL device topology if platform firmware advertises "
"at least one persistent memory capable CXL window. That root-level bridge "
"corresponds to a LIBNVDIMM 'bus' device. Then for each cxl_memdev in the CXL "
"device topology a bridge device is added to host a LIBNVDIMM dimm object. "
"When these bridges are registered native LIBNVDIMM uapis are translated to "
"CXL operations, for example, namespace label access commands."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:463:
#: ../drivers/cxl/core/pmem.c:55
msgid "find a bridge device relative to a port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:463:
#: ../drivers/cxl/core/pmem.c:56
msgid "any descendant port of an nvdimm-bridge associated root-cxl-port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:463:
#: ../drivers/cxl/core/pmem.c:119
msgid "add the root of a LIBNVDIMM topology"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:463:
#: ../drivers/cxl/core/pmem.c:120
msgid "platform firmware root device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:463:
#: ../drivers/cxl/core/pmem.c:121
msgid "CXL port at the root of a CXL topology"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:463:
#: ../drivers/cxl/core/pmem.c:123
msgid "bridge device that can host cxl_nvdimm objects"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:463:
#: ../drivers/cxl/core/pmem.c:239
msgid "add a bridge between a cxl_memdev and an nvdimm"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:463:
#: ../drivers/cxl/core/pmem.c:245
msgid "``struct cxl_port *parent_port``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:463:
#: ../drivers/cxl/core/pmem.c:240
msgid "parent port for the (to be added) **cxlmd** endpoint port"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:463:
#: ../drivers/cxl/core/pmem.c:242
#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:1277
msgid "``struct cxl_memdev *cxlmd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:463:
#: ../drivers/cxl/core/pmem.c:241
msgid "cxl_memdev instance that will perform LIBNVDIMM operations"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:463:
#: ../drivers/cxl/core/pmem.c:243
#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:3377
msgid "0 on success negative error code on failure."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:466:
#: ../drivers/cxl/core/regs.c:14
msgid ""
"CXL device capabilities are enumerated by PCI DVSEC (Designated Vendor-"
"specific) and / or descriptors provided by platform firmware. They can be "
"defined as a set like the device and component registers mandated by CXL "
"Section 8.1.12.2 Memory Device PCIe Capabilities and Extended Capabilities, "
"or they can be individual capabilities appended to bridged and endpoint "
"devices."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:466:
#: ../drivers/cxl/core/regs.c:21
msgid ""
"Provide common infrastructure for enumerating and mapping these discrete "
"capabilities."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:28
msgid "Detect CXL Component register blocks"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:34 ../drivers/cxl/core/regs.c:118
msgid "``struct device *dev``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:29 ../drivers/cxl/core/regs.c:113
msgid "Host device of the **base** mapping"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:31 ../drivers/cxl/core/regs.c:115
msgid "``void __iomem *base``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:30
msgid "Mapping containing the HDM Decoder Capability Header"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:32
msgid "``struct cxl_component_reg_map *map``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:31 ../drivers/cxl/core/regs.c:115
msgid "Map object describing the register block information found"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:32
msgid ""
"See CXL 2.0 8.2.4 Component Register Layout and Definition See CXL 2.0 "
"8.2.5.5 CXL Device Register Interface"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:35
msgid "Probe for component register information and return it in map object."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:112
msgid "Detect CXL Device register blocks"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:114
msgid "Mapping of CXL 2.0 8.2.8 CXL Device Register Interface"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:116
msgid "``struct cxl_device_reg_map *map``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:116
msgid "Probe for device register information and return it in map object."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:348
msgid "Locate a register block by type / index"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:349 ../drivers/cxl/core/regs.c:369
#: ../drivers/cxl/core/regs.c:387
msgid "The CXL PCI device to enumerate."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:351 ../drivers/cxl/core/regs.c:371
#: ../drivers/cxl/core/regs.c:389
msgid "``enum cxl_regloc_type type``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:350 ../drivers/cxl/core/regs.c:370
#: ../drivers/cxl/core/regs.c:388
msgid "Register Block Indicator id"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:352 ../drivers/cxl/core/regs.c:372
msgid "``struct cxl_register_map *map``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:351 ../drivers/cxl/core/regs.c:371
msgid "Enumeration output, clobbered on error"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:353
msgid "``unsigned int index``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:352
msgid ""
"Index into which particular instance of a regblock wanted in the order found "
"in register locator DVSEC."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:355 ../drivers/cxl/core/regs.c:373
msgid "0 if register block enumerated, negative error code otherwise"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:356
msgid ""
"A CXL DVSEC may point to one or more register blocks, search for them by "
"**type** and **index**."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:368
msgid "Locate register blocks by type"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:374
msgid ""
"A CXL DVSEC may point to one or more register blocks, search for them by "
"**type**."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:386
msgid "Count instances of a given regblock type."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:389
msgid "Some regblocks may be repeated. Count how many instances."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:469:
#: ../drivers/cxl/core/regs.c:392
msgid ""
"non-negative count of matching regblocks, negative error code otherwise."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:472:
#: ../drivers/cxl/core/mbox.c:19
msgid ""
"Core implementation of the CXL 2.0 Type-3 Memory Device Mailbox. The "
"implementation is used by the cxl_pci driver to initialize the device and "
"implement the cxl_mem.h IOCTL UAPI. It also implements the backend of the "
"cxl_pmem_ctl() transport for LIBNVDIMM."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:228
msgid "Kernel internal interface to send a mailbox command"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:230
msgid "initialized command to execute"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:232
msgid "Any context."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:233
msgid "%>=0      - Number of bytes returned in **out**."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:234
msgid "``-E2BIG``   - Payload is too large for hardware."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:235
msgid "``-EBUSY``   - Couldn't acquire exclusive mailbox access."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:236
msgid "``-EFAULT``  - Hardware error occurred."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:237
msgid "``-ENXIO``   - Command completed, but device reported an error."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:238
msgid "``-EIO``     - Unexpected output size."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:240
msgid ""
"Mailbox commands may execute successfully yet the device itself reported an "
"error. While this distinction can be useful for commands from userspace, the "
"kernel will only be able to use results when both are successful."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:311
msgid "Check contents of in_payload."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:317
msgid "``u16 opcode``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:312
msgid "The mailbox command opcode."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:314
msgid "``void *payload_in``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:313
msgid "Pointer to the input payload passed in from user space."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:315
msgid "true      - payload_in passes check for **opcode**."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:316
msgid "false     - payload_in contains invalid or unsupported values."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:318
msgid ""
"The driver may inspect payload contents before sending a mailbox command "
"from user space to the device. The intent is to reject commands with input "
"payloads that are known to be unsafe. This check is not intended to replace "
"the users careful selection of mailbox command parameters and makes no "
"guarantee that the user command will succeed, nor that it is appropriate."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:325
msgid "The specific checks are determined by the opcode."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:478
msgid "Check fields for CXL_MEM_SEND_COMMAND."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:479
msgid "Sanitized and populated :c:type:`struct cxl_mbox_cmd <cxl_mbox_cmd>`."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:482
msgid "``const struct cxl_send_command *send_cmd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:481
msgid ""
":c:type:`struct cxl_send_command <cxl_send_command>` copied in from "
"userspace."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:483
msgid "``0``        - **out_cmd** is ready to send."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:484
msgid "``-ENOTTY``  - Invalid command specified."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:485
msgid "``-EINVAL``  - Reserved fields or invalid values were used."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:486
msgid "``-ENOMEM``  - Input or output buffer wasn't sized properly."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:487
msgid "``-EPERM``   - Attempted to use a protected command."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:488
msgid "``-EBUSY``   - Kernel has claimed exclusive access to this opcode"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:490
msgid ""
"The result of this command is a fully validated command in **mbox_cmd** that "
"is safe to send to the hardware."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:567
msgid "Dispatch a mailbox command for userspace."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:568
msgid "The mailbox context for the operation."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:569
msgid "The validated mailbox command."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:571
msgid "``u64 out_payload``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:570
msgid "Pointer to userspace's output payload."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:572
msgid "``s32 *size_out``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:571
msgid ""
"(Input) Max payload size to copy out. (Output) Payload size hardware "
"generated."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:574
msgid "``u32 *retval``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:573
msgid "Hardware generated return code from the operation."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:575
msgid "``0``        - Mailbox transaction succeeded. This implies the mailbox"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:576
msgid ""
"protocol completed successfully not that the operation itself was successful."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:578
msgid "``-ENOMEM``  - Couldn't allocate a bounce buffer."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:579
msgid "``-EFAULT``  - Something happened with copy_to/from_user."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:580
msgid "``-EINTR``   - Mailbox acquisition interrupted."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:581
msgid "``-EXXX``    - Transaction level failures."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:583
msgid ""
"Dispatches a mailbox command on behalf of a userspace request. The output "
"payload is copied to userspace."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:586
msgid "See cxl_send_cmd()."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:740
msgid "Walk through the Command Effects Log."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:741 ../drivers/cxl/core/mbox.c:829
#: ../drivers/cxl/core/mbox.c:1111 ../drivers/cxl/core/mbox.c:1137
#: ../drivers/cxl/core/mbox.c:1173
msgid "The driver data for the operation"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:743
msgid "``size_t size``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:742
msgid "Length of the Command Effects Log."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:744
msgid "``u8 *cel``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:743
msgid "CEL"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:744
msgid ""
"Iterate over each entry in the CEL and determine if the driver supports the "
"command. If so, the command is enabled for the device and can be used later."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:828
msgid "Enumerate commands for a device."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:830
msgid "Returns 0 if enumerate completed successfully."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:832
msgid ""
"CXL devices have optional support for certain commands. This function will "
"determine the set of supported commands for the hardware and update the "
"enabled_cmds bitmap in the **mds**."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:1110
msgid "Get Event Records from the device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:1113
msgid "``u32 status``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:1112
msgid "Event Status register value identifying which events are available."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:1113
msgid ""
"Retrieve all event records available on the device, report them as trace "
"events, and clear them."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:1116
msgid ""
"See CXL rev 3.0 **8.2.9.2.2** Get Event Records See CXL rev 3.0 "
"**8.2.9.2.3** Clear Event Records"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:1136
msgid "Get partition info"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:1138
msgid ""
"Retrieve the current partition info for the device specified.  The active "
"values are the current capacity in bytes.  If not 0, the 'next' values are "
"the pending values, in bytes, which take affect on next cold reset."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:1143
msgid "See CXL **8.2.9.5.2.1** Get Partition Info"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:1172
msgid "Send the IDENTIFY command to the device."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:1175
msgid "0 if identify was executed successfully or media not ready."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:1176
msgid ""
"This will dispatch the identify command to the device and on success "
"populate structures to be exported to sysfs."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:1271
msgid "Send a sanitization command to the device."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:1272
msgid "The device for the operation"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:1274
msgid "``u16 cmd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:1273
msgid "The specific sanitization command opcode"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:1275
msgid ""
"0 if the command was executed successfully, regardless of whether or not the "
"actual security operation is done in the background, such as for the "
"Sanitize case. Error return values can be the result of the mailbox command, "
"-EINVAL when security requirements are not met or invalid contexts, or -"
"EBUSY if the sanitize operation is already in flight."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:475:
#: ../drivers/cxl/core/mbox.c:1281
msgid "See CXL 3.0 **8.2.9.8.5.1** Sanitize and **8.2.9.8.5.2** Secure Erase."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:478:
#: ../drivers/cxl/core/features.c:13
msgid ""
"CXL Features: A CXL device that includes a mailbox supports commands that "
"allows listing, getting, and setting of optionally defined features such as "
"memory sparing or post package sparing. Vendors may define custom features "
"for the device."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:395
msgid "See :c:func:`devm_cxl_setup_features` for API details."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:398
msgid "CXL Regions"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:485:
#: ../drivers/cxl/core/region.c:20
msgid ""
"CXL Regions represent mapped memory capacity in system physical address "
"space. Whereas the CXL Root Decoders identify the bounds of potential CXL "
"Memory ranges, Regions represent the active mapped capacity by the HDM "
"Decoder Capability structures throughout the Host Bridges, Switches, and "
"Endpoints in the topology."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:485:
#: ../drivers/cxl/core/region.c:26
msgid ""
"Region configuration has ordering constraints. UUID may be set at any time "
"but is only visible for persistent regions. 1. Interleave granularity 2. "
"Interleave size 3. Decoder targets"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:909
msgid "assign or lookup a decoder for a region"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:910
msgid "a port in the ancestry of the endpoint implied by **cxled**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:911
msgid "endpoint decoder to be, or currently, mapped by **port**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:912
msgid "region to establish, or validate, decode **port**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:913
msgid ""
"In the region creation path cxl_port_pick_region_decoder() is an allocator "
"to find a free port. In the region assembly path, it is recalling the "
"decoder that platform firmware picked for validation purposes."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:918
msgid "The result is recorded in a 'struct cxl_region_ref' in **port**."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:1107
msgid "track a region's interest in a port by endpoint"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:1108
msgid "port to add a new region reference 'struct cxl_region_ref'"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:1109
msgid "region to attach to **port**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:1110
msgid "endpoint decoder used to create or further pin a region reference"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:1112 ../drivers/cxl/core/region.c:2979
msgid "``int pos``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:1111
msgid "interleave position of **cxled** in **cxlr**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:1112
msgid ""
"The attach event is an opportunity to validate CXL decode setup constraints "
"and record metadata needed for programming HDM decoders, in particular "
"decoder target lists."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:1116
msgid "The steps are:"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:1118
msgid ""
"validate that there are no other regions with a higher HPA already "
"associated with **port**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:1120
msgid "establish a region reference if one is not already present"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:1122
msgid ""
"additionally allocate a decoder instance that will host **cxlr** on **port**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:1125
msgid "pin the region reference by the endpoint"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:1126
msgid ""
"account for how many entries in **port**'s target list are needed to cover "
"all of the added endpoints."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:1875
msgid "calculate an endpoint position in a region"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:1876
msgid "endpoint decoder member of given region"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:1877
msgid ""
"The endpoint position is calculated by traversing the topology from the "
"endpoint to the root decoder and iteratively applying this calculation:"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:1881
msgid "position = position * parent_ways + parent_pos;"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:1883
msgid ""
"...where **position** is inferred from switch and root decoder target lists."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:1886
msgid "position >= 0 on success -ENXIO on failure"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:2574
msgid "Adds a region to a decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:2580
msgid "``struct cxl_root_decoder *cxlrd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:2575
msgid "root decoder"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:2577
msgid "``int id``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:2576
msgid "memregion id to create, or memregion_free() on failure"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:2578
msgid "``enum cxl_partition_mode mode``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:2577
msgid "mode for the endpoint decoders of this region"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:2579
msgid "``enum cxl_decoder_type type``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:2578
msgid "select whether this is an expander or accelerator (type-2 or type-3)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:2579
msgid ""
"This is the second step of region initialization. Regions exist within an "
"address space which is mapped by a **cxlrd**."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:2583
msgid ""
"0 if the region was added to the **cxlrd**, else returns negative error "
"code. The region will be named \"regionZ\" where Z is the unique region "
"number."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:2981
msgid "``u8 eiw``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:2976
msgid "encoded interleave ways"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:2978
msgid "``u16 eig``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:2977
msgid "encoded interleave granularity"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:2978
msgid "position in interleave"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:2979
msgid "Callers pass CXL_POS_ZERO when no position parameter needs validating."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:2982
msgid "0 on success, -EINVAL on first invalid parameter"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:3374
msgid "add a cxl_region-to-nd_region bridge"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:488:
#: ../drivers/cxl/core/region.c:3375
msgid "parent CXL region for this pmem region bridge device"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:406
msgid "External Interfaces"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation.rst:409
msgid "CXL IOCTL Interface"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:497:
#: ../include/uapi/linux/cxl_mem.h:12
msgid ""
"Not all of the commands that the driver supports are available for use by "
"userspace at all times.  Userspace can check the result of the QUERY command "
"to determine the live set of commands.  Alternatively, it can issue the "
"command and check for failure."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:102
msgid "Command information returned from a query."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:104
msgid "ID number for the command."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:105
msgid "Flags that specify command behavior."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:118
msgid "``size_in``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:119
msgid "Expected input size, or ~0 if variable length."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:119
msgid "``size_out``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:120
msgid "Expected output size, or ~0 if variable length."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:105
msgid "CXL_MEM_COMMAND_FLAG_USER_ENABLED"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:107
msgid ""
"The given command id is supported by the driver and is supported by a "
"related opcode on the device."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:110
msgid "CXL_MEM_COMMAND_FLAG_EXCLUSIVE"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:112
msgid ""
"Requests with the given command id will terminate with EBUSY as the kernel "
"actively owns management of the given resource. For example, the label-"
"storage-area can not be written while the kernel is actively managing that "
"space."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:118
msgid ""
"Represents a single command that is supported by both the driver and the "
"hardware. This is returned as part of an array from the query ioctl. The "
"following would be a command that takes a variable length input and returns "
"0 bytes of output."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:123
msgid "**id** = 10"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:124
msgid "**flags** = CXL_MEM_COMMAND_FLAG_ENABLED"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:125
msgid "**size_in** = ~0"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:126
msgid "**size_out** = 0"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:128
msgid "See struct cxl_mem_query_commands."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:146
msgid "Query supported commands."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:147
msgid "``n_commands``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:148
msgid ""
"In/out parameter. When **n_commands** is > 0, the driver will return "
"min(num_support_commands, n_commands). When **n_commands** is 0, driver will "
"return the number of total supported commands."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:150 ../include/uapi/linux/cxl_mem.h:189
msgid "``rsvd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:151
msgid "Reserved for future use."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:151
msgid "``commands``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:152
msgid ""
"Output array of supported commands. This array must be allocated by "
"userspace to be at least min(num_support_commands, **n_commands**)"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:153
msgid ""
"Allow userspace to query the available commands supported by both the "
"driver, and the hardware. Commands that aren't supported by either the "
"driver, or the hardware are not returned in the query."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:157
msgid "**Examples**"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:158
msgid "{ .n_commands = 0 } // Get number of supported commands"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:159
msgid ""
"{ .n_commands = 15, .commands = buf } // Return first 15 (or less) supported "
"commands"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:182
msgid "Send a command to a memory device."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:184
msgid ""
"The command to send to the memory device. This must be one of the commands "
"returned by the query command."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:186
msgid "Flags for the command (input)."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:186
msgid "``raw``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:187
msgid "Special fields for raw commands"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:187
msgid "``raw.opcode``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:188
msgid "Opcode passed to hardware when using the RAW command."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:188
msgid "``raw.rsvd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:189 ../include/uapi/linux/cxl_mem.h:190
#: ../include/uapi/linux/cxl_mem.h:194 ../include/uapi/linux/cxl_mem.h:201
msgid "Must be zero."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:190
msgid "``retval``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:191
msgid "Return value from the memory device (output)."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:191
msgid "``in``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:192
msgid "Parameters associated with input payload."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:192
msgid "``in.size``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:193
msgid "Size of the payload to provide to the device (input)."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:193
msgid "``in.rsvd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:194
msgid "``in.payload``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:195
msgid "Pointer to memory for payload input, payload is little endian."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:195
msgid "``out``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:196
msgid "Parameters associated with output payload."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:196
msgid "``out.size``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:197
msgid ""
"Size of the payload received from the device (input/output). This field is "
"filled in by userspace to let the driver know how much space was allocated "
"for output. It is populated by the driver to let userspace know how large "
"the output payload actually was."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:200
msgid "``out.rsvd``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:201
msgid "``out.payload``"
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:202
msgid "Pointer to memory for payload output, payload is little endian."
msgstr ""

#: ../../../driver-api/cxl/theory-of-operation:500:
#: ../include/uapi/linux/cxl_mem.h:202
msgid ""
"Mechanism for userspace to send a command to the hardware for processing. "
"The driver will do basic validation on the command sizes. In some cases even "
"the payload may be introspected. Userspace is required to allocate large "
"enough buffers for size_out which can be variable length in certain "
"situations."
msgstr ""
