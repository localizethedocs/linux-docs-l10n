# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/pci/pci.rst:2
msgid "PCI Support Library"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:184
msgid "returns maximum PCI bus number of given bus' children"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:148
#: drivers/pci/devres.c:179 drivers/pci/devres.c:209 drivers/pci/devres.c:275
#: drivers/pci/devres.c:320 drivers/pci/devres.c:366 drivers/pci/devres.c:400
#: drivers/pci/devres.c:423 drivers/pci/devres.c:525 drivers/pci/devres.c:575
#: drivers/pci/devres.c:601 drivers/pci/devres.c:650 drivers/pci/devres.c:671
#: drivers/pci/devres.c:716 drivers/pci/devres.c:793 drivers/pci/devres.c:824
#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:37
#: drivers/pci/pci-driver.c:98 drivers/pci/pci-driver.c:1425
#: drivers/pci/pci-driver.c:1455 drivers/pci/pci-driver.c:1476
#: drivers/pci/pci-driver.c:1524 drivers/pci/pci-driver.c:1544
#: ../../../driver-api/pci/pci:16: drivers/pci/remove.c:132
#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:137
#: drivers/pci/search.c:162 drivers/pci/search.c:185 drivers/pci/search.c:218
#: drivers/pci/search.c:290 drivers/pci/search.c:321 drivers/pci/search.c:342
#: drivers/pci/search.c:371 drivers/pci/search.c:402
#: ../../../driver-api/pci/pci:22: drivers/pci/msi/msi.c:135
#: drivers/pci/msi/msi.c:147 drivers/pci/msi/msi.c:477
#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:249 drivers/pci/bus.c:339
#: drivers/pci/bus.c:385 drivers/pci/bus.c:433 ../../../driver-api/pci/pci:28:
#: drivers/pci/access.c:191 drivers/pci/access.c:285 drivers/pci/access.c:305
#: drivers/pci/access.c:329 ../../../driver-api/pci/pci:31:
#: drivers/pci/irq.c:23 drivers/pci/irq.c:67 drivers/pci/irq.c:126
#: drivers/pci/irq.c:240 drivers/pci/irq.c:253 ../../../driver-api/pci/pci:34:
#: drivers/pci/probe.c:2273 drivers/pci/probe.c:2821 drivers/pci/probe.c:3165
#: drivers/pci/probe.c:3452 ../../../driver-api/pci/pci:37:
#: drivers/pci/slot.c:193 drivers/pci/slot.c:313
#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:20 drivers/pci/rom.c:56
#: drivers/pci/rom.c:130 drivers/pci/rom.c:185 ../../../driver-api/pci/pci:43:
#: drivers/pci/iov.c:59 drivers/pci/iov.c:1154 drivers/pci/iov.c:1172
#: drivers/pci/iov.c:1187 drivers/pci/iov.c:1202 drivers/pci/iov.c:1243
#: drivers/pci/iov.c:1273 drivers/pci/iov.c:1290 drivers/pci/iov.c:1326
#: drivers/pci/iov.c:1368 ../../../driver-api/pci/pci:46:
#: drivers/pci/pci-sysfs.c:883 drivers/pci/pci-sysfs.c:908
#: drivers/pci/pci-sysfs.c:933 drivers/pci/pci-sysfs.c:953
#: drivers/pci/pci-sysfs.c:973 drivers/pci/pci-sysfs.c:985
#: drivers/pci/pci-sysfs.c:1060 drivers/pci/pci-sysfs.c:1170
#: drivers/pci/pci-sysfs.c:1254 drivers/pci/pci-sysfs.c:1293
#: drivers/pci/pci-sysfs.c:1318 drivers/pci/pci-sysfs.c:1668
#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:229 drivers/pci/tph.c:274
#: drivers/pci/tph.c:336 drivers/pci/tph.c:358 ../../../driver-api/pci/pci:4:
#: drivers/pci/pci.c:188 drivers/pci/pci.c:210 drivers/pci/pci.c:490
#: drivers/pci/pci.c:521 drivers/pci/pci.c:548 drivers/pci/pci.c:600
#: drivers/pci/pci.c:620 drivers/pci/pci.c:682 drivers/pci/pci.c:701
#: drivers/pci/pci.c:724 drivers/pci/pci.c:757 drivers/pci/pci.c:789
#: drivers/pci/pci.c:832 drivers/pci/pci.c:1235 drivers/pci/pci.c:1637
#: drivers/pci/pci.c:1792 drivers/pci/pci.c:1908 drivers/pci/pci.c:1948
#: drivers/pci/pci.c:1989 drivers/pci/pci.c:2025 drivers/pci/pci.c:2112
#: drivers/pci/pci.c:2184 drivers/pci/pci.c:2198 drivers/pci/pci.c:2275
#: drivers/pci/pci.c:2315 drivers/pci/pci.c:2413 drivers/pci/pci.c:2517
#: drivers/pci/pci.c:2654 drivers/pci/pci.c:2672 drivers/pci/pci.c:2754
#: drivers/pci/pci.c:2783 drivers/pci/pci.c:2828 drivers/pci/pci.c:2943
#: drivers/pci/pci.c:3174 drivers/pci/pci.c:3191 drivers/pci/pci.c:3790
#: drivers/pci/pci.c:3865 drivers/pci/pci.c:3948 drivers/pci/pci.c:4022
#: drivers/pci/pci.c:4043 drivers/pci/pci.c:4081 drivers/pci/pci.c:4096
#: drivers/pci/pci.c:4112 drivers/pci/pci.c:4127 drivers/pci/pci.c:4146
#: drivers/pci/pci.c:4228 drivers/pci/pci.c:4264 drivers/pci/pci.c:4338
#: drivers/pci/pci.c:4352 drivers/pci/pci.c:4362 drivers/pci/pci.c:4400
#: drivers/pci/pci.c:4431 drivers/pci/pci.c:4450 drivers/pci/pci.c:4487
#: drivers/pci/pci.c:4512 drivers/pci/pci.c:4528 drivers/pci/pci.c:4556
#: drivers/pci/pci.c:4986 drivers/pci/pci.c:5227 drivers/pci/pci.c:5314
#: drivers/pci/pci.c:5361 drivers/pci/pci.c:5395 drivers/pci/pci.c:5665
#: drivers/pci/pci.c:5768 drivers/pci/pci.c:5806 drivers/pci/pci.c:5819
#: drivers/pci/pci.c:5842 drivers/pci/pci.c:5865 drivers/pci/pci.c:5912
#: drivers/pci/pci.c:5928 drivers/pci/pci.c:5975 drivers/pci/pci.c:5991
#: drivers/pci/pci.c:6037 drivers/pci/pci.c:6144 drivers/pci/pci.c:6158
#: drivers/pci/pci.c:6237 drivers/pci/pci.c:6249
#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:341
#: drivers/pci/hotplug/pci_hotplug_core.c:374
#: drivers/pci/hotplug/pci_hotplug_core.c:419
#: drivers/pci/hotplug/pci_hotplug_core.c:448
#: drivers/pci/hotplug/pci_hotplug_core.c:462
#: drivers/pci/hotplug/pci_hotplug_core.c:477 ../../../driver-api/pci/pci:7:
#: drivers/pci/iomap.c:19 drivers/pci/iomap.c:65 drivers/pci/iomap.c:114
#: drivers/pci/iomap.c:134
msgid "**Parameters**"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:187
#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:251
#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:193
#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:2823
#: drivers/pci/probe.c:3167 drivers/pci/probe.c:3454
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:190 drivers/pci/pci.c:523
#: drivers/pci/pci.c:5770 ../../../driver-api/pci/pci:55:
#: drivers/pci/hotplug/pci_hotplug_core.c:340
#: drivers/pci/hotplug/pci_hotplug_core.c:373
msgid "``struct pci_bus *bus``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:185
msgid "pointer to PCI bus structure to search"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:149
#: drivers/pci/devres.c:180 drivers/pci/devres.c:209 drivers/pci/devres.c:274
#: drivers/pci/devres.c:322 drivers/pci/devres.c:367 drivers/pci/devres.c:399
#: drivers/pci/devres.c:424 drivers/pci/devres.c:528 drivers/pci/devres.c:575
#: drivers/pci/devres.c:604 drivers/pci/devres.c:650 drivers/pci/devres.c:674
#: drivers/pci/devres.c:719 drivers/pci/devres.c:795 drivers/pci/devres.c:828
#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:43
#: drivers/pci/pci-driver.c:98 drivers/pci/pci-driver.c:1426
#: drivers/pci/pci-driver.c:1454 drivers/pci/pci-driver.c:1475
#: drivers/pci/pci-driver.c:1523 drivers/pci/pci-driver.c:1543
#: ../../../driver-api/pci/pci:16: drivers/pci/remove.c:131
#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:137
#: drivers/pci/search.c:161 drivers/pci/search.c:187 drivers/pci/search.c:221
#: drivers/pci/search.c:293 drivers/pci/search.c:322 drivers/pci/search.c:342
#: drivers/pci/search.c:371 drivers/pci/search.c:402
#: ../../../driver-api/pci/pci:22: drivers/pci/msi/msi.c:476
#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:255 drivers/pci/bus.c:338
#: drivers/pci/bus.c:384 drivers/pci/bus.c:434 ../../../driver-api/pci/pci:28:
#: drivers/pci/access.c:191 drivers/pci/access.c:284 drivers/pci/access.c:304
#: drivers/pci/access.c:328 ../../../driver-api/pci/pci:31: drivers/pci/irq.c:3
#: drivers/pci/irq.c:68 drivers/pci/irq.c:126 drivers/pci/irq.c:239
#: drivers/pci/irq.c:252 ../../../driver-api/pci/pci:34:
#: drivers/pci/probe.c:2272 drivers/pci/probe.c:2821 drivers/pci/probe.c:3164
#: drivers/pci/probe.c:3451 ../../../driver-api/pci/pci:37:
#: drivers/pci/slot.c:195 drivers/pci/slot.c:312
#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:19 drivers/pci/rom.c:55
#: drivers/pci/rom.c:132 drivers/pci/rom.c:185 ../../../driver-api/pci/pci:43:
#: drivers/pci/iov.c:59 drivers/pci/iov.c:1154 drivers/pci/iov.c:1186
#: drivers/pci/iov.c:1201 drivers/pci/iov.c:1243 drivers/pci/iov.c:1272
#: drivers/pci/iov.c:1290 drivers/pci/iov.c:1327 drivers/pci/iov.c:1369
#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:887
#: drivers/pci/pci-sysfs.c:912 drivers/pci/pci-sysfs.c:935
#: drivers/pci/pci-sysfs.c:955 drivers/pci/pci-sysfs.c:973
#: drivers/pci/pci-sysfs.c:984 drivers/pci/pci-sysfs.c:1062
#: drivers/pci/pci-sysfs.c:1169 drivers/pci/pci-sysfs.c:1253
#: drivers/pci/pci-sysfs.c:1297 drivers/pci/pci-sysfs.c:1322
#: drivers/pci/pci-sysfs.c:1667 ../../../driver-api/pci/pci:49:
#: drivers/pci/tph.c:232 drivers/pci/tph.c:275 drivers/pci/tph.c:358
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:187 drivers/pci/pci.c:209
#: drivers/pci/pci.c:490 drivers/pci/pci.c:522 drivers/pci/pci.c:549
#: drivers/pci/pci.c:600 drivers/pci/pci.c:619 drivers/pci/pci.c:683
#: drivers/pci/pci.c:701 drivers/pci/pci.c:725 drivers/pci/pci.c:758
#: drivers/pci/pci.c:790 drivers/pci/pci.c:832 drivers/pci/pci.c:1637
#: drivers/pci/pci.c:1948 drivers/pci/pci.c:2183 drivers/pci/pci.c:2197
#: drivers/pci/pci.c:2274 drivers/pci/pci.c:2315 drivers/pci/pci.c:2517
#: drivers/pci/pci.c:2655 drivers/pci/pci.c:2672 drivers/pci/pci.c:2754
#: drivers/pci/pci.c:2783 drivers/pci/pci.c:2827 drivers/pci/pci.c:2943
#: drivers/pci/pci.c:3173 drivers/pci/pci.c:3190 drivers/pci/pci.c:3790
#: drivers/pci/pci.c:3868 drivers/pci/pci.c:3949 drivers/pci/pci.c:4025
#: drivers/pci/pci.c:4043 drivers/pci/pci.c:4112 drivers/pci/pci.c:4127
#: drivers/pci/pci.c:4148 drivers/pci/pci.c:4228 drivers/pci/pci.c:4263
#: drivers/pci/pci.c:4337 drivers/pci/pci.c:4361 drivers/pci/pci.c:4399
#: drivers/pci/pci.c:4430 drivers/pci/pci.c:4449 drivers/pci/pci.c:4487
#: drivers/pci/pci.c:4511 drivers/pci/pci.c:4527 drivers/pci/pci.c:4556
#: drivers/pci/pci.c:4985 drivers/pci/pci.c:5227 drivers/pci/pci.c:5313
#: drivers/pci/pci.c:5360 drivers/pci/pci.c:5394 drivers/pci/pci.c:5664
#: drivers/pci/pci.c:5767 drivers/pci/pci.c:5805 drivers/pci/pci.c:5818
#: drivers/pci/pci.c:5841 drivers/pci/pci.c:5866 drivers/pci/pci.c:5911
#: drivers/pci/pci.c:5929 drivers/pci/pci.c:5974 drivers/pci/pci.c:5992
#: drivers/pci/pci.c:6040 drivers/pci/pci.c:6143 drivers/pci/pci.c:6157
#: drivers/pci/pci.c:6236 drivers/pci/pci.c:6249
#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:345
#: drivers/pci/hotplug/pci_hotplug_core.c:378
#: drivers/pci/hotplug/pci_hotplug_core.c:418
#: drivers/pci/hotplug/pci_hotplug_core.c:447
#: drivers/pci/hotplug/pci_hotplug_core.c:461
#: drivers/pci/hotplug/pci_hotplug_core.c:476 ../../../driver-api/pci/pci:7:
#: drivers/pci/iomap.c:21 drivers/pci/iomap.c:67 drivers/pci/iomap.c:115
#: drivers/pci/iomap.c:135
msgid "**Description**"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:186
msgid ""
"Given a PCI bus, returns the highest PCI bus number present in the set "
"including the given PCI bus and its list of child PCI buses."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:206
msgid "return and clear error bits in PCI_STATUS"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:277
#: drivers/pci/devres.c:322 drivers/pci/devres.c:368 drivers/pci/devres.c:402
#: drivers/pci/devres.c:425 drivers/pci/devres.c:527 drivers/pci/devres.c:577
#: drivers/pci/devres.c:603 drivers/pci/devres.c:652 drivers/pci/devres.c:673
#: drivers/pci/devres.c:718 drivers/pci/devres.c:795 drivers/pci/devres.c:826
#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:22 drivers/pci/rom.c:58
#: drivers/pci/rom.c:132 drivers/pci/rom.c:187 ../../../driver-api/pci/pci:46:
#: drivers/pci/pci-sysfs.c:1172 drivers/pci/pci-sysfs.c:1256
#: drivers/pci/pci-sysfs.c:1670 ../../../driver-api/pci/pci:49:
#: drivers/pci/tph.c:231 drivers/pci/tph.c:276 drivers/pci/tph.c:338
#: drivers/pci/tph.c:360 ../../../driver-api/pci/pci:4: drivers/pci/pci.c:212
#: drivers/pci/pci.c:3792 drivers/pci/pci.c:3950 drivers/pci/pci.c:4024
#: drivers/pci/pci.c:4045 drivers/pci/pci.c:4083 drivers/pci/pci.c:4098
#: drivers/pci/pci.c:4114 drivers/pci/pci.c:4129 drivers/pci/pci.c:4148
#: drivers/pci/pci.c:4489 drivers/pci/pci.c:5808
msgid "``struct pci_dev *pdev``"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:123
#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1151
#: drivers/pci/iov.c:1169 drivers/pci/iov.c:1184 drivers/pci/iov.c:1199
#: drivers/pci/iov.c:1287 drivers/pci/iov.c:1323 drivers/pci/iov.c:1365
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:207 drivers/pci/pci.c:3862
msgid "the PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:208
msgid "Returns error bits set in PCI_STATUS and clears them."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:486 drivers/pci/pci.c:517
msgid "query for devices' capabilities"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:97
#: drivers/pci/pci-driver.c:1526 drivers/pci/pci-driver.c:1546
#: ../../../driver-api/pci/pci:16: drivers/pci/remove.c:134
#: ../../../driver-api/pci/pci:22: drivers/pci/msi/msi.c:479
#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:341
#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:287
#: drivers/pci/access.c:307 drivers/pci/access.c:331
#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:25 drivers/pci/irq.c:69
#: drivers/pci/irq.c:128 drivers/pci/irq.c:242 drivers/pci/irq.c:255
#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:2275
#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:61 drivers/pci/iov.c:1156
#: drivers/pci/iov.c:1174 drivers/pci/iov.c:1189 drivers/pci/iov.c:1204
#: drivers/pci/iov.c:1245 drivers/pci/iov.c:1275 drivers/pci/iov.c:1292
#: drivers/pci/iov.c:1328 drivers/pci/iov.c:1370 ../../../driver-api/pci/pci:4:
#: drivers/pci/pci.c:492 drivers/pci/pci.c:550 drivers/pci/pci.c:602
#: drivers/pci/pci.c:622 drivers/pci/pci.c:684 drivers/pci/pci.c:703
#: drivers/pci/pci.c:726 drivers/pci/pci.c:759 drivers/pci/pci.c:834
#: drivers/pci/pci.c:1237 drivers/pci/pci.c:1639 drivers/pci/pci.c:1794
#: drivers/pci/pci.c:1910 drivers/pci/pci.c:1950 drivers/pci/pci.c:1991
#: drivers/pci/pci.c:2027 drivers/pci/pci.c:2114 drivers/pci/pci.c:2186
#: drivers/pci/pci.c:2200 drivers/pci/pci.c:2277 drivers/pci/pci.c:2317
#: drivers/pci/pci.c:2415 drivers/pci/pci.c:2519 drivers/pci/pci.c:2674
#: drivers/pci/pci.c:2756 drivers/pci/pci.c:2785 drivers/pci/pci.c:2830
#: drivers/pci/pci.c:2945 drivers/pci/pci.c:3176 drivers/pci/pci.c:3193
#: drivers/pci/pci.c:3867 drivers/pci/pci.c:4340 drivers/pci/pci.c:4354
#: drivers/pci/pci.c:4364 drivers/pci/pci.c:4402 drivers/pci/pci.c:4433
#: drivers/pci/pci.c:4452 drivers/pci/pci.c:4514 drivers/pci/pci.c:4530
#: drivers/pci/pci.c:4558 drivers/pci/pci.c:4988 drivers/pci/pci.c:5229
#: drivers/pci/pci.c:5316 drivers/pci/pci.c:5363 drivers/pci/pci.c:5397
#: drivers/pci/pci.c:5821 drivers/pci/pci.c:5844 drivers/pci/pci.c:5867
#: drivers/pci/pci.c:5914 drivers/pci/pci.c:5930 drivers/pci/pci.c:5977
#: drivers/pci/pci.c:5993 drivers/pci/pci.c:6039 drivers/pci/pci.c:6146
#: drivers/pci/pci.c:6160 drivers/pci/pci.c:6239 drivers/pci/pci.c:6251
#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:21 drivers/pci/iomap.c:67
#: drivers/pci/iomap.c:116 drivers/pci/iomap.c:136
msgid "``struct pci_dev *dev``"
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:2270
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:487 drivers/pci/pci.c:519
#: drivers/pci/pci.c:545 drivers/pci/pci.c:597 drivers/pci/pci.c:617
#: drivers/pci/pci.c:679 drivers/pci/pci.c:698 drivers/pci/pci.c:721
#: drivers/pci/pci.c:754 drivers/pci/pci.c:829 drivers/pci/pci.c:5816
#: drivers/pci/pci.c:5839 drivers/pci/pci.c:5862 drivers/pci/pci.c:5909
#: drivers/pci/pci.c:5925 drivers/pci/pci.c:5972 drivers/pci/pci.c:5988
#: drivers/pci/pci.c:6035 drivers/pci/pci.c:6141 drivers/pci/pci.c:6155
#: drivers/pci/pci.c:6234
msgid "PCI device to query"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:489 drivers/pci/pci.c:521
#: drivers/pci/pci.c:548 drivers/pci/pci.c:599 drivers/pci/pci.c:724
msgid "``int cap``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:488 drivers/pci/pci.c:520
#: drivers/pci/pci.c:547 drivers/pci/pci.c:598
msgid "capability code"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:489
msgid ""
"Tell if a device supports a given PCI capability. Returns the address of the "
"requested capability structure within the device's PCI configuration space "
"or 0 in case the device does not support it.  Possible values for **cap** "
"include:"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:494
msgid ""
"``PCI_CAP_ID_PM``           Power Management ``PCI_CAP_ID_AGP``          "
"Accelerated Graphics Port ``PCI_CAP_ID_VPD``          Vital Product Data "
"``PCI_CAP_ID_SLOTID``       Slot Identification ``PCI_CAP_ID_MSI``          "
"Message Signalled Interrupts ``PCI_CAP_ID_CHSWP``        CompactPCI HotSwap "
"``PCI_CAP_ID_PCIX``         PCI-X ``PCI_CAP_ID_EXP``          PCI Express"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:518
msgid "the PCI bus to query"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:184
#: drivers/pci/search.c:218 ../../../driver-api/pci/pci:4:
#: drivers/pci/pci.c:520
msgid "``unsigned int devfn``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:521
msgid ""
"Like pci_find_capability() but works for PCI devices that do not have a "
"pci_dev structure set up yet."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:524
msgid ""
"Returns the address of the requested capability structure within the "
"device's PCI configuration space or 0 in case the device does not support it."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:544 drivers/pci/pci.c:596
msgid "Find an extended capability"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:547
msgid "``u16 start``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:546
msgid "address at which to start looking (0 to start at beginning of list)"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:548
msgid ""
"Returns the address of the next matching extended capability structure "
"within the device's PCI configuration space or 0 if the device does not "
"support it.  Some capabilities can occur several times, e.g., the vendor-"
"specific capability, and this provides a way to find them all."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:599
msgid ""
"Returns the address of the requested extended capability structure within "
"the device's PCI configuration space or 0 if the device does not support "
"it.  Possible values for **cap** include:"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:603
msgid ""
"``PCI_EXT_CAP_ID_ERR``         Advanced Error Reporting "
"``PCI_EXT_CAP_ID_VC``          Virtual Channel "
"``PCI_EXT_CAP_ID_DSN``         Device Serial Number "
"``PCI_EXT_CAP_ID_PWR``         Power Budgeting"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:616
msgid "Read and return the 8-byte Device Serial Number"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:618
msgid ""
"Looks up the PCI_EXT_CAP_ID_DSN and reads the 8 bytes of the Device Serial "
"Number."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:621
msgid "Returns the DSN, or zero if the capability does not exist."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:678 drivers/pci/pci.c:697
msgid "query a device's HyperTransport capabilities"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:681
msgid "``u8 pos``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:680
msgid "Position from which to continue searching"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:682 drivers/pci/pci.c:700
msgid "``int ht_cap``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:681 drivers/pci/pci.c:699
msgid "HyperTransport capability code"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:682
msgid ""
"To be used in conjunction with pci_find_ht_capability() to search for all "
"capabilities matching **ht_cap**. **pos** should always be a value returned "
"from pci_find_ht_capability()."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:686
msgid ""
"NB. To be 100% safe against broken PCI devices, the caller should take steps "
"to avoid an infinite loop."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:700
msgid ""
"Tell if a device supports a given HyperTransport capability. Returns an "
"address within the device's PCI configuration space or 0 in case the device "
"does not support the request capability. The address points to the PCI "
"capability, of type PCI_CAP_ID_HT, which has a HyperTransport capability "
"matching **ht_cap**."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:720
msgid "Find a vendor-specific extended capability"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:723 drivers/pci/pci.c:756
msgid "``u16 vendor``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:722
msgid "Vendor ID for which capability is defined"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:723
msgid "Vendor-specific capability ID"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:724
msgid ""
"If **dev** has Vendor ID **vendor**, search for a VSEC capability with VSEC "
"ID **cap**. If found, return the capability offset in config space; "
"otherwise return 0."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:753
msgid "Find DVSEC for vendor"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:755
msgid "Vendor ID to match for the DVSEC"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:757
msgid "``u16 dvsec``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:756
msgid "Designated Vendor-specific capability ID"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:757
msgid ""
"If DVSEC has Vendor ID **vendor** and DVSEC ID **dvsec** return the "
"capability offset in config space; otherwise return 0."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:785
msgid "return resource region of parent bus of given region"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1478
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:791
msgid "``const struct pci_dev *dev``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:787
msgid "PCI device structure contains resources to be searched"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:208
#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:248
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:789 drivers/pci/pci.c:831
#: drivers/pci/pci.c:4266
msgid "``struct resource *res``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:788
msgid "child resource record for which parent is sought"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:789
msgid ""
"For given resource region of given device, return the resource region of "
"parent bus the given region is contained in."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:828
msgid "Return matching PCI device resource"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:830
msgid "Resource to look for"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:831
msgid ""
"Goes over standard PCI resources (BARs) and checks if the given resource is "
"partially or fully contained in any of them. In that case the matching "
"resource is returned, ``NULL`` otherwise."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1231
msgid "Use platform to change device power state"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1232 drivers/pci/pci.c:1634
#: drivers/pci/pci.c:2410 drivers/pci/pci.c:2514
msgid "PCI device to handle."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1234 drivers/pci/pci.c:1636
#: drivers/pci/pci.c:2412 drivers/pci/pci.c:2653
msgid "``pci_power_t state``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1233
msgid "State to put the device into."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1633
msgid "Set the power state of a PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1635
msgid "PCI power state (D0, D1, D2, D3hot) to put the device into."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1636
msgid ""
"Transition a device to a new power state, using the platform firmware and/or "
"the device's PCI PM registers."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1639
msgid ""
"RETURN VALUE: -EINVAL if the requested state is invalid. -EIO if device does "
"not support PCI PM or its PM capabilities register has a wrong version, or "
"device doesn't support the requested state. 0 if the transition is to D1 or "
"D2 but D1 and D2 are not supported. 0 if device already is in the requested "
"state. 0 if the transition is to D3 but D3 is not supported. 0 if device's "
"power state has been successfully changed."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1788
msgid "save the PCI configuration space of a device before suspending"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1790 drivers/pci/pci.c:1905
#: drivers/pci/pci.c:1946 drivers/pci/pci.c:1986 drivers/pci/pci.c:2023
msgid "PCI device that we're dealing with"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1904
msgid "Restore the saved state of a PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1944
msgid "Allocate and return an opaque struct containing the device saved state."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1947
msgid "Return NULL if no state or error."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1985
msgid "Reload the provided save state into struct pci_dev."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1988
msgid "``struct pci_saved_state *state``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:1987
msgid "Saved state returned from pci_store_saved_state()"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2021
msgid ""
"Reload the save state pointed to by state, and free the memory allocated for "
"it."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2025
msgid "``struct pci_saved_state **state``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2024
msgid "Pointer to saved state returned from pci_store_saved_state()"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2108
msgid "Resume abandoned device"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2109
msgid "PCI device to be resumed"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:532
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2111
msgid "**NOTE**"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2111
msgid ""
"This function is a backend of pci_default_resume() and is not supposed to be "
"called by normal code, write proper resume handler and use it instead."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2180
msgid "Initialize a device for use with Memory space"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:363
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2181 drivers/pci/pci.c:2195
msgid "PCI device to be initialized"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2182
msgid ""
"Initialize device before it's used by a driver. Ask low-level code to enable "
"Memory resources. Wake up the device if it was suspended. Beware, this "
"function can fail."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2194
msgid "Initialize device before it's used by a driver."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2196
msgid ""
"Initialize device before it's used by a driver. Ask low-level code to enable "
"I/O and memory. Wake up the device if it was suspended. Beware, this "
"function can fail."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2200
msgid ""
"Note we don't actually enable the device many times if we call this function "
"repeatedly (we just increment the count)."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2271
msgid "Disable PCI device after use"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2272
msgid "PCI device to be disabled"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2273
msgid ""
"Signal to the system that the PCI device is not in use by the system "
"anymore.  This only involves disabling PCI bus-mastering, if active."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2276
msgid ""
"Note we don't actually disable the device until all callers of "
"pci_enable_device() have called pci_disable_device()."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2311
msgid "set reset state for device dev"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2312
msgid "the PCIe device reset"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2314
msgid "``enum pcie_reset_state state``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2313
msgid "Reset state to enter into"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2314
msgid "Sets the PCI reset state for the device."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2409
msgid "check the capability of PCI device to generate PME#"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2411
msgid "PCI state from which device will issue PME#."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2513
msgid "enable or disable PCI device's PME# function"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2516 drivers/pci/pci.c:2654
#: drivers/pci/pci.c:2671
msgid "``bool enable``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2515
msgid "'true' to enable PME# generation; 'false' to disable it."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2516
msgid ""
"The caller must verify that the device is capable of generating PME# before "
"calling this function with **enable** equal to 'true'."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2650
msgid "change wakeup settings for a PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2656
msgid "``struct pci_dev *pci_dev``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2651
msgid "Target device"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2652
msgid "PCI state from which device will issue wakeup events"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2653
msgid "Whether or not to enable event generation"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2654
msgid ""
"If **enable** is set, check device_may_wakeup() for the device before "
"calling __pci_enable_wake() for it."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2668
msgid "enable/disable device to wake up from D3_hot or D3_cold"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2669
msgid "PCI device to prepare"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2670
msgid "True to enable wake-up event generation; false to disable"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2671
msgid ""
"Many drivers want the device to wake up the system from D3_hot or D3_cold "
"and this function allows them to set that up cleanly - pci_enable_wake() "
"should not be called twice in a row to enable wake-up due to PCI PM vs ACPI "
"ordering constraints."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2676
msgid ""
"This function only returns error code if the device is not allowed to wake "
"up the system from sleep or it is not capable of generating PME# from both "
"D3_hot and D3_cold and the platform is unable to enable wake-up power for it."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2750
msgid "prepare PCI device for system-wide transition into a sleep state"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2752 drivers/pci/pci.c:2781
msgid "Device to handle."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2753
msgid ""
"Choose the power state appropriate for the device depending on whether it "
"can wake up the system and/or is power manageable by the platform (PCI_D3hot "
"is the default) and put the device into that state."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2779
msgid "turn PCI device on during system-wide transition into working state"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2782
msgid "Disable device's system wake-up capability and put it into D0."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2824
msgid "Check if device can generate run-time wake-up events."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2825
msgid "Device to check."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2826
msgid ""
"Return true if the device itself is capable of generating wake-up events "
"(through the platform or using the native PCIe PME) or if the device "
"supports PME and one of its upstream bridges can generate wake-up events."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2939
msgid "Choose the power state of a PCI device."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2940
msgid "Target PCI device."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2942
msgid "``pm_message_t state``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2941
msgid "Target state for the whole system."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:2942
msgid "Returns PCI power state suitable for **dev** and **state**."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3170
msgid "Enable D3cold for device"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3171 drivers/pci/pci.c:3188
msgid "PCI device to handle"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3172
msgid ""
"This function can be used in drivers to enable D3cold from the device they "
"handle.  It also updates upstream PCI bridge PM capabilities accordingly."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3187
msgid "Disable D3cold for device"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3189
msgid ""
"This function can be used in drivers to disable D3cold from the device they "
"handle.  It also updates upstream PCI bridge PM capabilities accordingly."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3786
msgid "get possible sizes for BAR"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:227 drivers/pci/tph.c:271
#: drivers/pci/tph.c:333 drivers/pci/tph.c:355 ../../../driver-api/pci/pci:4:
#: drivers/pci/pci.c:3787
msgid "PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:524
#: drivers/pci/devres.c:600 drivers/pci/devres.c:649 drivers/pci/devres.c:715
#: drivers/pci/devres.c:823 ../../../driver-api/pci/pci:4:
#: drivers/pci/pci.c:3789 drivers/pci/pci.c:3948 drivers/pci/pci.c:4021
#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:18 drivers/pci/iomap.c:64
#: drivers/pci/iomap.c:113 drivers/pci/iomap.c:133
msgid "``int bar``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3788
msgid "BAR to query"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3789
msgid ""
"Get the possible sizes of a resizable BAR as bitmask defined in the spec "
"(bit 0=1MB, bit 31=128TB). Returns 0 if BAR isn't resizable."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3861
msgid "enable AtomicOp requests to root port"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3864
msgid "``u32 cap_mask``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3863
msgid ""
"mask of desired AtomicOp sizes, including one or more of: "
"PCI_EXP_DEVCAP2_ATOMIC_COMP32 PCI_EXP_DEVCAP2_ATOMIC_COMP64 "
"PCI_EXP_DEVCAP2_ATOMIC_COMP128"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3867
msgid ""
"Return 0 if all upstream bridges support AtomicOp routing, egress blocking "
"is disabled on all upstream ports, and the root port supports the requested "
"completion capabilities (32-bit, 64-bit and/or 128-bit AtomicOp completion), "
"or negative otherwise."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3944
msgid "Release a PCI bar"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3945
msgid ""
"PCI device whose resources were previously reserved by pci_request_region()"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3947
msgid "BAR to release"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:3948
msgid ""
"Releases the PCI I/O and memory resources previously reserved by a "
"successful call to pci_request_region().  Call this function only after all "
"use of the PCI regions has ceased."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4018
msgid "Reserve PCI I/O and memory resource"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4019 drivers/pci/pci.c:4078
#: drivers/pci/pci.c:4124 drivers/pci/pci.c:4143
msgid "PCI device whose resources are to be reserved"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4020
msgid "BAR to be reserved"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:601
#: drivers/pci/devres.c:671 drivers/pci/devres.c:716 drivers/pci/devres.c:792
#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:193
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4022 drivers/pci/pci.c:4081
#: drivers/pci/pci.c:4096 drivers/pci/pci.c:4126 drivers/pci/pci.c:4145
#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:342
#: drivers/pci/hotplug/pci_hotplug_core.c:375
msgid "``const char *name``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4021
msgid "name of the driver requesting the resource"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:275
#: drivers/pci/devres.c:320 drivers/pci/devres.c:365 drivers/pci/devres.c:422
#: drivers/pci/devres.c:526 drivers/pci/devres.c:602 drivers/pci/devres.c:672
#: drivers/pci/devres.c:717 drivers/pci/devres.c:793 drivers/pci/devres.c:826
#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:49
#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:378
#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:130
#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1332
#: drivers/pci/iov.c:1371 ../../../driver-api/pci/pci:49: drivers/pci/tph.c:234
#: drivers/pci/tph.c:278 drivers/pci/tph.c:335 drivers/pci/tph.c:366
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4023 drivers/pci/pci.c:4082
#: drivers/pci/pci.c:4097 drivers/pci/pci.c:4146 drivers/pci/pci.c:4364
#: drivers/pci/pci.c:4400 drivers/pci/pci.c:4432 drivers/pci/pci.c:6144
msgid "**Return**"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:365
#: drivers/pci/devres.c:672 drivers/pci/devres.c:793
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4023 drivers/pci/pci.c:4082
#: drivers/pci/pci.c:4097 drivers/pci/pci.c:4146
msgid "0 on success, negative error code on failure."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4024
msgid ""
"Mark the PCI region associated with PCI device **pdev** BAR **bar** as being "
"reserved by owner **name**. Do not access any address inside the PCI regions "
"unless this call returns successfully."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4028 drivers/pci/pci.c:4130
#: drivers/pci/pci.c:4154
msgid ""
"Returns 0 on success, or ``EBUSY`` on error.  A warning message is also "
"printed on failure."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4039
msgid "Release selected PCI I/O and memory resources"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4040
msgid "PCI device whose resources were previously reserved"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4042 drivers/pci/pci.c:4080
#: drivers/pci/pci.c:4095
msgid "``int bars``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4041
msgid "Bitmask of BARs to be released"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4042
msgid ""
"Release selected PCI I/O and memory resources previously reserved. Call this "
"function only after all use of the PCI regions has ceased."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4077
msgid "Reserve selected PCI I/O and memory resources"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4079
msgid "Bitmask of BARs to be requested"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:670
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4080
msgid "Name of the driver requesting the resources"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4092
msgid "Request regions exclusively"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4093
msgid "PCI device to request regions from"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4094
msgid "bit mask of BARs to request"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:791
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4095 drivers/pci/pci.c:4125
#: drivers/pci/pci.c:4144
msgid "name of the driver requesting the resources"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4108
msgid "Release reserved PCI I/O and memory resources"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4109
msgid ""
"PCI device whose resources were previously reserved by pci_request_regions()"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4111
msgid ""
"Releases all PCI I/O and memory resources previously reserved by a "
"successful call to pci_request_regions().  Call this function only after all "
"use of the PCI regions has ceased."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4123 drivers/pci/pci.c:4142
msgid "Reserve PCI I/O and memory resources"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4126 drivers/pci/pci.c:4147
msgid ""
"Mark all PCI regions associated with PCI device **pdev** as being reserved "
"by owner **name**. Do not access any address inside the PCI regions unless "
"this call returns successfully."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4151
msgid ""
"pci_request_regions_exclusive() will mark the region so that /dev/mem and "
"the sysfs MMIO access will not be allowed."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4224
msgid "Remap the memory mapped I/O space"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:147
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4230
msgid "``const struct resource *res``"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:146
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4225
msgid "Resource describing the I/O space"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:148
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4227
msgid "``phys_addr_t phys_addr``"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:147
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4226
msgid "physical address of range to be mapped"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4227
msgid ""
"Remap the memory mapped I/O space described by the **res** and the CPU "
"physical address **phys_addr** into virtual address space.  Only "
"architectures that have memory mapped IO functions defined (and the "
"PCI_IOBASE value defined) should call this function."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4260
msgid "Unmap the memory mapped I/O space"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4261
msgid "resource to be unmapped"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4262
msgid ""
"Unmap the CPU virtual address **res** from virtual address space.  Only "
"architectures that have memory mapped IO functions defined (and the "
"PCI_IOBASE value defined) should call this function."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4334
msgid "enables bus-mastering for device dev"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4335
msgid "the PCI device to enable"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4336
msgid ""
"Enables bus-mastering on the device and calls pcibios_set_master() to do the "
"needed arch specific settings."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4348
msgid "disables bus-mastering for device dev"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4349 drivers/pci/pci.c:4447
msgid "the PCI device to disable"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4358
msgid "ensure the CACHE_LINE_SIZE register is programmed"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4359
msgid "the PCI device for which MWI is to be enabled"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4360
msgid ""
"Helper function for pci_set_mwi. Originally copied from drivers/net/acenic."
"c. Copyright 1998-2001 by Jes Sorensen, <jes**trained**-monkey.org>."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:276
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4365 drivers/pci/pci.c:4401
#: drivers/pci/pci.c:4433
msgid "An appropriate -ERRNO error value on error, or zero for success."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4396 drivers/pci/pci.c:4427
msgid "enables memory-write-invalidate PCI transaction"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:272
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4397 drivers/pci/pci.c:4428
msgid "the PCI device for which MWI is enabled"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4398
msgid "Enables the Memory-Write-Invalidate transaction in ``PCI_COMMAND``."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4429
msgid ""
"Enables the Memory-Write-Invalidate transaction in ``PCI_COMMAND``. Callers "
"are not required to check the return value."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4446
msgid "disables Memory-Write-Invalidate for device dev"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4448
msgid "Disables PCI Memory-Write-Invalidate transaction on the device"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4483
msgid "enables/disables PCI INTx for device dev"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:317
#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:237 drivers/pci/irq.c:250
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4484 drivers/pci/pci.c:4509
msgid "the PCI device to operate on"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:319
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4486
msgid "``int enable``"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:318
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4485
msgid "boolean: whether to enable or disable PCI INTx"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4486
msgid "Enables/disables PCI INTx for device **pdev**"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4508
msgid "wait for pending transaction"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4510
msgid "Return 0 if transaction is pending 1 otherwise."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4524 drivers/pci/pci.c:4552
msgid "initiate a PCIe function level reset"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4525 drivers/pci/pci.c:4553
msgid "device to reset"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4526
msgid ""
"Initiate a function level reset unconditionally on **dev** without checking "
"any flags and DEVCAP"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4555
msgid "``bool probe``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4554
msgid "if true, return 0 if device can be reset this way"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4555
msgid "Initiate a function level reset on **dev**."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4982
msgid "Reset the secondary bus on a PCI bridge."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4983
msgid "Bridge device"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:4984
msgid ""
"Use the bridge control register to assert reset on the secondary bus. "
"Devices on the secondary bus are left in power-on state."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5223
msgid "reset a PCI device function while holding the **dev** mutex lock."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5225 drivers/pci/pci.c:5311
#: drivers/pci/pci.c:5358 drivers/pci/pci.c:5392
msgid "PCI device to reset"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5226 drivers/pci/pci.c:5312
#: drivers/pci/pci.c:5359
msgid ""
"Some devices allow an individual function to be reset without affecting "
"other functions in the same device.  The PCI device must be responsive to "
"PCI config space in order to use this function."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5230
msgid ""
"The device function is presumed to be unused and the caller is holding the "
"device mutex lock when this function is called."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5233
msgid ""
"Resetting the device will make the contents of PCI configuration space "
"random, so any caller of this must be prepared to reinitialise the device "
"including MSI, bus mastering, BARs, decoding IO and memory spaces, etc."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5238 drivers/pci/pci.c:5321
#: drivers/pci/pci.c:5369
msgid ""
"Returns 0 if the device function was successfully reset or negative if the "
"device doesn't support resetting a single function."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5310 drivers/pci/pci.c:5357
#: drivers/pci/pci.c:5391
msgid "quiesce and reset a PCI device function"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5316
msgid ""
"This function does not just reset the PCI portion of a device, but clears "
"all the state associated with the device.  This function differs from "
"__pci_reset_function_locked() in that it saves and restores device state "
"over the reset and takes the PCI device lock."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5363
msgid ""
"This function does not just reset the PCI portion of a device, but clears "
"all the state associated with the device.  This function differs from "
"__pci_reset_function_locked() in that it saves and restores device state "
"over the reset.  It also differs from pci_reset_function() in that it "
"requires the PCI device lock to be held."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5393
msgid "Same as above, except return -EAGAIN if unable to lock device."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5661
msgid "probe whether a PCI slot can be reset"
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:315
#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5667
msgid "``struct pci_slot *slot``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5662
msgid "PCI slot to probe"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5663
msgid ""
"Return 0 if slot can be reset, negative if a slot reset is not supported."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5764
msgid "probe whether a PCI bus can be reset"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5765
msgid "PCI bus to probe"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5766
msgid "Return 0 if bus can be reset, negative if a bus reset is not supported."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5802
msgid "Try to reset a PCI bus"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5803
msgid "top level PCI device to reset via slot/bus"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5804
msgid "Same as above except return -EAGAIN if the bus cannot be locked"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5815
msgid "get PCI-X maximum designed memory read byte count"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5817
msgid ""
"Returns mmrbc: maximum designed memory read count in bytes or appropriate "
"error value."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5838
msgid "get PCI-X maximum memory read byte count"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5840
msgid ""
"Returns mmrbc: maximum memory read count in bytes or appropriate error value."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5861
msgid "set PCI-X maximum memory read byte count"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5864
msgid "``int mmrbc``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5863
msgid ""
"maximum memory read count in bytes valid values are 512, 1024, 2048, 4096"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5865
msgid ""
"If possible sets maximum memory read byte count, some bridges have errata "
"that prevent this."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5908
msgid "get PCI Express read request size"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5910
msgid ""
"Returns maximum memory read request in bytes or appropriate error value."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5924
msgid "set PCI Express maximum memory read request"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5927
msgid "``int rq``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5926
msgid ""
"maximum memory read count in bytes valid values are 128, 256, 512, 1024, "
"2048, 4096"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5928
msgid "If possible sets maximum memory read request in bytes"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5971
msgid "get PCI Express maximum payload size"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5973
msgid "Returns maximum payload size in bytes"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5987
msgid "set PCI Express maximum payload size"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5990
msgid "``int mps``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5989
msgid ""
"maximum payload size in bytes valid values are 128, 256, 512, 1024, 2048, "
"4096"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:5991
msgid "If possible sets maximum payload size"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6033
msgid ""
"determine minimum link settings of a PCIe device and its bandwidth limitation"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6037
msgid "``struct pci_dev **limiting_dev``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6036
msgid "storage for device causing the bandwidth limitation"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6038
msgid "``enum pci_bus_speed *speed``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6037
msgid "storage for speed of limiting device"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6039
msgid "``enum pcie_link_width *width``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6038
msgid "storage for width of limiting device"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6039
msgid ""
"Walk up the PCI device chain and find the point where the minimum bandwidth "
"is available.  Return the bandwidth available there and (if limiting_dev, "
"speed, and width pointers are supplied) information about that point.  The "
"bandwidth returned is in Mb/s, i.e., megabits/second of raw bandwidth."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6140
msgid "query for the PCI device's link speed capability"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6142
msgid "Query the PCI device speed capability."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6145
msgid "the maximum link speed supported by the device."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6154
msgid "query for the PCI device's link width capability"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6156
msgid ""
"Query the PCI device width capability.  Return the maximum link width "
"supported by the device."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6233
msgid "Report the PCI device's link speed and width"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6235
msgid "Report the available bandwidth at the device."
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6245
msgid "Make BAR mask from the type of resource"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6246
msgid "the PCI device for which BAR mask is made"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6248
msgid "``unsigned long flags``"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6247
msgid "resource type mask to be selected"
msgstr ""

#: ../../../driver-api/pci/pci:4: drivers/pci/pci.c:6248
msgid "This helper routine makes bar mask from the type of resource."
msgstr ""

#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:15
#: drivers/pci/iomap.c:110
msgid "create a virtual mapping cookie for a PCI BAR"
msgstr ""

#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:16 drivers/pci/iomap.c:62
#: drivers/pci/iomap.c:111 drivers/pci/iomap.c:131
msgid "PCI device that owns the BAR"
msgstr ""

#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:17 drivers/pci/iomap.c:63
#: drivers/pci/iomap.c:112 drivers/pci/iomap.c:132
msgid "BAR number"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:824
#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:19 drivers/pci/iomap.c:65
msgid "``unsigned long offset``"
msgstr ""

#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:18 drivers/pci/iomap.c:64
msgid "map memory at the given offset in BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:525
#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:20 drivers/pci/iomap.c:66
#: drivers/pci/iomap.c:114 drivers/pci/iomap.c:134
msgid "``unsigned long maxlen``"
msgstr ""

#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:19 drivers/pci/iomap.c:65
msgid "max length of the memory to map"
msgstr ""

#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:20
#: drivers/pci/iomap.c:114
msgid ""
"Using this function you will get a __iomem address to your device BAR. You "
"can access it using ioread*() and iowrite*(). These functions hide the "
"details if this is a MMIO or PIO address space and will just do what you "
"expect from them in the correct way."
msgstr ""

#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:25 drivers/pci/iomap.c:72
msgid ""
"**maxlen** specifies the maximum length to map. If you want to get access to "
"the complete BAR from offset to the end, pass ``0`` here."
msgstr ""

#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:61
#: drivers/pci/iomap.c:130
msgid "create a virtual WC mapping cookie for a PCI BAR"
msgstr ""

#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:66
#: drivers/pci/iomap.c:134
msgid ""
"Using this function you will get a __iomem address to your device BAR. You "
"can access it using ioread*() and iowrite*(). These functions hide the "
"details if this is a MMIO or PIO address space and will just do what you "
"expect from them in the correct way. When possible write combining is used."
msgstr ""

#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:113
#: drivers/pci/iomap.c:133
msgid "length of the memory to map"
msgstr ""

#: ../../../driver-api/pci/pci:7: drivers/pci/iomap.c:119
#: drivers/pci/iomap.c:140
msgid ""
"**maxlen** specifies the maximum length to map. If you want to get access to "
"the complete BAR without checking for its length first, pass ``0`` here."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:144
msgid "Managed pci_remap_iospace()"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:150
#: drivers/pci/devres.c:181 drivers/pci/devres.c:211
msgid "``struct device *dev``"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:145
#: drivers/pci/devres.c:176
msgid "Generic device to remap IO address for"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:148
msgid ""
"Managed pci_remap_iospace().  Map is automatically unmapped on driver detach."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:175
msgid "Managed pci_remap_cfgspace()"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:178
msgid "``resource_size_t offset``"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:177
msgid "Resource address to map"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:179
#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:249
msgid "``resource_size_t size``"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:178
msgid "Size of map"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:179
msgid ""
"Managed pci_remap_cfgspace().  Map is automatically unmapped on driver "
"detach."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:205
msgid "check, request region and ioremap cfg resource"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:206
msgid "generic device to handle the resource for"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:207
msgid "configuration space resource to be handled"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:208
msgid ""
"Checks that a resource is a valid memory region, requests the memory region "
"and ioremaps with pci_remap_cfgspace() API that ensures the proper PCI "
"configuration space memory attributes are guaranteed."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:212
msgid "All operations are managed and will be undone on driver detach."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:214
msgid ""
"Returns a pointer to the remapped memory or an IOMEM_ERR_PTR() encoded error "
"code on failure. Usage example::"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:271
msgid "a device-managed pci_set_mwi()"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:273
msgid "Managed pci_set_mwi()."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:316
msgid "managed pci_intx()"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:320
msgid "0 on success, -ENOMEM on error."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:321
msgid ""
"Enable/disable PCI INTx for device **pdev**. Restore the original state on "
"driver detach."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:362
msgid "Managed pci_enable_device()"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:366
msgid ""
"Managed pci_enable_device(). Device will automatically be disabled on driver "
"detach."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:396
msgid "Pin managed PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:397
msgid "PCI device to pin"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:398
msgid ""
"Pin managed PCI device **pdev**. Pinned device won't be disabled on driver "
"detach. **pdev** must have been enabled with pcim_enable_device()."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:419
msgid "access iomap allocation table (DEPRECATED)"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:420
msgid "PCI device to access iomap table for"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:422
msgid "Const pointer to array of __iomem pointers on success, NULL on failure."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:424
msgid ""
"Access iomap allocation table for **dev**.  If iomap table doesn't exist and "
"**pdev** is managed, it will be allocated.  All iomaps recorded in the iomap "
"table are automatically unmapped on driver detach."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:429
msgid ""
"This function might sleep when the table is first allocated but can be "
"safely called without context and guaranteed to succeed once allocated."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:433
msgid ""
"This function is DEPRECATED. Do not use it in new code. Instead, obtain a "
"mapping's address directly from one of the pcim_* mapping functions. For"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:436
msgid "**example**"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:436
msgid "void __iomem \\*mappy = pcim_iomap(pdev, bar, length);"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:521
msgid "Managed pcim_iomap()"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:522
msgid "PCI device to iomap for"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:523
msgid "BAR to iomap"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:524
msgid "Maximum length of iomap"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:526
msgid "__iomem pointer on success, NULL on failure."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:527
msgid ""
"Managed pci_iomap(). Map is automatically unmapped on driver detach. If "
"desired, unmap manually only with pcim_iounmap()."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:530
msgid "This SHOULD only be used once per BAR."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:533
msgid ""
"Contrary to the other pcim_* functions, this function does not return an "
"IOMEM_ERR_PTR() on failure, but a simple NULL. This is done for backwards "
"compatibility."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:571
msgid "Managed pci_iounmap()"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:572
msgid "PCI device to iounmap for"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:574
msgid "``void __iomem *addr``"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:573
msgid "Address to unmap"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:574
msgid ""
"Managed pci_iounmap(). **addr** must have been mapped using a pcim_* mapping "
"function."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:597
msgid "Request and iomap a PCI BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:598
#: drivers/pci/devres.c:668 drivers/pci/devres.c:790 drivers/pci/devres.c:821
msgid "PCI device to map IO resources for"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:599
msgid "Index of a BAR to map"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:600
#: drivers/pci/devres.c:715
msgid "Name of the driver requesting the resource"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:602
#: drivers/pci/devres.c:826
msgid "__iomem pointer on success, an IOMEM_ERR_PTR on failure."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:603
msgid ""
"Mapping and region will get automatically released on driver detach. If "
"desired, release manually only with pcim_iounmap_region()."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:646
msgid "Unmap and release a PCI BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:647
#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:20 drivers/pci/irq.c:64
msgid "PCI device to operate on"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:648
msgid "Index of BAR to unmap and release"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:649
msgid ""
"Unmap a BAR and release its region manually. Only pass BARs that were "
"previously mapped by pcim_iomap_region()."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:667
msgid "Request and iomap PCI BARs (DEPRECATED)"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:670
msgid "``int mask``"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:669
msgid "Mask of BARs to request and iomap"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:673
msgid "Request and iomap regions specified by **mask**."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:675
msgid ""
"This function is DEPRECATED. Do not use it in new code. Use "
"pcim_iomap_region() instead."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:712
msgid "Request a PCI BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:713
msgid "PCI device to request region for"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:714
msgid "Index of BAR to request"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:717
msgid "0 on success, a negative error code on failure."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:718
msgid "Request region specified by **bar**."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:720
msgid ""
"The region will automatically be released on driver detach. If desired, "
"release manually only with pcim_release_region()."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:789
msgid "Request all regions"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:794
msgid ""
"Requested regions will automatically be released at driver detach. If "
"desired, release individual regions with pcim_release_region() or all of "
"them at once with pcim_release_all_regions()."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:820
msgid "Create a ranged __iomap mapping within a PCI BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:822
msgid "Index of the BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:823
msgid "Offset from the begin of the BAR"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:825
msgid "``unsigned long len``"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:824
msgid "Length in bytes for the mapping"
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:827
msgid ""
"Creates a new IO-Mapping within the specified **bar**, ranging from "
"**offset** to **offset** + **len**."
msgstr ""

#: ../../../driver-api/pci/pci:10: drivers/pci/devres.c:830
msgid ""
"The mapping will automatically get unmapped on driver detach. If desired, "
"release manually only with pcim_iounmap()."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:33
msgid "add a new PCI device ID to this driver and re-probe devices"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:39
#: drivers/pci/pci-driver.c:1427 drivers/pci/pci-driver.c:1457
msgid "``struct pci_driver *drv``"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:34
msgid "target pci driver"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:36
#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:292
#: drivers/pci/search.c:323
msgid "``unsigned int vendor``"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:35
msgid "PCI vendor ID"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:37
#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:289
#: drivers/pci/search.c:320
msgid "``unsigned int device``"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:36
msgid "PCI device ID"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:38
msgid "``unsigned int subvendor``"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:37
msgid "PCI subvendor ID"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:39
msgid "``unsigned int subdevice``"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:38
msgid "PCI subdevice ID"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:40
#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:344
#: drivers/pci/search.c:373
msgid "``unsigned int class``"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:39
msgid "PCI class"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:41
msgid "``unsigned int class_mask``"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:40
msgid "PCI class mask"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:42
msgid "``unsigned long driver_data``"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:41
msgid "private driver data"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:42
msgid ""
"Adds a new dynamic pci device ID to this driver and causes the driver to "
"probe for all devices again.  **drv** must have been registered prior to "
"calling this function."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:46
msgid "**Context**"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:47
msgid "Does GFP_KERNEL allocation."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:50
msgid "0 on success, -errno on failure."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:94
msgid "See if a PCI device matches a given pci_id table"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:100
#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:404
msgid "``const struct pci_device_id *ids``"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:95
msgid "array of PCI device ID structures to search in"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:96
msgid "the PCI device structure to match against."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:97
msgid ""
"Used by a driver to check whether a PCI device is in its list of supported "
"devices.  Returns the matching pci_device_id structure or ``NULL`` if there "
"is no match."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:101
msgid ""
"Deprecated; don't use this as it will not catch any dynamic IDs that a "
"driver might want to check for."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1421
msgid "register a new pci driver"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1422
msgid "the driver structure to register"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1424
#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:343
#: drivers/pci/hotplug/pci_hotplug_core.c:376
msgid "``struct module *owner``"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1423
msgid "owner module of drv"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1425
#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:344
#: drivers/pci/hotplug/pci_hotplug_core.c:377
msgid "``const char *mod_name``"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1424
msgid "module name string"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1425
msgid ""
"Adds the driver structure to the list of registered drivers. Returns a "
"negative value on error, otherwise 0. If no error occurred, the driver "
"remains registered even if no device was claimed during registration."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1451
msgid "unregister a pci driver"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1452
msgid "the driver structure to unregister"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1453
msgid ""
"Deletes the driver structure from the list of registered PCI drivers, gives "
"it a chance to clean up by calling its remove() function for each device it "
"was responsible for, and marks those devices as driverless."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1472
msgid "get the pci_driver of a device"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1473
msgid "the device to query"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1474
msgid ""
"Returns the appropriate pci_driver structure or ``NULL`` if there is no "
"registered driver for the device."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1520
msgid "increments the reference count of the pci device structure"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1521
msgid "the device being referenced"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1522
msgid "Each live reference to a device should be refcounted."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1524
msgid ""
"Drivers for PCI devices should normally record such references in their "
"probe() methods, when they bind to a device, and release them by calling "
"pci_dev_put(), in their disconnect() methods."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1528
msgid ""
"A pointer to the device with the incremented reference counter is returned."
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1540
msgid "release a use of the pci device structure"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1541
msgid "device that's been disconnected"
msgstr ""

#: ../../../driver-api/pci/pci:13: drivers/pci/pci-driver.c:1542
msgid ""
"Must be called when a user of a device is finished with it.  When the last "
"user of the device calls this function, the memory of the device is freed."
msgstr ""

#: ../../../driver-api/pci/pci:16: drivers/pci/remove.c:128
msgid "remove a PCI device and any children"
msgstr ""

#: ../../../driver-api/pci/pci:16: drivers/pci/remove.c:129
msgid "the device to remove"
msgstr ""

#: ../../../driver-api/pci/pci:16: drivers/pci/remove.c:130
msgid ""
"Remove a PCI device from the device lists, informing the drivers that the "
"device has been removed.  We also remove any subordinate buses and children "
"in a depth-first manner."
msgstr ""

#: ../../../driver-api/pci/pci:16: drivers/pci/remove.c:134
msgid ""
"For each device we remove, delete the device structure from the device "
"lists, remove the /proc entry, and notify userspace (/sbin/hotplug)."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:133
msgid "locate PCI bus from a given domain and bus number"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:139
#: drivers/pci/search.c:220
msgid "``int domain``"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:134
msgid "number of PCI domain to search"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:136
msgid "``int busnr``"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:135
msgid "number of desired PCI bus"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:136
msgid ""
"Given a PCI bus number and domain number, the desired PCI bus is located in "
"the global list of PCI buses.  If the bus is found, a pointer to its data "
"structure is returned.  If no bus is found, ``NULL`` is returned."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:158
msgid "begin or continue searching for a PCI bus"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:164
msgid "``const struct pci_bus *from``"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:159
msgid "Previous PCI bus found, or ``NULL`` for new search."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:160
msgid ""
"Iterates through the list of known PCI buses.  A new search is initiated by "
"passing ``NULL`` as the **from** argument.  Otherwise if **from** is not "
"``NULL``, searches continue from next device on the global list."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:181
msgid "locate PCI device for a given PCI slot"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:182
#: drivers/pci/search.c:216
msgid "PCI bus on which desired PCI device resides"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:183
#: drivers/pci/search.c:217
msgid ""
"encodes number of PCI slot in which the desired PCI device resides and the "
"logical device number within that slot in case of multi-function devices."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:186
msgid ""
"Given a PCI bus and slot/function number, the desired PCI device is located "
"in the list of PCI devices. If the device is found, its reference count is "
"increased and this function returns a pointer to its data structure.  The "
"caller must decrement the reference count by calling pci_dev_put(). If no "
"device is found, ``NULL`` is returned."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:214
msgid "locate PCI device for a given PCI domain (segment), bus, and slot"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:215
msgid "PCI domain/segment on which the PCI device resides."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:217
msgid "``unsigned int bus``"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:220
msgid ""
"Given a PCI domain, bus, and slot/function number, the desired PCI device is "
"located in the list of PCI devices. If the device is found, its reference "
"count is increased and this function returns a pointer to its data "
"structure.  The caller must decrement the reference count by calling "
"pci_dev_put().  If no device is found, ``NULL`` is returned."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:286
msgid ""
"begin or continue searching for a PCI device by vendor/subvendor/device/"
"subdevice id"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:287
#: drivers/pci/search.c:318
msgid "PCI vendor id to match, or ``PCI_ANY_ID`` to match all vendor ids"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:288
#: drivers/pci/search.c:319
msgid "PCI device id to match, or ``PCI_ANY_ID`` to match all device ids"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:290
msgid "``unsigned int ss_vendor``"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:289
msgid ""
"PCI subsystem vendor id to match, or ``PCI_ANY_ID`` to match all vendor ids"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:291
msgid "``unsigned int ss_device``"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:290
msgid ""
"PCI subsystem device id to match, or ``PCI_ANY_ID`` to match all device ids"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:292
#: drivers/pci/search.c:321 drivers/pci/search.c:341 drivers/pci/search.c:370
msgid "``struct pci_dev *from``"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:291
#: drivers/pci/search.c:320 drivers/pci/search.c:340 drivers/pci/search.c:369
msgid "Previous PCI device found in search, or ``NULL`` for new search."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:292
msgid ""
"Iterates through the list of known PCI devices.  If a PCI device is found "
"with a matching **vendor**, **device**, **ss_vendor** and **ss_device**, a "
"pointer to its device structure is returned, and the reference count to the "
"device is incremented.  Otherwise, ``NULL`` is returned.  A new search is "
"initiated by passing ``NULL`` as the **from** argument.  Otherwise if "
"**from** is not ``NULL``, searches continue from next device on the global "
"list. The reference count for **from** is always decremented if it is not "
"``NULL``."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:317
msgid "begin or continue searching for a PCI device by vendor/device id"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:321
msgid ""
"Iterates through the list of known PCI devices.  If a PCI device is found "
"with a matching **vendor** and **device**, the reference count to the device "
"is incremented and a pointer to its device structure is returned. Otherwise, "
"``NULL`` is returned.  A new search is initiated by passing ``NULL`` as the "
"**from** argument.  Otherwise if **from** is not ``NULL``, searches continue "
"from next device on the global list.  The reference count for **from** is "
"always decremented if it is not ``NULL``."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:338
msgid "begin or continue searching for a PCI device by class"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:339
msgid "search for a PCI device with this class designation"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:341
msgid ""
"Iterates through the list of known PCI devices.  If a PCI device is found "
"with a matching **class**, the reference count to the device is incremented "
"and a pointer to its device structure is returned. Otherwise, ``NULL`` is "
"returned. A new search is initiated by passing ``NULL`` as the **from** "
"argument. Otherwise if **from** is not ``NULL``, searches continue from next "
"device on the global list.  The reference count for **from** is always "
"decremented if it is not ``NULL``."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:367
msgid "searching for a PCI device by matching against the base class code only"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:368
msgid "search for a PCI device with this base class code"
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:370
msgid ""
"Iterates through the list of known PCI devices. If a PCI device is found "
"with a matching base class code, the reference count to the device is "
"incremented. See pci_match_one_device() to figure out how does this works. A "
"new search is initiated by passing ``NULL`` as the **from** argument. "
"Otherwise if **from** is not ``NULL``, searches continue from next device on "
"the global list. The reference count for **from** is always decremented if "
"it is not ``NULL``."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:379
msgid "A pointer to a matched PCI device, ``NULL`` Otherwise."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:398
msgid "Returns 1 if device matching the device list is present, 0 if not."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:399
msgid ""
"A pointer to a null terminated list of struct pci_device_id structures that "
"describe the type of PCI device the caller is trying to find."
msgstr ""

#: ../../../driver-api/pci/pci:19: drivers/pci/search.c:401
msgid ""
"Obvious fact: You do not have a reference to any device that might be found "
"by this function, so if that device is removed from the system right after "
"this function is finished, the value will be stale.  Use this function to "
"find devices that are usually built into a system, or for a general hint as "
"to if another device happens to be present at this specific moment in time."
msgstr ""

#: ../../../driver-api/pci/pci:22: drivers/pci/msi/msi.c:131
msgid "Generic IRQ chip callback to mask PCI/MSI interrupts"
msgstr ""

#: ../../../driver-api/pci/pci:22: drivers/pci/msi/msi.c:137
#: drivers/pci/msi/msi.c:149
msgid "``struct irq_data *data``"
msgstr ""

#: ../../../driver-api/pci/pci:22: drivers/pci/msi/msi.c:132
#: drivers/pci/msi/msi.c:144
msgid "pointer to irqdata associated to that interrupt"
msgstr ""

#: ../../../driver-api/pci/pci:22: drivers/pci/msi/msi.c:143
msgid "Generic IRQ chip callback to unmask PCI/MSI interrupts"
msgstr ""

#: ../../../driver-api/pci/pci:22: drivers/pci/msi/msi.c:473
msgid "Return the number of MSI vectors a device can send"
msgstr ""

#: ../../../driver-api/pci/pci:22: drivers/pci/msi/msi.c:474
msgid "device to report about"
msgstr ""

#: ../../../driver-api/pci/pci:22: drivers/pci/msi/msi.c:475
msgid ""
"This function returns the number of MSI vectors a device requested via "
"Multiple Message Capable register. It returns a negative errno if the device "
"is not capable sending MSI interrupts. Otherwise, the call succeeds and "
"returns a power of two, up to a maximum of 2^5 (32), according to the MSI "
"specification."
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:245
msgid "allocate a resource from a parent bus"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:246
msgid "PCI bus"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:247
msgid "resource to allocate"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:248
msgid "size of resource to allocate"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:250
msgid "``resource_size_t align``"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:249
msgid "alignment of resource to allocate"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:251
msgid "``resource_size_t min``"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:250
msgid "minimum /proc/iomem address to allocate"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:252
msgid "``unsigned long type_mask``"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:251
msgid "IORESOURCE_* type flags"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:253
msgid "``resource_alignf alignf``"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:252
msgid "resource alignment function"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:254
msgid "``void *alignf_data``"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:253
msgid "data argument for resource alignment function"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:254
msgid ""
"Given the PCI bus a device resides on, the size, minimum address, alignment "
"and type, try to find an acceptable resource allocation for a specific "
"device resource."
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:335
msgid "start driver for a single device"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:336
msgid "device to add"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:337
msgid "This adds add sysfs entries and start device drivers"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:381
msgid "start driver for PCI devices"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:387
msgid "``const struct pci_bus *bus``"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:382
msgid "bus to check for new devices"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:383
msgid "Start driver for PCI devices and add some sysfs entries."
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:429
msgid "walk devices on/under bus, calling callback."
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:435
msgid "``struct pci_bus *top``"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:430
msgid "bus whose devices should be walked"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:432
msgid "``int (*cb)(struct pci_dev *, void *)``"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:431
msgid "callback to be called for each device found"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:433
msgid "``void *userdata``"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:432
msgid "arbitrary pointer to be passed to callback"
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:433
msgid ""
"Walk the given bus, including any bridged devices on buses under this bus.  "
"Call the provided callback on each device found."
msgstr ""

#: ../../../driver-api/pci/pci:25: drivers/pci/bus.c:437
msgid ""
"We check the return of **cb** each time. If it returns anything other than "
"0, we break out."
msgstr ""

#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:187
msgid "Set raw operations of pci bus"
msgstr ""

#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:188
msgid "pci bus struct"
msgstr ""

#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:190
msgid "``struct pci_ops *ops``"
msgstr ""

#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:189
msgid "new raw operations"
msgstr ""

#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:190
msgid "Return previous raw operations"
msgstr ""

#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:281
msgid "Lock PCI config reads/writes"
msgstr ""

#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:282
#: drivers/pci/access.c:302 drivers/pci/access.c:326
msgid "pci device struct"
msgstr ""

#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:283
msgid ""
"When access is locked, any userspace reads or writes to config space and "
"concurrent lock requests will sleep until access is allowed via "
"pci_cfg_access_unlock() again."
msgstr ""

#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:301
msgid "try to lock PCI config reads/writes"
msgstr ""

#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:303
msgid ""
"Same as pci_cfg_access_lock, but will return 0 if access is already locked, "
"1 otherwise. This function can be used from atomic contexts."
msgstr ""

#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:325
msgid "Unlock PCI config reads/writes"
msgstr ""

#: ../../../driver-api/pci/pci:28: drivers/pci/access.c:327
msgid "This function allows PCI config accesses to resume."
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:19
msgid "allocate an interrupt line for a PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:22 drivers/pci/irq.c:66
msgid "``unsigned int nr``"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:21 drivers/pci/irq.c:65
msgid "device-relative interrupt vector index (0-based)."
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:23
msgid "``irq_handler_t handler``"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:22
msgid ""
"Function to be called when the IRQ occurs. Primary handler for threaded "
"interrupts. If NULL and thread_fn != NULL the default primary handler is "
"installed."
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:27
msgid "``irq_handler_t thread_fn``"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:26
msgid ""
"Function called from the IRQ handler thread If NULL, no IRQ thread is created"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:29 drivers/pci/irq.c:67
msgid "``void *dev_id``"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:28
msgid "Cookie passed back to the handler function"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:30
msgid "``const char *fmt``"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:29
msgid "Printf-like format string naming the handler"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:31
msgid "``...``"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:1
msgid "variable arguments"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:30
msgid ""
"This call allocates interrupt resources and enables the interrupt line and "
"IRQ handling. From the point this call is made **handler** and **thread_fn** "
"may be invoked.  All interrupts requested using this function might be "
"shared."
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:34
msgid "**dev_id** must not be NULL and must be globally unique."
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:63
msgid "free an interrupt allocated with pci_request_irq"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:66
msgid "Device identity to free"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:67
msgid ""
"Remove an interrupt handler. The handler is removed and if the interrupt "
"line is no longer in use by any driver it is disabled.  The caller must "
"ensure the interrupt is disabled on the device before calling this function. "
"The function does not return until any executing interrupts for this IRQ "
"have completed."
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:73
msgid "This function must not be called from interrupt context."
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:122
msgid "swizzle INTx all the way to root bridge"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:125
msgid "``u8 *pinp``"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:124
msgid "pointer to the INTx pin value (1=INTA, 2=INTB, 3=INTD, 4=INTD)"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:125
msgid ""
"Perform INTx swizzling for a device.  This traverses through all PCI-to-PCI "
"bridges all the way up to a PCI root bus."
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:236
msgid "mask INTx on pending interrupt"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:238
msgid ""
"Check if the device dev has its INTx line asserted, mask it and return true "
"in that case. False is returned if no interrupt was pending."
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:249
msgid "unmask INTx if no interrupt is pending"
msgstr ""

#: ../../../driver-api/pci/pci:31: drivers/pci/irq.c:251
msgid ""
"Check if the device dev has its INTx line asserted, unmask it if not and "
"return true. False is returned and the mask remains active if there was "
"still an interrupt pending."
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:2269
msgid "Probe for PCIe relaxed ordering enable"
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:2271
msgid "Returns true if the device has enabled relaxed ordering attribute."
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:2817
msgid "Scan a PCI slot on a bus for devices"
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:2818
#: drivers/pci/probe.c:3449
msgid "PCI bus to scan"
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:2820
msgid "``int devfn``"
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:2819
msgid "slot number to scan (must have zero function)"
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:2820
msgid ""
"Scan a PCI slot on the specified PCI bus for devices, adding discovered "
"devices to the **bus->devices** list.  New devices will not have is_added "
"set."
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:2824
msgid "Returns the number of new devices found."
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:3161
msgid "Scan devices below a bus"
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:3162
msgid "Bus to scan for devices"
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:3163
msgid ""
"Scans devices below **bus** including subordinate buses. Returns new "
"subordinate number including all the found devices."
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:3448
msgid "Scan a PCI bus for devices"
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:3450
msgid ""
"Scan a PCI bus and child buses for new devices, add them, and enable them."
msgstr ""

#: ../../../driver-api/pci/pci:34: drivers/pci/probe.c:3453
msgid "Returns the max number of subordinate bus discovered."
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:189
msgid "create or increment refcount for physical PCI slot"
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:195
msgid "``struct pci_bus *parent``"
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:190
msgid "struct pci_bus of parent bridge"
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:192
msgid "``int slot_nr``"
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:191
msgid "PCI_SLOT(pci_dev->devfn) or -1 for placeholder"
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:192
msgid "user visible string presented in /sys/bus/pci/slots/<name>"
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:194
msgid "``struct hotplug_slot *hotplug``"
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:193
msgid "set if caller is hotplug driver, NULL otherwise"
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:194
msgid ""
"PCI slots have first class attributes such as address, speed, width, and a :"
"c:type:`struct pci_slot <pci_slot>` is used to manage them. This interface "
"will either return a new :c:type:`struct pci_slot <pci_slot>` to the caller, "
"or if the pci_slot already exists, its refcount will be incremented."
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:199
msgid "Slots are uniquely identified by a **pci_bus**, **slot_nr** tuple."
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:201
msgid ""
"There are known platforms with broken firmware that assign the same name to "
"multiple slots. Workaround these broken platforms by renaming the slots on "
"behalf of the caller. If firmware assigns name N to multiple slots:"
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:206
msgid ""
"The first slot is assigned N The second slot is assigned N-1 The third slot "
"is assigned N-2 etc."
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:211
msgid ""
"Placeholder slots: In most cases, **pci_bus**, **slot_nr** will be "
"sufficient to uniquely identify a slot. There is one notable exception - "
"pSeries (rpaphp), where the **slot_nr** cannot be determined until a device "
"is actually inserted into the slot. In this scenario, the caller may pass -1 "
"for **slot_nr**."
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:217
msgid ""
"The following semantics are imposed when the caller passes **slot_nr** == "
"-1. First, we no longer check for an existing ``struct`` pci_slot, as there "
"may be many slots with **slot_nr** of -1.  The other change in semantics is "
"user-visible, which is the 'address' parameter presented in sysfs will "
"consist solely of a dddd:bb tuple, where dddd is the PCI domain of the "
"``struct`` pci_bus and bb is the bus number. In other words, the devfn of "
"the 'placeholder' slot will not be displayed."
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:309
msgid "decrement refcount for physical PCI slot"
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:310
msgid "struct pci_slot to decrement"
msgstr ""

#: ../../../driver-api/pci/pci:37: drivers/pci/slot.c:311
msgid ""
"``struct`` pci_slot is refcounted, so destroying them is really easy; we "
"just call kobject_put on its kobj and let our release methods do the rest."
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:16
msgid "enable ROM decoding for a PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:17
msgid "PCI device to enable"
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:18
msgid ""
"Enable ROM decoding on **dev**.  This involves simply turning on the last "
"bit of the PCI ROM BAR.  Note that some cards may share address decoders "
"between the ROM and other resources, so enabling it may disable access to "
"MMIO registers or other card memory."
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:52
msgid "disable ROM decoding for a PCI device"
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:53
msgid "PCI device to disable"
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:54
msgid ""
"Disable ROM decoding on a PCI device by turning off the last bit in the ROM "
"BAR."
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:126
msgid "map a PCI ROM to kernel space"
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:127 drivers/pci/rom.c:182
msgid "pointer to pci device struct"
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:129
msgid "``size_t *size``"
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:128
msgid "pointer to receive size of pci window over ROM"
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:130
msgid "kernel virtual pointer to image of ROM"
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:131
msgid ""
"Map a PCI ROM into kernel space. If ROM is boot video ROM, the shadow BIOS "
"copy will be returned instead of the actual ROM."
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:181
msgid "unmap the ROM from kernel space"
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:184
msgid "``void __iomem *rom``"
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:183
msgid "virtual address of the previous mapping"
msgstr ""

#: ../../../driver-api/pci/pci:40: drivers/pci/rom.c:184
msgid "Remove a mapping of a previously mapped ROM"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:55
msgid "Return the drvdata of a PF"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:56
msgid "VF pci_dev"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:58
msgid "``struct pci_driver *pf_driver``"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:57
msgid "Device driver required to own the PF"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:58
msgid ""
"This must be called from a context that ensures that a VF driver is "
"attached. The value returned is invalid once the VF driver completes its "
"remove() callback."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:62
msgid ""
"Locking is achieved by the driver core. A VF driver cannot be probed until "
"pci_enable_sriov() is called and pci_disable_sriov() does not return until "
"all VF drivers have completed their remove()."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:66
msgid ""
"The PF driver must call pci_disable_sriov() before it begins to destroy the "
"drvdata."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1150
msgid "enable the SR-IOV capability"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1153
#: drivers/pci/iov.c:1289
msgid "``int nr_virtfn``"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1152
msgid "number of virtual functions to enable"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1153
msgid "Returns 0 on success, or negative on failure."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1168
msgid "disable the SR-IOV capability"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1183
msgid "return number of VFs associated with a PF device_release_driver"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1185
msgid "Returns number of VFs, or 0 if SR-IOV is not enabled."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1198
msgid "returns number of VFs are assigned to a guest"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1200
msgid ""
"Returns number of VFs belonging to this device that are assigned to a guest. "
"If device is not a physical function returns 0."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1239
msgid "reduce the TotalVFs available"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1240
#: drivers/pci/iov.c:1270
msgid "the PCI PF device"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1242
msgid "``u16 numvfs``"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1241
msgid "number that should be used for TotalVFs supported"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1242
msgid ""
"Should be called from PF driver's probe routine with device's mutex held."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1245
msgid ""
"Returns 0 if PF is an SRIOV-capable device and value of numvfs valid. If not "
"a PF return -ENOSYS; if numvfs is invalid return -EINVAL; if VFs already "
"enabled, return -EBUSY."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1269
msgid "get total VFs supported on this device"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1271
msgid ""
"For a PCIe device with SRIOV support, return the PCIe SRIOV capability value "
"of TotalVFs or the value of driver_max_VFs if the driver reduced it.  "
"Otherwise 0."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1286
msgid "helper to configure SR-IOV"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1288
msgid "number of virtual functions to enable, 0 to disable"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1289
msgid ""
"Enable or disable SR-IOV for devices that don't require any PF setup before "
"enabling SR-IOV.  Return value is negative on error, or number of VFs "
"allocated on success."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1322
msgid "set a new size for a VF BAR"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1325
#: drivers/pci/iov.c:1367
msgid "``int resno``"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1324
#: drivers/pci/iov.c:1366
msgid "the resource number"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1326
msgid "``int size``"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1325
msgid "new size as defined in the spec (0=1MB, 31=128TB)"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1326
msgid ""
"Set the new size of a VF BAR that supports VF resizable BAR capability. "
"Unlike pci_resize_resource(), this does not cause the resource that reserves "
"the MMIO space (originally up to total_VFs) to be resized, which means that "
"following calls to pci_enable_sriov() can fail if the resources no longer "
"fit."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1333
msgid "0 on success, or negative on failure."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1364
msgid "get VF BAR sizes allowing to create up to num_vfs"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1368
msgid "``int num_vfs``"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1367
msgid "number of VFs"
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1368
msgid ""
"Get the sizes of a VF resizable BAR that can accommodate **num_vfs** within "
"the currently assigned size of the resource **resno**."
msgstr ""

#: ../../../driver-api/pci/pci:43: drivers/pci/iov.c:1372
msgid ""
"A bitmask of sizes in format defined in the spec (bit 0=1MB, bit 31=128TB)."
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:879
msgid "read byte(s) from legacy I/O port space"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:885
#: drivers/pci/pci-sysfs.c:910 drivers/pci/pci-sysfs.c:935
#: drivers/pci/pci-sysfs.c:955 drivers/pci/pci-sysfs.c:1295
#: drivers/pci/pci-sysfs.c:1320
msgid "``struct file *filp``"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:880
#: drivers/pci/pci-sysfs.c:905 drivers/pci/pci-sysfs.c:930
#: drivers/pci/pci-sysfs.c:950
msgid "open sysfs file"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:882
#: drivers/pci/pci-sysfs.c:907 drivers/pci/pci-sysfs.c:932
#: drivers/pci/pci-sysfs.c:952 drivers/pci/pci-sysfs.c:1062
#: drivers/pci/pci-sysfs.c:1292 drivers/pci/pci-sysfs.c:1317
msgid "``struct kobject *kobj``"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:881
#: drivers/pci/pci-sysfs.c:906
msgid "kobject corresponding to file to read from"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:883
#: drivers/pci/pci-sysfs.c:908 drivers/pci/pci-sysfs.c:1293
#: drivers/pci/pci-sysfs.c:1318
msgid "``const struct bin_attribute *bin_attr``"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:882
#: drivers/pci/pci-sysfs.c:907 drivers/pci/pci-sysfs.c:932
#: drivers/pci/pci-sysfs.c:952 drivers/pci/pci-sysfs.c:1292
#: drivers/pci/pci-sysfs.c:1317
msgid "struct bin_attribute for this file"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:884
#: drivers/pci/pci-sysfs.c:909 drivers/pci/pci-sysfs.c:1294
#: drivers/pci/pci-sysfs.c:1319
msgid "``char *buf``"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:883
msgid "buffer to store results"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:885
#: drivers/pci/pci-sysfs.c:910 drivers/pci/pci-sysfs.c:1295
#: drivers/pci/pci-sysfs.c:1320
msgid "``loff_t off``"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:884
#: drivers/pci/pci-sysfs.c:909
msgid "offset into legacy I/O port space"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:886
#: drivers/pci/pci-sysfs.c:911 drivers/pci/pci-sysfs.c:1296
#: drivers/pci/pci-sysfs.c:1321
msgid "``size_t count``"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:885
#: drivers/pci/pci-sysfs.c:1320
msgid "number of bytes to read"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:886
msgid ""
"Reads 1, 2, or 4 bytes from legacy I/O port space using an arch specific "
"callback routine (pci_legacy_read)."
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:904
msgid "write byte(s) to legacy I/O port space"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:908
msgid "buffer containing value to be written"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:910
msgid "number of bytes to write"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:911
msgid ""
"Writes 1, 2, or 4 bytes from legacy I/O port space using an arch specific "
"callback routine (pci_legacy_write)."
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:929
msgid "map legacy PCI memory into user memory space"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:931
#: drivers/pci/pci-sysfs.c:951
msgid "kobject corresponding to device to be mapped"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:933
#: drivers/pci/pci-sysfs.c:953 drivers/pci/pci-sysfs.c:1059
msgid "``const struct bin_attribute *attr``"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:934
#: drivers/pci/pci-sysfs.c:954 drivers/pci/pci-sysfs.c:1060
msgid "``struct vm_area_struct *vma``"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:933
#: drivers/pci/pci-sysfs.c:953
msgid "struct vm_area_struct passed to mmap"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:934
msgid ""
"Uses an arch specific callback, pci_mmap_legacy_mem_page_range, to mmap "
"legacy memory space (first meg of bus space) into application virtual memory "
"space."
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:949
msgid "map legacy PCI IO into user memory space"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:954
msgid ""
"Uses an arch specific callback, pci_mmap_legacy_io_page_range, to mmap "
"legacy IO space (first meg of bus space) into application virtual memory "
"space. Returns -ENOSYS if the operation isn't supported"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:969
msgid "adjustment of legacy file attributes"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:975
#: drivers/pci/pci-sysfs.c:987
msgid "``struct pci_bus *b``"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:970
#: drivers/pci/pci-sysfs.c:982
msgid "bus to create files under"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:972
msgid "``enum pci_mmap_state mmap_type``"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:971
msgid "I/O port or memory"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:972
msgid "Stub implementation. Can be overridden by arch if necessary."
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:981
msgid "create legacy I/O port and memory files"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:983
msgid ""
"Some platforms allow access to legacy I/O port and ISA memory space on a per-"
"bus basis.  This routine creates the files and ties them into their "
"associated read, write and mmap files from pci-sysfs.c"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:987
msgid ""
"On error unwind, but don't propagate the error to the caller as it is ok to "
"set up the PCI bus without these files."
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1056
msgid "map a PCI resource into user memory space"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1057
msgid "kobject for mapping"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1058
msgid "struct bin_attribute for the file being mapped"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1059
msgid "struct vm_area_struct passed into the mmap"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1061
msgid "``int write_combine``"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1060
msgid "1 for write_combine mapping"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1061
msgid ""
"Use the regular PCI mapping routines to map a PCI resource into userspace."
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1166
msgid "cleanup resource files"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1167
msgid "dev to cleanup"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1168
msgid ""
"If we created resource files for **pdev**, remove them from sysfs and free "
"their resources."
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1250
msgid "create resource files in sysfs for **dev**"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1251
msgid "dev in question"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1252
msgid ""
"Walk the resources in **pdev** creating files for each resource available."
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1289
msgid "used to enable access to the PCI ROM display"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1290
#: drivers/pci/pci-sysfs.c:1315
msgid "sysfs file"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1291
#: drivers/pci/pci-sysfs.c:1316
msgid "kernel object handle"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1293
msgid "user input"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1294
#: drivers/pci/pci-sysfs.c:1319
msgid "file offset"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1295
msgid "number of byte in input"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1296
msgid "writing anything except 0 enables it"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1314
msgid "read a PCI ROM"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1318
msgid "where to put the data we read from the ROM"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1321
msgid ""
"Put **count** bytes starting at **off** into **buf** from the ROM in the PCI "
"device corresponding to **kobj**."
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1664
msgid "cleanup PCI specific sysfs files"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1665
msgid "device whose entries we should free"
msgstr ""

#: ../../../driver-api/pci/pci:46: drivers/pci/pci-sysfs.c:1666
msgid "Cleanup when **pdev** is removed from sysfs."
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:225
msgid ""
"Retrieve Steering Tag for a target memory associated with a specific CPU"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:229
msgid "``enum tph_mem_type mem_type``"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:228
msgid "target memory type (volatile or persistent RAM)"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:230
msgid "``unsigned int cpu_uid``"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:229
msgid "associated CPU id"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:231
msgid "``u16 *tag``"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:230
msgid "Steering Tag to be returned"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:231
msgid ""
"Return the Steering Tag for a target memory that is associated with a "
"specific CPU as indicated by cpu_uid."
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:235 drivers/pci/tph.c:279
msgid "0 if success, otherwise negative value (-errno)"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:270
msgid "Set Steering Tag in the ST table entry"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:273
msgid "``unsigned int index``"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:272
msgid "ST table entry index"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:274
msgid "``u16 tag``"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:273
msgid "Steering Tag to be written"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:274
msgid ""
"Figure out the proper location of ST table, either in the MSI-X table or in "
"the TPH Extended Capability space, and write the Steering Tag into the ST "
"entry pointed by index."
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:332
msgid "Turn off TPH support for device"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:335
msgid "none"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:354
msgid "Enable TPH support for device using a specific ST mode"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:357
msgid "``int mode``"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:356
msgid "ST mode to enable. Current supported modes include:"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:357
msgid "PCI_TPH_ST_NS_MODE: NO ST Mode"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:358
msgid "PCI_TPH_ST_IV_MODE: Interrupt Vector Mode"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:359
msgid "PCI_TPH_ST_DS_MODE: Device Specific Mode"
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:361
msgid ""
"Check whether the mode is actually supported by the device before enabling "
"and return an error if not. Additionally determine what types of requests, "
"TPH or extended TPH, can be issued by the device based on its TPH requester "
"capability and the Root Port's completer capability."
msgstr ""

#: ../../../driver-api/pci/pci:49: drivers/pci/tph.c:367
msgid "0 on success, otherwise negative value (-errno)"
msgstr ""

#: ../../../driver-api/pci/pci.rst:53
msgid "PCI Hotplug Support Library"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:337
msgid "register a hotplug_slot with the PCI hotplug subsystem"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:343
#: drivers/pci/hotplug/pci_hotplug_core.c:376
#: drivers/pci/hotplug/pci_hotplug_core.c:421
#: drivers/pci/hotplug/pci_hotplug_core.c:450
#: drivers/pci/hotplug/pci_hotplug_core.c:464
#: drivers/pci/hotplug/pci_hotplug_core.c:479
msgid "``struct hotplug_slot *slot``"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:338
msgid "pointer to the :c:type:`struct hotplug_slot <hotplug_slot>` to register"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:339
#: drivers/pci/hotplug/pci_hotplug_core.c:372
msgid "bus this slot is on"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:341
#: drivers/pci/hotplug/pci_hotplug_core.c:374
msgid "``int devnr``"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:340
msgid "device number"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:341
#: drivers/pci/hotplug/pci_hotplug_core.c:374
msgid "name registered with kobject core"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:342
#: drivers/pci/hotplug/pci_hotplug_core.c:375
msgid "caller module owner"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:343
#: drivers/pci/hotplug/pci_hotplug_core.c:376
msgid "caller module name"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:344
msgid ""
"Prepares a hotplug slot for in-kernel use and immediately publishes it to "
"user space in one go.  Drivers may alternatively carry out the two steps "
"separately by invoking pci_hp_initialize() and pci_hp_add()."
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:348
msgid "Returns 0 if successful, anything else for an error."
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:370
msgid "prepare hotplug slot for in-kernel use"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:371
msgid ""
"pointer to the :c:type:`struct hotplug_slot <hotplug_slot>` to initialize"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:373
msgid "slot number"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:377
msgid ""
"Allocate and fill in a PCI slot for use by a hotplug driver.  Once this has "
"been called, the driver may invoke hotplug_slot_name() to get the slot's "
"unique name.  The driver must be prepared to handle a ->reset_slot callback "
"from this point on."
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:382
#: drivers/pci/hotplug/pci_hotplug_core.c:421
msgid "Returns 0 on success or a negative int on error."
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:415
msgid "publish hotplug slot to user space"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:416
msgid "pointer to the :c:type:`struct hotplug_slot <hotplug_slot>` to publish"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:417
msgid ""
"Make a hotplug slot's sysfs interface available and inform user space of its "
"addition by sending a uevent.  The hotplug driver must be prepared to handle "
"all :c:type:`struct hotplug_slot_ops <hotplug_slot_ops>` callbacks from this "
"point on."
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:444
msgid "deregister a hotplug_slot with the PCI hotplug subsystem"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:445
msgid ""
"pointer to the :c:type:`struct hotplug_slot <hotplug_slot>` to deregister"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:446
msgid ""
"The **slot** must have been registered with the pci hotplug subsystem "
"previously with a call to pci_hp_register()."
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:458
msgid "unpublish hotplug slot from user space"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:459
msgid ""
"pointer to the :c:type:`struct hotplug_slot <hotplug_slot>` to unpublish"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:460
msgid "Remove a hotplug slot's sysfs interface."
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:473
msgid "remove hotplug slot from in-kernel use"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:474
msgid "pointer to the :c:type:`struct hotplug_slot <hotplug_slot>` to destroy"
msgstr ""

#: ../../../driver-api/pci/pci:55: drivers/pci/hotplug/pci_hotplug_core.c:475
msgid ""
"Destroy a PCI slot used by a hotplug driver.  Once this has been called, the "
"driver may no longer invoke hotplug_slot_name() to get the slot's unique "
"name.  The driver no longer needs to handle a ->reset_slot callback from "
"this point on."
msgstr ""
