# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-16 08:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/irq/irq-domain.rst:3
msgid "The irq_domain Interrupt Number Mapping Library"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:5
msgid ""
"The current design of the Linux kernel uses a single large number space "
"where each separate IRQ source is assigned a unique number. This is simple "
"when there is only one interrupt controller. But in systems with multiple "
"interrupt controllers, the kernel must ensure that each one gets assigned "
"non-overlapping allocations of Linux IRQ numbers."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:12
msgid ""
"The number of interrupt controllers registered as unique irqchips shows a "
"rising tendency. For example, subdrivers of different kinds such as GPIO "
"controllers avoid reimplementing identical callback mechanisms as the IRQ "
"core system by modelling their interrupt handlers as irqchips. I.e. in "
"effect cascading interrupt controllers."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:18
msgid ""
"So in the past, IRQ numbers could be chosen so that they match the hardware "
"IRQ line into the root interrupt controller (i.e. the component actually "
"firing the interrupt line to the CPU). Nowadays, this number is just a "
"number and the number has no relationship to hardware interrupt numbers."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:24
msgid ""
"For this reason, we need a mechanism to separate controller-local interrupt "
"numbers, called hardware IRQs, from Linux IRQ numbers."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:27
msgid ""
"The irq_alloc_desc*() and irq_free_desc*() APIs provide allocation of IRQ "
"numbers, but they don't provide any support for reverse mapping of the "
"controller-local IRQ (hwirq) number into the Linux IRQ number space."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:32
msgid ""
"The irq_domain library adds a mapping between hwirq and IRQ numbers on top "
"of the irq_alloc_desc*() API. An irq_domain to manage the mapping is "
"preferred over interrupt controller drivers open coding their own reverse "
"mapping scheme."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:37
msgid ""
"irq_domain also implements a translation from an abstract struct irq_fwspec "
"to hwirq numbers (Device Tree, non-DT firmware node, ACPI GSI, and software "
"node so far), and can be easily extended to support other IRQ topology data "
"sources. The implementation is performed without any extra platform support "
"code."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:44
msgid "irq_domain Usage"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:45
msgid ""
"struct irq_domain could be defined as an irq domain controller. That is, it "
"handles the mapping between hardware and virtual interrupt numbers for a "
"given interrupt domain. The domain structure is generally created by the PIC "
"code for a given PIC instance (though a domain can cover more than one PIC "
"if they have a flat number model). It is the domain callbacks that are "
"responsible for setting the irq_chip on a given irq_desc after it has been "
"mapped."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:53
msgid ""
"The host code and data structures use a fwnode_handle pointer to identify "
"the domain. In some cases, and in order to preserve source code "
"compatibility, this fwnode pointer is \"upgraded\" to a DT device_node. For "
"those firmware infrastructures that do not provide a unique identifier for "
"an interrupt controller, the irq_domain code offers a fwnode allocator."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:60
msgid ""
"An interrupt controller driver creates and registers a struct irq_domain by "
"calling one of the irq_domain_create_*() functions (each mapping method has "
"a different allocator function, more on that later). The function will "
"return a pointer to the struct irq_domain on success. The caller must "
"provide the allocator function with a struct irq_domain_ops pointer."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:67
msgid ""
"In most cases, the irq_domain will begin empty without any mappings between "
"hwirq and IRQ numbers.  Mappings are added to the irq_domain by calling "
"irq_create_mapping() which accepts the irq_domain and a hwirq number as "
"arguments. If a mapping for the hwirq doesn't already exist, "
"irq_create_mapping() allocates a new Linux irq_desc, associates it with the "
"hwirq, and calls the :c:member:`irq_domain_ops.map()` callback. In there, "
"the driver can perform any required hardware setup."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:76
msgid ""
"Once a mapping has been established, it can be retrieved or used via a "
"variety of methods:"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:79
msgid ""
"irq_resolve_mapping() returns a pointer to the irq_desc structure for a "
"given domain and hwirq number, or NULL if there was no mapping."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:82
msgid ""
"irq_find_mapping() returns a Linux IRQ number for a given domain and hwirq "
"number, or 0 if there was no mapping"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:84
msgid ""
"generic_handle_domain_irq() handles an interrupt described by a domain and a "
"hwirq number"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:87
msgid ""
"Note that irq_domain lookups must happen in contexts that are compatible "
"with an RCU read-side critical section."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:90
msgid ""
"The irq_create_mapping() function must be called *at least once* before any "
"call to irq_find_mapping(), lest the descriptor will not be allocated."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:94
msgid ""
"If the driver has the Linux IRQ number or the irq_data pointer, and needs to "
"know the associated hwirq number (such as in the irq_chip callbacks) then it "
"can be directly obtained from :c:member:`irq_data.hwirq`."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:100
msgid "Types of irq_domain Mappings"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:102
msgid ""
"There are several mechanisms available for reverse mapping from hwirq to "
"Linux IRQ, and each mechanism uses a different allocation function. Which "
"reverse map type should be used depends on the use case.  Each of the "
"reverse map types are described below:"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:108
msgid "Linear"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:114
msgid ""
"The linear reverse map maintains a fixed-size table indexed by the hwirq "
"number.  When a hwirq is mapped, an irq_desc is allocated for the hwirq, and "
"the IRQ number is stored in the table."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:118
msgid ""
"The Linear map is a good choice when the maximum number of hwirqs is fixed "
"and a relatively small number (~ < 256).  The advantages of this map are "
"fixed-time lookup for IRQ numbers, and irq_descs are only allocated for in-"
"use IRQs.  The disadvantage is that the table must be as large as the "
"largest possible hwirq number."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:124
msgid "The majority of drivers should use the Linear map."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:127
msgid "Tree"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:133
msgid ""
"The irq_domain maintains a radix tree map from hwirq numbers to Linux IRQs.  "
"When an hwirq is mapped, an irq_desc is allocated and the hwirq is used as "
"the lookup key for the radix tree."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:137
msgid ""
"The Tree map is a good choice if the hwirq number can be very large since it "
"doesn't need to allocate a table as large as the largest hwirq number.  The "
"disadvantage is that hwirq to IRQ number lookup is dependent on how many "
"entries are in the table."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:142
msgid "Very few drivers should need this mapping."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:145
msgid "No Map"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:151
msgid ""
"The No Map mapping is to be used when the hwirq number is programmable in "
"the hardware.  In this case it is best to program the Linux IRQ number into "
"the hardware itself so that no mapping is required.  Calling "
"irq_create_direct_mapping() will allocate a Linux IRQ number and call the ."
"map() callback so that driver can program the Linux IRQ number into the "
"hardware."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:158
msgid ""
"Most drivers cannot use this mapping, and it is now gated on the "
"CONFIG_IRQ_DOMAIN_NOMAP option. Please refrain from introducing new users of "
"this API."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:163
msgid "Legacy"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:170
msgid ""
"The Legacy mapping is a special case for drivers that already have a range "
"of irq_descs allocated for the hwirqs.  It is used when the driver cannot be "
"immediately converted to use the Linear mapping.  For example, many embedded "
"system board support files use a set of #defines for IRQ numbers that are "
"passed to struct device registrations.  In that case the Linux IRQ numbers "
"cannot be dynamically assigned and the Legacy mapping should be used."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:178
msgid ""
"As the name implies, the \\*_legacy() functions are deprecated and only "
"exist to ease the support of ancient platforms. No new users should be "
"added. Same goes for the \\*_simple() functions when their use results in "
"the legacy behaviour."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:183
msgid ""
"The Legacy map assumes a contiguous range of IRQ numbers has already been "
"allocated for the controller and that the IRQ number can be calculated by "
"adding a fixed offset to the hwirq number, and visa-versa.  The disadvantage "
"is that it requires the interrupt controller to manage IRQ allocations and "
"it requires an irq_desc to be allocated for every hwirq, even if it is "
"unused."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:190
msgid ""
"The Legacy map should only be used if fixed IRQ mappings must be supported.  "
"For example, ISA controllers would use the Legacy map for mapping Linux IRQs "
"0-15 so that existing ISA drivers get the correct IRQ numbers."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:195
msgid ""
"Most users of legacy mappings should use irq_domain_create_simple() which "
"will use a legacy domain only if an IRQ range is supplied by the system and "
"will otherwise use a linear domain mapping. The semantics of this call are "
"such that if an IRQ range is specified then descriptors will be allocated on-"
"the-fly for it, and if no range is specified it will fall through to "
"irq_domain_create_linear() which means *no* IRQ descriptors will be "
"allocated."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:203
msgid ""
"A typical use case for simple domains is where an irqchip provider is "
"supporting both dynamic and static IRQ assignments."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:206
msgid ""
"In order to avoid ending up in a situation where a linear domain is used and "
"no descriptor gets allocated it is very important to make sure that the "
"driver using the simple domain call irq_create_mapping() before any "
"irq_find_mapping() since the latter will actually work for the static IRQ "
"assignment case."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:213
msgid "Hierarchy IRQ Domain"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:215
msgid ""
"On some architectures, there may be multiple interrupt controllers involved "
"in delivering an interrupt from the device to the target CPU. Let's look at "
"a typical interrupt delivery path on x86 platforms::"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:221
msgid "There are three interrupt controllers involved:"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:223
msgid "IOAPIC controller"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:224
msgid "Interrupt remapping controller"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:225
msgid "Local APIC controller"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:227
msgid ""
"To support such a hardware topology and make software architecture match "
"hardware architecture, an irq_domain data structure is built for each "
"interrupt controller and those irq_domains are organized into hierarchy. "
"When building irq_domain hierarchy, the irq_domain nearest the device is "
"child and the irq_domain nearest the CPU is parent. So a hierarchy structure "
"as below will be built for the example above::"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:242
msgid "There are four major interfaces to use hierarchy irq_domain:"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:244
msgid ""
"irq_domain_alloc_irqs(): allocate IRQ descriptors and interrupt controller "
"related resources to deliver these interrupts."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:246
msgid ""
"irq_domain_free_irqs(): free IRQ descriptors and interrupt controller "
"related resources associated with these interrupts."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:248
msgid ""
"irq_domain_activate_irq(): activate interrupt controller hardware to deliver "
"the interrupt."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:250
msgid ""
"irq_domain_deactivate_irq(): deactivate interrupt controller hardware to "
"stop delivering the interrupt."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:253
msgid "The following is needed to support hierarchy irq_domain:"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:255
msgid ""
"The :c:member:`parent` field in struct irq_domain is used to maintain "
"irq_domain hierarchy information."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:257
msgid ""
"The :c:member:`parent_data` field in struct irq_data is used to build "
"hierarchy irq_data to match hierarchy irq_domains. The irq_data is used to "
"store irq_domain pointer and hardware irq number."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:261
msgid ""
"The :c:member:`alloc()`, :c:member:`free()`, and other callbacks in struct "
"irq_domain_ops to support hierarchy irq_domain operations."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:264
msgid ""
"With the support of hierarchy irq_domain and hierarchy irq_data ready, an "
"irq_domain structure is built for each interrupt controller, and an irq_data "
"structure is allocated for each irq_domain associated with an IRQ."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:269
msgid ""
"For an interrupt controller driver to support hierarchy irq_domain, it needs "
"to:"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:272
msgid "Implement irq_domain_ops.alloc() and irq_domain_ops.free()"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:273
msgid ""
"Optionally, implement irq_domain_ops.activate() and irq_domain_ops."
"deactivate()."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:275
msgid ""
"Optionally, implement an irq_chip to manage the interrupt controller "
"hardware."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:277
msgid ""
"There is no need to implement irq_domain_ops.map() and irq_domain_ops."
"unmap(). They are unused with hierarchy irq_domain."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:280
msgid ""
"Note the hierarchy irq_domain is in no way x86-specific, and is heavily used "
"to support other architectures, such as ARM, ARM64 etc."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:284
msgid "Stacked irq_chip"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:286
msgid ""
"Now, we could go one step further to support stacked (hierarchy) irq_chip. "
"That is, an irq_chip is associated with each irq_data along the hierarchy. A "
"child irq_chip may implement a required action by itself or by cooperating "
"with its parent irq_chip."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:291
msgid ""
"With stacked irq_chip, interrupt controller driver only needs to deal with "
"the hardware managed by itself and may ask for services from its parent "
"irq_chip when needed. So we could achieve a much cleaner software "
"architecture."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:297
msgid "Debugging"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:299
msgid ""
"Most of the internals of the IRQ subsystem are exposed in debugfs by turning "
"CONFIG_GENERIC_IRQ_DEBUGFS on."
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:303
msgid "Structures and Public Functions Provided"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:305
msgid ""
"This chapter contains the autogenerated documentation of the structures and "
"exported kernel API functions which are used for IRQ domains."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:32
msgid "generic IRQ specifier structure"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:36
#: ../include/linux/irqdomain.h:52 ../include/linux/irqdomain.h:73
#: ../include/linux/irqdomain.h:136 ../include/linux/irqdomain.h:317
msgid "**Definition**::"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:44
#: ../include/linux/irqdomain.h:59 ../include/linux/irqdomain.h:94
#: ../include/linux/irqdomain.h:165 ../include/linux/irqdomain.h:340
msgid "**Members**"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:34
#: ../include/linux/irqdomain.h:144 ../include/linux/irqdomain.h:314
msgid "``fwnode``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:35
msgid "Pointer to a firmware-specific descriptor"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:35
msgid "``param_count``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:36
msgid "Number of device-specific parameters"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:36
msgid "``param``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:37
msgid "Device-specific parameters"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:40
#: ../include/linux/irqdomain.h:55 ../include/linux/irqdomain.h:96
#: ../include/linux/irqdomain.h:170 ../include/linux/irqdomain.h:491
#: ../include/linux/irqdomain.h:581 ../include/linux/irqdomain.h:622
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:79
#: ../kernel/irq/irqdomain.c:128 ../kernel/irq/irqdomain.c:394
#: ../kernel/irq/irqdomain.c:468 ../kernel/irq/irqdomain.c:565
#: ../kernel/irq/irqdomain.c:583 ../kernel/irq/irqdomain.c:743
#: ../kernel/irq/irqdomain.c:815 ../kernel/irq/irqdomain.c:1050
#: ../kernel/irq/irqdomain.c:1104 ../kernel/irq/irqdomain.c:1128
#: ../kernel/irq/irqdomain.c:1152 ../kernel/irq/irqdomain.c:1177
#: ../kernel/irq/irqdomain.c:1235 ../kernel/irq/irqdomain.c:1260
#: ../kernel/irq/irqdomain.c:1399 ../kernel/irq/irqdomain.c:1683
#: ../kernel/irq/irqdomain.c:1743 ../kernel/irq/irqdomain.c:1826
#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:1999
#: ../kernel/irq/irqdomain.c:2018
msgid "**Description**"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:37
msgid ""
"This structure, directly modeled after of_phandle_args, is used to pass a "
"device-specific description of an interrupt."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:48
msgid "firmware provided IRQ information structure"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:50
#: ../include/linux/irqdomain.h:138
msgid "``flags``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:51
msgid "Information validity flags"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:51
msgid "``affinity``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:52
msgid "Affinity mask for this interrupt"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:52
msgid ""
"This structure reports firmware-specific information about an interrupt. The "
"only significant information is the affinity of a per-CPU interrupt, but "
"this is designed to be extended as required."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:69
msgid "Methods for irq_domain objects"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:70
msgid "``match``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:71
msgid ""
"Match an interrupt controller device node to a domain, returns 1 on a match"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:72
msgid "``select``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:73
msgid ""
"Match an interrupt controller fw specification. It is more generic than "
"**match** as it receives a complete struct irq_fwspec. Therefore, **select** "
"is preferred if provided. Returns 1 on a match."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:75
msgid "``map``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:76
msgid ""
"Create or update a mapping between a virtual irq number and a hw irq number. "
"This is called only once for a given mapping."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:77
msgid "``unmap``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:78
msgid "Dispose of such a mapping"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:78
msgid "``xlate``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:79
msgid ""
"Given a device tree node and interrupt specifier, decode the hardware irq "
"number and linux irq type value."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:80
msgid "``alloc``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:81
msgid "Allocate **nr_irqs** interrupts starting from **virq**."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:81
msgid "``free``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:82
msgid "Free **nr_irqs** interrupts starting from **virq**."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:82
msgid "``activate``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:83
msgid ""
"Activate one interrupt in HW (**irqd**). If **reserve** is set, only reserve "
"the vector. If unset, assign the vector (called from request_irq())."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:85
msgid "``deactivate``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:86
msgid "Disarm one interrupt (**irqd**)."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:86
msgid "``translate``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:87
msgid ""
"Given **fwspec**, decode the hardware irq number (**out_hwirq**) and linux "
"irq type value (**out_type**). This is a generalised **xlate** (over struct "
"irq_fwspec) and is preferred if provided."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:89
msgid "``get_fwspec_info``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:90
msgid ""
"Given **fwspec**, report additional firmware-provided information in "
"**info**. Optional."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:92
msgid "``debug_show``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:93
msgid "For domains to show specific data for an interrupt in debugfs."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:93
msgid ""
"Functions below are provided by the driver and called whenever a new mapping "
"is created or an old mapping is disposed. The driver can then proceed to "
"whatever internal data structures management is required. It also needs to "
"setup the irq_desc when returning from map()."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:132
msgid "Hardware interrupt number translation object"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:133
msgid "``link``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:134
msgid "Element in global irq_domain list."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:134
msgid "``name``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:135
msgid "Name of interrupt domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:135
#: ../include/linux/irqdomain.h:326
msgid "``ops``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:136
msgid "Pointer to irq_domain methods"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:136
#: ../include/linux/irqdomain.h:327
msgid "``host_data``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:137
msgid ""
"Private data pointer for use by owner.  Not touched by irq_domain core code."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:139
msgid "Per irq_domain flags"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:139
msgid "``mapcount``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:140
msgid "The number of mapped interrupts"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:140
msgid "``mutex``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:141
msgid "Domain lock, hierarchical domains use root domain's lock"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:141
msgid "``root``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:142
msgid "Pointer to root domain, or containing structure if non-hierarchical"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:145
msgid ""
"Pointer to firmware node associated with the irq_domain. Pretty easy to swap "
"it for the of_node via the irq_domain_get_of_node accessor"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:146
#: ../include/linux/irqdomain.h:323
msgid "``bus_token``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:147
msgid ""
"**fwnode**'s device_node might be used for several irq domains. But in "
"connection with **bus_token**, the pair shall be unique in a system."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:149
msgid "``gc``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:150
msgid ""
"Pointer to a list of generic chips. There is a helper function for setting "
"up one or more generic chips for interrupt controllers drivers using the "
"generic chip library which uses this pointer."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:152
#: ../include/linux/irqdomain.h:328
msgid "``dev``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:153
msgid ""
"Pointer to the device which instantiated the irqdomain With per device irq "
"domains this is not necessarily the same as **pm_dev**."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:155
msgid "``pm_dev``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:156
msgid ""
"Pointer to a device that can be utilized for power management purposes "
"related to the irq domain."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:157
#: ../include/linux/irqdomain.h:351
msgid "``parent``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:158
msgid "Pointer to parent irq_domain to support hierarchy irq_domains"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:158
msgid "``msi_parent_ops``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:159
msgid "Pointer to MSI parent domain methods for per device domain init"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:159
#: ../include/linux/irqdomain.h:333
msgid "``exit``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:160
msgid "Function called when the domain is destroyed"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:162
#: ../include/linux/irqdomain.h:317
msgid "``hwirq_max``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:163
msgid ""
"Top limit for the HW irq number. Especially to avoid conflicts/failures with "
"reserved HW irqs. Can be ~0."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:164
msgid "``revmap_size``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:165
msgid "Size of the linear map table **revmap**"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:165
msgid "``revmap_tree``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:166
msgid "Radix map tree for hwirqs that don't fit in the linear map"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:166
msgid "``revmap``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:167
msgid "Linear table of irq_data pointers"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:142
msgid "Optional elements:"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:144
msgid "Revmap data, used internally by the irq domain code:"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:313
msgid "Domain information structure"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:315
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:460
msgid "firmware node for the interrupt controller"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:315
msgid "``domain_flags``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:316
msgid "Additional flags to add to the domain flags"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:316
msgid "``size``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:317
msgid "Size of linear map; 0 for radix mapping only"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:318
msgid "Maximum number of interrupts supported by controller"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:318
msgid "``direct_max``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:319
msgid ""
"Maximum value of direct maps; Use ~0 for no limit; 0 for no direct mapping"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:320
msgid "``hwirq_base``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:321
msgid "The first hardware interrupt number (legacy domains only)"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:321
msgid "``virq_base``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:322
msgid ""
"The first Linux interrupt number for legacy domains to immediately associate "
"the interrupts after domain creation"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:324
msgid "Domain bus token"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:324
msgid "``name_suffix``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:325
msgid ""
"Optional name suffix to avoid collisions when multiple domains are added "
"using same fwnode"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:327
msgid "Domain operation callbacks"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:328
#: ../include/linux/irqdomain.h:439 ../include/linux/irqdomain.h:579
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:466
msgid "Controller private data pointer"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:329
msgid "Device which creates the domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:352
msgid "Pointer to the parent irq domain used in a hierarchy domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:329
msgid "``dgc_info``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:330
msgid ""
"Geneneric chip information structure pointer used to create generic chips "
"for the domain if not NULL."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:331
msgid "``init``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:332
msgid ""
"Function called when the domain is created. Allow to do some additional "
"domain initialisation."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:334
msgid ""
"Function called when the domain is destroyed. Allow to do some additional "
"cleanup operation."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:435
msgid "Allocate and register a linear revmap irq_domain."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:439
#: ../include/linux/irqdomain.h:491 ../include/linux/irqdomain.h:512
#: ../include/linux/irqdomain.h:525 ../include/linux/irqdomain.h:577
#: ../include/linux/irqdomain.h:620 ../../../core-api/irq/irq-domain:310:
#: ../kernel/irq/irqdomain.c:75 ../kernel/irq/irqdomain.c:129
#: ../kernel/irq/irqdomain.c:383 ../kernel/irq/irqdomain.c:395
#: ../kernel/irq/irqdomain.c:463 ../kernel/irq/irqdomain.c:523
#: ../kernel/irq/irqdomain.c:566 ../kernel/irq/irqdomain.c:583
#: ../kernel/irq/irqdomain.c:744 ../kernel/irq/irqdomain.c:814
#: ../kernel/irq/irqdomain.c:1023 ../kernel/irq/irqdomain.c:1049
#: ../kernel/irq/irqdomain.c:1100 ../kernel/irq/irqdomain.c:1124
#: ../kernel/irq/irqdomain.c:1148 ../kernel/irq/irqdomain.c:1173
#: ../kernel/irq/irqdomain.c:1211 ../kernel/irq/irqdomain.c:1232
#: ../kernel/irq/irqdomain.c:1257 ../kernel/irq/irqdomain.c:1311
#: ../kernel/irq/irqdomain.c:1399 ../kernel/irq/irqdomain.c:1499
#: ../kernel/irq/irqdomain.c:1518 ../kernel/irq/irqdomain.c:1544
#: ../kernel/irq/irqdomain.c:1566 ../kernel/irq/irqdomain.c:1587
#: ../kernel/irq/irqdomain.c:1678 ../kernel/irq/irqdomain.c:1742
#: ../kernel/irq/irqdomain.c:1826 ../kernel/irq/irqdomain.c:1895
#: ../kernel/irq/irqdomain.c:1931 ../kernel/irq/irqdomain.c:1950
#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:1998
#: ../kernel/irq/irqdomain.c:2018
msgid "**Parameters**"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:441
#: ../include/linux/irqdomain.h:578 ../../../core-api/irq/irq-domain:310:
#: ../kernel/irq/irqdomain.c:131 ../kernel/irq/irqdomain.c:465
msgid "``struct fwnode_handle *fwnode``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:436
msgid "pointer to interrupt controller's FW node."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:438
#: ../include/linux/irqdomain.h:577 ../../../core-api/irq/irq-domain:310:
#: ../kernel/irq/irqdomain.c:462
msgid "``unsigned int size``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:437
msgid "Number of interrupts in the domain."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:439
#: ../include/linux/irqdomain.h:579 ../../../core-api/irq/irq-domain:310:
#: ../kernel/irq/irqdomain.c:466
msgid "``const struct irq_domain_ops *ops``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:438
msgid "map/unmap domain callbacks"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:440
#: ../include/linux/irqdomain.h:580 ../../../core-api/irq/irq-domain:310:
#: ../kernel/irq/irqdomain.c:467
msgid "``void *host_data``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:441
#: ../include/linux/irqdomain.h:495 ../include/linux/irqdomain.h:512
#: ../include/linux/irqdomain.h:525 ../include/linux/irqdomain.h:585
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:3
#: ../kernel/irq/irqdomain.c:382
msgid "**Return**"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:441
msgid "Newly created irq_domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:487
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:810
msgid "Map a hardware interrupt into linux irq space"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:493
#: ../include/linux/irqdomain.h:514 ../include/linux/irqdomain.h:527
#: ../include/linux/irqdomain.h:622 ../../../core-api/irq/irq-domain:310:
#: ../kernel/irq/irqdomain.c:397 ../kernel/irq/irqdomain.c:568
#: ../kernel/irq/irqdomain.c:746 ../kernel/irq/irqdomain.c:816
#: ../kernel/irq/irqdomain.c:1051 ../kernel/irq/irqdomain.c:1401
#: ../kernel/irq/irqdomain.c:1501 ../kernel/irq/irqdomain.c:1520
#: ../kernel/irq/irqdomain.c:1546 ../kernel/irq/irqdomain.c:1568
#: ../kernel/irq/irqdomain.c:1589 ../kernel/irq/irqdomain.c:1680
#: ../kernel/irq/irqdomain.c:1744 ../kernel/irq/irqdomain.c:1828
#: ../kernel/irq/irqdomain.c:1933 ../kernel/irq/irqdomain.c:1952
msgid "``struct irq_domain *domain``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:488
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:811
msgid "domain owning this hardware interrupt or NULL for default domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:490
#: ../include/linux/irqdomain.h:511 ../include/linux/irqdomain.h:524
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:813
#: ../kernel/irq/irqdomain.c:1048 ../kernel/irq/irqdomain.c:1518
#: ../kernel/irq/irqdomain.c:1544
msgid "``irq_hw_number_t hwirq``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:489
#: ../include/linux/irqdomain.h:510 ../include/linux/irqdomain.h:523
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:812
#: ../kernel/irq/irqdomain.c:1047
msgid "hardware irq number in that domain space"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:490
msgid "Only one mapping per hardware interrupt is permitted."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:492
msgid ""
"If the sense/trigger is to be specified, set_irq_type() should be called on "
"the number returned from that call."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:496
msgid "Linux irq number or 0 on error"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:508
#: ../include/linux/irqdomain.h:521 ../../../core-api/irq/irq-domain:310:
#: ../kernel/irq/irqdomain.c:1045
msgid "Find a linux irq from a hw irq number."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:509
#: ../include/linux/irqdomain.h:522 ../../../core-api/irq/irq-domain:310:
#: ../kernel/irq/irqdomain.c:1046
msgid "domain owning this hardware interrupt"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:512
msgid "Interrupt descriptor"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:525
msgid "Linux irq number or 0 if not found"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:573
msgid "Add a irqdomain into the hierarchy"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:579
msgid "``struct irq_domain *parent``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:574
msgid "Parent irq domain to associate with the new domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:576
msgid "``unsigned int flags``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:575
msgid "Irq domain flags associated to the domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:576
msgid "Size of the domain. See below"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:577
msgid "Optional fwnode of the interrupt controller"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:578
msgid "Pointer to the interrupt domain callbacks"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:580
msgid "If **size** is 0 a tree domain is created, otherwise a linear domain."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:582
msgid ""
"If successful the parent is associated to the new domain and the domain "
"flags are set."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:586
msgid "A pointer to IRQ domain, or ``NULL`` on failure."
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:616
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1674
msgid "Allocate IRQs from domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:617
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1675
msgid "domain to allocate from"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:619
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1566
#: ../kernel/irq/irqdomain.c:1587 ../kernel/irq/irqdomain.c:1678
#: ../kernel/irq/irqdomain.c:1894 ../kernel/irq/irqdomain.c:1931
#: ../kernel/irq/irqdomain.c:1950
msgid "``unsigned int nr_irqs``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:618
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1677
msgid "number of IRQs to allocate"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:620
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1679
msgid "``int node``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:619
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1678
msgid "NUMA node id for memory allocation"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:621
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1680
#: ../kernel/irq/irqdomain.c:1742 ../kernel/irq/irqdomain.c:1932
msgid "``void *arg``"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:620
#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1679
msgid "domain specific argument"
msgstr ""

#: ../../../core-api/irq/irq-domain:308: ../include/linux/irqdomain.h:621
msgid "See __irq_domain_alloc_irqs()' documentation."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:71
msgid "Allocate a fwnode_handle suitable for identifying an irq domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:77
msgid "``unsigned int type``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:73
msgid "Type of irqchip_fwnode. See linux/irqdomain.h"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:75
msgid "``int id``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:74
msgid "Optional user provided id if name != NULL"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:76
msgid "``const char *name``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:75
msgid "Optional user provided domain name"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:77
msgid "``phys_addr_t *pa``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:76
msgid "Optional user-provided physical address"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:78
msgid "``struct fwnode_handle *parent``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:77
msgid "Optional parent fwnode_handle"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:78
msgid ""
"Allocate a struct irqchip_fwid, and return a pointer to the embedded "
"fwnode_handle (or NULL on failure)."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:81
#: ../kernel/irq/irqdomain.c:1180
msgid "**Note**"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:82
msgid ""
"The types IRQCHIP_FWNODE_NAMED and IRQCHIP_FWNODE_NAMED_ID are solely to "
"transport name information to irqdomain creation code. The node is not "
"stored. For other types the pointer is kept in the irq domain struct."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:125
msgid "Free a non-OF-backed fwnode_handle"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:126
msgid "fwnode_handle to free"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:127
msgid "Free a fwnode_handle allocated with irq_domain_alloc_fwnode."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:379
msgid "Instantiate a new irq domain data structure"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:385
msgid "``const struct irq_domain_info *info``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:380
msgid "Domain information pointer pointing to the information for this domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:382
msgid "A pointer to the instantiated irq domain or an ERR_PTR value."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:391
msgid "Remove an irq domain."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:392
msgid "domain to remove"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:393
msgid ""
"This routine is used to remove an irq domain. The caller must ensure that "
"all mappings within the domain have been disposed of prior to use, depending "
"on the revmap type."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:459
msgid "Register an irq_domain and optionally map a range of irqs"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:461
msgid "total number of irqs in mapping"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:463
msgid "``unsigned int first_irq``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:462
msgid ""
"first number of irq block assigned to the domain, pass zero to assign irqs "
"on-the-fly. If first_irq is non-zero, then pre-map all of the irqs in the "
"domain to virqs starting at first_irq."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:465
msgid "domain callbacks"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:467
msgid ""
"Allocates an irq_domain, and optionally if first_irq is positive then also "
"allocate irq_descs and map all of the hwirqs to virqs starting at first_irq."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:470
msgid ""
"This is intended to implement the expected behaviour for most interrupt "
"controllers. If device tree is used, then first_irq will be 0 and irqs get "
"mapped dynamically on the fly. However, if the controller requires static "
"virq assignments (non-DT boot) then it will set that up correctly."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:519
msgid "Locates a domain for a given fwspec"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:525
#: ../kernel/irq/irqdomain.c:1211 ../kernel/irq/irqdomain.c:1232
#: ../kernel/irq/irqdomain.c:1257
msgid "``struct irq_fwspec *fwspec``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:520
msgid "FW specifier for an interrupt"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:522
msgid "``enum irq_domain_bus_token bus_token``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:521
msgid "domain-specific data"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:562
msgid "Set a \"default\" irq domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:563
msgid "default domain pointer"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:564
msgid ""
"For convenience, it's possible to set a \"default\" domain that will be used "
"whenever NULL is passed to irq_create_mapping(). It makes life easier for "
"platforms that want to manipulate a few hard coded interrupt numbers that "
"aren't properly represented in the device-tree."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:579
msgid "Retrieve the \"default\" irq domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:585
msgid "``void``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1
msgid "no arguments"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:581
msgid "the default domain, if any."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:582
msgid ""
"Modern code should never use this. This should only be used on systems that "
"cannot implement a firmware->fwnode mapping (which both DT and ACPI provide)."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:740
msgid "Allocate an irq for direct mapping"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:741
msgid "domain to allocate the irq for or NULL for default domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:742
msgid ""
"This routine is used for irq controllers which can choose the hardware "
"interrupt numbers they generate. In such a case it's simplest to use the "
"linux irq as the hardware interrupt number. It still uses the linear or "
"radix tree to store the mapping, but the irq controller can optimize the "
"revmap path by using the hwirq directly."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:814
#: ../kernel/irq/irqdomain.c:1682
msgid "``const struct irq_affinity_desc *affinity``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:813
msgid "irq affinity"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:814
msgid ""
"Only one mapping per hardware interrupt is permitted. Returns a linux irq "
"number. If the sense/trigger is to be specified, set_irq_type() should be "
"called on the number returned from that call."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1019
msgid "Unmap an interrupt"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1025
#: ../kernel/irq/irqdomain.c:1398 ../kernel/irq/irqdomain.c:1498
#: ../kernel/irq/irqdomain.c:1517 ../kernel/irq/irqdomain.c:1543
#: ../kernel/irq/irqdomain.c:1565 ../kernel/irq/irqdomain.c:1586
#: ../kernel/irq/irqdomain.c:1897
msgid "``unsigned int virq``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1020
msgid "linux irq number of the interrupt to unmap"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1049
msgid "``unsigned int *irq``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1048
msgid "optional pointer to return the Linux irq if required"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1049
msgid "Returns the interrupt descriptor."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1096
msgid "Generic xlate for direct one cell bindings"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1102
#: ../kernel/irq/irqdomain.c:1126 ../kernel/irq/irqdomain.c:1150
#: ../kernel/irq/irqdomain.c:1175 ../kernel/irq/irqdomain.c:1213
#: ../kernel/irq/irqdomain.c:1234 ../kernel/irq/irqdomain.c:1259
msgid "``struct irq_domain *d``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1097
#: ../kernel/irq/irqdomain.c:1121 ../kernel/irq/irqdomain.c:1145
#: ../kernel/irq/irqdomain.c:1170 ../kernel/irq/irqdomain.c:1209
#: ../kernel/irq/irqdomain.c:1230 ../kernel/irq/irqdomain.c:1255
msgid "Interrupt domain involved in the translation"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1099
#: ../kernel/irq/irqdomain.c:1123 ../kernel/irq/irqdomain.c:1147
#: ../kernel/irq/irqdomain.c:1172
msgid "``struct device_node *ctrlr``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1098
#: ../kernel/irq/irqdomain.c:1122 ../kernel/irq/irqdomain.c:1146
#: ../kernel/irq/irqdomain.c:1171
msgid "The device tree node for the device whose interrupt is translated"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1100
#: ../kernel/irq/irqdomain.c:1124 ../kernel/irq/irqdomain.c:1148
#: ../kernel/irq/irqdomain.c:1173
msgid "``const u32 *intspec``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1099
#: ../kernel/irq/irqdomain.c:1123 ../kernel/irq/irqdomain.c:1147
#: ../kernel/irq/irqdomain.c:1172
msgid "The interrupt specifier data from the device tree"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1101
#: ../kernel/irq/irqdomain.c:1125 ../kernel/irq/irqdomain.c:1149
#: ../kernel/irq/irqdomain.c:1174
msgid "``unsigned int intsize``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1100
#: ../kernel/irq/irqdomain.c:1124 ../kernel/irq/irqdomain.c:1148
#: ../kernel/irq/irqdomain.c:1173
msgid "The number of entries in **intspec**"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1102
#: ../kernel/irq/irqdomain.c:1175 ../kernel/irq/irqdomain.c:1212
#: ../kernel/irq/irqdomain.c:1233 ../kernel/irq/irqdomain.c:1258
msgid "``unsigned long *out_hwirq``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1101
#: ../kernel/irq/irqdomain.c:1125 ../kernel/irq/irqdomain.c:1149
#: ../kernel/irq/irqdomain.c:1174 ../kernel/irq/irqdomain.c:1211
#: ../kernel/irq/irqdomain.c:1232 ../kernel/irq/irqdomain.c:1257
msgid "Pointer to storage for the hardware interrupt number"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1103
#: ../kernel/irq/irqdomain.c:1127 ../kernel/irq/irqdomain.c:1151
#: ../kernel/irq/irqdomain.c:1176 ../kernel/irq/irqdomain.c:1213
#: ../kernel/irq/irqdomain.c:1234 ../kernel/irq/irqdomain.c:1259
msgid "``unsigned int *out_type``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1102
#: ../kernel/irq/irqdomain.c:1126 ../kernel/irq/irqdomain.c:1150
#: ../kernel/irq/irqdomain.c:1175 ../kernel/irq/irqdomain.c:1212
#: ../kernel/irq/irqdomain.c:1233 ../kernel/irq/irqdomain.c:1258
msgid "Pointer to storage for the interrupt type"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1103
msgid ""
"Device Tree IRQ specifier translation function which works with one cell "
"bindings where the cell value maps directly to the hwirq number."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1120
msgid "Generic xlate for direct two cell bindings"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1126
#: ../kernel/irq/irqdomain.c:1150
msgid "``irq_hw_number_t *out_hwirq``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1127
#: ../kernel/irq/irqdomain.c:1234
msgid ""
"Device Tree IRQ specifier translation function which works with two cell "
"bindings where the cell values map directly to the hwirq number and linux "
"irq flags."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1144
msgid "Generic xlate for direct two or three cell bindings"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1151
msgid ""
"Device Tree interrupt specifier translation function for two or three cell "
"bindings, where the cell values map directly to the hardware interrupt "
"number and the type specifier."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1169
msgid "Generic xlate for one or two cell bindings"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1176
msgid ""
"Device Tree IRQ specifier translation function which works with either one "
"or two cell bindings where the cell values map directly to the hwirq number "
"and linux irq flags."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1181
msgid ""
"don't use this function unless your interrupt controller explicitly supports "
"both one and two cell bindings.  For the majority of controllers the "
"_onecell() or _twocell() variants above should be used."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1207
msgid "Generic translate for direct one cell bindings"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1210
#: ../kernel/irq/irqdomain.c:1231 ../kernel/irq/irqdomain.c:1256
msgid "The firmware interrupt specifier to translate"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1228
msgid "Generic translate for direct two cell bindings"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1253
msgid "Generic translate for direct two or three cell bindings"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1259
msgid ""
"Firmware interrupt specifier translation function for two or three cell "
"specifications, where the parameter values map directly to the hardware "
"interrupt number and the type specifier."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1307
msgid "Clear hwirq, chip and chip_data in **irq_data**"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1313
#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:2000
#: ../kernel/irq/irqdomain.c:2020
msgid "``struct irq_data *irq_data``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1308
msgid "The pointer to irq_data"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1395
msgid "Mark the first unused level of a hierarchy"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1396
msgid "IRQ domain from which the hierarchy is to be disconnected"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1397
msgid "IRQ number where the hierarchy is to be trimmed"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1398
msgid ""
"Marks the **virq** level belonging to **domain** as disconnected. Returns -"
"EINVAL if **virq** doesn't have a valid irq_data pointing to **domain**."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1402
msgid ""
"Its only use is to be able to trim levels of hierarchy that do not have any "
"real meaning for this interrupt, and that the driver marks as such from its ."
"alloc() callback."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1495
msgid "Get irq_data associated with **virq** and **domain**"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1496
msgid "domain to match"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1497
msgid "IRQ number to get irq_data"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1514
msgid "Set hwirq and irqchip of **virq** at **domain**"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1515
#: ../kernel/irq/irqdomain.c:1541 ../kernel/irq/irqdomain.c:1563
#: ../kernel/irq/irqdomain.c:1584
msgid "Interrupt domain to match"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1516
#: ../kernel/irq/irqdomain.c:1542
msgid "IRQ number"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1517
msgid "The hwirq number"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1519
#: ../kernel/irq/irqdomain.c:1545
msgid "``const struct irq_chip *chip``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1518
#: ../kernel/irq/irqdomain.c:1544
msgid "The associated interrupt chip"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1520
#: ../kernel/irq/irqdomain.c:1546
msgid "``void *chip_data``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1519
msgid "The associated chip data"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1540
msgid "Set the complete data for a **virq** in **domain**"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1543
msgid "The hardware interrupt number"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1545
msgid "The associated interrupt chip data"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1547
msgid "``irq_flow_handler_t handler``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1546
msgid "The interrupt flow handler"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1548
msgid "``void *handler_data``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1547
msgid "The interrupt flow handler data"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1549
msgid "``const char *handler_name``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1548
msgid "The interrupt handler name"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1562
msgid "Clear irq_data and free the parent"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1564
#: ../kernel/irq/irqdomain.c:1585
msgid "IRQ number to start with"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1565
#: ../kernel/irq/irqdomain.c:1586
msgid "The number of irqs to free"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1583
msgid "Clear handler and handler data, clear irqdata and free parent"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1677
msgid "``int irq_base``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1676
msgid "allocate specified IRQ number if irq_base >= 0"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1681
msgid "``bool realloc``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1680
msgid "IRQ descriptors have already been allocated if true"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1681
msgid "Optional irq affinity mask for multiqueue devices"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1682
msgid ""
"Allocate IRQ numbers and initialized all data structures to support "
"hierarchy IRQ domains. Parameter **realloc** is mainly to support legacy "
"IRQs. Returns error code or allocated IRQ number"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1687
msgid ""
"The whole process to setup an IRQ has been split into two steps. The first "
"step, __irq_domain_alloc_irqs(), is to allocate IRQ descriptor and required "
"hardware resources. The second step, irq_domain_activate_irq(), is to "
"program the hardware with preallocated resources. In this way, it's easier "
"to rollback when failing to allocate resources."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1738
msgid "Push a domain in to the top of a hierarchy."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1739
msgid "Domain to push."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1741
#: ../kernel/irq/irqdomain.c:1825
msgid "``int virq``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1740
msgid "Irq to push the domain in to."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1741
msgid "Passed to the irq_domain_ops alloc() function."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1742
msgid ""
"For an already existing irqdomain hierarchy, as might be obtained via a call "
"to pci_enable_msix(), add an additional domain to the head of the processing "
"chain.  Must be called before request_irq() has been called."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1822
msgid "Remove a domain from the top of a hierarchy."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1823
msgid "Domain to remove."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1824
msgid "Irq to remove the domain from."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1825
msgid ""
"Undo the effects of a call to irq_domain_push_irq().  Must be called either "
"before request_irq() or after free_irq()."
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1891
msgid "Free IRQ number and associated data structures"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1892
msgid "base IRQ number"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1893
msgid "number of IRQs to free"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1927
msgid "Allocate interrupts from parent domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1928
msgid "Domain below which interrupts must be allocated"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1930
#: ../kernel/irq/irqdomain.c:1949
msgid "``unsigned int irq_base``"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1929
#: ../kernel/irq/irqdomain.c:1948
msgid "Base IRQ number"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1930
msgid "Number of IRQs to allocate"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1931
msgid "Allocation data (arch/domain specific)"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1946
msgid "Free interrupts from parent domain"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1947
msgid "Domain below which interrupts must be freed"
msgstr ""

#: ../../../core-api/irq/irq-domain:310: ../kernel/irq/irqdomain.c:1949
msgid "Number of IRQs to free"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:314
msgid "Internal Functions Provided"
msgstr ""

#: ../../../core-api/irq/irq-domain.rst:316
msgid ""
"This chapter contains the autogenerated documentation of the internal "
"functions."
msgstr ""

#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:1994
msgid "Call domain_ops->activate recursively to activate interrupt"
msgstr ""

#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:1996
msgid "Outermost irq_data associated with interrupt"
msgstr ""

#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:1998
msgid "``bool reserve``"
msgstr ""

#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:1997
msgid "If set only reserve an interrupt vector instead of assigning one"
msgstr ""

#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:1998
msgid ""
"This is the second step to call domain_ops->activate to program interrupt "
"controllers, so the interrupt could actually get delivered."
msgstr ""

#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:2014
msgid "Call domain_ops->deactivate recursively to deactivate interrupt"
msgstr ""

#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:2016
msgid "outermost irq_data associated with interrupt"
msgstr ""

#: ../../../core-api/irq/irq-domain:319: ../kernel/irq/irqdomain.c:2017
msgid ""
"It calls domain_ops->deactivate to program interrupt controllers to disable "
"interrupt delivery."
msgstr ""
