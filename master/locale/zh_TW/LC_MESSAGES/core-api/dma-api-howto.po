# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-16 08:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/dma-api-howto.rst:3
msgid "Dynamic DMA mapping Guide"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:0
msgid "Author"
msgstr "作者"

#: ../../../core-api/dma-api-howto.rst:5
msgid "David S. Miller <davem@redhat.com>"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:6
msgid "Richard Henderson <rth@cygnus.com>"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:7
msgid "Jakub Jelinek <jakub@redhat.com>"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:9
msgid ""
"This is a guide to device driver writers on how to use the DMA API with "
"example pseudo-code.  For a concise description of the API, see "
"Documentation/core-api/dma-api.rst."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:14
msgid "CPU and DMA addresses"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:16
msgid ""
"There are several kinds of addresses involved in the DMA API, and it's "
"important to understand the differences."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:19
msgid ""
"The kernel normally uses virtual addresses.  Any address returned by "
"kmalloc(), vmalloc(), and similar interfaces is a virtual address and can be "
"stored in a ``void *``."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:23
msgid ""
"The virtual memory system (TLB, page tables, etc.) translates virtual "
"addresses to CPU physical addresses, which are stored as \"phys_addr_t\" or "
"\"resource_size_t\".  The kernel manages device resources like registers as "
"physical addresses.  These are the addresses in /proc/iomem.  The physical "
"address is not directly useful to a driver; it must use ioremap() to map the "
"space and produce a virtual address."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:30
msgid ""
"I/O devices use a third kind of address: a \"bus address\".  If a device has "
"registers at an MMIO address, or if it performs DMA to read or write system "
"memory, the addresses used by the device are bus addresses.  In some "
"systems, bus addresses are identical to CPU physical addresses, but in "
"general they are not.  IOMMUs and host bridges can produce arbitrary "
"mappings between physical and bus addresses."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:37
msgid ""
"From a device's point of view, DMA uses the bus address space, but it may be "
"restricted to a subset of that space.  For example, even if a system "
"supports 64-bit addresses for main memory and PCI BARs, it may use an IOMMU "
"so devices only need to use 32-bit DMA addresses."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:42
msgid "Here's a picture and some examples::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:66
msgid ""
"During the enumeration process, the kernel learns about I/O devices and "
"their MMIO space and the host bridges that connect them to the system.  For "
"example, if a PCI device has a BAR, the kernel reads the bus address (A) "
"from the BAR and converts it to a CPU physical address (B).  The address B "
"is stored in a struct resource and usually exposed via /proc/iomem.  When a "
"driver claims a device, it typically uses ioremap() to map physical address "
"B at a virtual address (C).  It can then use, e.g., ioread32(C), to access "
"the device registers at bus address A."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:75
msgid ""
"If the device supports DMA, the driver sets up a buffer using kmalloc() or a "
"similar interface, which returns a virtual address (X).  The virtual memory "
"system maps X to a physical address (Y) in system RAM.  The driver can use "
"virtual address X to access the buffer, but the device itself cannot because "
"DMA doesn't go through the CPU virtual memory system."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:81
msgid ""
"In some simple systems, the device can do DMA directly to physical address "
"Y.  But in many others, there is IOMMU hardware that translates DMA "
"addresses to physical addresses, e.g., it translates Z to Y.  This is part "
"of the reason for the DMA API: the driver can give a virtual address X to an "
"interface like dma_map_single(), which sets up any required IOMMU mapping "
"and returns the DMA address Z.  The driver then tells the device to do DMA "
"to Z, and the IOMMU maps it to the buffer at address Y in system RAM."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:90
msgid ""
"So that Linux can use the dynamic DMA mapping, it needs some help from the "
"drivers, namely it has to take into account that DMA addresses should be "
"mapped only for the time they are actually used and unmapped after the DMA "
"transfer."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:95
msgid ""
"The following API will work of course even on platforms where no such "
"hardware exists."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:98
msgid ""
"Note that the DMA API works with any bus independent of the underlying "
"microprocessor architecture. You should use the DMA API rather than the bus-"
"specific DMA API, i.e., use the dma_map_*() interfaces rather than the "
"pci_map_*() interfaces."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:103
msgid "First of all, you should make sure::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:107
msgid ""
"is in your driver, which provides the definition of dma_addr_t.  This type "
"can hold any valid DMA address for the platform and should be used "
"everywhere you hold a DMA address returned from the DMA mapping functions."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:112
msgid "What memory is DMA'able?"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:114
msgid ""
"The first piece of information you must know is what kernel memory can be "
"used with the DMA mapping facilities.  There has been an unwritten set of "
"rules regarding this, and this text is an attempt to finally write them down."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:119
msgid ""
"If you acquired your memory via the page allocator (i.e. __get_free_page*()) "
"or the generic memory allocators (i.e. kmalloc() or kmem_cache_alloc()) then "
"you may DMA to/from that memory using the addresses returned from those "
"routines."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:124
msgid ""
"This means specifically that you may _not_ use the memory/addresses returned "
"from vmalloc() for DMA.  It is possible to DMA to the _underlying_ memory "
"mapped into a vmalloc() area, but this requires walking page tables to get "
"the physical addresses, and then translating each of those pages back to a "
"kernel address using something like __va().  [ EDIT: Update this when we "
"integrate Gerd Knorr's generic code which does this. ]"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:132
msgid ""
"This rule also means that you may use neither kernel image addresses (items "
"in data/text/bss segments), nor module image addresses, nor stack addresses "
"for DMA.  These could all be mapped somewhere entirely different than the "
"rest of physical memory.  Even if those classes of memory could physically "
"work with DMA, you'd need to ensure the I/O buffers were cacheline-aligned.  "
"Without that, you'd see cacheline sharing problems (data corruption) on CPUs "
"with DMA-incoherent caches. (The CPU could write to one word, DMA would "
"write to a different one in the same cache line, and one of them could be "
"overwritten.)"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:142
msgid ""
"Also, this means that you cannot take the return of a kmap() call and DMA to/"
"from that.  This is similar to vmalloc()."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:145
msgid ""
"What about block I/O and networking buffers?  The block I/O and networking "
"subsystems make sure that the buffers they use are valid for you to DMA from/"
"to."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:150
msgid "__dma_from_device_group_begin/end annotations"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:152
msgid ""
"As explained previously, when a structure contains a DMA_FROM_DEVICE / "
"DMA_BIDIRECTIONAL buffer (device writes to memory) alongside fields that the "
"CPU writes to, cache line sharing between the DMA buffer and CPU-written "
"fields can cause data corruption on CPUs with DMA-incoherent caches."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:157
msgid ""
"The ``__dma_from_device_group_begin(GROUP)/"
"__dma_from_device_group_end(GROUP)`` macros ensure proper alignment to "
"prevent this::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:169
msgid ""
"To isolate a DMA buffer from adjacent fields, use "
"``__dma_from_device_group_begin(GROUP)`` before the first DMA buffer field "
"and ``__dma_from_device_group_end(GROUP)`` after the last DMA buffer field "
"(with the same GROUP name). This protects both the head and tail of the "
"buffer from cache line sharing."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:175
msgid ""
"The GROUP parameter is an optional identifier that names the DMA buffer "
"group (in case you have several in the same structure)::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:189
msgid ""
"On cache-coherent platforms these macros expand to zero-length array "
"markers. On non-coherent platforms, they also ensure the minimal DMA "
"alignment, which can be as large as 128 bytes."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:195
msgid ""
"It is allowed (though somewhat fragile) to include extra fields, not "
"intended for DMA from the device, within the group (in order to pack the "
"structure tightly) - but only as long as the CPU does not write these fields "
"while any fields in the group are mapped for DMA_FROM_DEVICE or "
"DMA_BIDIRECTIONAL."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:202
msgid "DMA addressing capabilities"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:204
msgid ""
"By default, the kernel assumes that your device can address 32-bits of DMA "
"addressing.  For a 64-bit capable device, this needs to be increased, and "
"for a device with limitations, it needs to be decreased."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:208
msgid ""
"Special note about PCI: PCI-X specification requires PCI-X devices to "
"support 64-bit addressing (DAC) for all transactions.  And at least one "
"platform (SGI SN2) requires 64-bit coherent allocations to operate correctly "
"when the IO bus is in PCI-X mode."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:213
msgid ""
"For correct operation, you must set the DMA mask to inform the kernel about "
"your devices DMA addressing capabilities."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:216
msgid "This is performed via a call to dma_set_mask_and_coherent()::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:220
msgid ""
"which will set the mask for both streaming and coherent APIs together.  If "
"you have some special requirements, then the following two separate calls "
"can be used instead:"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:224
msgid ""
"The setup for streaming mappings is performed via a call to dma_set_mask()::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:229
msgid ""
"The setup for coherent allocations is performed via a call to "
"dma_set_coherent_mask()::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:234
msgid ""
"Here, dev is a pointer to the device struct of your device, and mask is a "
"bit mask describing which bits of an address your device supports.  Often "
"the device struct of your device is embedded in the bus-specific device "
"struct of your device.  For example, &pdev->dev is a pointer to the device "
"struct of a PCI device (pdev is a pointer to the PCI device struct of your "
"device)."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:240
msgid ""
"These calls usually return zero to indicate your device can perform DMA "
"properly on the machine given the address mask you provided, but they might "
"return an error if the mask is too small to be supportable on the given "
"system.  If it returns non-zero, your device cannot perform DMA properly on "
"this platform, and attempting to do so will result in undefined behavior. "
"You must not use DMA on this device unless the dma_set_mask family of "
"functions has returned success."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:248
msgid "This means that in the failure case, you have two options:"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:250
msgid "Use some non-DMA mode for data transfer, if possible."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:251
msgid "Ignore this device and do not initialize it."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:253
msgid ""
"It is recommended that your driver print a kernel KERN_WARNING message when "
"setting the DMA mask fails.  In this manner, if a user of your driver "
"reports that performance is bad or that the device is not even detected, you "
"can ask them for the kernel messages to find out exactly why."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:258
msgid "The 24-bit addressing device would do something like this::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:265
msgid "The standard 64-bit addressing device would do something like this::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:269
msgid ""
"dma_set_mask_and_coherent() never return fail when DMA_BIT_MASK(64). Typical "
"error code like::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:276
msgid ""
"dma_set_mask_and_coherent() will never return failure when bigger than 32. "
"So typical code like::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:285
msgid ""
"If the device only supports 32-bit addressing for descriptors in the "
"coherent allocations, but supports full 64-bits for streaming mappings it "
"would look like this::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:294
msgid ""
"The coherent mask will always be able to set the same or a smaller mask as "
"the streaming mask. However for the rare case that a device driver only uses "
"coherent allocations, one would have to check the return value from "
"dma_set_coherent_mask()."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:299
msgid ""
"Finally, if your device can only drive the low 24-bits of address you might "
"do something like::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:307
msgid ""
"When dma_set_mask() or dma_set_mask_and_coherent() is successful, and "
"returns zero, the kernel saves away this mask you have provided.  The kernel "
"will use this information later when you make DMA mappings."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:311
msgid ""
"There is a case which we are aware of at this time, which is worth "
"mentioning in this documentation.  If your device supports multiple "
"functions (for example a sound card provides playback and record functions) "
"and the various different functions have _different_ DMA addressing "
"limitations, you may wish to probe each mask and only provide the "
"functionality which the machine can handle.  It is important that the last "
"call to dma_set_mask() be for the most specific mask."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:320
msgid "Here is pseudo-code showing how this might be done::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:344
msgid ""
"A sound card was used as an example here because this genre of PCI devices "
"seems to be littered with ISA chips given a PCI front end, and thus "
"retaining the 16MB DMA addressing limitations of ISA."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:349
msgid "Types of DMA mappings"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:351
msgid "There are two types of DMA mappings:"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:353
msgid ""
"Coherent DMA mappings which are usually mapped at driver initialization, "
"unmapped at the end and for which the hardware should guarantee that the "
"device and the CPU can access the data in parallel and will see updates made "
"by each other without any explicit software flushing."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:359
msgid "Think of \"coherent\" as \"synchronous\"."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:361
msgid ""
"The current default is to return coherent memory in the low 32 bits of the "
"DMA space.  However, for future compatibility you should set the coherent "
"mask even if this default is fine for your driver."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:366
msgid "Good examples of what to use coherent mappings for are:"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:368
msgid "Network card DMA ring descriptors."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:369
msgid "SCSI adapter mailbox command data structures."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:370
msgid "Device firmware microcode executed out of main memory."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:373
msgid ""
"The invariant these examples all require is that any CPU store to memory is "
"immediately visible to the device, and vice versa.  Coherent mappings "
"guarantee this."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:379
msgid ""
"Coherent DMA memory does not preclude the usage of proper memory barriers.  "
"The CPU may reorder stores to coherent memory just as it may normal memory.  "
"Example: if it is important for the device to see the first word of a "
"descriptor updated before the second, you must do something like::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:390
msgid "in order to get correct behavior on all platforms."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:392
msgid ""
"Also, on some platforms your driver may need to flush CPU write buffers in "
"much the same way as it needs to flush write buffers found in PCI bridges "
"(such as by reading a register's value after writing it)."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:397
msgid ""
"Streaming DMA mappings which are usually mapped for one DMA transfer, "
"unmapped right after it (unless you use dma_sync_* below) and for which "
"hardware can optimize for sequential accesses."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:401
msgid ""
"Think of \"streaming\" as \"asynchronous\" or \"outside the coherency "
"domain\"."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:404
msgid "Good examples of what to use streaming mappings for are:"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:406
msgid "Networking buffers transmitted/received by a device."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:407
msgid "Filesystem buffers written/read by a SCSI device."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:409
msgid ""
"The interfaces for using this type of mapping were designed in such a way "
"that an implementation can make whatever performance optimizations the "
"hardware allows.  To this end, when using such mappings you must be explicit "
"about what you want to happen."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:414
msgid ""
"Neither type of DMA mapping has alignment restrictions that come from the "
"underlying bus, although some devices may have such restrictions. Also, "
"systems with caches that aren't DMA-coherent will work better when the "
"underlying buffers don't share cache lines with other data."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:421
msgid "Using Coherent DMA mappings"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:423
msgid ""
"To allocate and map large (PAGE_SIZE or so) coherent DMA regions, you should "
"do::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:430
msgid ""
"where device is a ``struct device *``. This may be called in interrupt "
"context with the GFP_ATOMIC flag."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:433
msgid "Size is the length of the region you want to allocate, in bytes."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:435
msgid ""
"This routine will allocate RAM for that region, so it acts similarly to "
"__get_free_pages() (but takes size instead of a page order).  If your driver "
"needs regions sized smaller than a page, you may prefer using the dma_pool "
"interface, described below."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:440
msgid ""
"The coherent DMA mapping interfaces, will by default return a DMA address "
"which is 32-bit addressable.  Even if the device indicates (via the DMA "
"mask) that it may address the upper 32-bits, coherent allocation will only "
"return > 32-bit addresses for DMA if the coherent DMA mask has been "
"explicitly changed via dma_set_coherent_mask().  This is true of the "
"dma_pool interface as well."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:447
msgid ""
"dma_alloc_coherent() returns two values: the virtual address which you can "
"use to access it from the CPU and dma_handle which you pass to the card."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:451
msgid ""
"The CPU virtual address and the DMA address are both guaranteed to be "
"aligned to the smallest PAGE_SIZE order which is greater than or equal to "
"the requested size.  This invariant exists (for example) to guarantee that "
"if you allocate a chunk which is smaller than or equal to 64 kilobytes, the "
"extent of the buffer you receive will not cross a 64K boundary."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:458
msgid "To unmap and free such a DMA region, you call::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:462
msgid ""
"where dev, size are the same as in the above call and cpu_addr and "
"dma_handle are the values dma_alloc_coherent() returned to you. This "
"function may not be called in interrupt context."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:466
msgid ""
"If your driver needs lots of smaller memory regions, you can write custom "
"code to subdivide pages returned by dma_alloc_coherent(), or you can use the "
"dma_pool API to do that.  A dma_pool is like a kmem_cache, but it uses "
"dma_alloc_coherent(), not __get_free_pages(). Also, it understands common "
"hardware constraints for alignment, like queue heads needing to be aligned "
"on N byte boundaries."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:473
msgid "Create a dma_pool like this::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:479
msgid ""
"The \"name\" is for diagnostics (like a kmem_cache name); dev and size are "
"as above.  The device's hardware alignment requirement for this type of data "
"is \"align\" (which is expressed in bytes, and must be a power of two).  If "
"your device has no boundary crossing restrictions, pass 0 for boundary; "
"passing 4096 says memory allocated from this pool must not cross 4KByte "
"boundaries (but at that time it may be better to use dma_alloc_coherent() "
"directly instead)."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:487
msgid "Allocate memory from a DMA pool like this::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:491
msgid ""
"flags are GFP_KERNEL if blocking is permitted (not in_interrupt nor holding "
"SMP locks), GFP_ATOMIC otherwise.  Like dma_alloc_coherent(), this returns "
"two values, cpu_addr and dma_handle."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:495
msgid "Free memory that was allocated from a dma_pool like this::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:499
msgid ""
"where pool is what you passed to dma_pool_alloc(), and cpu_addr and "
"dma_handle are the values dma_pool_alloc() returned. This function may be "
"called in interrupt context."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:503
msgid "Destroy a dma_pool by calling::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:507
msgid ""
"Make sure you've called dma_pool_free() for all memory allocated from a pool "
"before you destroy the pool. This function may not be called in interrupt "
"context."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:512
msgid "DMA Direction"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:514
msgid ""
"The interfaces described in subsequent portions of this document take a DMA "
"direction argument, which is an integer and takes on one of the following "
"values::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:523
msgid "You should provide the exact DMA direction if you know it."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:525
msgid ""
"DMA_TO_DEVICE means \"from main memory to the device\" DMA_FROM_DEVICE means "
"\"from the device to main memory\" It is the direction in which the data "
"moves during the DMA transfer."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:530
msgid ""
"You are _strongly_ encouraged to specify this as precisely as you possibly "
"can."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:533
msgid ""
"If you absolutely cannot know the direction of the DMA transfer, specify "
"DMA_BIDIRECTIONAL.  It means that the DMA can go in either direction.  The "
"platform guarantees that you may legally specify this, and that it will "
"work, but this may be at the cost of performance for example."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:539
msgid ""
"The value DMA_NONE is to be used for debugging.  One can hold this in a data "
"structure before you come to know the precise direction, and this will help "
"catch cases where your direction tracking logic has failed to set things up "
"properly."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:544
msgid ""
"Another advantage of specifying this value precisely (outside of potential "
"platform-specific optimizations of such) is for debugging. Some platforms "
"actually have a write permission boolean which DMA mappings can be marked "
"with, much like page protections in the user program address space.  Such "
"platforms can and do report errors in the kernel logs when the DMA "
"controller hardware detects violation of the permission setting."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:552
msgid ""
"Only streaming mappings specify a direction, coherent mappings implicitly "
"have a direction attribute setting of DMA_BIDIRECTIONAL."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:556
msgid ""
"The SCSI subsystem tells you the direction to use in the 'sc_data_direction' "
"member of the SCSI command your driver is working on."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:560
msgid ""
"For Networking drivers, it's a rather simple affair.  For transmit packets, "
"map/unmap them with the DMA_TO_DEVICE direction specifier.  For receive "
"packets, just the opposite, map/unmap them with the DMA_FROM_DEVICE "
"direction specifier."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:566
msgid "Using Streaming DMA mappings"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:568
msgid ""
"The streaming DMA mapping routines can be called from interrupt context.  "
"There are two versions of each map/unmap, one which will map/unmap a single "
"memory region, and one which will map/unmap a scatterlist."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:573
msgid "To map a single region, you do::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:590
msgid "and to unmap it::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:594
msgid ""
"You should call dma_mapping_error() as dma_map_single() could fail and "
"return error.  Doing so will ensure that the mapping code will work "
"correctly on all DMA implementations without any dependency on the specifics "
"of the underlying implementation. Using the returned address without "
"checking for errors could result in failures ranging from panics to silent "
"data corruption.  The same applies to dma_map_page() as well."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:601
msgid ""
"You should call dma_unmap_single() when the DMA activity is finished, e.g., "
"from the interrupt which told you that the DMA transfer is done."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:604
msgid ""
"Using CPU pointers like this for single mappings has a disadvantage: you "
"cannot reference HIGHMEM memory in this way.  Thus, there is a map/unmap "
"interface pair akin to dma_{map,unmap}_single().  These interfaces deal with "
"page/offset pairs instead of CPU pointers. Specifically::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:630
msgid "Here, \"offset\" means byte offset within the given page."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:632
msgid ""
"You should call dma_mapping_error() as dma_map_page() could fail and return "
"error as outlined under the dma_map_single() discussion."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:635
msgid ""
"You should call dma_unmap_page() when the DMA activity is finished, e.g., "
"from the interrupt which told you that the DMA transfer is done."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:638
msgid "With scatterlists, you map a region gathered from several regions by::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:648
msgid "where nents is the number of entries in the sglist."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:650
msgid ""
"The implementation is free to merge several consecutive sglist entries into "
"one (e.g. if DMA mapping is done with PAGE_SIZE granularity, any consecutive "
"sglist entries can be merged into one provided the first one ends and the "
"second one starts on a page boundary - in fact this is a huge advantage for "
"cards which either cannot do scatter-gather or have very limited number of "
"scatter-gather entries) and returns the actual number of sg entries it "
"mapped them to. On failure 0 is returned."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:658
msgid ""
"Then you should loop count times (note: this can be less than nents times) "
"and use sg_dma_address() and sg_dma_len() macros where you previously "
"accessed sg->address and sg->length as shown above."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:662
msgid "To unmap a scatterlist, just call::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:666
msgid "Again, make sure DMA activity has already finished."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:670
msgid ""
"The 'nents' argument to the dma_unmap_sg call must be the _same_ one you "
"passed into the dma_map_sg call, it should _NOT_ be the 'count' value "
"_returned_ from the dma_map_sg call."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:675
msgid ""
"Every dma_map_{single,sg}() call should have its dma_unmap_{single,sg}() "
"counterpart, because the DMA address space is a shared resource and you "
"could render the machine unusable by consuming all DMA addresses."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:679
msgid ""
"If you need to use the same streaming DMA region multiple times and touch "
"the data in between the DMA transfers, the buffer needs to be synced "
"properly in order for the CPU and device to see the most up-to-date and "
"correct copy of the DMA buffer."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:684
msgid ""
"So, firstly, just map it with dma_map_{single,sg}(), and after each DMA "
"transfer call either::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:689
#: ../../../core-api/dma-api-howto.rst:701
msgid "or::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:693
#: ../../../core-api/dma-api-howto.rst:705
msgid "as appropriate."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:695
msgid ""
"Then, if you wish to let the device get at the DMA area again, finish "
"accessing the data with the CPU, and then before actually giving the buffer "
"to the hardware call either::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:709
msgid ""
"The 'nents' argument to dma_sync_sg_for_cpu() and dma_sync_sg_for_device() "
"must be the same passed to dma_map_sg(). It is _NOT_ the count returned by "
"dma_map_sg()."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:714
msgid ""
"After the last DMA transfer call one of the DMA unmap routines "
"dma_unmap_{single,sg}(). If you don't touch the data from the first "
"dma_map_*() call till dma_unmap_*(), then you don't have to call the "
"dma_sync_*() routines at all."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:719
msgid ""
"Here is pseudo code which shows a situation in which you would need to use "
"the dma_sync_*() interfaces::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:783
msgid "Handling Errors"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:785
msgid ""
"DMA address space is limited on some architectures and an allocation failure "
"can be determined by:"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:788
msgid "checking if dma_alloc_coherent() returns NULL or dma_map_sg returns 0"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:790
msgid ""
"checking the dma_addr_t returned from dma_map_single() and dma_map_page() by "
"using dma_mapping_error()::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:805
msgid ""
"unmap pages that are already mapped, when mapping error occurs in the middle "
"of a multiple page mapping attempt. These example are applicable to "
"dma_map_page() as well."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:809
msgid "Example 1::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:839
msgid "Example 2::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:878
msgid ""
"Networking drivers must call dev_kfree_skb() to free the socket buffer and "
"return NETDEV_TX_OK if the DMA mapping fails on the transmit hook "
"(ndo_start_xmit). This means that the socket buffer is just dropped in the "
"failure case."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:883
msgid ""
"SCSI drivers must return SCSI_MLQUEUE_HOST_BUSY if the DMA mapping fails in "
"the queuecommand hook. This means that the SCSI subsystem passes the command "
"to the driver again later."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:888
msgid "Optimizing Unmap State Space Consumption"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:890
msgid ""
"On many platforms, dma_unmap_{single,page}() is simply a nop. Therefore, "
"keeping track of the mapping address and length is a waste of space.  "
"Instead of filling your drivers up with ifdefs and the like to \"work "
"around\" this (which would defeat the whole purpose of a portable API) the "
"following facilities are provided."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:896
msgid ""
"Actually, instead of describing the macros one by one, we'll transform some "
"example code."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:899
msgid ""
"Use DEFINE_DMA_UNMAP_{ADDR,LEN} in state saving structures. Example, before::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:908
#: ../../../core-api/dma-api-howto.rst:922
#: ../../../core-api/dma-api-howto.rst:933
msgid "after::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:916
msgid "Use dma_unmap_{addr,len}_set() to set these values. Example, before::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:927
msgid "Use dma_unmap_{addr,len}() to access these values. Example, before::"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:940
msgid ""
"It really should be self-explanatory.  We treat the ADDR and LEN separately, "
"because it is possible for an implementation to only need the address in "
"order to perform the unmap operation."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:945
msgid "Platform Issues"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:947
msgid ""
"If you are just writing drivers for Linux and do not maintain an "
"architecture port for the kernel, you can safely skip down to \"Closing\"."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:951
msgid "Struct scatterlist requirements."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:953
msgid ""
"You need to enable CONFIG_NEED_SG_DMA_LENGTH if the architecture supports "
"IOMMUs (including software IOMMU)."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:956
msgid "ARCH_DMA_MINALIGN"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:958
msgid ""
"Architectures must ensure that kmalloc'ed buffer is DMA-safe. Drivers and "
"subsystems depend on it. If an architecture isn't fully DMA-coherent (i.e. "
"hardware doesn't ensure that data in the CPU cache is identical to data in "
"main memory), ARCH_DMA_MINALIGN must be set so that the memory allocator "
"makes sure that kmalloc'ed buffer doesn't share a cache line with the "
"others. See arch/arm/include/asm/cache.h as an example."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:966
msgid ""
"Note that ARCH_DMA_MINALIGN is about DMA memory alignment constraints. You "
"don't need to worry about the architecture data alignment constraints (e.g. "
"the alignment constraints about 64-bit objects)."
msgstr ""

#: ../../../core-api/dma-api-howto.rst:972
msgid "Closing"
msgstr ""

#: ../../../core-api/dma-api-howto.rst:974
msgid ""
"This document, and the API itself, would not be in its current form without "
"the feedback and suggestions from numerous individuals. We would like to "
"specifically mention, in no particular order, the following people::"
msgstr ""
