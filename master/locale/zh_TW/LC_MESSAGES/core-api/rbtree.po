# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/rbtree.rst:3
msgid "Red-black Trees (rbtree) in Linux"
msgstr ""

#: ../../../core-api/rbtree.rst:0
msgid "Date"
msgstr ""

#: ../../../core-api/rbtree.rst:6
msgid "January 18, 2007"
msgstr ""

#: ../../../core-api/rbtree.rst:0
msgid "Author"
msgstr ""

#: ../../../core-api/rbtree.rst:7
msgid "Rob Landley <rob@landley.net>"
msgstr ""

#: ../../../core-api/rbtree.rst:10
msgid "What are red-black trees, and what are they for?"
msgstr ""

#: ../../../core-api/rbtree.rst:12
msgid ""
"Red-black trees are a type of self-balancing binary search tree, used for "
"storing sortable key/value data pairs.  This differs from radix trees (which "
"are used to efficiently store sparse arrays and thus use long integer "
"indexes to insert/access/delete nodes) and hash tables (which are not kept "
"sorted to be easily traversed in order, and must be tuned for a specific "
"size and hash function where rbtrees scale gracefully storing arbitrary "
"keys)."
msgstr ""

#: ../../../core-api/rbtree.rst:19
msgid ""
"Red-black trees are similar to AVL trees, but provide faster real-time "
"bounded worst case performance for insertion and deletion (at most two "
"rotations and three rotations, respectively, to balance the tree), with "
"slightly slower (but still O(log n)) lookup time."
msgstr ""

#: ../../../core-api/rbtree.rst:24
msgid "To quote Linux Weekly News:"
msgstr ""

#: ../../../core-api/rbtree.rst:26
msgid ""
"There are a number of red-black trees in use in the kernel. The deadline and "
"CFQ I/O schedulers employ rbtrees to track requests; the packet CD/DVD "
"driver does the same. The high-resolution timer code uses an rbtree to "
"organize outstanding timer requests.  The ext3 filesystem tracks directory "
"entries in a red-black tree.  Virtual memory areas (VMAs) are tracked with "
"red-black trees, as are epoll file descriptors, cryptographic keys, and "
"network packets in the \"hierarchical token bucket\" scheduler."
msgstr ""

#: ../../../core-api/rbtree.rst:35
msgid ""
"This document covers use of the Linux rbtree implementation.  For more "
"information on the nature and implementation of Red Black Trees,  see:"
msgstr ""

#: ../../../core-api/rbtree.rst:38
msgid "Linux Weekly News article on red-black trees"
msgstr ""

#: ../../../core-api/rbtree.rst:39
msgid "https://lwn.net/Articles/184495/"
msgstr ""

#: ../../../core-api/rbtree.rst:41
msgid "Wikipedia entry on red-black trees"
msgstr ""

#: ../../../core-api/rbtree.rst:42
msgid "https://en.wikipedia.org/wiki/Red-black_tree"
msgstr ""

#: ../../../core-api/rbtree.rst:45
msgid "Linux implementation of red-black trees"
msgstr ""

#: ../../../core-api/rbtree.rst:47
msgid ""
"Linux's rbtree implementation lives in the file \"lib/rbtree.c\".  To use "
"it, \"#include <linux/rbtree.h>\"."
msgstr ""

#: ../../../core-api/rbtree.rst:50
msgid ""
"The Linux rbtree implementation is optimized for speed, and thus has one "
"less layer of indirection (and better cache locality) than more traditional "
"tree implementations.  Instead of using pointers to separate rb_node and "
"data structures, each instance of struct rb_node is embedded in the data "
"structure it organizes.  And instead of using a comparison callback function "
"pointer, users are expected to write their own tree search and insert "
"functions which call the provided rbtree functions.  Locking is also left up "
"to the user of the rbtree code."
msgstr ""

#: ../../../core-api/rbtree.rst:60
msgid "Creating a new rbtree"
msgstr ""

#: ../../../core-api/rbtree.rst:62
msgid ""
"Data nodes in an rbtree tree are structures containing a struct rb_node "
"member::"
msgstr ""

#: ../../../core-api/rbtree.rst:69
msgid ""
"When dealing with a pointer to the embedded struct rb_node, the containing "
"data structure may be accessed with the standard container_of() macro.  In "
"addition, individual members may be accessed directly via rb_entry(node, "
"type, member)."
msgstr ""

#: ../../../core-api/rbtree.rst:73
msgid ""
"At the root of each rbtree is an rb_root structure, which is initialized to "
"be empty via:"
msgstr ""

#: ../../../core-api/rbtree.rst:76
msgid "struct rb_root mytree = RB_ROOT;"
msgstr ""

#: ../../../core-api/rbtree.rst:79
msgid "Searching for a value in an rbtree"
msgstr ""

#: ../../../core-api/rbtree.rst:81
msgid ""
"Writing a search function for your tree is fairly straightforward: start at "
"the root, compare each value, and follow the left or right branch as "
"necessary."
msgstr ""

#: ../../../core-api/rbtree.rst:84 ../../../core-api/rbtree.rst:116
#: ../../../core-api/rbtree.rst:150 ../../../core-api/rbtree.rst:190
msgid "Example::"
msgstr ""

#: ../../../core-api/rbtree.rst:107
msgid "Inserting data into an rbtree"
msgstr ""

#: ../../../core-api/rbtree.rst:109
msgid ""
"Inserting data in the tree involves first searching for the place to insert "
"the new node, then inserting the node and rebalancing (\"recoloring\") the "
"tree."
msgstr ""

#: ../../../core-api/rbtree.rst:112
msgid ""
"The search for insertion differs from the previous search by finding the "
"location of the pointer on which to graft the new node.  The new node also "
"needs a link to its parent node for rebalancing purposes."
msgstr ""

#: ../../../core-api/rbtree.rst:144
msgid "Removing or replacing existing data in an rbtree"
msgstr ""

#: ../../../core-api/rbtree.rst:146
msgid "To remove an existing node from a tree, call::"
msgstr ""

#: ../../../core-api/rbtree.rst:159
msgid ""
"To replace an existing node in a tree with a new one with the same key, "
"call::"
msgstr ""

#: ../../../core-api/rbtree.rst:164
msgid ""
"Replacing a node this way does not re-sort the tree: If the new node doesn't "
"have the same key as the old node, the rbtree will probably become corrupted."
msgstr ""

#: ../../../core-api/rbtree.rst:168
msgid "Iterating through the elements stored in an rbtree (in sort order)"
msgstr ""

#: ../../../core-api/rbtree.rst:170
msgid ""
"Four functions are provided for iterating through an rbtree's contents in "
"sorted order.  These work on arbitrary trees, and should not need to be "
"modified or wrapped (except for locking purposes)::"
msgstr ""

#: ../../../core-api/rbtree.rst:179
msgid ""
"To start iterating, call rb_first() or rb_last() with a pointer to the root "
"of the tree, which will return a pointer to the node structure contained in "
"the first or last element in the tree.  To continue, fetch the next or "
"previous node by calling rb_next() or rb_prev() on the current node.  This "
"will return NULL when there are no more nodes left."
msgstr ""

#: ../../../core-api/rbtree.rst:185
msgid ""
"The iterator functions return a pointer to the embedded struct rb_node, from "
"which the containing data structure may be accessed with the container_of() "
"macro, and individual members may be accessed directly via rb_entry(node, "
"type, member)."
msgstr ""

#: ../../../core-api/rbtree.rst:197
msgid "Cached rbtrees"
msgstr ""

#: ../../../core-api/rbtree.rst:199
msgid ""
"Computing the leftmost (smallest) node is quite a common task for binary "
"search trees, such as for traversals or users relying on a the particular "
"order for their own logic. To this end, users can use 'struct "
"rb_root_cached' to optimize O(logN) rb_first() calls to a simple pointer "
"fetch avoiding potentially expensive tree iterations. This is done at "
"negligible runtime overhead for maintenance; albeit larger memory footprint."
msgstr ""

#: ../../../core-api/rbtree.rst:206
msgid ""
"Similar to the rb_root structure, cached rbtrees are initialized to be empty "
"via::"
msgstr ""

#: ../../../core-api/rbtree.rst:211
msgid ""
"Cached rbtree is simply a regular rb_root with an extra pointer to cache the "
"leftmost node. This allows rb_root_cached to exist wherever rb_root does, "
"which permits augmented trees to be supported as well as only a few extra "
"interfaces::"
msgstr ""

#: ../../../core-api/rbtree.rst:220
msgid ""
"Both insert and erase calls have their respective counterpart of augmented "
"trees::"
msgstr ""

#: ../../../core-api/rbtree.rst:230
msgid "Support for Augmented rbtrees"
msgstr ""

#: ../../../core-api/rbtree.rst:232
msgid ""
"Augmented rbtree is an rbtree with \"some\" additional data stored in each "
"node, where the additional data for node N must be a function of the "
"contents of all nodes in the subtree rooted at N. This data can be used to "
"augment some new functionality to rbtree. Augmented rbtree is an optional "
"feature built on top of basic rbtree infrastructure. An rbtree user who "
"wants this feature will have to call the augmentation functions with the "
"user provided augmentation callback when inserting and erasing nodes."
msgstr ""

#: ../../../core-api/rbtree.rst:241
msgid ""
"C files implementing augmented rbtree manipulation must include <linux/"
"rbtree_augmented.h> instead of <linux/rbtree.h>. Note that linux/"
"rbtree_augmented.h exposes some rbtree implementations details you are not "
"expected to rely on; please stick to the documented APIs there and do not "
"include <linux/rbtree_augmented.h> from header files either so as to "
"minimize chances of your users accidentally relying on such implementation "
"details."
msgstr ""

#: ../../../core-api/rbtree.rst:249
msgid ""
"On insertion, the user must update the augmented information on the path "
"leading to the inserted node, then call rb_link_node() as usual and "
"rb_augment_inserted() instead of the usual rb_insert_color() call. If "
"rb_augment_inserted() rebalances the rbtree, it will callback into a user "
"provided function to update the augmented information on the affected "
"subtrees."
msgstr ""

#: ../../../core-api/rbtree.rst:256
msgid ""
"When erasing a node, the user must call rb_erase_augmented() instead of "
"rb_erase(). rb_erase_augmented() calls back into user provided functions to "
"updated the augmented information on affected subtrees."
msgstr ""

#: ../../../core-api/rbtree.rst:260
msgid ""
"In both cases, the callbacks are provided through struct "
"rb_augment_callbacks. 3 callbacks must be defined:"
msgstr ""

#: ../../../core-api/rbtree.rst:263
msgid ""
"A propagation callback, which updates the augmented value for a given node "
"and its ancestors, up to a given stop point (or NULL to update all the way "
"to the root)."
msgstr ""

#: ../../../core-api/rbtree.rst:267
msgid ""
"A copy callback, which copies the augmented value for a given subtree to a "
"newly assigned subtree root."
msgstr ""

#: ../../../core-api/rbtree.rst:270
msgid ""
"A tree rotation callback, which copies the augmented value for a given "
"subtree to a newly assigned subtree root AND recomputes the augmented "
"information for the former subtree root."
msgstr ""

#: ../../../core-api/rbtree.rst:274
msgid ""
"The compiled code for rb_erase_augmented() may inline the propagation and "
"copy callbacks, which results in a large function, so each augmented rbtree "
"user should have a single rb_erase_augmented() call site in order to limit "
"compiled code size."
msgstr ""

#: ../../../core-api/rbtree.rst:281
msgid "Sample usage"
msgstr ""

#: ../../../core-api/rbtree.rst:283
msgid ""
"Interval tree is an example of augmented rb tree. Reference - \"Introduction "
"to Algorithms\" by Cormen, Leiserson, Rivest and Stein. More details about "
"interval trees:"
msgstr ""

#: ../../../core-api/rbtree.rst:287
msgid ""
"Classical rbtree has a single key and it cannot be directly used to store "
"interval ranges like [lo:hi] and do a quick lookup for any overlap with a "
"new lo:hi or to find whether there is an exact match for a new lo:hi."
msgstr ""

#: ../../../core-api/rbtree.rst:291
msgid ""
"However, rbtree can be augmented to store such interval ranges in a "
"structured way making it possible to do efficient lookup and exact match."
msgstr ""

#: ../../../core-api/rbtree.rst:294
msgid ""
"This \"extra information\" stored in each node is the maximum hi (max_hi) "
"value among all the nodes that are its descendants. This information can be "
"maintained at each node just be looking at the node and its immediate "
"children. And this will be used in O(log n) lookup for lowest match (lowest "
"start address among all possible matches) with something like::"
msgstr ""

#: ../../../core-api/rbtree.rst:343
msgid "Insertion/removal are defined using the following augmented callbacks::"
msgstr ""
