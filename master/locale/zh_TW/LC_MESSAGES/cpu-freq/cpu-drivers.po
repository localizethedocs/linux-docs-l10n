# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../cpu-freq/cpu-drivers.rst:5
msgid "How to Implement a new CPUFreq Processor Driver"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:7
msgid "Authors:"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:10
msgid "Dominik Brodowski  <linux@brodo.de>"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:11
msgid "Rafael J. Wysocki <rafael.j.wysocki@intel.com>"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:12
msgid "Viresh Kumar <viresh.kumar@linaro.org>"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:29
msgid "1. What To Do?"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:31
msgid ""
"So, you just got a brand-new CPU / chipset with datasheets and want to add "
"cpufreq support for this CPU / chipset? Great. Here are some hints on what "
"is necessary:"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:37
msgid "1.1 Initialization"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:39
msgid ""
"First of all, in an __initcall level 7 (module_init()) or later function "
"check whether this kernel runs on the right CPU and the right chipset. If "
"so, register a struct cpufreq_driver with the CPUfreq core using "
"cpufreq_register_driver()"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:44
msgid "What shall this struct cpufreq_driver contain?"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:46
msgid ".name - The name of this driver."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:48
msgid ".init - A pointer to the per-policy initialization function."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:50
msgid ".verify - A pointer to a \"verification\" function."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:52
msgid ""
".setpolicy _or_ .fast_switch _or_ .target _or_ .target_index - See below on "
"the differences."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:55
msgid "And optionally"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:57
msgid ".flags - Hints for the cpufreq core."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:59
msgid ".driver_data - cpufreq driver specific data."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:61
msgid ""
".get_intermediate and target_intermediate - Used to switch to stable "
"frequency while changing CPU frequency."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:64
msgid ".get - Returns current frequency of the CPU."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:66
msgid ".bios_limit - Returns HW/BIOS max frequency limitations for the CPU."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:68
msgid ""
".exit - A pointer to a per-policy cleanup function called during "
"CPU_POST_DEAD phase of cpu hotplug process."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:71
msgid ""
".suspend - A pointer to a per-policy suspend function which is called with "
"interrupts disabled and _after_ the governor is stopped for the policy."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:75
msgid ""
".resume - A pointer to a per-policy resume function which is called with "
"interrupts disabled and _before_ the governor is started again."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:78
msgid ""
".ready - A pointer to a per-policy ready function which is called after the "
"policy is fully initialized."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:81
msgid ""
".attr - A pointer to a NULL-terminated list of \"struct freq_attr\" which "
"allow to export values to sysfs."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:84
msgid ".boost_enabled - If set, boost frequencies are enabled."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:86
msgid ""
".set_boost - A pointer to a per-policy function to enable/disable boost "
"frequencies."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:91
msgid "1.2 Per-CPU Initialization"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:93
msgid ""
"Whenever a new CPU is registered with the device model, or after the cpufreq "
"driver registers itself, the per-policy initialization function "
"cpufreq_driver.init is called if no cpufreq policy existed for the CPU. Note "
"that the .init() and .exit() routines are called only once for the policy "
"and not for each CPU managed by the policy. It takes a ``struct "
"cpufreq_policy *policy`` as argument. What to do now?"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:100
msgid "If necessary, activate the CPUfreq support on your CPU."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:102
msgid "Then, the driver must fill in the following values:"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:105
msgid "policy->cpuinfo.min_freq _and_ policy->cpuinfo.max_freq"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:106
msgid ""
"the minimum and maximum frequency (in kHz) which is supported by this CPU"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:110
msgid "policy->cpuinfo.transition_latency"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:110
msgid ""
"the time it takes on this CPU to switch between two frequencies in "
"nanoseconds (if appropriate, else specify CPUFREQ_ETERNAL)"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:115
msgid "policy->cur"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:115
msgid "The current operating frequency of this CPU (if appropriate)"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:118
msgid ""
"policy->min, policy->max, policy->policy and, if necessary, policy->governor"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:121
msgid ""
"must contain the \"default policy\" for this CPU. A few moments later, "
"cpufreq_driver.verify and either cpufreq_driver.setpolicy or cpufreq_driver."
"target/target_index is called with these values."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:128
msgid "policy->cpus"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:128
msgid ""
"Update this with the masks of the (online + offline) CPUs that do DVFS along "
"with this CPU (i.e.  that share clock/voltage rails with it)."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:134
msgid ""
"For setting some of these values (cpuinfo.min[max]_freq, policy->min[max]), "
"the frequency table helpers might be helpful. See the section 2 for more "
"information on them."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:140
msgid "1.3 verify"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:142
msgid ""
"When the user decides a new policy (consisting of \"policy,governor,min,"
"max\") shall be set, this policy must be validated so that incompatible "
"values can be corrected. For verifying these values "
"cpufreq_verify_within_limits(``struct cpufreq_policy *policy``, ``unsigned "
"int min_freq``, ``unsigned int max_freq``) function might be helpful. See "
"section 2 for details on frequency table helpers."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:149
msgid ""
"You need to make sure that at least one valid frequency (or operating range) "
"is within policy->min and policy->max. If necessary, increase policy->max "
"first, and only if this is no solution, decrease policy->min."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:155
msgid "1.4 target or target_index or setpolicy or fast_switch?"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:157
msgid ""
"Most cpufreq drivers or even most cpu frequency scaling algorithms only "
"allow the CPU frequency to be set to predefined fixed values. For these, you "
"use the ->target(), ->target_index() or ->fast_switch() callbacks."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:162
msgid ""
"Some cpufreq capable processors switch the frequency between certain limits "
"on their own. These shall use the ->setpolicy() callback."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:167
msgid "1.5. target/target_index"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:169
msgid ""
"The target_index call has two arguments: ``struct cpufreq_policy *policy``, "
"and ``unsigned int`` index (into the exposed frequency table)."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:172
msgid ""
"The CPUfreq driver must set the new frequency when called here. The actual "
"frequency must be determined by freq_table[index].frequency."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:175
msgid ""
"It should always restore to earlier frequency (i.e. policy->restore_freq) in "
"case of errors, even if we switched to intermediate frequency earlier."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:179
msgid "Deprecated"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:180
msgid ""
"The target call has three arguments: ``struct cpufreq_policy *policy``, "
"unsigned int target_frequency, unsigned int relation."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:183
msgid ""
"The CPUfreq driver must set the new frequency when called here. The actual "
"frequency must be determined using the following rules:"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:186
msgid "keep close to \"target_freq\""
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:187
msgid "policy->min <= new_freq <= policy->max (THIS MUST BE VALID!!!)"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:188
msgid ""
"if relation==CPUFREQ_REL_L, try to select a new_freq higher than or equal "
"target_freq. (\"L for lowest, but no lower than\")"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:190
msgid ""
"if relation==CPUFREQ_REL_H, try to select a new_freq lower than or equal "
"target_freq. (\"H for highest, but no higher than\")"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:193
msgid ""
"Here again the frequency table helper might assist you - see section 2 for "
"details."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:197
msgid "1.6. fast_switch"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:199
msgid ""
"This function is used for frequency switching from scheduler's context. Not "
"all drivers are expected to implement it, as sleeping from within this "
"callback isn't allowed. This callback must be highly optimized to do "
"switching as fast as possible."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:204
msgid ""
"This function has two arguments: ``struct cpufreq_policy *policy`` and "
"``unsigned int target_frequency``."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:209
msgid "1.7 setpolicy"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:211
msgid ""
"The setpolicy call only takes a ``struct cpufreq_policy *policy`` as "
"argument. You need to set the lower limit of the in-processor or in-chipset "
"dynamic frequency switching to policy->min, the upper limit to policy->max, "
"and -if supported- select a performance-oriented setting when policy->policy "
"is CPUFREQ_POLICY_PERFORMANCE, and a powersaving-oriented setting when "
"CPUFREQ_POLICY_POWERSAVE. Also check the reference implementation in drivers/"
"cpufreq/longrun.c"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:220
msgid "1.8 get_intermediate and target_intermediate"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:222
msgid ""
"Only for drivers with target_index() and CPUFREQ_ASYNC_NOTIFICATION unset."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:224
msgid ""
"get_intermediate should return a stable intermediate frequency platform "
"wants to switch to, and target_intermediate() should set CPU to that "
"frequency, before jumping to the frequency corresponding to 'index'. Core "
"will take care of sending notifications and driver doesn't have to handle "
"them in target_intermediate() or target_index()."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:230
msgid ""
"Drivers can return '0' from get_intermediate() in case they don't wish to "
"switch to intermediate frequency for some target frequency. In that case "
"core will directly call ->target_index()."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:234
msgid ""
"NOTE: ->target_index() should restore to policy->restore_freq in case of "
"failures as core would send notifications for that."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:239
msgid "2. Frequency Table Helpers"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:241
msgid ""
"As most cpufreq processors only allow for being set to a few specific "
"frequencies, a \"frequency table\" with some functions might assist in some "
"work of the processor driver. Such a \"frequency table\" consists of an "
"array of struct cpufreq_frequency_table entries, with driver specific values "
"in \"driver_data\", the corresponding frequency in \"frequency\" and flags "
"set. At the end of the table, you need to add a cpufreq_frequency_table "
"entry with frequency set to CPUFREQ_TABLE_END. And if you want to skip one "
"entry in the table, set the frequency to CPUFREQ_ENTRY_INVALID. The entries "
"don't need to be in sorted in any particular order, but if they are cpufreq "
"core will do DVFS a bit quickly for them as search for best match is faster."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:253
msgid ""
"The cpufreq table is verified automatically by the core if the policy "
"contains a valid pointer in its policy->freq_table field."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:256
msgid ""
"cpufreq_frequency_table_verify() assures that at least one valid frequency "
"is within policy->min and policy->max, and all other criteria are met. This "
"is helpful for the ->verify call."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:260
msgid ""
"cpufreq_frequency_table_target() is the corresponding frequency table helper "
"for the ->target stage. Just pass the values to this function, and this "
"function returns the of the frequency table entry which contains the "
"frequency the CPU shall be set to."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:265
msgid ""
"The following macros can be used as iterators over cpufreq_frequency_table:"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:267
msgid ""
"cpufreq_for_each_entry(pos, table) - iterates over all entries of frequency "
"table."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:270
msgid ""
"cpufreq_for_each_valid_entry(pos, table) - iterates over all entries, "
"excluding CPUFREQ_ENTRY_INVALID frequencies. Use arguments \"pos\" - a "
"``cpufreq_frequency_table *`` as a loop cursor and \"table\" - the "
"``cpufreq_frequency_table *`` you want to iterate over."
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:275
msgid "For example::"
msgstr ""

#: ../../../cpu-freq/cpu-drivers.rst:284
msgid ""
"If you need to work with the position of pos within driver_freq_table, do "
"not subtract the pointers, as it is quite costly. Instead, use the macros "
"cpufreq_for_each_entry_idx() and cpufreq_for_each_valid_entry_idx()."
msgstr ""
