# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../scsi/scsi_mid_low_api.rst:5
msgid "SCSI mid_level - lower_level driver interface"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:8
msgid "Introduction"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:9
msgid ""
"This document outlines the interface between the Linux SCSI mid level and "
"SCSI lower level drivers. Lower level drivers (LLDs) are variously called "
"host bus adapter (HBA) drivers and host drivers (HD). A \"host\" in this "
"context is a bridge between a computer IO bus (e.g. PCI or ISA) and a single "
"SCSI initiator port on a SCSI transport. An \"initiator\" port (SCSI "
"terminology, see SAM-3 at http://www.t10.org) sends SCSI commands to "
"\"target\" SCSI ports (e.g. disks). There can be many LLDs in a running "
"system, but only one per hardware type. Most LLDs can control one or more "
"SCSI HBAs. Some HBAs contain multiple hosts."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:19
msgid ""
"In some cases the SCSI transport is an external bus that already has its own "
"subsystem in Linux (e.g. USB and ieee1394). In such cases the SCSI subsystem "
"LLD is a software bridge to the other driver subsystem. Examples are the usb-"
"storage driver (found in the drivers/usb/storage directory) and the ieee1394/"
"sbp2 driver (found in the drivers/ieee1394 directory)."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:26
msgid ""
"For example, the aic7xxx LLD controls Adaptec SCSI parallel interface (SPI) "
"controllers based on that company's 7xxx chip series. The aic7xxx LLD can be "
"built into the kernel or loaded as a module. There can only be one aic7xxx "
"LLD running in a Linux system but it may be controlling many HBAs. These "
"HBAs might be either on PCI daughter-boards or built into the motherboard "
"(or both). Some aic7xxx based HBAs are dual controllers and thus represent "
"two hosts. Like most modern HBAs, each aic7xxx host has its own PCI device "
"address. [The one-to-one correspondence between a SCSI host and a PCI device "
"is common but not required (e.g. with ISA adapters).]"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:37
msgid ""
"The SCSI mid level isolates an LLD from other layers such as the SCSI upper "
"layer drivers and the block layer."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:40
msgid ""
"This version of the document roughly matches Linux kernel version 2.6.8 ."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:43
msgid "Documentation"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:44
msgid ""
"There is a SCSI documentation directory within the kernel source tree, "
"typically Documentation/scsi . Most documents are in reStructuredText "
"format. This file is named scsi_mid_low_api.rst and can be found in that "
"directory. A more recent copy of this document may be found at https://docs."
"kernel.org/scsi/scsi_mid_low_api.html. Many LLDs are documented in "
"Documentation/scsi (e.g. aic7xxx.rst). The SCSI mid-level is briefly "
"described in scsi.rst which contains a URL to a document describing the SCSI "
"subsystem in the Linux kernel 2.4 series. Two upper level drivers have "
"documents in that directory: st.rst (SCSI tape driver) and scsi-generic.rst "
"(for the sg driver)."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:55
msgid ""
"Some documentation (or URLs) for LLDs may be found in the C source code or "
"in the same directory as the C source code. For example to find a URL about "
"the USB mass storage driver see the /usr/src/linux/drivers/usb/storage "
"directory."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:61
msgid "Driver structure"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:62
msgid ""
"Traditionally an LLD for the SCSI subsystem has been at least two files in "
"the drivers/scsi directory. For example, a driver called \"xyz\" has a "
"header file \"xyz.h\" and a source file \"xyz.c\". [Actually there is no "
"good reason why this couldn't all be in one file; the header file is "
"superfluous.] Some drivers that have been ported to several operating "
"systems have more than two files. For example the aic7xxx driver has "
"separate files for generic and OS-specific code (e.g. FreeBSD and Linux). "
"Such drivers tend to have their own directory under the drivers/scsi "
"directory."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:71
msgid ""
"When a new LLD is being added to Linux, the following files (found in the "
"drivers/scsi directory) will need some attention: Makefile and Kconfig . It "
"is probably best to study how existing LLDs are organized."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:75
msgid ""
"As the 2.5 series development kernels evolve into the 2.6 series production "
"series, changes are being introduced into this interface. An example of this "
"is driver initialization code where there are now 2 models available. The "
"older one, similar to what was found in the Linux 2.4 series, is based on "
"hosts that are detected at HBA driver load time. This will be referred to "
"the \"passive\" initialization model. The newer model allows HBAs to be hot "
"plugged (and unplugged) during the lifetime of the LLD and will be referred "
"to as the \"hotplug\" initialization model. The newer model is preferred as "
"it can handle both traditional SCSI equipment that is permanently connected "
"as well as modern \"SCSI\" devices (e.g. USB or IEEE 1394 connected digital "
"cameras) that are hotplugged. Both initialization models are discussed in "
"the following sections."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:88
msgid "An LLD interfaces to the SCSI subsystem several ways:"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:90
msgid "directly invoking functions supplied by the mid level"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:91
msgid ""
"passing a set of function pointers to a registration function supplied by "
"the mid level. The mid level will then invoke these functions at some point "
"in the future. The LLD will supply implementations of these functions."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:95
msgid ""
"direct access to instances of well known data structures maintained by the "
"mid level"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:98
msgid ""
"Those functions in group a) are listed in a section entitled \"Mid level "
"supplied functions\" below."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:101
msgid ""
"Those functions in group b) are listed in a section entitled \"Interface "
"functions\" below. Their function pointers are placed in the members of "
"\"struct scsi_host_template\", an instance of which is passed to "
"scsi_host_alloc().  Those interface functions that the LLD does not wish to "
"supply should have NULL placed in the corresponding member of struct "
"scsi_host_template.  Defining an instance of struct scsi_host_template at "
"file scope will cause NULL to be  placed in function pointer members not "
"explicitly initialized."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:110
msgid ""
"Those usages in group c) should be handled with care, especially in a "
"\"hotplug\" environment. LLDs should be aware of the lifetime of instances "
"that are shared with the mid level and other layers."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:114
msgid ""
"All functions defined within an LLD and all data defined at file scope "
"should be static. For example the sdev_init() function in an LLD called "
"\"xxx\" could be defined as ``static int xxx_sdev_init(struct scsi_device * "
"sdev) { /* code */ }``"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:121
msgid "Hotplug initialization model"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:122
msgid ""
"In this model an LLD controls when SCSI hosts are introduced and removed "
"from the SCSI subsystem. Hosts can be introduced as early as driver "
"initialization and removed as late as driver shutdown. Typically a driver "
"will respond to a sysfs probe() callback that indicates an HBA has been "
"detected. After confirming that the new device is one that the LLD wants to "
"control, the LLD will initialize the HBA and then register a new host with "
"the SCSI mid level."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:130
msgid ""
"During LLD initialization the driver should register itself with the "
"appropriate IO bus on which it expects to find HBA(s) (e.g. the PCI bus). "
"This can probably be done via sysfs. Any driver parameters (especially those "
"that are writable after the driver is loaded) could also be registered with "
"sysfs at this point. The SCSI mid level first becomes aware of an LLD when "
"that LLD registers its first HBA."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:137
msgid ""
"At some later time, the LLD becomes aware of an HBA and what follows is a "
"typical sequence of calls between the LLD and the mid level. This example "
"shows the mid level scanning the newly introduced HBA for 3 scsi devices of "
"which only the first 2 respond::"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:162
msgid ""
"If the LLD wants to adjust the default queue settings, it can invoke "
"scsi_change_queue_depth() in its sdev_configure() routine."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:165
msgid ""
"When an HBA is being removed it could be as part of an orderly shutdown "
"associated with the LLD module being unloaded (e.g. with the \"rmmod\" "
"command) or in response to a \"hot unplug\" indicated by sysfs()'s remove() "
"callback being invoked. In either case, the sequence is the same::"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:180
msgid ""
"It may be useful for a LLD to keep track of struct Scsi_Host instances (a "
"pointer is returned by scsi_host_alloc()). Such instances are \"owned\" by "
"the mid-level.  struct Scsi_Host instances are freed from scsi_host_put() "
"when the reference count hits zero."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:185
msgid ""
"Hot unplugging an HBA that controls a disk which is processing SCSI commands "
"on a mounted file system is an interesting situation. Reference counting "
"logic is being introduced into the mid level to cope with many of the issues "
"involved. See the section on reference counting below."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:191
msgid ""
"The hotplug concept may be extended to SCSI devices. Currently, when an HBA "
"is added, the scsi_scan_host() function causes a scan for SCSI devices "
"attached to the HBA's SCSI transport. On newer SCSI transports the HBA may "
"become aware of a new SCSI device _after_ the scan has completed. An LLD can "
"use this sequence to make the mid level aware of a SCSI device::"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:205
msgid ""
"In a similar fashion, an LLD may become aware that a SCSI device has been "
"removed (unplugged) or the connection to it has been interrupted. Some "
"existing SCSI transports (e.g. SPI) may not become aware that a SCSI device "
"has been removed until a subsequent SCSI command fails which will probably "
"cause that device to be set offline by the mid level. An LLD that detects "
"the removal of a SCSI device can instigate its removal from upper layers "
"with this sequence::"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:220
msgid ""
"It may be useful for an LLD to keep track of struct scsi_device instances (a "
"pointer is passed as the parameter to sdev_init() and sdev_configure() "
"callbacks). Such instances are \"owned\" by the mid-level. struct "
"scsi_device instances are freed after sdev_destroy()."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:227
msgid "Reference Counting"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:228
msgid ""
"The Scsi_Host structure has had reference counting infrastructure added. "
"This effectively spreads the ownership of struct Scsi_Host instances across "
"the various SCSI layers which use them. Previously such instances were "
"exclusively owned by the mid level. LLDs would not usually need to directly "
"manipulate these reference counts but there may be some cases where they do."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:235
msgid ""
"There are 3 reference counting functions of interest associated with struct "
"Scsi_Host:"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:238
msgid "scsi_host_alloc():"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:239
msgid ""
"returns a pointer to new instance of struct Scsi_Host which has its "
"reference count ^^ set to 1"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:242
msgid "scsi_host_get():"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:243
msgid "adds 1 to the reference count of the given instance"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:245
msgid "scsi_host_put():"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:246
msgid ""
"decrements 1 from the reference count of the given instance. If the "
"reference count reaches 0 then the given instance is freed"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:250
msgid ""
"The scsi_device structure has had reference counting infrastructure added. "
"This effectively spreads the ownership of struct scsi_device instances "
"across the various SCSI layers which use them. Previously such instances "
"were exclusively owned by the mid level. See the access functions declared "
"towards the end of include/scsi/scsi_device.h . If an LLD wants to keep a "
"copy of a pointer to a scsi_device instance it should use scsi_device_get() "
"to bump its reference count. When it is finished with the pointer it can use "
"scsi_device_put() to decrement its reference count (and potentially delete "
"it)."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:262
msgid ""
"struct Scsi_Host actually has 2 reference counts which are manipulated in "
"parallel by these functions."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:267
msgid "Conventions"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:268
msgid ""
"First, Linus Torvalds's thoughts on C coding style can be found in the "
"Documentation/process/coding-style.rst file."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:271
msgid ""
"Also, most C99 enhancements are encouraged to the extent they are supported "
"by the relevant gcc compilers. So C99 style structure and array initializers "
"are encouraged where appropriate. Don't go too far, VLAs are not properly "
"supported yet.  An exception to this is the use of ``//`` style comments; ``/"
"*...*/`` comments are still preferred in Linux."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:277
msgid ""
"Well written, tested and documented code, need not be re-formatted to comply "
"with the above conventions. For example, the aic7xxx driver comes to Linux "
"from FreeBSD and Adaptec's own labs. No doubt FreeBSD and Adaptec have their "
"own coding conventions."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:284
msgid "Mid level supplied functions"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:285
msgid ""
"These functions are supplied by the SCSI mid level for use by LLDs. The "
"names (i.e. entry points) of these functions are exported so an LLD that is "
"a module can access them. The kernel will arrange for the SCSI mid level to "
"be loaded and initialized before any LLD is initialized. The functions below "
"are listed alphabetically and their names all start with ``scsi_``."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:292
#: ../../../scsi/scsi_mid_low_api.rst:603
msgid "Summary:"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:294
msgid "scsi_add_device - creates new scsi device (lu) instance"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:295
msgid "scsi_add_host - perform sysfs registration and set up transport class"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:296
msgid "scsi_change_queue_depth - change the queue depth on a SCSI device"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:297
msgid "scsi_bios_ptable - return copy of block device's partition table"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:298
msgid ""
"scsi_block_requests - prevent further commands being queued to given host"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:299
msgid "scsi_host_alloc - return a new scsi_host instance whose refcount==1"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:300
msgid "scsi_host_get - increments Scsi_Host instance's refcount"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:301
msgid "scsi_host_put - decrements Scsi_Host instance's refcount (free if 0)"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:302
msgid "scsi_remove_device - detach and remove a SCSI device"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:303
msgid "scsi_remove_host - detach and remove all SCSI devices owned by host"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:304
msgid "scsi_report_bus_reset - report scsi _bus_ reset observed"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:305
msgid "scsi_scan_host - scan SCSI bus"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:306
msgid "scsi_track_queue_full - track successive QUEUE_FULL events"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:307
msgid ""
"scsi_unblock_requests - allow further commands to be queued to given host"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:310
#: ../../../scsi/scsi_mid_low_api.rst:620
msgid "Details::"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:580
msgid "Interface Functions"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:581
msgid ""
"Interface functions are supplied (defined) by LLDs and their function "
"pointers are placed in an instance of struct scsi_host_template which is "
"passed to scsi_host_alloc(). Some are mandatory. Interface functions should "
"be declared static. The accepted convention is that driver \"xyz\" will "
"declare its sdev_configure() function as::"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:590
msgid "and so forth for all interface functions listed below."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:592
msgid ""
"A pointer to this function should be placed in the 'sdev_configure' member "
"of a \"struct scsi_host_template\" instance. A pointer to such an instance "
"should be passed to the mid level's scsi_host_alloc(). ."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:597
msgid ""
"The interface functions are also described in the include/scsi/scsi_host.h "
"file immediately above their definition point in \"struct "
"scsi_host_template\". In some cases more detail is given in scsi_host.h than "
"below."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:601
msgid "The interface functions are listed below in alphabetical order."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:605
msgid "bios_param - fetch head, sector, cylinder info for a disk"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:606
msgid "eh_timed_out - notify the host that a command timer expired"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:607
msgid "eh_abort_handler - abort given command"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:608
msgid "eh_bus_reset_handler - issue SCSI bus reset"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:609
msgid "eh_device_reset_handler - issue SCSI device reset"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:610
msgid "eh_host_reset_handler - reset host (host bus adapter)"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:611
msgid "info - supply information about given host"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:612
msgid "ioctl - driver can respond to ioctls"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:613
msgid "proc_info - supports /proc/scsi/{driver_name}/{host_no}"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:614
msgid "queuecommand - queue scsi command, invoke 'done' on completion"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:615
msgid "sdev_init - prior to any commands being sent to a new device"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:616
msgid "sdev_configure - driver fine tuning for given device after attach"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:617
msgid "sdev_destroy - given device is about to be shut down"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:983
msgid "Data Structures"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:985
msgid "struct scsi_host_template"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:986
msgid ""
"There is one \"struct scsi_host_template\" instance per LLD [#]_. It is "
"typically initialized as a file scope static in a driver's header file. That "
"way members that are not explicitly initialized will be set to 0 or NULL. "
"Members of interest:"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:991
msgid "name"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:992
msgid ""
"name of driver (may contain spaces, please limit to less than 80 characters)"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:995
msgid "proc_name"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:996
msgid ""
"name used in \"/proc/scsi/<proc_name>/<host_no>\" and by sysfs in one of its "
"\"drivers\" directories. Hence \"proc_name\" should only contain characters "
"acceptable to a Unix file name."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1001
msgid "``(*queuecommand)()``"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1002
msgid ""
"primary callback that the mid level uses to inject SCSI commands into an LLD."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1005
msgid "vendor_id"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1006
msgid ""
"a unique value that identifies the vendor supplying the LLD for the "
"Scsi_Host.  Used most often in validating vendor-specific message requests.  "
"Value consists of an identifier type and a vendor-specific value. See "
"scsi_netlink.h for a description of valid formats."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1012
msgid "The structure is defined and commented in include/scsi/scsi_host.h"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1014
msgid ""
"In extreme situations a single driver may have several instances if it "
"controls several different classes of hardware (e.g. an LLD that handles "
"both ISA and PCI cards and has a separate instance of struct "
"scsi_host_template for each class)."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1020
msgid "struct Scsi_Host"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1021
msgid ""
"There is one struct Scsi_Host instance per host (HBA) that an LLD controls. "
"The struct Scsi_Host structure has many members in common with \"struct "
"scsi_host_template\". When a new struct Scsi_Host instance is created (in "
"scsi_host_alloc() in hosts.c) those common members are initialized from the "
"driver's struct scsi_host_template instance. Members of interest:"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1028
msgid "host_no"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1029
msgid ""
"system-wide unique number that is used for identifying this host. Issued in "
"ascending order from 0."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1031
msgid "can_queue"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1032
msgid ""
"must be greater than 0; do not send more than can_queue commands to the "
"adapter."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1034
msgid "this_id"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1035
msgid "scsi id of host (scsi initiator) or -1 if not known"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1036
msgid "sg_tablesize"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1037
msgid ""
"maximum scatter gather elements allowed by host. Set this to SG_ALL or less "
"to avoid chained SG lists. Must be at least 1."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1040
msgid "max_sectors"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1041
msgid ""
"maximum number of sectors (usually 512 bytes) allowed in a single SCSI "
"command. The default value of 0 leads to a setting of "
"SCSI_DEFAULT_MAX_SECTORS (defined in scsi_host.h) which is currently set to "
"1024. So for a disk the maximum transfer size is 512 KB when max_sectors is "
"not defined. Note that this size may not be sufficient for disk firmware "
"uploads."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1048
msgid "cmd_per_lun"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1049
msgid ""
"maximum number of commands that can be queued on devices controlled by the "
"host. Overridden by LLD calls to scsi_change_queue_depth()."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1052
msgid "hostt"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1053
msgid ""
"pointer to driver's struct scsi_host_template from which this struct "
"Scsi_Host instance was spawned"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1055
msgid "hostt->proc_name"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1056
msgid "name of LLD. This is the driver name that sysfs uses."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1057
msgid "transportt"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1058
msgid ""
"pointer to driver's struct scsi_transport_template instance (if any). FC and "
"SPI transports currently supported."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1060
msgid "hostdata[0]"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1061
msgid ""
"area reserved for LLD at end of struct Scsi_Host. Size is set by the second "
"argument (named 'privsize') to scsi_host_alloc()."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1065
msgid "The scsi_host structure is defined in include/scsi/scsi_host.h"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1068
msgid "struct scsi_device"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1069
msgid ""
"Generally, there is one instance of this structure for each SCSI logical "
"unit on a host. SCSI devices connected to a host are uniquely identified by "
"a channel number, target id and logical unit number (lun). The structure is "
"defined in include/scsi/scsi_device.h"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1075
msgid "struct scsi_cmnd"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1076
msgid ""
"Instances of this structure convey SCSI commands to the LLD and responses "
"back to the mid level. The SCSI mid level will ensure that no more SCSI "
"commands become queued against the LLD than are indicated by "
"scsi_change_queue_depth() (or struct Scsi_Host::cmd_per_lun). There will be "
"at least one instance of struct scsi_cmnd available for each SCSI device. "
"Members of interest:"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1083
msgid "cmnd"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1084
msgid "array containing SCSI command"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1085
msgid "cmd_len"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1086
msgid "length (in bytes) of SCSI command"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1087
msgid "sc_data_direction"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1088
msgid ""
"direction of data transfer in data phase. See \"enum dma_data_direction\" in "
"include/linux/dma-mapping.h"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1090
msgid "result"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1091
msgid ""
"should be set by LLD prior to calling 'done'. A value of 0 implies a "
"successfully completed command (and all data (if any) has been transferred "
"to or from the SCSI target device). 'result' is a 32-bit unsigned integer "
"that can be viewed as 2 related bytes. The SCSI status value is in the LSB. "
"See include/scsi/scsi.h status_byte() and host_byte() macros and related "
"constants."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1098
msgid "sense_buffer"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1099
msgid ""
"an array (maximum size: SCSI_SENSE_BUFFERSIZE bytes) that should be written "
"when the SCSI status (LSB of 'result') is set to CHECK_CONDITION (2). When "
"CHECK_CONDITION is set, if the top nibble of sense_buffer[0] has the value 7 "
"then the mid level will assume the sense_buffer array contains a valid SCSI "
"sense buffer; otherwise the mid level will issue a REQUEST_SENSE SCSI "
"command to retrieve the sense buffer. The latter strategy is error prone in "
"the presence of command queuing so the LLD should always \"auto-sense\"."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1109
msgid "device"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1110
msgid "pointer to scsi_device object that this command is associated with."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1112
msgid "resid_len   (access by calling scsi_set_resid() / scsi_get_resid())"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1113
msgid ""
"an LLD should set this unsigned integer to the requested transfer length (i."
"e. 'request_bufflen') less the number of bytes that are actually "
"transferred. 'resid_len' is preset to 0 so an LLD can ignore it if it cannot "
"detect underruns (overruns should not be reported). An LLD should set "
"'resid_len' prior to invoking 'done'. The most interesting case is data "
"transfers from a SCSI target device (e.g. READs) that underrun."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1121
msgid "underflow"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1122
msgid ""
"LLD should place (DID_ERROR << 16) in 'result' if actual number of bytes "
"transferred is less than this figure. Not many LLDs implement this check and "
"some that do just output an error message to the log rather than report a "
"DID_ERROR. Better for an LLD to implement 'resid_len'."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1129
msgid ""
"It is recommended that a LLD set 'resid_len' on data transfers from a SCSI "
"target device (e.g. READs). It is especially important that 'resid_len' is "
"set when such data transfers have sense keys of MEDIUM ERROR and HARDWARE "
"ERROR (and possibly RECOVERED ERROR). In these cases if a LLD is in doubt "
"how much data has been received then the safest approach is to indicate no "
"bytes have been received. For example: to indicate that no valid data has "
"been received a LLD might use these helpers::"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1139
msgid ""
"where 'SCpnt' is a pointer to a scsi_cmnd object. To indicate only three 512 "
"bytes blocks have been received 'resid_len' could be set like this::"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1144
msgid "The scsi_cmnd structure is defined in include/scsi/scsi_cmnd.h"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1148
msgid "Locks"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1149
msgid ""
"Each struct Scsi_Host instance has a spin_lock called struct Scsi_Host::"
"default_lock which is initialized in scsi_host_alloc() [found in hosts.c]. "
"Within the same function the struct Scsi_Host::host_lock pointer is "
"initialized to point at default_lock.  Thereafter lock and unlock operations "
"performed by the mid level use the struct Scsi_Host::host_lock pointer.  "
"Previously drivers could override the host_lock pointer but this is not "
"allowed anymore."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1159
msgid "Autosense"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1160
msgid ""
"Autosense (or auto-sense) is defined in the SAM-2 document as \"the "
"automatic return of sense data to the application client coincident with the "
"completion of a SCSI command\" when a status of CHECK CONDITION occurs. LLDs "
"should perform autosense. This should be done when the LLD detects a CHECK "
"CONDITION status by either:"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1166
msgid ""
"instructing the SCSI protocol (e.g. SCSI Parallel Interface (SPI)) to "
"perform an extra data in phase on such responses"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1168
msgid "or, the LLD issuing a REQUEST SENSE command itself"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1170
msgid ""
"Either way, when a status of CHECK CONDITION is detected, the mid level "
"decides whether the LLD has performed autosense by checking struct "
"scsi_cmnd::sense_buffer[0] . If this byte has an upper nibble of 7 (or 0xf) "
"then autosense is assumed to have taken place. If it has another value (and "
"this byte is initialized to 0 before each command) then the mid level will "
"issue a REQUEST SENSE command."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1177
msgid ""
"In the presence of queued commands the \"nexus\" that maintains sense buffer "
"data from the command that failed until a following REQUEST SENSE may get "
"out of synchronization. This is why it is best for the LLD to perform "
"autosense."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1184
msgid "Changes since Linux kernel 2.4 series"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1185
msgid ""
"io_request_lock has been replaced by several finer grained locks. The lock "
"relevant to LLDs is struct Scsi_Host::host_lock and there is one per SCSI "
"host."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1189
msgid ""
"The older error handling mechanism has been removed. This means the LLD "
"interface functions abort() and reset() have been removed. The struct "
"scsi_host_template::use_new_eh_code flag has been removed."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1193
msgid ""
"In the 2.4 series the SCSI subsystem configuration descriptions were "
"aggregated with the configuration descriptions from all other Linux "
"subsystems in the Documentation/Configure.help file. In the 2.6 series, the "
"SCSI subsystem now has its own (much smaller) drivers/scsi/Kconfig file that "
"contains both configuration and help information."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1199
msgid "struct SHT has been renamed to struct scsi_host_template."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1201
msgid ""
"Addition of the \"hotplug initialization model\" and many extra functions to "
"support it."
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1206
msgid "Credits"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1207
msgid "The following people have contributed to this document:"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1209
msgid "Mike Anderson <andmike at us dot ibm dot com>"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1210
msgid "James Bottomley <James dot Bottomley at hansenpartnership dot com>"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1211
msgid "Patrick Mansfield <patmans at us dot ibm dot com>"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1212
msgid "Christoph Hellwig <hch at infradead dot org>"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1213
msgid "Doug Ledford <dledford at redhat dot com>"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1214
msgid "Andries Brouwer <Andries dot Brouwer at cwi dot nl>"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1215
msgid "Randy Dunlap <rdunlap at xenotime dot net>"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1216
msgid "Alan Stern <stern at rowland dot harvard dot edu>"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1219
msgid "Douglas Gilbert dgilbert at interlog dot com"
msgstr ""

#: ../../../scsi/scsi_mid_low_api.rst:1222
msgid "21st September 2004"
msgstr ""
