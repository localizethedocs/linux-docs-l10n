# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-06 06:05+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../security/landlock.rst:7
msgid "Landlock LSM: kernel documentation"
msgstr ""

#: ../../../security/landlock.rst:0
msgid "Author"
msgstr ""

#: ../../../security/landlock.rst:9
msgid "Mickaël Salaün"
msgstr ""

#: ../../../security/landlock.rst:0
msgid "Date"
msgstr ""

#: ../../../security/landlock.rst:10
msgid "September 2025"
msgstr ""

#: ../../../security/landlock.rst:12
msgid ""
"Landlock's goal is to create scoped access-control (i.e. sandboxing).  To "
"harden a whole system, this feature should be available to any process, "
"including unprivileged ones.  Because such a process may be compromised or "
"backdoored (i.e. untrusted), Landlock's features must be safe to use from "
"the kernel and other processes point of view.  Landlock's interface must "
"therefore expose a minimal attack surface."
msgstr ""

#: ../../../security/landlock.rst:19
msgid ""
"Landlock is designed to be usable by unprivileged processes while following "
"the system security policy enforced by other access control mechanisms (e.g. "
"DAC, LSM).  A Landlock rule shall not interfere with other access-controls "
"enforced on the system, only add more restrictions."
msgstr ""

#: ../../../security/landlock.rst:24
msgid ""
"Any user can enforce Landlock rulesets on their processes.  They are merged "
"and evaluated against inherited rulesets in a way that ensures that only "
"more constraints can be added."
msgstr ""

#: ../../../security/landlock.rst:28
msgid ""
"User space documentation can be found here: Documentation/userspace-api/"
"landlock.rst."
msgstr ""

#: ../../../security/landlock.rst:32
msgid "Guiding principles for safe access controls"
msgstr ""

#: ../../../security/landlock.rst:34
msgid ""
"A Landlock rule shall be focused on access control on kernel objects instead "
"of syscall filtering (i.e. syscall arguments), which is the purpose of "
"seccomp-bpf."
msgstr ""

#: ../../../security/landlock.rst:37
msgid ""
"To avoid multiple kinds of side-channel attacks (e.g. leak of security "
"policies, CPU-based attacks), Landlock rules shall not be able to "
"programmatically communicate with user space."
msgstr ""

#: ../../../security/landlock.rst:40
msgid ""
"Kernel access check shall not slow down access request from unsandboxed "
"processes."
msgstr ""

#: ../../../security/landlock.rst:42
msgid ""
"Computation related to Landlock operations (e.g. enforcing a ruleset) shall "
"only impact the processes requesting them."
msgstr ""

#: ../../../security/landlock.rst:44
msgid ""
"Resources (e.g. file descriptors) directly obtained from the kernel by a "
"sandboxed process shall retain their scoped accesses (at the time of "
"resource acquisition) whatever process uses them. Cf. `File descriptor "
"access rights`_."
msgstr ""

#: ../../../security/landlock.rst:48
msgid ""
"Access denials shall be logged according to system and Landlock domain "
"configurations.  Log entries must contain information about the cause of the "
"denial and the owner of the related security policy.  Such log generation "
"should have a negligible performance and memory impact on allowed requests."
msgstr ""

#: ../../../security/landlock.rst:54
msgid "Design choices"
msgstr ""

#: ../../../security/landlock.rst:57
msgid "Inode access rights"
msgstr ""

#: ../../../security/landlock.rst:59
msgid ""
"All access rights are tied to an inode and what can be accessed through it. "
"Reading the content of a directory does not imply to be allowed to read the "
"content of a listed inode.  Indeed, a file name is local to its parent "
"directory, and an inode can be referenced by multiple file names thanks to "
"(hard) links.  Being able to unlink a file only has a direct impact on the "
"directory, not the unlinked inode.  This is the reason why "
"``LANDLOCK_ACCESS_FS_REMOVE_FILE`` or ``LANDLOCK_ACCESS_FS_REFER`` are not "
"allowed to be tied to files but only to directories."
msgstr ""

#: ../../../security/landlock.rst:69
msgid "File descriptor access rights"
msgstr ""

#: ../../../security/landlock.rst:71
msgid ""
"Access rights are checked and tied to file descriptors at open time.  The "
"underlying principle is that equivalent sequences of operations should lead "
"to the same results, when they are executed under the same Landlock domain."
msgstr ""

#: ../../../security/landlock.rst:75
msgid ""
"Taking the ``LANDLOCK_ACCESS_FS_TRUNCATE`` right as an example, it may be "
"allowed to open a file for writing without being allowed to :manpage:"
"`ftruncate` the resulting file descriptor if the related file hierarchy "
"doesn't grant that access right.  The following sequences of operations have "
"the same semantic and should then have the same result:"
msgstr ""

#: ../../../security/landlock.rst:81
msgid "``truncate(path);``"
msgstr ""

#: ../../../security/landlock.rst:82
msgid "``int fd = open(path, O_WRONLY); ftruncate(fd); close(fd);``"
msgstr ""

#: ../../../security/landlock.rst:84
msgid ""
"Similarly to file access modes (e.g. ``O_RDWR``), Landlock access rights "
"attached to file descriptors are retained even if they are passed between "
"processes (e.g. through a Unix domain socket).  Such access rights will then "
"be enforced even if the receiving process is not sandboxed by Landlock.  "
"Indeed, this is required to keep access controls consistent over the whole "
"system, and this avoids unattended bypasses through file descriptor passing "
"(i.e. confused deputy attack)."
msgstr ""

#: ../../../security/landlock.rst:93
msgid "Tests"
msgstr ""

#: ../../../security/landlock.rst:95
msgid ""
"Userspace tests for backward compatibility, ptrace restrictions and "
"filesystem support can be found here: `tools/testing/selftests/landlock/`_."
msgstr ""

#: ../../../security/landlock.rst:99
msgid "Kernel structures"
msgstr ""

#: ../../../security/landlock.rst:102
msgid "Object"
msgstr ""

#: ../../../security/landlock:104: ../security/landlock/object.h:19
msgid "Operations on an underlying object"
msgstr ""

#: ../../../security/landlock:104: ../security/landlock/object.h:23
#: ../security/landlock/object.h:34 ../../../security/landlock:110:
#: ../security/landlock/fs.h:28 ../security/landlock/fs.h:48
#: ../security/landlock/fs.h:98 ../../../security/landlock:116:
#: ../security/landlock/cred.h:28 ../../../security/landlock:134:
#: ../security/landlock/ruleset.h:30 ../security/landlock/ruleset.h:45
#: ../security/landlock/ruleset.h:76 ../security/landlock/ruleset.h:91
#: ../security/landlock/ruleset.h:118 ../../../security/landlock:137:
#: ../security/landlock/domain.h:35 ../security/landlock/domain.h:77
msgid "**Definition**::"
msgstr ""

#: ../../../security/landlock:104: ../security/landlock/object.h:29
#: ../security/landlock/object.h:46 ../../../security/landlock:110:
#: ../security/landlock/fs.h:34 ../security/landlock/fs.h:59
#: ../security/landlock/fs.h:104 ../../../security/landlock:116:
#: ../security/landlock/cred.h:38 ../../../security/landlock:134:
#: ../security/landlock/ruleset.h:37 ../security/landlock/ruleset.h:52
#: ../security/landlock/ruleset.h:83 ../security/landlock/ruleset.h:100
#: ../security/landlock/ruleset.h:138 ../../../security/landlock:137:
#: ../security/landlock/domain.h:44 ../security/landlock/domain.h:91
msgid "**Members**"
msgstr ""

#: ../../../security/landlock:104: ../security/landlock/object.h:23
msgid "``release``"
msgstr ""

#: ../../../security/landlock:104: ../security/landlock/object.h:24
msgid "Releases the underlying object (e.g. iput() for an inode)."
msgstr ""

#: ../../../security/landlock:104: ../security/landlock/object.h:30
msgid "Security blob tied to a kernel object"
msgstr ""

#: ../../../security/landlock:104: ../security/landlock/object.h:41
#: ../../../security/landlock:134: ../security/landlock/ruleset.h:159
#: ../../../security/landlock:137: ../security/landlock/domain.h:82
msgid "``usage``"
msgstr ""

#: ../../../security/landlock:104: ../security/landlock/object.h:42
msgid ""
"This counter is used to tie an object to the rules matching it or to keep it "
"alive while adding a new rule.  If this counter reaches zero, this struct "
"must not be modified, but this counter can still be read from within an RCU "
"read-side critical section.  When adding a new rule to an object with a "
"usage counter of zero, we must wait until the pointer to this object is set "
"to NULL (or recycled)."
msgstr ""

#: ../../../security/landlock:104: ../security/landlock/object.h:50
#: ../../../security/landlock:134: ../security/landlock/ruleset.h:154
msgid "``lock``"
msgstr ""

#: ../../../security/landlock:104: ../security/landlock/object.h:51
msgid ""
"Protects against concurrent modifications.  This lock must be held from the "
"time **usage** drops to zero until any weak references from **underobj** to "
"this object have been cleaned up."
msgstr ""

#: ../../../security/landlock:104: ../security/landlock/object.h:55
msgid "Lock ordering: inode->i_lock nests inside this."
msgstr ""

#: ../../../security/landlock:104: ../security/landlock/object.h:58
msgid "``underobj``"
msgstr ""

#: ../../../security/landlock:104: ../security/landlock/object.h:59
msgid ""
"Used when cleaning up an object and to mark an object as tied to its "
"underlying kernel structure.  This pointer is protected by **lock**.  Cf. "
"landlock_release_inodes() and release_inode()."
msgstr ""

#: ../../../security/landlock:104: ../security/landlock/object.h:1
#: ../../../security/landlock:134: ../security/landlock/ruleset.h:1
msgid "``{unnamed_union}``"
msgstr ""

#: ../../../security/landlock:104: ../security/landlock/object.h:2
#: ../../../security/landlock:134: ../security/landlock/ruleset.h:2
msgid "anonymous"
msgstr ""

#: ../../../security/landlock:104: ../security/landlock/object.h:65
msgid "``rcu_free``"
msgstr ""

#: ../../../security/landlock:104: ../security/landlock/object.h:66
msgid ""
"Enables lockless use of **usage**, **lock** and **underobj** from within an "
"RCU read-side critical section. **rcu_free** and **underops** are only used "
"by landlock_put_object()."
msgstr ""

#: ../../../security/landlock:104: ../security/landlock/object.h:72
msgid "``underops``"
msgstr ""

#: ../../../security/landlock:104: ../security/landlock/object.h:73
msgid ""
"Enables landlock_put_object() to release the underlying object (e.g. inode)."
msgstr ""

#: ../../../security/landlock:104: ../security/landlock/object.h:77
#: ../../../security/landlock:110: ../security/landlock/fs.h:42
#: ../security/landlock/fs.h:82 ../security/landlock/fs.h:106
#: ../../../security/landlock:116: ../security/landlock/cred.h:51
#: ../../../security/landlock:134: ../security/landlock/ruleset.h:189
#: ../../../security/landlock:137: ../security/landlock/domain.h:64
msgid "**Description**"
msgstr ""

#: ../../../security/landlock:104: ../security/landlock/object.h:31
msgid ""
"The goal of this structure is to enable to tie a set of ephemeral access "
"rights (pertaining to different domains) to a kernel object (e.g an inode) "
"in a safe way.  This implies to handle concurrent use and modification."
msgstr ""

#: ../../../security/landlock:104: ../security/landlock/object.h:35
msgid ""
"The lifetime of a :c:type:`struct landlock_object <landlock_object>` depends "
"on the rules referring to it."
msgstr ""

#: ../../../security/landlock.rst:108
msgid "Filesystem"
msgstr ""

#: ../../../security/landlock:110: ../security/landlock/fs.h:24
msgid "Inode security blob"
msgstr ""

#: ../../../security/landlock:110: ../security/landlock/fs.h:31
#: ../../../security/landlock:134: ../security/landlock/ruleset.h:45
msgid "``object``"
msgstr ""

#: ../../../security/landlock:110: ../security/landlock/fs.h:32
msgid ""
"Weak pointer to an allocated object.  All assignments of a new object are "
"protected by the underlying inode->i_lock.  However, atomically "
"disassociating **object** from the inode is only protected by **object-"
">lock**, from the time **object**'s usage refcount drops to zero to the time "
"this pointer is nulled out (cf. release_inode() and hook_sb_delete()).  "
"Indeed, such disassociation doesn't require inode->i_lock thanks to the "
"careful rcu_access_pointer() check performed by get_inode_object()."
msgstr ""

#: ../../../security/landlock:110: ../security/landlock/fs.h:25
msgid ""
"Enable to reference a :c:type:`struct landlock_object <landlock_object>` "
"tied to an inode (i.e. underlying object)."
msgstr ""

#: ../../../security/landlock:110: ../security/landlock/fs.h:44
msgid "File security blob"
msgstr ""

#: ../../../security/landlock:110: ../security/landlock/fs.h:53
msgid "``allowed_access``"
msgstr ""

#: ../../../security/landlock:110: ../security/landlock/fs.h:54
msgid ""
"Access rights that were available at the time of opening the file. This is "
"not necessarily the full set of access rights available at that time, but "
"it's the necessary subset as needed to authorize later operations on the "
"open file."
msgstr ""

#: ../../../security/landlock:110: ../security/landlock/fs.h:62
msgid "``deny_masks``"
msgstr ""

#: ../../../security/landlock:110: ../security/landlock/fs.h:63
msgid ""
"Domain layer levels that deny an optional access (see "
"_LANDLOCK_ACCESS_FS_OPTIONAL)."
msgstr ""

#: ../../../security/landlock:110: ../security/landlock/fs.h:67
msgid "``fown_layer``"
msgstr ""

#: ../../../security/landlock:110: ../security/landlock/fs.h:68
msgid "Layer level of **fown_subject->domain** with LANDLOCK_SCOPE_SIGNAL."
msgstr ""

#: ../../../security/landlock:110: ../security/landlock/fs.h:74
msgid "``fown_subject``"
msgstr ""

#: ../../../security/landlock:110: ../security/landlock/fs.h:75
msgid ""
"Landlock credential of the task that set the PID that may receive a signal e."
"g., SIGURG when writing MSG_OOB to the related socket.  This pointer is "
"protected by the related file->f_owner->lock, as for fown_struct's members: "
"pid, uid, and euid."
msgstr ""

#: ../../../security/landlock:110: ../security/landlock/fs.h:45
msgid ""
"This information is populated when opening a file in hook_file_open, and "
"tracks the relevant Landlock access rights that were available at the time "
"of opening the file. Other LSM hooks use these rights in order to authorize "
"operations on already opened files."
msgstr ""

#: ../../../security/landlock:110: ../security/landlock/fs.h:94
msgid "Superblock security blob"
msgstr ""

#: ../../../security/landlock:110: ../security/landlock/fs.h:100
msgid "``inode_refs``"
msgstr ""

#: ../../../security/landlock:110: ../security/landlock/fs.h:101
msgid ""
"Number of pending inodes (from this superblock) that are being released by "
"release_inode(). Cf. struct super_block->s_fsnotify_inode_refs ."
msgstr ""

#: ../../../security/landlock:110: ../security/landlock/fs.h:95
msgid ""
"Enable hook_sb_delete() to wait for concurrent calls to release_inode()."
msgstr ""

#: ../../../security/landlock.rst:114
msgid "Process credential"
msgstr ""

#: ../../../security/landlock:116: ../security/landlock/cred.h:24
msgid "Credential security blob"
msgstr ""

#: ../../../security/landlock:116: ../security/landlock/cred.h:32
msgid "``domain``"
msgstr ""

#: ../../../security/landlock:116: ../security/landlock/cred.h:33
msgid "Immutable ruleset enforced on a task."
msgstr ""

#: ../../../security/landlock:116: ../security/landlock/cred.h:38
msgid "``domain_exec``"
msgstr ""

#: ../../../security/landlock:116: ../security/landlock/cred.h:39
msgid ""
"Bitmask identifying the domain layers that were enforced by the current "
"task's executed file (i.e. no new execve(2) since landlock_restrict_self(2))."
msgstr ""

#: ../../../security/landlock:116: ../security/landlock/cred.h:44
msgid "``log_subdomains_off``"
msgstr ""

#: ../../../security/landlock:116: ../security/landlock/cred.h:45
msgid ""
"Set if the domain descendants's log_status should be set to "
"``LANDLOCK_LOG_DISABLED``.  This is not a landlock_hierarchy configuration "
"because it applies to future descendant domains and it does not require a "
"current domain."
msgstr ""

#: ../../../security/landlock:116: ../security/landlock/cred.h:25
msgid ""
"This structure is packed to minimize the size of struct "
"landlock_file_security.  However, it is always aligned in the LSM cred blob, "
"see lsm_set_blob_size()."
msgstr ""

#: ../../../security/landlock:116: ../security/landlock/cred.h:96
msgid ""
"Return the subject's Landlock credential if its enforced domain applies to "
"(i.e. handles) at least one of the access rights specified in **masks**"
msgstr ""

#: ../../../security/landlock:116: ../security/landlock/cred.h:100
#: ../../../security/landlock:134: ../security/landlock/ruleset.h:226
msgid "**Parameters**"
msgstr ""

#: ../../../security/landlock:116: ../security/landlock/cred.h:102
msgid "``const struct cred *const cred``"
msgstr ""

#: ../../../security/landlock:116: ../security/landlock/cred.h:101
msgid "credential"
msgstr ""

#: ../../../security/landlock:116: ../security/landlock/cred.h:103
msgid "``const struct access_masks masks``"
msgstr ""

#: ../../../security/landlock:116: ../security/landlock/cred.h:102
msgid "access masks"
msgstr ""

#: ../../../security/landlock:116: ../security/landlock/cred.h:104
msgid "``size_t *const handle_layer``"
msgstr ""

#: ../../../security/landlock:116: ../security/landlock/cred.h:103
msgid ""
"returned youngest layer handling a subset of **masks**.  Not set if the "
"function returns NULL."
msgstr ""

#: ../../../security/landlock:116: ../security/landlock/cred.h:106
#: ../../../security/landlock:134: ../security/landlock/ruleset.h:227
msgid "**Return**"
msgstr ""

#: ../../../security/landlock:116: ../security/landlock/cred.h:106
msgid ""
"landlock_cred(**cred**) if any access rights specified in **masks** is "
"handled, or NULL otherwise."
msgstr ""

#: ../../../security/landlock.rst:120
msgid "Ruleset and domain"
msgstr ""

#: ../../../security/landlock.rst:122
msgid ""
"A domain is a read-only ruleset tied to a set of subjects (i.e. tasks' "
"credentials).  Each time a ruleset is enforced on a task, the current domain "
"is duplicated and the ruleset is imported as a new layer of rules in the new "
"domain.  Indeed, once in a domain, each rule is tied to a layer level.  To "
"grant access to an object, at least one rule of each layer must allow the "
"requested action on the object.  A task can then only transit to a new "
"domain that is the intersection of the constraints from the current domain "
"and those of a ruleset provided by the task."
msgstr ""

#: ../../../security/landlock.rst:131
msgid ""
"The definition of a subject is implicit for a task sandboxing itself, which "
"makes the reasoning much easier and helps avoid pitfalls."
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:26
msgid "Access rights for a given layer"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:30
msgid "``level``"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:31
msgid "Position of this layer in the layer stack.  Starts from 1."
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:34
msgid "``access``"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:35
msgid ""
"Bitfield of allowed actions on the kernel object.  They are relative to the "
"object type (e.g. ``LANDLOCK_ACTION_FS_READ``)."
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:41
msgid "Key of a ruleset's red-black tree"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:46
msgid "Pointer to identify a kernel object (e.g. an inode)."
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:49
msgid "``data``"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:50
msgid "Raw data to identify an arbitrary 32-bit value (e.g. a TCP port)."
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:56
msgid "Type of :c:type:`union landlock_key <landlock_key>`"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:60
msgid "**Constants**"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:62
msgid "``LANDLOCK_KEY_INODE``"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:63
msgid ""
"Type of :c:type:`landlock_ruleset.root_inode <landlock_ruleset>`'s node keys."
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:66
msgid "``LANDLOCK_KEY_NET_PORT``"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:67
msgid ""
"Type of :c:type:`landlock_ruleset.root_net_port <landlock_ruleset>`'s node "
"keys."
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:72
msgid "Unique rule identifier for a ruleset"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:76
#: ../security/landlock/ruleset.h:95
msgid "``key``"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:77
msgid ""
"Identifies either a kernel object (e.g. an inode) or a raw value (e.g. a TCP "
"port)."
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:81
msgid "``type``"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:82
msgid "Type of a landlock_ruleset's root tree."
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:87
msgid "Access rights tied to an object"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:91
msgid "``node``"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:92
msgid "Node in the ruleset's red-black tree."
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:96
msgid ""
"A union to identify either a kernel object (e.g. an inode) or a raw data "
"value (e.g. a network socket port). This is used as a key for this ruleset "
"element.  The pointer is set once and never modified.  It always points to "
"an allocated object because each rule increments the refcount of its object."
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:103
#: ../security/landlock/ruleset.h:169
msgid "``num_layers``"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:104
msgid "Number of entries in **layers**."
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:107
msgid "``layers``"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:108
msgid ""
"Stack of layers, from the latest to the newest, implemented as a flexible "
"array member (FAM)."
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:114
msgid "Landlock ruleset"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:121
msgid "``root_inode``"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:122
msgid ""
"Root of a red-black tree containing :c:type:`struct landlock_rule "
"<landlock_rule>` nodes with inode object.  Once a ruleset is tied to a "
"process (i.e. as a domain), this tree is immutable until **usage** reaches "
"zero."
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:130
msgid "``root_net_port``"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:131
msgid ""
"Root of a red-black tree containing :c:type:`struct landlock_rule "
"<landlock_rule>` nodes with network port. Once a ruleset is tied to a "
"process (i.e. as a domain), this tree is immutable until **usage** reaches "
"zero."
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:139
msgid "``hierarchy``"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:140
msgid ""
"Enables hierarchy identification even when a parent domain vanishes.  This "
"is needed for the ptrace protection."
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:145
msgid "``work_free``"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:146
msgid ""
"Enables to free a ruleset within a lockless section.  This is only used by "
"landlock_put_ruleset_deferred() when **usage** reaches zero. The fields "
"**lock**, **usage**, **num_rules**, **num_layers** and **access_masks** are "
"then unused."
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:1
msgid "``{unnamed_struct}``"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:155
msgid ""
"Protects against concurrent modifications of **root**, if **usage** is "
"greater than zero."
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:160
msgid ""
"Number of processes (i.e. domains) or file descriptors referencing this "
"ruleset."
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:164
msgid "``num_rules``"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:165
msgid ""
"Number of non-overlapping (i.e. not for the same object) rules in this "
"ruleset."
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:170
msgid ""
"Number of layers that are used in this ruleset.  This enables to check that "
"all the layers allow an access request.  A value of 0 identifies a non-"
"merged ruleset (i.e. not a domain)."
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:176
msgid "``access_masks``"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:177
msgid ""
"Contains the subset of filesystem and network actions that are restricted by "
"a ruleset. A domain saves all layers of merged rulesets in a stack (FAM), "
"starting from the first layer to the last one.  These layers are used when "
"merging rulesets, for user space backward compatibility (i.e. future-proof), "
"and to properly handle merged rulesets without overlapping access rights.  "
"These layers are set once and never changed for the lifetime of the ruleset."
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:115
msgid ""
"This data structure must contain unique entries, be updatable, and quick to "
"match an object."
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:222
msgid "Return all access rights handled in the domain"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:228
msgid "``const struct landlock_ruleset *const domain``"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:225
msgid "Landlock ruleset (used as a domain)"
msgstr ""

#: ../../../security/landlock:134: ../security/landlock/ruleset.h:227
msgid "an access_masks result of the OR of all the domain's access masks."
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:31
msgid "Domain's creation information"
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:43
msgid "``pid``"
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:44
msgid ""
"PID of the task that initially restricted itself.  It still identifies the "
"same task.  Keeping a reference to this PID ensures that it will not be "
"recycled."
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:49
msgid "``uid``"
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:50
msgid "UID of the task that initially restricted itself, at creation time."
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:53
msgid "``comm``"
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:54
msgid ""
"Command line of the task that initially restricted itself, at creation "
"time.  Always NULL terminated."
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:58
msgid "``exe_path``"
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:59
msgid ""
"Executable path of the task that initially restricted itself, at creation "
"time.  Always NULL terminated, and never greater than LANDLOCK_PATH_MAX_SIZE."
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:32
msgid "Rarely accessed, mainly when logging the first domain's denial."
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:34
msgid ""
"The contained pointers are initialized at the domain creation time and never "
"changed again.  Contrary to most other Landlock object types, this one is "
"not allocated with GFP_KERNEL_ACCOUNT because its size may not be under the "
"caller's control (e.g. unknown exe_path) and the data is not explicitly "
"requested nor used by tasks."
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:73
msgid "Node in a domain hierarchy"
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:77
msgid "``parent``"
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:78
msgid "Pointer to the parent node, or NULL if it is a root Landlock domain."
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:83
msgid "Number of potential children domains plus their parent domain."
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:89
msgid "``log_status``"
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:90
msgid ""
"Whether this domain should be logged or not.  Because concurrent log entries "
"may be created at the same time, it is still possible to have several domain "
"records of the same domain."
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:95
msgid "``num_denials``"
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:96
msgid ""
"Number of access requests denied by this domain. Masked (i.e. never logged) "
"denials are still counted."
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:100
msgid "``id``"
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:101
msgid "Landlock domain ID, sets once at domain creation time."
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:104
msgid "``details``"
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:105
msgid "Information about the related domain."
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:108
msgid "``log_same_exec``"
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:109
msgid ""
"Set if the domain is *not* configured with "
"``LANDLOCK_RESTRICT_SELF_LOG_SAME_EXEC_OFF``.  Set to true by default."
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:113
msgid "``log_new_exec``"
msgstr ""

#: ../../../security/landlock:137: ../security/landlock/domain.h:114
msgid ""
"Set if the domain is configured with "
"``LANDLOCK_RESTRICT_SELF_LOG_NEW_EXEC_ON``.  Set to false by default."
msgstr ""

#: ../../../security/landlock.rst:141
msgid "Additional documentation"
msgstr ""

#: ../../../security/landlock.rst:143
msgid "Documentation/userspace-api/landlock.rst"
msgstr ""

#: ../../../security/landlock.rst:144
msgid "Documentation/admin-guide/LSM/landlock.rst"
msgstr ""

#: ../../../security/landlock.rst:145
msgid "https://landlock.io"
msgstr ""
