# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/fuse.rst:5
msgid "FUSE"
msgstr ""

#: ../../../filesystems/fuse.rst:8
msgid "Definitions"
msgstr ""

#: ../../../filesystems/fuse.rst:10
msgid "Userspace filesystem:"
msgstr ""

#: ../../../filesystems/fuse.rst:11
msgid ""
"A filesystem in which data and metadata are provided by an ordinary "
"userspace process.  The filesystem can be accessed normally through the "
"kernel interface."
msgstr ""

#: ../../../filesystems/fuse.rst:15
msgid "Filesystem daemon:"
msgstr ""

#: ../../../filesystems/fuse.rst:16
msgid "The process(es) providing the data and metadata of the filesystem."
msgstr ""

#: ../../../filesystems/fuse.rst:18
msgid "Non-privileged mount (or user mount):"
msgstr ""

#: ../../../filesystems/fuse.rst:19
msgid ""
"A userspace filesystem mounted by a non-privileged (non-root) user. The "
"filesystem daemon is running with the privileges of the mounting user.  "
"NOTE: this is not the same as mounts allowed with the \"user\" option in /"
"etc/fstab, which is not discussed here."
msgstr ""

#: ../../../filesystems/fuse.rst:24
msgid "Filesystem connection:"
msgstr ""

#: ../../../filesystems/fuse.rst:25
msgid ""
"A connection between the filesystem daemon and the kernel.  The connection "
"exists until either the daemon dies, or the filesystem is umounted.  Note "
"that detaching (or lazy umounting) the filesystem does *not* break the "
"connection, in this case it will exist until the last reference to the "
"filesystem is released."
msgstr ""

#: ../../../filesystems/fuse.rst:31
msgid "Mount owner:"
msgstr ""

#: ../../../filesystems/fuse.rst:32
msgid "The user who does the mounting."
msgstr ""

#: ../../../filesystems/fuse.rst:34
msgid "User:"
msgstr ""

#: ../../../filesystems/fuse.rst:35
msgid "The user who is performing filesystem operations."
msgstr ""

#: ../../../filesystems/fuse.rst:38
msgid "What is FUSE?"
msgstr ""

#: ../../../filesystems/fuse.rst:40
msgid ""
"FUSE is a userspace filesystem framework.  It consists of a kernel module "
"(fuse.ko), a userspace library (libfuse.*) and a mount utility (fusermount)."
msgstr ""

#: ../../../filesystems/fuse.rst:44
msgid ""
"One of the most important features of FUSE is allowing secure, non-"
"privileged mounts.  This opens up new possibilities for the use of "
"filesystems.  A good example is sshfs: a secure network filesystem using the "
"sftp protocol."
msgstr ""

#: ../../../filesystems/fuse.rst:49
msgid ""
"The userspace library and utilities are available from the `FUSE homepage: "
"<https://github.com/libfuse/>`_"
msgstr ""

#: ../../../filesystems/fuse.rst:53
msgid "Filesystem type"
msgstr ""

#: ../../../filesystems/fuse.rst:55
msgid "The filesystem type given to mount(2) can be one of the following:"
msgstr ""

#: ../../../filesystems/fuse.rst:57
msgid "fuse"
msgstr ""

#: ../../../filesystems/fuse.rst:58
msgid ""
"This is the usual way to mount a FUSE filesystem.  The first argument of the "
"mount system call may contain an arbitrary string, which is not interpreted "
"by the kernel."
msgstr ""

#: ../../../filesystems/fuse.rst:62
msgid "fuseblk"
msgstr ""

#: ../../../filesystems/fuse.rst:63
msgid ""
"The filesystem is block device based.  The first argument of the mount "
"system call is interpreted as the name of the device."
msgstr ""

#: ../../../filesystems/fuse.rst:67
msgid "Mount options"
msgstr ""

#: ../../../filesystems/fuse.rst:69
msgid "fd=N"
msgstr ""

#: ../../../filesystems/fuse.rst:70
msgid ""
"The file descriptor to use for communication between the userspace "
"filesystem and the kernel.  The file descriptor must have been obtained by "
"opening the FUSE device ('/dev/fuse')."
msgstr ""

#: ../../../filesystems/fuse.rst:74
msgid "rootmode=M"
msgstr ""

#: ../../../filesystems/fuse.rst:75
msgid "The file mode of the filesystem's root in octal representation."
msgstr ""

#: ../../../filesystems/fuse.rst:77
msgid "user_id=N"
msgstr ""

#: ../../../filesystems/fuse.rst:78
msgid "The numeric user id of the mount owner."
msgstr ""

#: ../../../filesystems/fuse.rst:80
msgid "group_id=N"
msgstr ""

#: ../../../filesystems/fuse.rst:81
msgid "The numeric group id of the mount owner."
msgstr ""

#: ../../../filesystems/fuse.rst:83
msgid "default_permissions"
msgstr ""

#: ../../../filesystems/fuse.rst:84
msgid ""
"By default FUSE doesn't check file access permissions, the filesystem is "
"free to implement its access policy or leave it to the underlying file "
"access mechanism (e.g. in case of network filesystems).  This option enables "
"permission checking, restricting access based on file mode.  It is usually "
"useful together with the 'allow_other' mount option."
msgstr ""

#: ../../../filesystems/fuse.rst:91
msgid "allow_other"
msgstr ""

#: ../../../filesystems/fuse.rst:92
msgid ""
"This option overrides the security measure restricting file access to the "
"user mounting the filesystem.  This option is by default only allowed to "
"root, but this restriction can be removed with a (userspace) configuration "
"option."
msgstr ""

#: ../../../filesystems/fuse.rst:97
msgid "max_read=N"
msgstr ""

#: ../../../filesystems/fuse.rst:98
msgid ""
"With this option the maximum size of read operations can be set. The default "
"is infinite.  Note that the size of read requests is limited anyway to 32 "
"pages (which is 128kbyte on i386)."
msgstr ""

#: ../../../filesystems/fuse.rst:102
msgid "blksize=N"
msgstr ""

#: ../../../filesystems/fuse.rst:103
msgid ""
"Set the block size for the filesystem.  The default is 512.  This option is "
"only valid for 'fuseblk' type mounts."
msgstr ""

#: ../../../filesystems/fuse.rst:107
msgid "Control filesystem"
msgstr ""

#: ../../../filesystems/fuse.rst:109
msgid "There's a control filesystem for FUSE, which can be mounted by::"
msgstr ""

#: ../../../filesystems/fuse.rst:113
msgid ""
"Mounting it under the '/sys/fs/fuse/connections' directory makes it "
"backwards compatible with earlier versions."
msgstr ""

#: ../../../filesystems/fuse.rst:116
msgid ""
"Under the fuse control filesystem each connection has a directory named by a "
"unique number."
msgstr ""

#: ../../../filesystems/fuse.rst:119
msgid "For each connection the following files exist within this directory:"
msgstr ""

#: ../../../filesystems/fuse.rst:121
msgid "waiting"
msgstr ""

#: ../../../filesystems/fuse.rst:122
msgid ""
"The number of requests which are waiting to be transferred to userspace or "
"being processed by the filesystem daemon.  If there is no filesystem "
"activity and 'waiting' is non-zero, then the filesystem is hung or "
"deadlocked."
msgstr ""

#: ../../../filesystems/fuse.rst:127
msgid "abort"
msgstr ""

#: ../../../filesystems/fuse.rst:128
msgid ""
"Writing anything into this file will abort the filesystem connection.  This "
"means that all waiting requests will be aborted an error returned for all "
"aborted and new requests."
msgstr ""

#: ../../../filesystems/fuse.rst:132
msgid "Only the owner of the mount may read or write these files."
msgstr ""

#: ../../../filesystems/fuse.rst:135
msgid "Interrupting filesystem operations"
msgstr ""

#: ../../../filesystems/fuse.rst:137
msgid ""
"If a process issuing a FUSE filesystem request is interrupted, the following "
"will happen:"
msgstr ""

#: ../../../filesystems/fuse.rst:140
msgid ""
"If the request is not yet sent to userspace AND the signal is fatal (SIGKILL "
"or unhandled fatal signal), then the request is dequeued and returns "
"immediately."
msgstr ""

#: ../../../filesystems/fuse.rst:144
msgid ""
"If the request is not yet sent to userspace AND the signal is not fatal, "
"then an interrupted flag is set for the request.  When the request has been "
"successfully transferred to userspace and this flag is set, an INTERRUPT "
"request is queued."
msgstr ""

#: ../../../filesystems/fuse.rst:149
msgid ""
"If the request is already sent to userspace, then an INTERRUPT request is "
"queued."
msgstr ""

#: ../../../filesystems/fuse.rst:152
msgid ""
"INTERRUPT requests take precedence over other requests, so the userspace "
"filesystem will receive queued INTERRUPTs before any others."
msgstr ""

#: ../../../filesystems/fuse.rst:155
msgid ""
"The userspace filesystem may ignore the INTERRUPT requests entirely, or may "
"honor them by sending a reply to the *original* request, with the error set "
"to EINTR."
msgstr ""

#: ../../../filesystems/fuse.rst:159
msgid ""
"It is also possible that there's a race between processing the original "
"request and its INTERRUPT request.  There are two possibilities:"
msgstr ""

#: ../../../filesystems/fuse.rst:162
msgid ""
"The INTERRUPT request is processed before the original request is processed"
msgstr ""

#: ../../../filesystems/fuse.rst:165
msgid ""
"The INTERRUPT request is processed after the original request has been "
"answered"
msgstr ""

#: ../../../filesystems/fuse.rst:168
msgid ""
"If the filesystem cannot find the original request, it should wait for some "
"timeout and/or a number of new requests to arrive, after which it should "
"reply to the INTERRUPT request with an EAGAIN error.  In case 1) the "
"INTERRUPT request will be requeued.  In case 2) the INTERRUPT reply will be "
"ignored."
msgstr ""

#: ../../../filesystems/fuse.rst:175
msgid "Aborting a filesystem connection"
msgstr ""

#: ../../../filesystems/fuse.rst:177
msgid ""
"It is possible to get into certain situations where the filesystem is not "
"responding.  Reasons for this may be:"
msgstr ""

#: ../../../filesystems/fuse.rst:180
msgid "Broken userspace filesystem implementation"
msgstr ""

#: ../../../filesystems/fuse.rst:182
msgid "Network connection down"
msgstr ""

#: ../../../filesystems/fuse.rst:184
msgid "Accidental deadlock"
msgstr ""

#: ../../../filesystems/fuse.rst:186
msgid "Malicious deadlock"
msgstr ""

#: ../../../filesystems/fuse.rst:188
msgid "(For more on c) and d) see later sections)"
msgstr ""

#: ../../../filesystems/fuse.rst:190
msgid ""
"In either of these cases it may be useful to abort the connection to the "
"filesystem.  There are several ways to do this:"
msgstr ""

#: ../../../filesystems/fuse.rst:193
msgid "Kill the filesystem daemon.  Works in case of a) and b)"
msgstr ""

#: ../../../filesystems/fuse.rst:195
msgid ""
"Kill the filesystem daemon and all users of the filesystem.  Works in all "
"cases except some malicious deadlocks"
msgstr ""

#: ../../../filesystems/fuse.rst:198
msgid ""
"Use forced umount (umount -f).  Works in all cases but only if filesystem is "
"still attached (it hasn't been lazy unmounted)"
msgstr ""

#: ../../../filesystems/fuse.rst:201
msgid ""
"Abort filesystem through the FUSE control filesystem.  Most powerful method, "
"always works."
msgstr ""

#: ../../../filesystems/fuse.rst:205
msgid "How do non-privileged mounts work?"
msgstr ""

#: ../../../filesystems/fuse.rst:207
msgid ""
"Since the mount() system call is a privileged operation, a helper program "
"(fusermount) is needed, which is installed setuid root."
msgstr ""

#: ../../../filesystems/fuse.rst:210
msgid ""
"The implication of providing non-privileged mounts is that the mount owner "
"must not be able to use this capability to compromise the system.  Obvious "
"requirements arising from this are:"
msgstr ""

#: ../../../filesystems/fuse.rst:214
msgid ""
"mount owner should not be able to get elevated privileges with the help of "
"the mounted filesystem"
msgstr ""

#: ../../../filesystems/fuse.rst:217
msgid ""
"mount owner should not get illegitimate access to information from other "
"users' and the super user's processes"
msgstr ""

#: ../../../filesystems/fuse.rst:220
msgid ""
"mount owner should not be able to induce undesired behavior in other users' "
"or the super user's processes"
msgstr ""

#: ../../../filesystems/fuse.rst:224
msgid "How are requirements fulfilled?"
msgstr ""

#: ../../../filesystems/fuse.rst:226
msgid "The mount owner could gain elevated privileges by either:"
msgstr ""

#: ../../../filesystems/fuse.rst:228
msgid ""
"creating a filesystem containing a device file, then opening this device"
msgstr ""

#: ../../../filesystems/fuse.rst:230
msgid ""
"creating a filesystem containing a suid or sgid application, then executing "
"this application"
msgstr ""

#: ../../../filesystems/fuse.rst:232
msgid ""
"The solution is not to allow opening device files and ignore setuid and "
"setgid bits when executing programs.  To ensure this fusermount always adds "
"\"nosuid\" and \"nodev\" to the mount options for non-privileged mounts."
msgstr ""

#: ../../../filesystems/fuse.rst:237
msgid ""
"If another user is accessing files or directories in the filesystem, the "
"filesystem daemon serving requests can record the exact sequence and timing "
"of operations performed.  This information is otherwise inaccessible to the "
"mount owner, so this counts as an information leak."
msgstr ""

#: ../../../filesystems/fuse.rst:243
msgid "The solution to this problem will be presented in point 2) of C)."
msgstr ""

#: ../../../filesystems/fuse.rst:245
msgid ""
"There are several ways in which the mount owner can induce undesired "
"behavior in other users' processes, such as:"
msgstr ""

#: ../../../filesystems/fuse.rst:248
msgid ""
"mounting a filesystem over a file or directory which the mount owner could "
"otherwise not be able to modify (or could only make limited modifications)."
msgstr ""

#: ../../../filesystems/fuse.rst:252
msgid ""
"This is solved in fusermount, by checking the access permissions on the "
"mountpoint and only allowing the mount if the mount owner can do unlimited "
"modification (has write access to the mountpoint, and mountpoint is not a "
"\"sticky\" directory)"
msgstr ""

#: ../../../filesystems/fuse.rst:258
msgid ""
"Even if 1) is solved the mount owner can change the behavior of other users' "
"processes."
msgstr ""

#: ../../../filesystems/fuse.rst:261
msgid ""
"It can slow down or indefinitely delay the execution of a filesystem "
"operation creating a DoS against the user or the whole system.  For example "
"a suid application locking a system file, and then accessing a file on the "
"mount owner's filesystem could be stopped, and thus causing the system file "
"to be locked forever."
msgstr ""

#: ../../../filesystems/fuse.rst:268
msgid ""
"It can present files or directories of unlimited length, or directory "
"structures of unlimited depth, possibly causing a system process to eat up "
"diskspace, memory or other resources, again causing *DoS*."
msgstr ""

#: ../../../filesystems/fuse.rst:273
msgid ""
"The solution to this as well as B) is not to allow processes to access the "
"filesystem, which could otherwise not be monitored or manipulated by the "
"mount owner.  Since if the mount owner can ptrace a process, it can do all "
"of the above without using a FUSE mount, the same criteria as used in ptrace "
"can be used to check if a process is allowed to access the filesystem or not."
msgstr ""

#: ../../../filesystems/fuse.rst:281
msgid ""
"Note that the *ptrace* check is not strictly necessary to prevent C/2/i, it "
"is enough to check if mount owner has enough privilege to send signal to the "
"process accessing the filesystem, since *SIGSTOP* can be used to get a "
"similar effect."
msgstr ""

#: ../../../filesystems/fuse.rst:287
msgid "I think these limitations are unacceptable?"
msgstr ""

#: ../../../filesystems/fuse.rst:289
msgid ""
"If a sysadmin trusts the users enough, or can ensure through other measures, "
"that system processes will never enter non-privileged mounts, it can relax "
"the last limitation in several ways:"
msgstr ""

#: ../../../filesystems/fuse.rst:293
msgid ""
"With the 'user_allow_other' config option. If this config option is set, the "
"mounting user can add the 'allow_other' mount option which disables the "
"check for other users' processes."
msgstr ""

#: ../../../filesystems/fuse.rst:297
msgid ""
"User namespaces have an unintuitive interaction with 'allow_other': an "
"unprivileged user - normally restricted from mounting with 'allow_other' - "
"could do so in a user namespace where they're privileged. If any process "
"could access such an 'allow_other' mount this would give the mounting user "
"the ability to manipulate processes in user namespaces where they're "
"unprivileged. For this reason 'allow_other' restricts access to users in the "
"same userns or a descendant."
msgstr ""

#: ../../../filesystems/fuse.rst:306
msgid ""
"With the 'allow_sys_admin_access' module option. If this option is set, "
"super user's processes have unrestricted access to mounts irrespective of "
"allow_other setting or user namespace of the mounting user."
msgstr ""

#: ../../../filesystems/fuse.rst:311
msgid ""
"Note that both of these relaxations expose the system to potential "
"information leak or *DoS* as described in points B and C/2/i-ii in the "
"preceding section."
msgstr ""

#: ../../../filesystems/fuse.rst:316
msgid "Kernel - userspace interface"
msgstr ""

#: ../../../filesystems/fuse.rst:318
msgid ""
"The following diagram shows how a filesystem operation (in this example "
"unlink) is performed in FUSE. ::"
msgstr ""

#: ../../../filesystems/fuse.rst:362
msgid "Everything in the description above is greatly simplified"
msgstr ""

#: ../../../filesystems/fuse.rst:364
msgid ""
"There are a couple of ways in which to deadlock a FUSE filesystem. Since we "
"are talking about unprivileged userspace programs, something must be done "
"about these."
msgstr ""

#: ../../../filesystems/fuse.rst:368
msgid "**Scenario 1 -  Simple deadlock**::"
msgstr ""

#: ../../../filesystems/fuse.rst:383
msgid "The solution for this is to allow the filesystem to be aborted."
msgstr ""

#: ../../../filesystems/fuse.rst:385
msgid "**Scenario 2 - Tricky deadlock**"
msgstr ""

#: ../../../filesystems/fuse.rst:388
msgid ""
"This one needs a carefully crafted filesystem.  It's a variation on the "
"above, only the call back to the filesystem is not explicit, but is caused "
"by a pagefault. ::"
msgstr ""

#: ../../../filesystems/fuse.rst:416
msgid "The solution is basically the same as above."
msgstr ""

#: ../../../filesystems/fuse.rst:418
msgid ""
"An additional problem is that while the write buffer is being copied to the "
"request, the request must not be interrupted/aborted.  This is because the "
"destination address of the copy may not be valid after the request has "
"returned."
msgstr ""

#: ../../../filesystems/fuse.rst:423
msgid ""
"This is solved with doing the copy atomically, and allowing abort while the "
"page(s) belonging to the write buffer are faulted with get_user_pages().  "
"The 'req->locked' flag indicates when the copy is taking place, and abort is "
"delayed until this flag is unset."
msgstr ""
