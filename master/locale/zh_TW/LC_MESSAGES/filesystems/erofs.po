# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/erofs.rst:5
msgid "EROFS - Enhanced Read-Only File System"
msgstr ""

#: ../../../filesystems/erofs.rst:8
msgid "Overview"
msgstr ""

#: ../../../filesystems/erofs.rst:10
msgid ""
"EROFS filesystem stands for Enhanced Read-Only File System.  It aims to form "
"a generic read-only filesystem solution for various read-only use cases "
"instead of just focusing on storage space saving without considering any "
"side effects of runtime performance."
msgstr ""

#: ../../../filesystems/erofs.rst:15
msgid ""
"It is designed to meet the needs of flexibility, feature extendability and "
"user payload friendly, etc.  Apart from those, it is still kept as a simple "
"random-access friendly high-performance filesystem to get rid of unneeded I/"
"O amplification and memory-resident overhead compared to similar approaches."
msgstr ""

#: ../../../filesystems/erofs.rst:20
msgid "It is implemented to be a better choice for the following scenarios:"
msgstr ""

#: ../../../filesystems/erofs.rst:22
msgid "read-only storage media or"
msgstr ""

#: ../../../filesystems/erofs.rst:24
msgid ""
"part of a fully trusted read-only solution, which means it needs to be "
"immutable and bit-for-bit identical to the official golden image for their "
"releases due to security or other considerations and"
msgstr ""

#: ../../../filesystems/erofs.rst:28
msgid ""
"hope to minimize extra storage space with guaranteed end-to-end performance "
"by using compact layout, transparent file compression and direct access, "
"especially for those embedded devices with limited memory and high-density "
"hosts with numerous containers."
msgstr ""

#: ../../../filesystems/erofs.rst:33
msgid "Here are the main features of EROFS:"
msgstr ""

#: ../../../filesystems/erofs.rst:35
msgid "Little endian on-disk design;"
msgstr ""

#: ../../../filesystems/erofs.rst:37
msgid ""
"Block-based distribution and file-based distribution over fscache are "
"supported;"
msgstr ""

#: ../../../filesystems/erofs.rst:40
msgid ""
"Support multiple devices to refer to external blobs, which can be used for "
"container images;"
msgstr ""

#: ../../../filesystems/erofs.rst:43
msgid ""
"32-bit block addresses for each device, therefore 16TiB address space at "
"most with 4KiB block size for now;"
msgstr ""

#: ../../../filesystems/erofs.rst:46
msgid "Two inode layouts for different requirements:"
msgstr ""

#: ../../../filesystems/erofs.rst:51
msgid "Inode metadata size"
msgstr ""

#: ../../../filesystems/erofs.rst:51
msgid "32 bytes"
msgstr ""

#: ../../../filesystems/erofs.rst:51
msgid "64 bytes"
msgstr ""

#: ../../../filesystems/erofs.rst:52
msgid "Max file size"
msgstr ""

#: ../../../filesystems/erofs.rst:52
msgid "4 GiB"
msgstr ""

#: ../../../filesystems/erofs.rst:52
msgid "16 EiB (also limited by max. vol size)"
msgstr ""

#: ../../../filesystems/erofs.rst:53
msgid "Max uids/gids"
msgstr ""

#: ../../../filesystems/erofs.rst:53 ../../../filesystems/erofs.rst:55
msgid "65536"
msgstr ""

#: ../../../filesystems/erofs.rst:53 ../../../filesystems/erofs.rst:55
msgid "4294967296"
msgstr ""

#: ../../../filesystems/erofs.rst:54
msgid "Per-inode timestamp"
msgstr ""

#: ../../../filesystems/erofs.rst:54
msgid "no"
msgstr ""

#: ../../../filesystems/erofs.rst:54
msgid "yes (64 + 32-bit timestamp)"
msgstr ""

#: ../../../filesystems/erofs.rst:55
msgid "Max hardlinks"
msgstr ""

#: ../../../filesystems/erofs.rst:56
msgid "Metadata reserved"
msgstr ""

#: ../../../filesystems/erofs.rst:56
msgid "8 bytes"
msgstr ""

#: ../../../filesystems/erofs.rst:56
msgid "18 bytes"
msgstr ""

#: ../../../filesystems/erofs.rst:59
msgid "Support extended attributes as an option;"
msgstr ""

#: ../../../filesystems/erofs.rst:61
msgid ""
"Support a bloom filter that speeds up negative extended attribute lookups;"
msgstr ""

#: ../../../filesystems/erofs.rst:63
msgid "Support POSIX.1e ACLs by using extended attributes;"
msgstr ""

#: ../../../filesystems/erofs.rst:65
msgid ""
"Support transparent data compression as an option: LZ4, MicroLZMA and "
"DEFLATE algorithms can be used on a per-file basis; In addition, inplace "
"decompression is also supported to avoid bounce compressed buffers and "
"unnecessary page cache thrashing."
msgstr ""

#: ../../../filesystems/erofs.rst:70
msgid ""
"Support chunk-based data deduplication and rolling-hash compressed data "
"deduplication;"
msgstr ""

#: ../../../filesystems/erofs.rst:73
msgid ""
"Support tailpacking inline compared to byte-addressed unaligned metadata or "
"smaller block size alternatives;"
msgstr ""

#: ../../../filesystems/erofs.rst:76
msgid "Support merging tail-end data into a special inode as fragments."
msgstr ""

#: ../../../filesystems/erofs.rst:78
msgid "Support large folios to make use of THPs (Transparent Hugepages);"
msgstr ""

#: ../../../filesystems/erofs.rst:80
msgid ""
"Support direct I/O on uncompressed files to avoid double caching for loop "
"devices;"
msgstr ""

#: ../../../filesystems/erofs.rst:83
msgid ""
"Support FSDAX on uncompressed images for secure containers and ramdisks in "
"order to get rid of unnecessary page cache."
msgstr ""

#: ../../../filesystems/erofs.rst:86
msgid "Support file-based on-demand loading with the Fscache infrastructure."
msgstr ""

#: ../../../filesystems/erofs.rst:88
msgid ""
"The following git tree provides the file system user-space tools under "
"development, such as a formatting tool (mkfs.erofs), an on-disk consistency "
"& compatibility checking tool (fsck.erofs), and a debugging tool (dump."
"erofs):"
msgstr ""

#: ../../../filesystems/erofs.rst:92
msgid "git://git.kernel.org/pub/scm/linux/kernel/git/xiang/erofs-utils.git"
msgstr ""

#: ../../../filesystems/erofs.rst:94
msgid "For more information, please also refer to the documentation site:"
msgstr ""

#: ../../../filesystems/erofs.rst:96
msgid "https://erofs.docs.kernel.org"
msgstr ""

#: ../../../filesystems/erofs.rst:98
msgid ""
"Bugs and patches are welcome, please kindly help us and send to the "
"following linux-erofs mailing list:"
msgstr ""

#: ../../../filesystems/erofs.rst:101
msgid "linux-erofs mailing list   <linux-erofs@lists.ozlabs.org>"
msgstr ""

#: ../../../filesystems/erofs.rst:104
msgid "Mount options"
msgstr ""

#: ../../../filesystems/erofs.rst:107
msgid "(no)user_xattr"
msgstr ""

#: ../../../filesystems/erofs.rst:107
msgid ""
"Setup Extended User Attributes. Note: xattr is enabled by default if "
"CONFIG_EROFS_FS_XATTR is selected."
msgstr ""

#: ../../../filesystems/erofs.rst:109
msgid "(no)acl"
msgstr ""

#: ../../../filesystems/erofs.rst:109
msgid ""
"Setup POSIX Access Control List. Note: acl is enabled by default if "
"CONFIG_EROFS_FS_POSIX_ACL is selected."
msgstr ""

#: ../../../filesystems/erofs.rst:111
msgid "cache_strategy=%s"
msgstr ""

#: ../../../filesystems/erofs.rst:111
msgid "Select a strategy for cached decompression from now on:"
msgstr ""

#: ../../../filesystems/erofs.rst:114
msgid "disabled"
msgstr ""

#: ../../../filesystems/erofs.rst:114
msgid "In-place I/O decompression only;"
msgstr ""

#: ../../../filesystems/erofs.rst:115
msgid "readahead"
msgstr ""

#: ../../../filesystems/erofs.rst:115
msgid ""
"Cache the last incomplete compressed physical cluster for further reading. "
"It still does in-place I/O decompression for the rest compressed physical "
"clusters;"
msgstr ""

#: ../../../filesystems/erofs.rst:119
msgid "readaround"
msgstr ""

#: ../../../filesystems/erofs.rst:119
msgid ""
"Cache the both ends of incomplete compressed physical clusters for further "
"reading. It still does in-place I/O decompression for the rest compressed "
"physical clusters."
msgstr ""

#: ../../../filesystems/erofs.rst:124
msgid "dax={always,never}"
msgstr ""

#: ../../../filesystems/erofs.rst:124
msgid ""
"Use direct access (no page cache).  See Documentation/filesystems/dax.rst."
msgstr ""

#: ../../../filesystems/erofs.rst:126
msgid "dax"
msgstr ""

#: ../../../filesystems/erofs.rst:126
msgid "A legacy option which is an alias for ``dax=always``."
msgstr ""

#: ../../../filesystems/erofs.rst:127
msgid "device=%s"
msgstr ""

#: ../../../filesystems/erofs.rst:127
msgid "Specify a path to an extra device to be used together."
msgstr ""

#: ../../../filesystems/erofs.rst:128
msgid "fsid=%s"
msgstr ""

#: ../../../filesystems/erofs.rst:128
msgid "Specify a filesystem image ID for Fscache back-end."
msgstr ""

#: ../../../filesystems/erofs.rst:129
msgid "domain_id=%s"
msgstr ""

#: ../../../filesystems/erofs.rst:129
msgid ""
"Specify a domain ID in fscache mode so that different images with the same "
"blobs under a given domain ID can share storage."
msgstr ""

#: ../../../filesystems/erofs.rst:131
msgid "fsoffset=%llu"
msgstr ""

#: ../../../filesystems/erofs.rst:131
msgid "Specify block-aligned filesystem offset for the primary device."
msgstr ""

#: ../../../filesystems/erofs.rst:135
msgid "Sysfs Entries"
msgstr ""

#: ../../../filesystems/erofs.rst:137
msgid ""
"Information about mounted erofs file systems can be found in /sys/fs/erofs. "
"Each mounted filesystem will have a directory in /sys/fs/erofs based on its "
"device name (i.e., /sys/fs/erofs/sda). (see also Documentation/ABI/testing/"
"sysfs-fs-erofs)"
msgstr ""

#: ../../../filesystems/erofs.rst:143
msgid "On-disk details"
msgstr ""

#: ../../../filesystems/erofs.rst:146
msgid "Summary"
msgstr ""

#: ../../../filesystems/erofs.rst:147
msgid ""
"Different from other read-only file systems, an EROFS volume is designed to "
"be as simple as possible::"
msgstr ""

#: ../../../filesystems/erofs.rst:156
msgid ""
"All data areas should be aligned with the block size, but metadata areas may "
"not. All metadatas can be now observed in two different spaces (views):"
msgstr ""

#: ../../../filesystems/erofs.rst:159
msgid "Inode metadata space"
msgstr ""

#: ../../../filesystems/erofs.rst:161
msgid ""
"Each valid inode should be aligned with an inode slot, which is a fixed "
"value (32 bytes) and designed to be kept in line with compact inode size."
msgstr ""

#: ../../../filesystems/erofs.rst:164
msgid "Each inode can be directly found with the following formula:"
msgstr ""

#: ../../../filesystems/erofs.rst:165
msgid "inode offset = meta_blkaddr * block_size + 32 * nid"
msgstr ""

#: ../../../filesystems/erofs.rst:195
msgid ""
"Inode could be 32 or 64 bytes, which can be distinguished from a common "
"field which all inode versions have -- i_format::"
msgstr ""

#: ../../../filesystems/erofs.rst:207
msgid ""
"Xattrs, extents, data inline are placed after the corresponding inode with "
"proper alignment, and they could be optional for different data mappings. "
"_currently_ total 5 data layouts are supported:"
msgstr ""

#: ../../../filesystems/erofs.rst:212
msgid "0"
msgstr ""

#: ../../../filesystems/erofs.rst:212
msgid "flat file data without data inline (no extent);"
msgstr ""

#: ../../../filesystems/erofs.rst:213
msgid "1"
msgstr ""

#: ../../../filesystems/erofs.rst:213
msgid "fixed-sized output data compression (with non-compacted indexes);"
msgstr ""

#: ../../../filesystems/erofs.rst:214
msgid "2"
msgstr ""

#: ../../../filesystems/erofs.rst:214
msgid "flat file data with tail packing data inline (no extent);"
msgstr ""

#: ../../../filesystems/erofs.rst:215
msgid "3"
msgstr ""

#: ../../../filesystems/erofs.rst:215
msgid "fixed-sized output data compression (with compacted indexes, v5.3+);"
msgstr ""

#: ../../../filesystems/erofs.rst:216
msgid "4"
msgstr ""

#: ../../../filesystems/erofs.rst:216
msgid "chunk-based file (v5.15+)."
msgstr ""

#: ../../../filesystems/erofs.rst:219
msgid ""
"The size of the optional xattrs is indicated by i_xattr_count in inode "
"header. Large xattrs or xattrs shared by many different files can be stored "
"in shared xattrs metadata rather than inlined right after inode."
msgstr ""

#: ../../../filesystems/erofs.rst:223
msgid "Shared xattrs metadata space"
msgstr ""

#: ../../../filesystems/erofs.rst:225
msgid ""
"Shared xattrs space is similar to the above inode space, started with a "
"specific block indicated by xattr_blkaddr, organized one by one with proper "
"align."
msgstr ""

#: ../../../filesystems/erofs.rst:229
msgid "Each share xattr can also be directly found by the following formula:"
msgstr ""

#: ../../../filesystems/erofs.rst:230
msgid "xattr offset = xattr_blkaddr * block_size + 4 * xattr_id"
msgstr ""

#: ../../../filesystems/erofs.rst:241
msgid "Directories"
msgstr ""

#: ../../../filesystems/erofs.rst:242
msgid ""
"All directories are now organized in a compact on-disk format. Note that "
"each directory block is divided into index and name areas in order to "
"support random file lookup, and all directory entries are _strictly_ "
"recorded in alphabetical order in order to support improved prefix binary "
"search algorithm (could refer to the related source code)."
msgstr ""

#: ../../../filesystems/erofs.rst:263
msgid ""
"Note that apart from the offset of the first filename, nameoff0 also "
"indicates the total number of directory entries in this block since it is no "
"need to introduce another on-disk field at all."
msgstr ""

#: ../../../filesystems/erofs.rst:268
msgid "Chunk-based files"
msgstr ""

#: ../../../filesystems/erofs.rst:269
msgid ""
"In order to support chunk-based data deduplication, a new inode data layout "
"has been supported since Linux v5.15: Files are split in equal-sized data "
"chunks with ``extents`` area of the inode metadata indicating how to get the "
"chunk data: these can be simply as a 4-byte block address array or in the 8-"
"byte chunk index form (see struct erofs_inode_chunk_index in erofs_fs.h for "
"more details.)"
msgstr ""

#: ../../../filesystems/erofs.rst:276
msgid "By the way, chunk-based files are all uncompressed for now."
msgstr ""

#: ../../../filesystems/erofs.rst:279
msgid "Long extended attribute name prefixes"
msgstr ""

#: ../../../filesystems/erofs.rst:280
msgid ""
"There are use cases where extended attributes with different values can have "
"only a few common prefixes (such as overlayfs xattrs).  The predefined "
"prefixes work inefficiently in both image size and runtime performance in "
"such cases."
msgstr ""

#: ../../../filesystems/erofs.rst:284
msgid ""
"The long xattr name prefixes feature is introduced to address this issue.  "
"The overall idea is that, apart from the existing predefined prefixes, the "
"xattr entry could also refer to user-specified long xattr name prefixes, e."
"g. \"trusted.overlay.\"."
msgstr ""

#: ../../../filesystems/erofs.rst:289
msgid ""
"When referring to a long xattr name prefix, the highest bit (bit 7) of "
"erofs_xattr_entry.e_name_index is set, while the lower bits (bit 0-6) as a "
"whole represent the index of the referred long name prefix among all long "
"name prefixes.  Therefore, only the trailing part of the name apart from the "
"long xattr name prefix is stored in erofs_xattr_entry.e_name, which could be "
"empty if the full xattr name matches exactly as its long xattr name prefix."
msgstr ""

#: ../../../filesystems/erofs.rst:296
msgid ""
"All long xattr prefixes are stored one by one in the packed inode as long as "
"the packed inode is valid, or in the meta inode otherwise.  The "
"xattr_prefix_count (of the on-disk superblock) indicates the total number of "
"long xattr name prefixes, while (xattr_prefix_start * 4) indicates the start "
"offset of long name prefixes in the packed/meta inode.  Note that, long "
"extended attribute name prefixes are disabled if xattr_prefix_count is 0."
msgstr ""

#: ../../../filesystems/erofs.rst:303
msgid ""
"Each long name prefix is stored in the format: ALIGN({__le16 len, data}, 4), "
"where len represents the total size of the data part.  The data part is "
"actually represented by 'struct erofs_xattr_long_prefix', where base_index "
"represents the index of the predefined xattr name prefix, e.g. "
"EROFS_XATTR_INDEX_TRUSTED for \"trusted.overlay.\" long name prefix, while "
"the infix string keeps the string after stripping the short prefix, e.g. "
"\"overlay.\" for the example above."
msgstr ""

#: ../../../filesystems/erofs.rst:311
msgid "Data compression"
msgstr ""

#: ../../../filesystems/erofs.rst:312
msgid ""
"EROFS implements fixed-sized output compression which generates fixed-sized "
"compressed data blocks from variable-sized input in contrast to other "
"existing fixed-sized input solutions. Relatively higher compression ratios "
"can be gotten by using fixed-sized output compression since nowadays popular "
"data compression algorithms are mostly LZ77-based and such fixed-sized "
"output approach can be benefited from the historical dictionary (aka. "
"sliding window)."
msgstr ""

#: ../../../filesystems/erofs.rst:319
msgid ""
"In details, original (uncompressed) data is turned into several variable-"
"sized extents and in the meanwhile, compressed into physical clusters "
"(pclusters). In order to record each variable-sized extent, logical clusters "
"(lclusters) are introduced as the basic unit of compress indexes to indicate "
"whether a new extent is generated within the range (HEAD) or not (NONHEAD). "
"Lclusters are now fixed in block size, as illustrated below::"
msgstr ""

#: ../../../filesystems/erofs.rst:342
msgid ""
"A physical cluster can be seen as a container of physical compressed blocks "
"which contains compressed data. Previously, only lcluster-sized (4KB) "
"pclusters were supported. After big pcluster feature is introduced "
"(available since Linux v5.13), pcluster can be a multiple of lcluster size."
msgstr ""

#: ../../../filesystems/erofs.rst:347
msgid ""
"For each HEAD lcluster, clusterofs is recorded to indicate where a new "
"extent starts and blkaddr is used to seek the compressed data. For each "
"NONHEAD lcluster, delta0 and delta1 are available instead of blkaddr to "
"indicate the distance to its HEAD lcluster and the next HEAD lcluster. A "
"PLAIN lcluster is also a HEAD lcluster except that its data is uncompressed. "
"See the comments around \"struct z_erofs_vle_decompressed_index\" in "
"erofs_fs.h for more details."
msgstr ""

#: ../../../filesystems/erofs.rst:354
msgid ""
"If big pcluster is enabled, pcluster size in lclusters needs to be recorded "
"as well. Let the delta0 of the first NONHEAD lcluster store the compressed "
"block count with a special flag as a new called CBLKCNT NONHEAD lcluster. "
"It's easy to understand its delta0 is constantly 1, as illustrated below::"
msgstr ""

#: ../../../filesystems/erofs.rst:365
msgid ""
"If another HEAD follows a HEAD lcluster, there is no room to record CBLKCNT, "
"but it's easy to know the size of such pcluster is 1 lcluster as well."
msgstr ""

#: ../../../filesystems/erofs.rst:368
msgid ""
"Since Linux v6.1, each pcluster can be used for multiple variable-sized "
"extents, therefore it can be used for compressed data deduplication."
msgstr ""
