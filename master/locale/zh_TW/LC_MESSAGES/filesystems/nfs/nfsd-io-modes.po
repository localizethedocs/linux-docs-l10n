# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-06 06:05+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/nfs/nfsd-io-modes.rst:5
msgid "NFSD IO MODES"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:8
msgid "Overview"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:10
msgid ""
"NFSD has historically always used buffered IO when servicing READ and WRITE "
"operations. BUFFERED is NFSD's default IO mode, but it is possible to "
"override that default to use either DONTCACHE or DIRECT IO modes."
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:14
msgid ""
"Experimental NFSD debugfs interfaces are available to allow the NFSD IO mode "
"used for READ and WRITE to be configured independently. See both:"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:17
msgid "/sys/kernel/debug/nfsd/io_cache_read"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:18
msgid "/sys/kernel/debug/nfsd/io_cache_write"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:20
msgid ""
"The default value for both io_cache_read and io_cache_write reflects NFSD's "
"default IO mode (which is NFSD_IO_BUFFERED=0)."
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:23
msgid "Based on the configured settings, NFSD's IO will either be:"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:25
msgid "cached using page cache (NFSD_IO_BUFFERED=0)"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:26
msgid "cached but removed from page cache on completion (NFSD_IO_DONTCACHE=1)"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:27
msgid "not cached stable_how=NFS_UNSTABLE (NFSD_IO_DIRECT=2)"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:29
msgid ""
"To set an NFSD IO mode, write a supported value (0 - 2) to the corresponding "
"IO operation's debugfs interface, e.g.::"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:35
msgid ""
"To check which IO mode NFSD is using for READ or WRITE, simply read the "
"corresponding IO operation's debugfs interface, e.g.::"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:41
msgid ""
"If you experiment with NFSD's IO modes on a recent kernel and have "
"interesting results, please report them to linux-nfs@vger.kernel.org"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:45
msgid "NFSD DONTCACHE"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:47
msgid ""
"DONTCACHE offers a hybrid approach to servicing IO that aims to offer the "
"benefits of using DIRECT IO without any of the strict alignment requirements "
"that DIRECT IO imposes. To achieve this buffered IO is used but the IO is "
"flagged to \"drop behind\" (meaning associated pages are dropped from the "
"page cache) when IO completes."
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:53
msgid ""
"DONTCACHE aims to avoid what has proven to be a fairly significant limition "
"of Linux's memory management subsystem if/when large amounts of data is "
"infrequently accessed (e.g. read once _or_ written once but not read until "
"much later). Such use-cases are particularly problematic because the page "
"cache will eventually become a bottleneck to servicing new IO requests."
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:60
msgid "For more context on DONTCACHE, please see these Linux commit headers:"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:62
msgid ""
"Overview:  9ad6344568cc3 (\"mm/filemap: change filemap_create_folio() to "
"take a struct kiocb\")"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:64
msgid ""
"for READ:  8026e49bff9b1 (\"mm/filemap: add read support for RWF_DONTCACHE\")"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:66
msgid "for WRITE: 974c5e6139db3 (\"xfs: flag as supporting FOP_DONTCACHE\")"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:68
msgid ""
"NFSD_IO_DONTCACHE will fall back to NFSD_IO_BUFFERED if the underlying "
"filesystem doesn't indicate support by setting FOP_DONTCACHE."
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:72
msgid "NFSD DIRECT"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:74
msgid ""
"DIRECT IO doesn't make use of the page cache, as such it is able to avoid "
"the Linux memory management's page reclaim scalability problems without "
"resorting to the hybrid use of page cache that DONTCACHE does."
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:78
msgid ""
"Some workloads benefit from NFSD avoiding the page cache, particularly those "
"with a working set that is significantly larger than available system "
"memory. The pathological worst-case workload that NFSD DIRECT has proven to "
"help most is: NFS client issuing large sequential IO to a file that is 2-3 "
"times larger than the NFS server's available system memory. The reason for "
"such improvement is NFSD DIRECT eliminates a lot of work that the memory "
"management subsystem would otherwise be required to perform (e.g. page "
"allocation, dirty writeback, page reclaim). When using NFSD DIRECT, kswapd "
"and kcompactd are no longer commanding CPU time trying to find adequate free "
"pages so that forward IO progress can be made."
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:90
msgid ""
"The performance win associated with using NFSD DIRECT was previously "
"discussed on linux-nfs, see: https://lore.kernel.org/linux-nfs/"
"aEslwqa9iMeZjjlV@kernel.org/"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:94
msgid "But in summary:"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:96
msgid "NFSD DIRECT can significantly reduce memory requirements"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:97
msgid "NFSD DIRECT can reduce CPU load by avoiding costly page reclaim work"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:98
msgid "NFSD DIRECT can offer more deterministic IO performance"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:100
msgid ""
"As always, your mileage may vary and so it is important to carefully "
"consider if/when it is beneficial to make use of NFSD DIRECT. When assessing "
"comparative performance of your workload please be sure to log relevant "
"performance metrics during testing (e.g. memory usage, cpu usage, IO "
"performance). Using perf to collect perf data that may be used to generate a "
"\"flamegraph\" for work Linux must perform on behalf of your test is a "
"really meaningful way to compare the relative health of the system and how "
"switching NFSD's IO mode changes what is observed."
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:109
msgid ""
"If NFSD_IO_DIRECT is specified by writing 2 (or 3 and 4 for WRITE) to NFSD's "
"debugfs interfaces, ideally the IO will be aligned relative to the "
"underlying block device's logical_block_size. Also the memory buffer used to "
"store the READ or WRITE payload must be aligned relative to the underlying "
"block device's dma_alignment."
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:115
msgid ""
"But NFSD DIRECT does handle misaligned IO in terms of O_DIRECT as best it "
"can:"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:118
msgid "Misaligned READ:"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:119
msgid ""
"If NFSD_IO_DIRECT is used, expand any misaligned READ to the next DIO-"
"aligned block (on either end of the READ). The expanded READ is verified to "
"have proper offset/len (logical_block_size) and dma_alignment checking."
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:124
msgid "Misaligned WRITE:"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:125
msgid ""
"If NFSD_IO_DIRECT is used, split any misaligned WRITE into a start, middle "
"and end as needed. The large middle segment is DIO-aligned and the start and/"
"or end are misaligned. Buffered IO is used for the misaligned segments and "
"O_DIRECT is used for the middle DIO-aligned segment. DONTCACHE buffered IO "
"is _not_ used for the misaligned segments because using normal buffered IO "
"offers significant RMW performance benefit when handling streaming "
"misaligned WRITEs."
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:133
msgid "Tracing:"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:134
msgid ""
"The nfsd_read_direct trace event shows how NFSD expands any misaligned READ "
"to the next DIO-aligned block (on either end of the original READ, as "
"needed)."
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:138
msgid "This combination of trace events is useful for READs::"
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:145
msgid ""
"The nfsd_write_direct trace event shows how NFSD splits a given misaligned "
"WRITE into a DIO-aligned middle segment."
msgstr ""

#: ../../../filesystems/nfs/nfsd-io-modes.rst:148
msgid "This combination of trace events is useful for WRITEs::"
msgstr ""
