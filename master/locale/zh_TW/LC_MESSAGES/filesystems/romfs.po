# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/romfs.rst:5
msgid "ROMFS - ROM File System"
msgstr ""

#: ../../../filesystems/romfs.rst:7
msgid ""
"This is a quite dumb, read only filesystem, mainly for initial RAM disks of "
"installation disks.  It has grown up by the need of having modules linked at "
"boot time.  Using this filesystem, you get a very similar feature, and even "
"the possibility of a small kernel, with a file system which doesn't take up "
"useful memory from the router functions in the basement of your office."
msgstr ""

#: ../../../filesystems/romfs.rst:14
msgid ""
"For comparison, both the older minix and xiafs (the latter is now defunct) "
"filesystems, compiled as module need more than 20000 bytes, while romfs is "
"less than a page, about 4000 bytes (assuming i586 code).  Under the same "
"conditions, the msdos filesystem would need about 30K (and does not support "
"device nodes or symlinks), while the nfs module with nfsroot is about 57K.  "
"Furthermore, as a bit unfair comparison, an actual rescue disk used up 3202 "
"blocks with ext2, while with romfs, it needed 3079 blocks."
msgstr ""

#: ../../../filesystems/romfs.rst:23
msgid ""
"To create such a file system, you'll need a user program named genromfs. It "
"is available on http://romfs.sourceforge.net/"
msgstr ""

#: ../../../filesystems/romfs.rst:26
msgid ""
"As the name suggests, romfs could be also used (space-efficiently) on "
"various read-only media, like (E)EPROM disks if someone will have the "
"motivation.. :)"
msgstr ""

#: ../../../filesystems/romfs.rst:30
msgid ""
"However, the main purpose of romfs is to have a very small kernel, which has "
"only this filesystem linked in, and then can load any module later, with the "
"current module utilities.  It can also be used to run some program to decide "
"if you need SCSI devices, and even IDE or floppy drives can be loaded later "
"if you use the \"initrd\"--initial RAM disk--feature of the kernel.  This "
"would not be really news flash, but with romfs, you can even spare off your "
"ext2 or minix or maybe even affs filesystem until you really know that you "
"need it."
msgstr ""

#: ../../../filesystems/romfs.rst:39
msgid ""
"For example, a distribution boot disk can contain only the cd disk drivers "
"(and possibly the SCSI drivers), and the ISO 9660 filesystem module.  The "
"kernel can be small enough, since it doesn't have other filesystems, like "
"the quite large ext2fs module, which can then be loaded off the CD at a "
"later stage of the installation.  Another use would be for a recovery disk, "
"when you are reinstalling a workstation from the network, and you will have "
"all the tools/modules available from a nearby server, so you don't want to "
"carry two disks for this purpose, just because it won't fit into ext2."
msgstr ""

#: ../../../filesystems/romfs.rst:49
msgid ""
"romfs operates on block devices as you can expect, and the underlying "
"structure is very simple.  Every accessible structure begins on 16 byte "
"boundaries for fast access.  The minimum space a file will take is 32 bytes "
"(this is an empty file, with a less than 16 character name).  The maximum "
"overhead for any non-empty file is the header, and the 16 byte padding for "
"the name and the contents, also 16+14+15 = 45 bytes.  This is quite rare "
"however, since most file names are longer than 3 bytes, and shorter than 15 "
"bytes."
msgstr ""

#: ../../../filesystems/romfs.rst:58
msgid "The layout of the filesystem is the following::"
msgstr ""

#: ../../../filesystems/romfs.rst:77
msgid ""
"Every multi byte value (32 bit words, I'll use the longwords term from now "
"on) must be in big endian order."
msgstr ""

#: ../../../filesystems/romfs.rst:80
msgid ""
"The first eight bytes identify the filesystem, even for the casual "
"inspector.  After that, in the 3rd longword, it contains the number of bytes "
"accessible from the start of this filesystem.  The 4th longword is the "
"checksum of the first 512 bytes (or the number of bytes accessible, "
"whichever is smaller).  The applied algorithm is the same as in the AFFS "
"filesystem, namely a simple sum of the longwords (assuming bigendian "
"quantities again).  For details, please consult the source.  This algorithm "
"was chosen because although it's not quite reliable, it does not require any "
"tables, and it is very simple."
msgstr ""

#: ../../../filesystems/romfs.rst:90
msgid ""
"The following bytes are now part of the file system; each file header must "
"begin on a 16 byte boundary::"
msgstr ""

#: ../../../filesystems/romfs.rst:110
msgid ""
"Since the file headers begin always at a 16 byte boundary, the lowest 4 bits "
"would be always zero in the next filehdr pointer.  These four bits are used "
"for the mode information.  Bits 0..2 specify the type of the file; while bit "
"4 shows if the file is executable or not.  The permissions are assumed to be "
"world readable, if this bit is not set, and world executable if it is; "
"except the character and block devices, they are never accessible for other "
"than owner.  The owner of every file is user and group 0, this should never "
"be a problem for the intended use.  The mapping of the 8 possible values to "
"file types is the following:"
msgstr ""

#: ../../../filesystems/romfs.rst:124
msgid "0"
msgstr ""

#: ../../../filesystems/romfs.rst:124
msgid "hard link"
msgstr ""

#: ../../../filesystems/romfs.rst:124
msgid "link destination [file header]"
msgstr ""

#: ../../../filesystems/romfs.rst:125
msgid "1"
msgstr ""

#: ../../../filesystems/romfs.rst:125
msgid "directory"
msgstr ""

#: ../../../filesystems/romfs.rst:125
msgid "first file's header"
msgstr ""

#: ../../../filesystems/romfs.rst:126
msgid "2"
msgstr ""

#: ../../../filesystems/romfs.rst:126
msgid "regular file"
msgstr ""

#: ../../../filesystems/romfs.rst:126
msgid "unused, must be zero [MBZ]"
msgstr ""

#: ../../../filesystems/romfs.rst:127
msgid "3"
msgstr ""

#: ../../../filesystems/romfs.rst:127
msgid "symbolic link"
msgstr ""

#: ../../../filesystems/romfs.rst:127
msgid "unused, MBZ (file data is the link content)"
msgstr ""

#: ../../../filesystems/romfs.rst:128
msgid "4"
msgstr ""

#: ../../../filesystems/romfs.rst:128
msgid "block device"
msgstr ""

#: ../../../filesystems/romfs.rst:128
msgid "16/16 bits major/minor number"
msgstr ""

#: ../../../filesystems/romfs.rst:129
msgid "5"
msgstr ""

#: ../../../filesystems/romfs.rst:129
msgid "char device"
msgstr ""

#: ../../../filesystems/romfs.rst:129
msgid "\" -"
msgstr ""

#: ../../../filesystems/romfs.rst:130
msgid "6"
msgstr ""

#: ../../../filesystems/romfs.rst:130
msgid "socket"
msgstr ""

#: ../../../filesystems/romfs.rst:130 ../../../filesystems/romfs.rst:131
msgid "unused, MBZ"
msgstr ""

#: ../../../filesystems/romfs.rst:131
msgid "7"
msgstr ""

#: ../../../filesystems/romfs.rst:131
msgid "fifo"
msgstr ""

#: ../../../filesystems/romfs.rst:134
msgid ""
"Note that hard links are specifically marked in this filesystem, but they "
"will behave as you can expect (i.e. share the inode number). Note also that "
"it is your responsibility to not create hard link loops, and creating all "
"the . and .. links for directories.  This is normally done correctly by the "
"genromfs program.  Please refrain from using the executable bits for special "
"purposes on the socket and fifo special files, they may have other uses in "
"the future.  Additionally, please remember that only regular files, and "
"symlinks are supposed to have a nonzero size field; they contain the number "
"of bytes available directly after the (padded) file name."
msgstr ""

#: ../../../filesystems/romfs.rst:145
msgid ""
"Another thing to note is that romfs works on file headers and data aligned "
"to 16 byte boundaries, but most hardware devices and the block device "
"drivers are unable to cope with smaller than block-sized data. To overcome "
"this limitation, the whole size of the file system must be padded to an 1024 "
"byte boundary."
msgstr ""

#: ../../../filesystems/romfs.rst:151
msgid ""
"If you have any problems or suggestions concerning this file system, please "
"contact me.  However, think twice before wanting me to add features and "
"code, because the primary and most important advantage of this file system "
"is the small code.  On the other hand, don't be alarmed, I'm not getting "
"that much romfs related mail.  Now I can understand why Avery wrote poems in "
"the ARCnet docs to get some more feedback. :)"
msgstr ""

#: ../../../filesystems/romfs.rst:159
msgid ""
"romfs has also a mailing list, and to date, it hasn't received any traffic, "
"so you are welcome to join it to discuss your ideas. :)"
msgstr ""

#: ../../../filesystems/romfs.rst:162
msgid ""
"It's run by ezmlm, so you can subscribe to it by sending a message to romfs-"
"subscribe@shadow.banki.hu, the content is irrelevant."
msgstr ""

#: ../../../filesystems/romfs.rst:165
msgid "Pending issues:"
msgstr ""

#: ../../../filesystems/romfs.rst:167
msgid ""
"Permissions and owner information are pretty essential features of a Un*x "
"like system, but romfs does not provide the full possibilities. I have never "
"found this limiting, but others might."
msgstr ""

#: ../../../filesystems/romfs.rst:171
msgid ""
"The file system is read only, so it can be very small, but in case one would "
"want to write _anything_ to a file system, he still needs a writable file "
"system, thus negating the size advantages.  Possible solutions: implement "
"write access as a compile-time option, or a new, similarly small writable "
"filesystem for RAM disks."
msgstr ""

#: ../../../filesystems/romfs.rst:177
msgid ""
"Since the files are only required to have alignment on a 16 byte boundary, "
"it is currently possibly suboptimal to read or execute files from the "
"filesystem.  It might be resolved by reordering file data to have most of it "
"(i.e. except the start and the end) laying at \"natural\" boundaries, thus "
"it would be possible to directly map a big portion of the file contents to "
"the mm subsystem."
msgstr ""

#: ../../../filesystems/romfs.rst:184
msgid ""
"Compression might be an useful feature, but memory is quite a limiting "
"factor in my eyes."
msgstr ""

#: ../../../filesystems/romfs.rst:187
msgid "Where it is used?"
msgstr ""

#: ../../../filesystems/romfs.rst:189
msgid "Does it work on other architectures than intel and motorola?"
msgstr ""

#: ../../../filesystems/romfs.rst:192
msgid "Have fun,"
msgstr ""

#: ../../../filesystems/romfs.rst:194
msgid "Janos Farkas <chexum@shadow.banki.hu>"
msgstr ""
