# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../userspace-api/mseal.rst:5
msgid "Introduction of mseal"
msgstr ""

#: ../../../userspace-api/mseal.rst:0
msgid "Author"
msgstr ""

#: ../../../userspace-api/mseal.rst:7
msgid "Jeff Xu <jeffxu@chromium.org>"
msgstr ""

#: ../../../userspace-api/mseal.rst:9
msgid ""
"Modern CPUs support memory permissions such as RW and NX bits. The memory "
"permission feature improves security stance on memory corruption bugs, i.e. "
"the attacker can’t just write to arbitrary memory and point the code to it, "
"the memory has to be marked with X bit, or else an exception will happen."
msgstr ""

#: ../../../userspace-api/mseal.rst:14
msgid ""
"Memory sealing additionally protects the mapping itself against "
"modifications. This is useful to mitigate memory corruption issues where a "
"corrupted pointer is passed to a memory management system. For example, such "
"an attacker primitive can break control-flow integrity guarantees since read-"
"only memory that is supposed to be trusted can become writable or .text "
"pages can get remapped. Memory sealing can automatically be applied by the "
"runtime loader to seal .text and .rodata pages and applications can "
"additionally seal security critical data at runtime."
msgstr ""

#: ../../../userspace-api/mseal.rst:23
msgid ""
"A similar feature already exists in the XNU kernel with the "
"VM_FLAGS_PERMANENT flag [1] and on OpenBSD with the mimmutable syscall [2]."
msgstr ""

#: ../../../userspace-api/mseal.rst:27
msgid "SYSCALL"
msgstr ""

#: ../../../userspace-api/mseal.rst:29
msgid "mseal syscall signature"
msgstr ""

#: ../../../userspace-api/mseal.rst:30
msgid "``int mseal(void *addr, size_t len, unsigned long flags)``"
msgstr ""

#: ../../../userspace-api/mseal.rst:32
msgid "**addr**/**len**: virtual memory address range."
msgstr ""

#: ../../../userspace-api/mseal.rst:33
msgid "The address range set by **addr**/**len** must meet:"
msgstr ""

#: ../../../userspace-api/mseal.rst:34
msgid "The start address must be in an allocated VMA."
msgstr ""

#: ../../../userspace-api/mseal.rst:35
msgid "The start address must be page aligned."
msgstr ""

#: ../../../userspace-api/mseal.rst:36
msgid "The end address (**addr** + **len**) must be in an allocated VMA."
msgstr ""

#: ../../../userspace-api/mseal.rst:37
msgid "no gap (unallocated memory) between start and end address."
msgstr ""

#: ../../../userspace-api/mseal.rst:39
msgid "The ``len`` will be paged aligned implicitly by the kernel."
msgstr ""

#: ../../../userspace-api/mseal.rst:41
msgid "**flags**: reserved for future use."
msgstr ""

#: ../../../userspace-api/mseal.rst:43
msgid "**Return values**:"
msgstr ""

#: ../../../userspace-api/mseal.rst:44
msgid "**0**: Success."
msgstr ""

#: ../../../userspace-api/mseal.rst:45
msgid "**-EINVAL**:"
msgstr ""

#: ../../../userspace-api/mseal.rst:46
msgid "Invalid input ``flags``."
msgstr ""

#: ../../../userspace-api/mseal.rst:47
msgid "The start address (``addr``) is not page aligned."
msgstr ""

#: ../../../userspace-api/mseal.rst:48
msgid "Address range (``addr`` + ``len``) overflow."
msgstr ""

#: ../../../userspace-api/mseal.rst:49
msgid "**-ENOMEM**:"
msgstr ""

#: ../../../userspace-api/mseal.rst:50
msgid "The start address (``addr``) is not allocated."
msgstr ""

#: ../../../userspace-api/mseal.rst:51
msgid "The end address (``addr`` + ``len``) is not allocated."
msgstr ""

#: ../../../userspace-api/mseal.rst:52
msgid "A gap (unallocated memory) between start and end address."
msgstr ""

#: ../../../userspace-api/mseal.rst:53
msgid "**-EPERM**:"
msgstr ""

#: ../../../userspace-api/mseal.rst:54
msgid "sealing is supported only on 64-bit CPUs, 32-bit is not supported."
msgstr ""

#: ../../../userspace-api/mseal.rst:56
msgid "**Note about error return**:"
msgstr ""

#: ../../../userspace-api/mseal.rst:57
msgid ""
"For above error cases, users can expect the given memory range is "
"unmodified, i.e. no partial update."
msgstr ""

#: ../../../userspace-api/mseal.rst:59
msgid ""
"There might be other internal errors/cases not listed here, e.g. error "
"during merging/splitting VMAs, or the process reaching the maximum number of "
"supported VMAs. In those cases, partial updates to the given memory range "
"could happen. However, those cases should be rare."
msgstr ""

#: ../../../userspace-api/mseal.rst:64
msgid "**Architecture support**:"
msgstr ""

#: ../../../userspace-api/mseal.rst:65
msgid "mseal only works on 64-bit CPUs, not 32-bit CPUs."
msgstr ""

#: ../../../userspace-api/mseal.rst:67
msgid "**Idempotent**:"
msgstr ""

#: ../../../userspace-api/mseal.rst:68
msgid ""
"users can call mseal multiple times. mseal on an already sealed memory is a "
"no-action (not error)."
msgstr ""

#: ../../../userspace-api/mseal.rst:71
msgid "**no munseal**"
msgstr ""

#: ../../../userspace-api/mseal.rst:72
msgid ""
"Once mapping is sealed, it can't be unsealed. The kernel should never have "
"munseal, this is consistent with other sealing feature, e.g. F_SEAL_SEAL for "
"file."
msgstr ""

#: ../../../userspace-api/mseal.rst:77
msgid "Blocked mm syscall for sealed mapping"
msgstr ""

#: ../../../userspace-api/mseal.rst:78
msgid ""
"It might be important to note: **once the mapping is sealed, it will stay in "
"the process's memory until the process terminates**."
msgstr ""

#: ../../../userspace-api/mseal.rst:81 ../../../userspace-api/mseal.rst:177
msgid "Example::"
msgstr ""

#: ../../../userspace-api/mseal.rst:89
msgid "Blocked mm syscall:"
msgstr ""

#: ../../../userspace-api/mseal.rst:90
msgid "munmap"
msgstr ""

#: ../../../userspace-api/mseal.rst:91
msgid "mmap"
msgstr ""

#: ../../../userspace-api/mseal.rst:92
msgid "mremap"
msgstr ""

#: ../../../userspace-api/mseal.rst:93
msgid "mprotect and pkey_mprotect"
msgstr ""

#: ../../../userspace-api/mseal.rst:94
msgid ""
"some destructive madvise behaviors: MADV_DONTNEED, MADV_FREE, "
"MADV_DONTNEED_LOCKED, MADV_FREE, MADV_DONTFORK, MADV_WIPEONFORK"
msgstr ""

#: ../../../userspace-api/mseal.rst:97
msgid ""
"The first set of syscalls to block is munmap, mremap, mmap. They can either "
"leave an empty space in the address space, therefore allowing replacement "
"with a new mapping with new set of attributes, or can overwrite the existing "
"mapping with another mapping."
msgstr ""

#: ../../../userspace-api/mseal.rst:102
msgid ""
"mprotect and pkey_mprotect are blocked because they changes the protection "
"bits (RWX) of the mapping."
msgstr ""

#: ../../../userspace-api/mseal.rst:105
msgid ""
"Certain destructive madvise behaviors, specifically MADV_DONTNEED, "
"MADV_FREE, MADV_DONTNEED_LOCKED, and MADV_WIPEONFORK, can introduce risks "
"when applied to anonymous memory by threads lacking write permissions. "
"Consequently, these operations are prohibited under such conditions. The "
"aforementioned behaviors have the potential to modify region contents by "
"discarding pages, effectively performing a memset(0) operation on the "
"anonymous memory."
msgstr ""

#: ../../../userspace-api/mseal.rst:113
msgid "Kernel will return -EPERM for blocked syscalls."
msgstr ""

#: ../../../userspace-api/mseal.rst:115
msgid ""
"When blocked syscall return -EPERM due to sealing, the memory regions may or "
"may not be changed, depends on the syscall being blocked:"
msgstr ""

#: ../../../userspace-api/mseal.rst:118
msgid ""
"munmap: munmap is atomic. If one of VMAs in the given range is sealed, none "
"of VMAs are updated."
msgstr ""

#: ../../../userspace-api/mseal.rst:120
msgid ""
"mprotect, pkey_mprotect, madvise: partial update might happen, e.g. when "
"mprotect over multiple VMAs, mprotect might update the beginning VMAs before "
"reaching the sealed VMA and return -EPERM."
msgstr ""

#: ../../../userspace-api/mseal.rst:123
msgid "mmap and mremap: undefined behavior."
msgstr ""

#: ../../../userspace-api/mseal.rst:126
msgid "Use cases"
msgstr ""

#: ../../../userspace-api/mseal.rst:127
msgid ""
"glibc: The dynamic linker, during loading ELF executables, can apply sealing "
"to mapping segments."
msgstr ""

#: ../../../userspace-api/mseal.rst:131
msgid "Chrome browser: protect some security sensitive data structures."
msgstr ""

#: ../../../userspace-api/mseal.rst:133
msgid ""
"System mappings: The system mappings are created by the kernel and includes "
"vdso, vvar, vvar_vclock, vectors (arm compat-mode), sigpage (arm compat-"
"mode), uprobes."
msgstr ""

#: ../../../userspace-api/mseal.rst:137
msgid ""
"Those system mappings are readonly only or execute only, memory sealing can "
"protect them from ever changing to writable or unmmap/remapped as different "
"attributes. This is useful to mitigate memory corruption issues where a "
"corrupted pointer is passed to a memory management system."
msgstr ""

#: ../../../userspace-api/mseal.rst:142
msgid ""
"If supported by an architecture "
"(CONFIG_ARCH_SUPPORTS_MSEAL_SYSTEM_MAPPINGS), the "
"CONFIG_MSEAL_SYSTEM_MAPPINGS seals all system mappings of this architecture."
msgstr ""

#: ../../../userspace-api/mseal.rst:146
msgid ""
"The following architectures currently support this feature: x86-64, arm64, "
"loongarch and s390."
msgstr ""

#: ../../../userspace-api/mseal.rst:149
msgid ""
"WARNING: This feature breaks programs which rely on relocating or unmapping "
"system mappings. Known broken software at the time of writing includes "
"CHECKPOINT_RESTORE, UML, gVisor, rr. Therefore this config can't be enabled "
"universally."
msgstr ""

#: ../../../userspace-api/mseal.rst:155
msgid "When not to use mseal"
msgstr ""

#: ../../../userspace-api/mseal.rst:156
msgid ""
"Applications can apply sealing to any virtual memory region from userspace, "
"but it is *crucial to thoroughly analyze the mapping's lifetime* prior to "
"apply the sealing. This is because the sealed mapping *won’t be unmapped* "
"until the process terminates or the exec system call is invoked."
msgstr ""

#: ../../../userspace-api/mseal.rst:161
msgid "For example:"
msgstr ""

#: ../../../userspace-api/mseal.rst:162
msgid ""
"aio/shm aio/shm can call mmap and  munmap on behalf of userspace, e.g. "
"ksys_shmdt() in shm.c. The lifetimes of those mapping are not tied to the "
"lifetime of the process. If those memories are sealed from userspace, then "
"munmap will fail, causing leaks in VMA address space during the lifetime of "
"the process."
msgstr ""

#: ../../../userspace-api/mseal.rst:169
msgid ""
"ptr allocated by malloc (heap) Don't use mseal on the memory ptr return from "
"malloc(). malloc() is implemented by allocator, e.g. by glibc. Heap manager "
"might allocate a ptr from brk or mapping created by mmap. If an app calls "
"mseal on a ptr returned from malloc(), this can affect the heap manager's "
"ability to manage the mappings; the outcome is non-deterministic."
msgstr ""

#: ../../../userspace-api/mseal.rst:186
msgid "mseal doesn't block"
msgstr ""

#: ../../../userspace-api/mseal.rst:187
msgid ""
"In a nutshell, mseal blocks certain mm syscall from modifying some of VMA's "
"attributes, such as protection bits (RWX). Sealed mappings doesn't mean the "
"memory is immutable."
msgstr ""

#: ../../../userspace-api/mseal.rst:191
msgid ""
"As Jann Horn pointed out in [3], there are still a few ways to write to RO "
"memory, which is, in a way, by design. And those could be blocked by "
"different security measures."
msgstr ""

#: ../../../userspace-api/mseal.rst:195
msgid "Those cases are:"
msgstr ""

#: ../../../userspace-api/mseal.rst:197
msgid ""
"Write to read-only memory through /proc/self/mem interface (FOLL_FORCE)."
msgstr ""

#: ../../../userspace-api/mseal.rst:198
msgid "Write to read-only memory through ptrace (such as PTRACE_POKETEXT)."
msgstr ""

#: ../../../userspace-api/mseal.rst:199
msgid "userfaultfd."
msgstr ""

#: ../../../userspace-api/mseal.rst:201
msgid ""
"The idea that inspired this patch comes from Stephen Röttger’s work in V8 "
"CFI [4]. Chrome browser in ChromeOS will be the first user of this API."
msgstr ""

#: ../../../userspace-api/mseal.rst:205
msgid "Reference"
msgstr ""

#: ../../../userspace-api/mseal.rst:206
msgid ""
"[1] https://github.com/apple-oss-distributions/xnu/"
"blob/1031c584a5e37aff177559b9f69dbd3c8c3fd30a/osfmk/mach/vm_statistics.h#L274"
msgstr ""

#: ../../../userspace-api/mseal.rst:207
msgid "[2] https://man.openbsd.org/mimmutable.2"
msgstr ""

#: ../../../userspace-api/mseal.rst:208
msgid ""
"[3] https://lore.kernel.org/lkml/"
"CAG48ez3ShUYey+ZAFsU2i1RpQn0a5eOs2hzQ426FkcgnfUGLvA@mail.gmail.com"
msgstr ""

#: ../../../userspace-api/mseal.rst:209
msgid ""
"[4] https://docs.google.com/document/"
"d/1O2jwK4dxI3nRcOJuPYkonhTkNQfbmwdvxQMyXgeaRHo/edit#heading=h.bvaojj9fu6hc"
msgstr ""
