# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-16 08:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../userspace-api/rseq.rst:3
msgid "Restartable Sequences"
msgstr ""

#: ../../../userspace-api/rseq.rst:5
msgid ""
"Restartable Sequences allow to register a per thread userspace memory area "
"to be used as an ABI between kernel and userspace for three purposes:"
msgstr ""

#: ../../../userspace-api/rseq.rst:8
msgid "userspace restartable sequences"
msgstr ""

#: ../../../userspace-api/rseq.rst:10
msgid "quick access to read the current CPU number, node ID from userspace"
msgstr ""

#: ../../../userspace-api/rseq.rst:12
msgid "scheduler time slice extensions"
msgstr ""

#: ../../../userspace-api/rseq.rst:15
msgid "Restartable sequences (per-cpu atomics)"
msgstr ""

#: ../../../userspace-api/rseq.rst:17
msgid ""
"Restartable sequences allow userspace to perform update operations on per-"
"cpu data without requiring heavyweight atomic operations. The actual ABI is "
"unfortunately only available in the code and selftests."
msgstr ""

#: ../../../userspace-api/rseq.rst:22
msgid "Quick access to CPU number, node ID"
msgstr ""

#: ../../../userspace-api/rseq.rst:24
msgid ""
"Allows to implement per CPU data efficiently. Documentation is in code and "
"selftests. :("
msgstr ""

#: ../../../userspace-api/rseq.rst:28
msgid "Scheduler time slice extensions"
msgstr ""

#: ../../../userspace-api/rseq.rst:30
msgid ""
"This allows a thread to request a time slice extension when it enters a "
"critical section to avoid contention on a resource when the thread is "
"scheduled out inside of the critical section."
msgstr ""

#: ../../../userspace-api/rseq.rst:34
msgid "The prerequisites for this functionality are:"
msgstr ""

#: ../../../userspace-api/rseq.rst:36
msgid "Enabled in Kconfig"
msgstr ""

#: ../../../userspace-api/rseq.rst:38
msgid "Enabled at boot time (default is enabled)"
msgstr ""

#: ../../../userspace-api/rseq.rst:40
msgid "A rseq userspace pointer has been registered for the thread"
msgstr ""

#: ../../../userspace-api/rseq.rst:42
msgid "The thread has to enable the functionality via prctl(2)::"
msgstr ""

#: ../../../userspace-api/rseq.rst:47
msgid ""
"prctl() returns 0 on success or otherwise with the following error codes:"
msgstr ""

#: ../../../userspace-api/rseq.rst:50 ../../../userspace-api/rseq.rst:66
msgid "Errorcode"
msgstr ""

#: ../../../userspace-api/rseq.rst:50 ../../../userspace-api/rseq.rst:66
msgid "Meaning"
msgstr ""

#: ../../../userspace-api/rseq.rst:52 ../../../userspace-api/rseq.rst:68
msgid "EINVAL"
msgstr ""

#: ../../../userspace-api/rseq.rst:52
msgid ""
"Functionality not available or invalid function arguments. Note: arg4 and "
"arg5 must be zero"
msgstr ""

#: ../../../userspace-api/rseq.rst:54
msgid "ENOTSUPP"
msgstr ""

#: ../../../userspace-api/rseq.rst:54
msgid "Functionality was disabled on the kernel command line"
msgstr ""

#: ../../../userspace-api/rseq.rst:55
msgid "ENXIO"
msgstr ""

#: ../../../userspace-api/rseq.rst:55
msgid "Available, but no rseq user struct registered"
msgstr ""

#: ../../../userspace-api/rseq.rst:58
msgid "The state can be also queried via prctl(2)::"
msgstr ""

#: ../../../userspace-api/rseq.rst:62
msgid ""
"prctl() returns ``PR_RSEQ_SLICE_EXT_ENABLE`` when it is enabled or 0 if "
"disabled. Otherwise it returns with the following error codes:"
msgstr ""

#: ../../../userspace-api/rseq.rst:68
msgid ""
"Functionality not available or invalid function arguments. Note: arg3 and "
"arg4 and arg5 must be zero"
msgstr ""

#: ../../../userspace-api/rseq.rst:72
msgid ""
"The availability and status is also exposed via the rseq ABI struct flags "
"field via the ``RSEQ_CS_FLAG_SLICE_EXT_AVAILABLE_BIT`` and the "
"``RSEQ_CS_FLAG_SLICE_EXT_ENABLED_BIT``. These bits are read-only for user "
"space and only for informational purposes."
msgstr ""

#: ../../../userspace-api/rseq.rst:77
msgid ""
"If the mechanism was enabled via prctl(), the thread can request a time "
"slice extension by setting rseq::slice_ctrl::request to 1. If the thread is "
"interrupted and the interrupt results in a reschedule request in the kernel, "
"then the kernel can grant a time slice extension and return to userspace "
"instead of scheduling out. The length of the extension is determined by "
"debugfs:rseq/slice_ext_nsec. The default value is 5 usec; which is the "
"minimum value. It can be incremented to 50 usecs, however doing so can/will "
"affect the minimum scheduling latency."
msgstr ""

#: ../../../userspace-api/rseq.rst:86
msgid ""
"Any proposed changes to this default will have to come with a selftest and "
"rseq-slice-hist.py output that shows the new value has merrit."
msgstr ""

#: ../../../userspace-api/rseq.rst:89
msgid ""
"The kernel indicates the grant by clearing rseq::slice_ctrl::request and "
"setting rseq::slice_ctrl::granted to 1. If there is a reschedule of the "
"thread after granting the extension, the kernel clears the granted bit to "
"indicate that to userspace."
msgstr ""

#: ../../../userspace-api/rseq.rst:94
msgid ""
"If the request bit is still set when the leaving the critical section, "
"userspace can clear it and continue."
msgstr ""

#: ../../../userspace-api/rseq.rst:97
msgid ""
"If the granted bit is set, then userspace invokes rseq_slice_yield(2) when "
"leaving the critical section to relinquish the CPU. The kernel enforces this "
"by arming a timer to prevent misbehaving userspace from abusing this "
"mechanism."
msgstr ""

#: ../../../userspace-api/rseq.rst:102
msgid ""
"If both the request bit and the granted bit are false when leaving the "
"critical section, then this indicates that a grant was revoked and no "
"further action is required by userspace."
msgstr ""

#: ../../../userspace-api/rseq.rst:106
msgid "The required code flow is as follows::"
msgstr ""

#: ../../../userspace-api/rseq.rst:116
msgid ""
"As all of this is strictly CPU local, there are no atomicity requirements. "
"Checking the granted state is racy, but that cannot be avoided at all::"
msgstr ""

#: ../../../userspace-api/rseq.rst:123
msgid ""
"So there is no point in pretending that this might be solved by an atomic "
"operation."
msgstr ""

#: ../../../userspace-api/rseq.rst:126
msgid ""
"If the thread issues a syscall other than rseq_slice_yield(2) within the "
"granted timeslice extension, the grant is also revoked and the CPU is "
"relinquished immediately when entering the kernel. This is required as "
"syscalls might consume arbitrary CPU time until they reach a scheduling "
"point when the preemption model is either NONE or VOLUNTARY and therefore "
"might exceed the grant by far."
msgstr ""

#: ../../../userspace-api/rseq.rst:133
msgid ""
"The preferred solution for user space is to use rseq_slice_yield(2) which is "
"side effect free. The support for arbitrary syscalls is required to support "
"onion layer architectured applications, where the code handling the critical "
"section and requesting the time slice extension has no control over the code "
"within the critical section."
msgstr ""

#: ../../../userspace-api/rseq.rst:139
msgid ""
"The kernel enforces flag consistency and terminates the thread with SIGSEGV "
"if it detects a violation."
msgstr ""
