# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../bpf/standardization/instruction-set.rst:0
msgid "Contents"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:6
msgid "BPF Instruction Set Architecture (ISA)"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:8
msgid ""
"eBPF, also commonly referred to as BPF, is a technology with origins in the "
"Linux kernel that can run untrusted programs in a privileged context such as "
"an operating system kernel. This document specifies the BPF instruction set "
"architecture (ISA)."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:14
msgid ""
"As a historical note, BPF originally stood for Berkeley Packet Filter, but "
"now that it can do so much more than packet filtering, the acronym no longer "
"makes sense. BPF is now considered a standalone term that does not stand for "
"anything.  The original BPF is sometimes referred to as cBPF (classic BPF) "
"to distinguish it from the now widely deployed eBPF (extended BPF)."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:22
msgid "Documentation conventions"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:24
msgid ""
"The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL "
"NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", "
"\"MAY\", and \"OPTIONAL\" in this document are to be interpreted as "
"described in BCP 14 `<https://www.rfc-editor.org/info/rfc2119>`_ `<https://"
"www.rfc-editor.org/info/rfc8174>`_ when, and only when, they appear in all "
"capitals, as shown here."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:31
msgid ""
"For brevity and consistency, this document refers to families of types using "
"a shorthand syntax and refers to several expository, mnemonic functions when "
"describing the semantics of instructions. The range of valid values for "
"those types and the semantics of those functions are defined in the "
"following subsections."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:38
msgid "Types"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:39
msgid ""
"This document refers to integer types with the notation `SN` to specify a "
"type's signedness (`S`) and bit width (`N`), respectively."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:42
msgid "Meaning of signedness notation"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:45
msgid "S"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:45
msgid "Meaning"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:47
msgid "u"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:47
#: ../../../bpf/standardization/instruction-set.rst:501
#: ../../../bpf/standardization/instruction-set.rst:502
#: ../../../bpf/standardization/instruction-set.rst:511
#: ../../../bpf/standardization/instruction-set.rst:512
msgid "unsigned"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:48
msgid "s"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:48
#: ../../../bpf/standardization/instruction-set.rst:505
#: ../../../bpf/standardization/instruction-set.rst:506
#: ../../../bpf/standardization/instruction-set.rst:513
#: ../../../bpf/standardization/instruction-set.rst:514
msgid "signed"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:51
msgid "Meaning of bit-width notation"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:54
msgid "N"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:54
msgid "Bit width"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:56
msgid "8"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:56
msgid "8 bits"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:57
msgid "16"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:57
msgid "16 bits"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:58
msgid "32"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:58
msgid "32 bits"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:59
msgid "64"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:59
msgid "64 bits"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:60
msgid "128"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:60
msgid "128 bits"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:63
msgid ""
"For example, `u32` is a type whose valid values are all the 32-bit unsigned "
"numbers and `s16` is a type whose valid values are all the 16-bit signed "
"numbers."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:68
msgid "Functions"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:70
msgid ""
"The following byteswap functions are direction-agnostic.  That is, the same "
"function is used for conversion in either direction discussed below."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:74
msgid ""
"be16: Takes an unsigned 16-bit number and converts it between host byte "
"order and big-endian (`IEN137 <https://www.rfc-editor.org/ien/ien137.txt>`_) "
"byte order."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:77
msgid ""
"be32: Takes an unsigned 32-bit number and converts it between host byte "
"order and big-endian byte order."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:79
msgid ""
"be64: Takes an unsigned 64-bit number and converts it between host byte "
"order and big-endian byte order."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:81
msgid ""
"bswap16: Takes an unsigned 16-bit number in either big- or little-endian "
"format and returns the equivalent number with the same bit width but "
"opposite endianness."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:84
msgid ""
"bswap32: Takes an unsigned 32-bit number in either big- or little-endian "
"format and returns the equivalent number with the same bit width but "
"opposite endianness."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:87
msgid ""
"bswap64: Takes an unsigned 64-bit number in either big- or little-endian "
"format and returns the equivalent number with the same bit width but "
"opposite endianness."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:90
msgid ""
"le16: Takes an unsigned 16-bit number and converts it between host byte "
"order and little-endian byte order."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:92
msgid ""
"le32: Takes an unsigned 32-bit number and converts it between host byte "
"order and little-endian byte order."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:94
msgid ""
"le64: Takes an unsigned 64-bit number and converts it between host byte "
"order and little-endian byte order."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:98
msgid "Definitions"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:101
msgid "Sign Extend"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:103
msgid ""
"To `sign extend an` ``X`` `-bit number, A, to a` ``Y`` `-bit number, B  ,` "
"means to"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:105
msgid "Copy all ``X`` bits from `A` to the lower ``X`` bits of `B`."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:106
msgid ""
"Set the value of the remaining ``Y`` - ``X`` bits of `B` to the value of "
"the  most-significant bit of `A`."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:109
msgid "Example"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:111
msgid ""
"Sign extend an 8-bit number ``A`` to a 16-bit number ``B`` on a big-endian "
"platform: ::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:118
msgid "Conformance groups"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:120
msgid ""
"An implementation does not need to support all instructions specified in "
"this document (e.g., deprecated instructions).  Instead, a number of "
"conformance groups are specified.  An implementation MUST support the base32 "
"conformance group and MAY support additional conformance groups, where "
"supporting a conformance group means it MUST support all instructions in "
"that conformance group."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:127
msgid ""
"The use of named conformance groups enables interoperability between a "
"runtime that executes instructions, and tools such as compilers that "
"generate instructions for the runtime.  Thus, capability discovery in terms "
"of conformance groups might be done manually by users or automatically by "
"tools."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:132
msgid ""
"Each conformance group has a short ASCII label (e.g., \"base32\") that "
"corresponds to a set of instructions that are mandatory.  That is, each "
"instruction has one or more conformance groups of which it is a member."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:136
msgid "This document defines the following conformance groups:"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:138
msgid ""
"base32: includes all instructions defined in this specification unless "
"otherwise noted."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:140
msgid ""
"base64: includes base32, plus instructions explicitly noted as being in the "
"base64 conformance group."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:142
msgid ""
"atomic32: includes 32-bit atomic operation instructions (see `Atomic "
"operations`_)."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:143
msgid "atomic64: includes atomic32, plus 64-bit atomic operation instructions."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:144
msgid ""
"divmul32: includes 32-bit division, multiplication, and modulo instructions."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:145
msgid ""
"divmul64: includes divmul32, plus 64-bit division, multiplication, and "
"modulo instructions."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:147
msgid "packet: deprecated packet access instructions."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:150
msgid "Instruction encoding"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:152
msgid "BPF has two instruction encodings:"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:154
msgid ""
"the basic instruction encoding, which uses 64 bits to encode an instruction"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:155
msgid ""
"the wide instruction encoding, which appends a second 64 bits after the "
"basic instruction for a total of 128 bits."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:159
msgid "Basic instruction encoding"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:161
msgid "A basic instruction is encoded as follows::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:169
#: ../../../bpf/standardization/instruction-set.rst:247
msgid "**opcode**"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:170
msgid "operation to perform, encoded as follows::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:176
msgid "**specific**"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:177
msgid "The format of these bits varies by instruction class"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:179
#: ../../../bpf/standardization/instruction-set.rst:620
msgid "**class**"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:180
#: ../../../bpf/standardization/instruction-set.rst:621
msgid "The instruction class (see `Instruction classes`_)"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:182
#: ../../../bpf/standardization/instruction-set.rst:250
msgid "**regs**"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:183
msgid ""
"The source and destination register numbers, encoded as follows on a little-"
"endian host::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:190
msgid "and as follows on a big-endian host::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:196
msgid "**src_reg**"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:197
msgid ""
"the source register number (0-10), except where otherwise specified (`64-bit "
"immediate instructions`_ reuse this field for other purposes)"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:200
msgid "**dst_reg**"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:201
msgid ""
"destination register number (0-10), unless otherwise specified (future "
"instructions might reuse this field for other purposes)"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:204
#: ../../../bpf/standardization/instruction-set.rst:254
msgid "**offset**"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:205
msgid ""
"signed integer offset used with pointer arithmetic, except where otherwise "
"specified (some arithmetic instructions reuse this field for other purposes)"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:209
#: ../../../bpf/standardization/instruction-set.rst:258
msgid "**imm**"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:210
#: ../../../bpf/standardization/instruction-set.rst:259
msgid "signed integer immediate value"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:212
msgid ""
"Note that the contents of multi-byte fields ('offset' and 'imm') are stored "
"using big-endian byte ordering on big-endian hosts and little-endian byte "
"ordering on little-endian hosts."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:216
msgid "For example::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:224
msgid ""
"Note that most instructions do not use all of the fields. Unused fields "
"SHALL be cleared to zero."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:228
msgid "Wide instruction encoding"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:230
msgid ""
"Some instructions are defined to use the wide instruction encoding, which "
"uses two 32-bit immediate values.  The 64 bits following the basic "
"instruction format contain a pseudo instruction with 'opcode', 'dst_reg', "
"'src_reg', and 'offset' all set to zero."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:235
msgid "This is depicted in the following figure::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:248
msgid "operation to perform, encoded as explained above"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:251
msgid ""
"The source and destination register numbers (unless otherwise specified), "
"encoded as explained above"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:255
msgid ""
"signed integer offset used with pointer arithmetic, unless otherwise "
"specified"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:261
msgid "**reserved**"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:262
msgid "unused, set to zero"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:264
msgid "**next_imm**"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:265
msgid "second signed integer immediate value"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:268
msgid "Instruction classes"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:270
msgid ""
"The three least significant bits of the 'opcode' field store the instruction "
"class:"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:272
msgid "Instruction class"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:275
#: ../../../bpf/standardization/instruction-set.rst:452
msgid "class"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:275
#: ../../../bpf/standardization/instruction-set.rst:306
#: ../../../bpf/standardization/instruction-set.rst:452
#: ../../../bpf/standardization/instruction-set.rst:496
#: ../../../bpf/standardization/instruction-set.rst:594
#: ../../../bpf/standardization/instruction-set.rst:610
#: ../../../bpf/standardization/instruction-set.rst:680
#: ../../../bpf/standardization/instruction-set.rst:703
msgid "value"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:275
#: ../../../bpf/standardization/instruction-set.rst:306
#: ../../../bpf/standardization/instruction-set.rst:328
#: ../../../bpf/standardization/instruction-set.rst:452
#: ../../../bpf/standardization/instruction-set.rst:496
#: ../../../bpf/standardization/instruction-set.rst:594
#: ../../../bpf/standardization/instruction-set.rst:610
#: ../../../bpf/standardization/instruction-set.rst:680
#: ../../../bpf/standardization/instruction-set.rst:703
msgid "description"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:275
#: ../../../bpf/standardization/instruction-set.rst:594
msgid "reference"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:277
msgid "LD"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:277
#: ../../../bpf/standardization/instruction-set.rst:330
#: ../../../bpf/standardization/instruction-set.rst:498
#: ../../../bpf/standardization/instruction-set.rst:499
#: ../../../bpf/standardization/instruction-set.rst:507
#: ../../../bpf/standardization/instruction-set.rst:510
#: ../../../bpf/standardization/instruction-set.rst:740
msgid "0x0"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:277
msgid "non-standard load operations"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:277
#: ../../../bpf/standardization/instruction-set.rst:278
#: ../../../bpf/standardization/instruction-set.rst:279
#: ../../../bpf/standardization/instruction-set.rst:280
msgid "`Load and store instructions`_"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:278
msgid "LDX"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:278
#: ../../../bpf/standardization/instruction-set.rst:331
#: ../../../bpf/standardization/instruction-set.rst:500
#: ../../../bpf/standardization/instruction-set.rst:508
#: ../../../bpf/standardization/instruction-set.rst:741
msgid "0x1"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:278
msgid "load into register operations"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:279
msgid "ST"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:279
#: ../../../bpf/standardization/instruction-set.rst:332
#: ../../../bpf/standardization/instruction-set.rst:501
#: ../../../bpf/standardization/instruction-set.rst:509
#: ../../../bpf/standardization/instruction-set.rst:742
msgid "0x2"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:279
msgid "store from immediate operations"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:280
msgid "STX"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:280
#: ../../../bpf/standardization/instruction-set.rst:333
#: ../../../bpf/standardization/instruction-set.rst:334
#: ../../../bpf/standardization/instruction-set.rst:502
#: ../../../bpf/standardization/instruction-set.rst:743
msgid "0x3"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:280
msgid "store from register operations"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:281
#: ../../../bpf/standardization/instruction-set.rst:454
#: ../../../bpf/standardization/instruction-set.rst:455
msgid "ALU"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:281
#: ../../../bpf/standardization/instruction-set.rst:335
#: ../../../bpf/standardization/instruction-set.rst:503
#: ../../../bpf/standardization/instruction-set.rst:744
msgid "0x4"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:281
msgid "32-bit arithmetic operations"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:281
#: ../../../bpf/standardization/instruction-set.rst:282
#: ../../../bpf/standardization/instruction-set.rst:283
#: ../../../bpf/standardization/instruction-set.rst:284
msgid "`Arithmetic and jump instructions`_"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:282
msgid "JMP"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:282
#: ../../../bpf/standardization/instruction-set.rst:336
#: ../../../bpf/standardization/instruction-set.rst:504
#: ../../../bpf/standardization/instruction-set.rst:745
msgid "0x5"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:282
msgid "64-bit jump operations"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:283
msgid "JMP32"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:283
#: ../../../bpf/standardization/instruction-set.rst:337
#: ../../../bpf/standardization/instruction-set.rst:505
#: ../../../bpf/standardization/instruction-set.rst:746
msgid "0x6"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:283
msgid "32-bit jump operations"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:284
#: ../../../bpf/standardization/instruction-set.rst:456
msgid "ALU64"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:284
#: ../../../bpf/standardization/instruction-set.rst:338
#: ../../../bpf/standardization/instruction-set.rst:506
msgid "0x7"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:284
msgid "64-bit arithmetic operations"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:288
msgid "Arithmetic and jump instructions"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:290
msgid ""
"For arithmetic and jump instructions (``ALU``, ``ALU64``, ``JMP`` and "
"``JMP32``), the 8-bit 'opcode' field is divided into three parts::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:297
msgid "**code**"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:298
msgid "the operation code, whose meaning varies by instruction class"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:300
msgid "**s (source)**"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:301
msgid ""
"the source operand location, which unless otherwise specified is one of:"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:303
msgid "Source operand location"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:306
#: ../../../bpf/standardization/instruction-set.rst:452
msgid "source"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:308
msgid "K"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:308
#: ../../../bpf/standardization/instruction-set.rst:330
#: ../../../bpf/standardization/instruction-set.rst:331
#: ../../../bpf/standardization/instruction-set.rst:332
#: ../../../bpf/standardization/instruction-set.rst:333
#: ../../../bpf/standardization/instruction-set.rst:335
#: ../../../bpf/standardization/instruction-set.rst:336
#: ../../../bpf/standardization/instruction-set.rst:337
#: ../../../bpf/standardization/instruction-set.rst:338
#: ../../../bpf/standardization/instruction-set.rst:339
#: ../../../bpf/standardization/instruction-set.rst:340
#: ../../../bpf/standardization/instruction-set.rst:342
#: ../../../bpf/standardization/instruction-set.rst:343
#: ../../../bpf/standardization/instruction-set.rst:345
#: ../../../bpf/standardization/instruction-set.rst:346
#: ../../../bpf/standardization/instruction-set.rst:454
#: ../../../bpf/standardization/instruction-set.rst:456
#: ../../../bpf/standardization/instruction-set.rst:596
#: ../../../bpf/standardization/instruction-set.rst:612
msgid "0"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:308
msgid "use 32-bit 'imm' value as source operand"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:309
msgid "X"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:309
#: ../../../bpf/standardization/instruction-set.rst:334
#: ../../../bpf/standardization/instruction-set.rst:341
#: ../../../bpf/standardization/instruction-set.rst:455
#: ../../../bpf/standardization/instruction-set.rst:597
#: ../../../bpf/standardization/instruction-set.rst:613
msgid "1"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:309
msgid "use 'src_reg' register value as source operand"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:312
msgid "**instruction class**"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:313
msgid "the instruction class (see `Instruction classes`_)"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:316
#: ../../../bpf/standardization/instruction-set.rst:325
msgid "Arithmetic instructions"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:318
msgid ""
"``ALU`` uses 32-bit wide operands while ``ALU64`` uses 64-bit wide operands "
"for otherwise identical operations. ``ALU64`` instructions belong to the "
"base64 conformance group unless noted otherwise. The 'code' field encodes "
"the operation as below, where 'src' refers to the the source operand and "
"'dst' refers to the value of the destination register."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:328
msgid "name"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:328
#: ../../../bpf/standardization/instruction-set.rst:496
msgid "code"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:328
msgid "offset"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:330
#: ../../../bpf/standardization/instruction-set.rst:682
msgid "ADD"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:330
msgid "dst += src"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:331
msgid "SUB"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:331
msgid "dst -= src"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:332
msgid "MUL"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:332
msgid "dst \\*= src"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:333
msgid "DIV"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:333
msgid "dst = (src != 0) ? (dst / src) : 0"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:334
msgid "SDIV"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:334
msgid ""
"dst = (src == 0) ? 0 : ((src == -1 && dst == LLONG_MIN) ? LLONG_MIN : (dst "
"s/ src))"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:335
#: ../../../bpf/standardization/instruction-set.rst:683
msgid "OR"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:335
msgid "dst \\|= src"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:336
#: ../../../bpf/standardization/instruction-set.rst:684
msgid "AND"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:336
msgid "dst &= src"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:337
msgid "LSH"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:337
msgid "dst <<= (src & mask)"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:338
msgid "RSH"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:338
msgid "dst >>= (src & mask)"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:339
msgid "NEG"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:339
#: ../../../bpf/standardization/instruction-set.rst:507
#: ../../../bpf/standardization/instruction-set.rst:508
#: ../../../bpf/standardization/instruction-set.rst:509
msgid "0x8"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:339
msgid "dst = -dst"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:340
msgid "MOD"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:340
#: ../../../bpf/standardization/instruction-set.rst:341
#: ../../../bpf/standardization/instruction-set.rst:510
msgid "0x9"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:340
msgid "dst = (src != 0) ? (dst % src) : dst"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:341
msgid "SMOD"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:341
msgid ""
"dst = (src == 0) ? dst : ((src == -1 && dst == LLONG_MIN) ? 0: (dst s% src))"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:342
#: ../../../bpf/standardization/instruction-set.rst:685
msgid "XOR"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:342
#: ../../../bpf/standardization/instruction-set.rst:511
msgid "0xa"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:342
msgid "dst ^= src"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:343
msgid "MOV"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:343
#: ../../../bpf/standardization/instruction-set.rst:344
#: ../../../bpf/standardization/instruction-set.rst:512
msgid "0xb"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:343
msgid "dst = src"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:344
msgid "MOVSX"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:344
msgid "8/16/32"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:344
msgid "dst = (s8,s16,s32)src"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:345
msgid "ARSH"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:345
#: ../../../bpf/standardization/instruction-set.rst:513
msgid "0xc"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:345
msgid ":term:`sign extending<Sign Extend>` dst >>= (src & mask)"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:346
msgid "END"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:346
#: ../../../bpf/standardization/instruction-set.rst:514
msgid "0xd"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:346
msgid "byte swap operations (see `Byte swap instructions`_ below)"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:349
msgid ""
"Underflow and overflow are allowed during arithmetic operations, meaning the "
"64-bit or 32-bit value will wrap. If BPF program execution would result in "
"division by zero, the destination register is instead set to zero. "
"Otherwise, for ``ALU64``, if execution would result in ``LLONG_MIN`` divided "
"by -1, the destination register is instead set to ``LLONG_MIN``. For "
"``ALU``, if execution would result in ``INT_MIN`` divided by -1, the "
"destination register is instead set to ``INT_MIN``."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:357
msgid ""
"If execution would result in modulo by zero, for ``ALU64`` the value of the "
"destination register is unchanged whereas for ``ALU`` the upper 32 bits of "
"the destination register are zeroed. Otherwise, for ``ALU64``, if execution "
"would resuslt in ``LLONG_MIN`` modulo -1, the destination register is "
"instead set to 0. For ``ALU``, if execution would result in ``INT_MIN`` "
"modulo -1, the destination register is instead set to 0."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:364
msgid ""
"``{ADD, X, ALU}``, where 'code' = ``ADD``, 'source' = ``X``, and 'class' = "
"``ALU``, means::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:368
msgid "where '(u32)' indicates that the upper 32 bits are zeroed."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:370
msgid "``{ADD, X, ALU64}`` means::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:374
msgid "``{XOR, K, ALU}`` means::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:378
msgid "``{XOR, K, ALU64}`` means::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:382
msgid ""
"Note that most arithmetic instructions have 'offset' set to 0. Only three "
"instructions (``SDIV``, ``SMOD``, ``MOVSX``) have a non-zero 'offset'."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:385
msgid ""
"Division, multiplication, and modulo operations for ``ALU`` are part of the "
"\"divmul32\" conformance group, and division, multiplication, and modulo "
"operations for ``ALU64`` are part of the \"divmul64\" conformance group. The "
"division and modulo operations support both unsigned and signed flavors."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:391
msgid ""
"For unsigned operations (``DIV`` and ``MOD``), for ``ALU``, 'imm' is "
"interpreted as a 32-bit unsigned value. For ``ALU64``, 'imm' is first :term:"
"`sign extended<Sign Extend>` from 32 to 64 bits, and then interpreted as a "
"64-bit unsigned value."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:396
msgid ""
"For signed operations (``SDIV`` and ``SMOD``), for ``ALU``, 'imm' is "
"interpreted as a 32-bit signed value. For ``ALU64``, 'imm' is first :term:"
"`sign extended<Sign Extend>` from 32 to 64 bits, and then interpreted as a "
"64-bit signed value."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:401
msgid ""
"Note that there are varying definitions of the signed modulo operation when "
"the dividend or divisor are negative, where implementations often vary by "
"language such that Python, Ruby, etc.  differ from C, Go, Java, etc. This "
"specification requires that signed modulo MUST use truncated division (where "
"-13 % 3 == -1) as implemented in C, Go, etc.::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:409
msgid ""
"The ``MOVSX`` instruction does a move operation with sign extension. "
"``{MOVSX, X, ALU}`` :term:`sign extends<Sign Extend>` 8-bit and 16-bit "
"operands into 32-bit operands, and zeroes the remaining upper 32 bits. "
"``{MOVSX, X, ALU64}`` :term:`sign extends<Sign Extend>` 8-bit, 16-bit, and "
"32-bit operands into 64-bit operands.  Unlike other arithmetic instructions, "
"``MOVSX`` is only defined for register source operands (``X``)."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:416
msgid "``{MOV, K, ALU64}`` means::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:420
msgid "``{MOV, X, ALU}`` means::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:424
msgid "``{MOVSX, X, ALU}`` with 'offset' 8 means::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:429
msgid ""
"The ``NEG`` instruction is only defined when the source bit is clear (``K``)."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:432
msgid ""
"Shift operations use a mask of 0x3F (63) for 64-bit operations and 0x1F (31) "
"for 32-bit operations."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:436
#: ../../../bpf/standardization/instruction-set.rst:449
msgid "Byte swap instructions"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:438
msgid ""
"The byte swap instructions use instruction classes of ``ALU`` and ``ALU64`` "
"and a 4-bit 'code' field of ``END``."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:441
msgid ""
"The byte swap instructions operate on the destination register only and do "
"not use a separate source register or immediate value."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:444
msgid ""
"For ``ALU``, the 1-bit source operand field in the opcode is used to select "
"what byte order the operation converts from or to. For ``ALU64``, the 1-bit "
"source operand field in the opcode is reserved and MUST be set to 0."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:454
msgid "LE"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:454
msgid "convert between host byte order and little endian"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:455
msgid "BE"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:455
msgid "convert between host byte order and big endian"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:456
msgid "Reserved"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:456
msgid "do byte swap unconditionally"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:459
msgid ""
"The 'imm' field encodes the width of the swap operations.  The following "
"widths are supported: 16, 32 and 64.  Width 64 operations belong to the "
"base64 conformance group and other swap operations belong to the base32 "
"conformance group."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:464
msgid "Examples:"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:466
msgid "``{END, LE, ALU}`` with 'imm' = 16/32/64 means::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:472
msgid "``{END, BE, ALU}`` with 'imm' = 16/32/64 means::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:478
msgid "``{END, TO, ALU64}`` with 'imm' = 16/32/64 means::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:485
#: ../../../bpf/standardization/instruction-set.rst:493
msgid "Jump instructions"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:487
msgid ""
"``JMP32`` uses 32-bit wide operands and indicates the base32 conformance "
"group, while ``JMP`` uses 64-bit wide operands for otherwise identical "
"operations, and indicates the base64 conformance group unless otherwise "
"specified. The 'code' field encodes the operation as below:"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:496
#: ../../../bpf/standardization/instruction-set.rst:738
msgid "src_reg"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:496
msgid "notes"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:498
#: ../../../bpf/standardization/instruction-set.rst:499
msgid "JA"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:498
msgid "PC += offset"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:498
msgid "{JA, K, JMP} only"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:499
msgid "PC += imm"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:499
msgid "{JA, K, JMP32} only"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:500
msgid "JEQ"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:500
#: ../../../bpf/standardization/instruction-set.rst:501
#: ../../../bpf/standardization/instruction-set.rst:502
#: ../../../bpf/standardization/instruction-set.rst:503
#: ../../../bpf/standardization/instruction-set.rst:504
#: ../../../bpf/standardization/instruction-set.rst:505
#: ../../../bpf/standardization/instruction-set.rst:506
#: ../../../bpf/standardization/instruction-set.rst:511
#: ../../../bpf/standardization/instruction-set.rst:512
#: ../../../bpf/standardization/instruction-set.rst:513
#: ../../../bpf/standardization/instruction-set.rst:514
msgid "any"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:500
msgid "PC += offset if dst == src"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:501
msgid "JGT"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:501
#: ../../../bpf/standardization/instruction-set.rst:505
msgid "PC += offset if dst > src"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:502
msgid "JGE"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:502
#: ../../../bpf/standardization/instruction-set.rst:506
msgid "PC += offset if dst >= src"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:503
msgid "JSET"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:503
msgid "PC += offset if dst & src"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:504
msgid "JNE"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:504
msgid "PC += offset if dst != src"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:505
msgid "JSGT"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:506
msgid "JSGE"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:507
#: ../../../bpf/standardization/instruction-set.rst:508
#: ../../../bpf/standardization/instruction-set.rst:509
msgid "CALL"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:507
msgid "call helper function by static ID"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:507
#: ../../../bpf/standardization/instruction-set.rst:509
msgid "{CALL, K, JMP} only, see `Helper functions`_"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:508
msgid "call PC += imm"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:508
msgid "{CALL, K, JMP} only, see `Program-local functions`_"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:509
msgid "call helper function by BTF ID"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:510
msgid "EXIT"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:510
msgid "return"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:510
msgid "{CALL, K, JMP} only"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:511
msgid "JLT"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:511
#: ../../../bpf/standardization/instruction-set.rst:513
msgid "PC += offset if dst < src"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:512
msgid "JLE"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:512
#: ../../../bpf/standardization/instruction-set.rst:514
msgid "PC += offset if dst <= src"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:513
msgid "JSLT"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:514
msgid "JSLE"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:517
msgid ""
"where 'PC' denotes the program counter, and the offset to increment by is in "
"units of 64-bit instructions relative to the instruction following the jump "
"instruction.  Thus 'PC += 1' skips execution of the next instruction if it's "
"a basic instruction or results in undefined behavior if the next instruction "
"is a 128-bit wide instruction."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:523
msgid "Example:"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:525
msgid "``{JSGE, X, JMP32}`` means::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:529
msgid "where 's>=' indicates a signed '>=' comparison."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:531
msgid "``{JLE, K, JMP}`` means::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:535
msgid "``{JA, K, JMP32}`` means::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:539
msgid "where 'imm' means the branch offset comes from the 'imm' field."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:541
msgid ""
"Note that there are two flavors of ``JA`` instructions. The ``JMP`` class "
"permits a 16-bit jump offset specified by the 'offset' field, whereas the "
"``JMP32`` class permits a 32-bit jump offset specified by the 'imm' field. A "
"> 16-bit conditional jump may be converted to a < 16-bit conditional jump "
"plus a 32-bit unconditional jump."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:548
msgid ""
"All ``CALL`` and ``JA`` instructions belong to the base32 conformance group."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:552
msgid "Helper functions"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:554
msgid ""
"Helper functions are a concept whereby BPF programs can call into a set of "
"function calls exposed by the underlying platform."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:557
msgid ""
"Historically, each helper function was identified by a static ID encoded in "
"the 'imm' field.  Further documentation of helper functions is outside the "
"scope of this document and standardization is left for future work, but use "
"is widely deployed and more information can be found in platform-specific "
"documentation (e.g., Linux kernel documentation)."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:563
msgid ""
"Platforms that support the BPF Type Format (BTF) support identifying a "
"helper function by a BTF ID encoded in the 'imm' field, where the BTF ID "
"identifies the helper name and type.  Further documentation of BTF is "
"outside the scope of this document and standardization is left for future "
"work, but use is widely deployed and more information can be found in "
"platform-specific documentation (e.g., Linux kernel documentation)."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:571
msgid "Program-local functions"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:572
msgid ""
"Program-local functions are functions exposed by the same BPF program as the "
"caller, and are referenced by offset from the instruction following the call "
"instruction, similar to ``JA``.  The offset is encoded in the 'imm' field of "
"the call instruction. An ``EXIT`` within the program-local function will "
"return to the caller."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:579
msgid "Load and store instructions"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:581
msgid ""
"For load and store instructions (``LD``, ``LDX``, ``ST``, and ``STX``), the "
"8-bit 'opcode' field is divided as follows::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:588
msgid "**mode**"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:589
msgid "The mode modifier is one of:"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:591
msgid "Mode modifier"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:594
msgid "mode modifier"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:596
msgid "IMM"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:596
#: ../../../bpf/standardization/instruction-set.rst:725
#: ../../../bpf/standardization/instruction-set.rst:735
msgid "64-bit immediate instructions"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:596
msgid "`64-bit immediate instructions`_"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:597
msgid "ABS"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:597
msgid "legacy BPF packet access (absolute)"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:597
#: ../../../bpf/standardization/instruction-set.rst:598
msgid "`Legacy BPF Packet access instructions`_"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:598
msgid "IND"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:598
#: ../../../bpf/standardization/instruction-set.rst:614
msgid "2"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:598
msgid "legacy BPF packet access (indirect)"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:599
msgid "MEM"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:599
#: ../../../bpf/standardization/instruction-set.rst:615
msgid "3"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:599
msgid "regular load and store operations"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:599
msgid "`Regular load and store operations`_"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:600
msgid "MEMSX"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:600
msgid "4"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:600
msgid "sign-extension load operations"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:600
msgid "`Sign-extension load operations`_"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:601
msgid "ATOMIC"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:601
msgid "6"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:601
msgid "atomic operations"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:601
msgid "`Atomic operations`_"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:604
msgid "**sz (size)**"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:605
msgid "The size modifier is one of:"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:607
msgid "Size modifier"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:610
msgid "size"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:612
msgid "W"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:612
msgid "word        (4 bytes)"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:613
msgid "H"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:613
msgid "half word   (2 bytes)"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:614
msgid "B"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:614
msgid "byte"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:615
msgid "DW"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:615
msgid "double word (8 bytes)"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:618
msgid "Instructions using ``DW`` belong to the base64 conformance group."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:624
msgid "Regular load and store operations"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:626
msgid ""
"The ``MEM`` mode modifier is used to encode regular load and store "
"instructions that transfer data between a register and memory."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:629
msgid "``{MEM, <size>, STX}`` means::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:633
msgid "``{MEM, <size>, ST}`` means::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:637
msgid "``{MEM, <size>, LDX}`` means::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:641
msgid ""
"Where '<size>' is one of: ``B``, ``H``, ``W``, or ``DW``, and 'unsigned "
"size' is one of: u8, u16, u32, or u64."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:645
msgid "Sign-extension load operations"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:647
msgid ""
"The ``MEMSX`` mode modifier is used to encode :term:`sign-extension<Sign "
"Extend>` load instructions that transfer data between a register and memory."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:650
msgid "``{MEMSX, <size>, LDX}`` means::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:654
msgid ""
"Where '<size>' is one of: ``B``, ``H``, or ``W``, and 'signed size' is one "
"of: s8, s16, or s32."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:658
msgid "Atomic operations"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:660
msgid ""
"Atomic operations are operations that operate on memory and can not be "
"interrupted or corrupted by other access to the same memory region by other "
"BPF programs or means outside of this specification."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:664
msgid ""
"All atomic operations supported by BPF are encoded as store operations that "
"use the ``ATOMIC`` mode modifier as follows:"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:667
msgid ""
"``{ATOMIC, W, STX}`` for 32-bit operations, which are part of the "
"\"atomic32\" conformance group."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:669
msgid ""
"``{ATOMIC, DW, STX}`` for 64-bit operations, which are part of the "
"\"atomic64\" conformance group."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:671
msgid "8-bit and 16-bit wide atomic operations are not supported."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:673
msgid ""
"The 'imm' field is used to encode the actual atomic operation. Simple atomic "
"operation use a subset of the values defined to encode arithmetic operations "
"in the 'imm' field to encode the atomic operation:"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:677
msgid "Simple atomic operations"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:680
#: ../../../bpf/standardization/instruction-set.rst:703
msgid "imm"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:682
msgid "0x00"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:682
msgid "atomic add"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:683
msgid "0x40"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:683
msgid "atomic or"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:684
msgid "0x50"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:684
msgid "atomic and"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:685
msgid "0xa0"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:685
msgid "atomic xor"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:689
msgid "``{ATOMIC, W, STX}`` with 'imm' = ADD means::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:693
msgid "``{ATOMIC, DW, STX}`` with 'imm' = ADD means::"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:697
msgid ""
"In addition to the simple atomic operations, there also is a modifier and "
"two complex atomic operations:"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:700
msgid "Complex atomic operations"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:705
msgid "FETCH"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:705
msgid "0x01"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:705
msgid "modifier: return old value"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:706
msgid "XCHG"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:706
msgid "0xe0 | FETCH"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:706
msgid "atomic exchange"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:707
msgid "CMPXCHG"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:707
msgid "0xf0 | FETCH"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:707
msgid "atomic compare and exchange"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:710
msgid ""
"The ``FETCH`` modifier is optional for simple atomic operations, and always "
"set for the complex atomic operations.  If the ``FETCH`` flag is set, then "
"the operation also overwrites ``src`` with the value that was in memory "
"before it was modified."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:715
msgid ""
"The ``XCHG`` operation atomically exchanges ``src`` with the value addressed "
"by ``dst + offset``."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:718
msgid ""
"The ``CMPXCHG`` operation atomically compares the value addressed by ``dst + "
"offset`` with ``R0``. If they match, the value addressed by ``dst + offset`` "
"is replaced with ``src``. In either case, the value that was at ``dst + "
"offset`` before the operation is zero-extended and loaded back to ``R0``."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:727
msgid ""
"Instructions with the ``IMM`` 'mode' modifier use the wide instruction "
"encoding defined in `Instruction encoding`_, and use the 'src_reg' field of "
"the basic instruction to hold an opcode subtype."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:731
msgid ""
"The following table defines a set of ``{IMM, DW, LD}`` instructions with "
"opcode subtypes in the 'src_reg' field, using new terms such as \"map\" "
"defined further below:"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:738
msgid "pseudocode"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:738
msgid "imm type"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:738
msgid "dst type"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:740
msgid "dst = (next_imm << 32) | imm"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:740
#: ../../../bpf/standardization/instruction-set.rst:744
msgid "integer"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:741
msgid "dst = map_by_fd(imm)"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:741
#: ../../../bpf/standardization/instruction-set.rst:742
msgid "map fd"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:741
#: ../../../bpf/standardization/instruction-set.rst:745
msgid "map"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:742
msgid "dst = map_val(map_by_fd(imm)) + next_imm"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:742
#: ../../../bpf/standardization/instruction-set.rst:743
#: ../../../bpf/standardization/instruction-set.rst:746
msgid "data address"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:743
msgid "dst = var_addr(imm)"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:743
msgid "variable id"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:744
msgid "dst = code_addr(imm)"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:744
msgid "code address"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:745
msgid "dst = map_by_idx(imm)"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:745
#: ../../../bpf/standardization/instruction-set.rst:746
msgid "map index"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:746
msgid "dst = map_val(map_by_idx(imm)) + next_imm"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:749
msgid "where"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:751
msgid ""
"map_by_fd(imm) means to convert a 32-bit file descriptor into an address of "
"a map (see `Maps`_)"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:752
msgid ""
"map_by_idx(imm) means to convert a 32-bit index into an address of a map"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:753
msgid "map_val(map) gets the address of the first value in a given map"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:754
msgid ""
"var_addr(imm) gets the address of a platform variable (see `Platform "
"Variables`_) with a given id"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:755
msgid ""
"code_addr(imm) gets the address of the instruction at a specified relative "
"offset in number of (64-bit) instructions"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:756
msgid "the 'imm type' can be used by disassemblers for display"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:757
msgid ""
"the 'dst type' can be used for verification and JIT compilation purposes"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:760
msgid "Maps"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:762
msgid ""
"Maps are shared memory regions accessible by BPF programs on some platforms. "
"A map can have various semantics as defined in a separate document, and may "
"or may not have a single contiguous memory region, but the 'map_val(map)' is "
"currently only defined for maps that do have a single contiguous memory "
"region."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:767
msgid ""
"Each map can have a file descriptor (fd) if supported by the platform, where "
"'map_by_fd(imm)' means to get the map with the specified file descriptor. "
"Each BPF program can also be defined to use a set of maps associated with "
"the program at load time, and 'map_by_idx(imm)' means to get the map with "
"the given index in the set associated with the BPF program containing the "
"instruction."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:774
msgid "Platform Variables"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:776
msgid ""
"Platform variables are memory regions, identified by integer ids, exposed by "
"the runtime and accessible by BPF programs on some platforms.  The "
"'var_addr(imm)' operation means to get the address of the memory region "
"identified by the given id."
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:782
msgid "Legacy BPF Packet access instructions"
msgstr ""

#: ../../../bpf/standardization/instruction-set.rst:784
msgid ""
"BPF previously introduced special instructions for access to packet data "
"that were carried over from classic BPF. These instructions used an "
"instruction class of ``LD``, a size modifier of ``W``, ``H``, or ``B``, and "
"a mode modifier of ``ABS`` or ``IND``.  The 'dst_reg' and 'offset' fields "
"were set to zero, and 'src_reg' was set to zero for ``ABS``.  However, these "
"instructions are deprecated and SHOULD no longer be used.  All legacy packet "
"access instructions belong to the \"packet\" conformance group."
msgstr ""
