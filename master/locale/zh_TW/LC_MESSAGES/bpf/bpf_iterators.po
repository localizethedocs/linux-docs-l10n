# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../bpf/bpf_iterators.rst:3
msgid "BPF Iterators"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:7
msgid "Overview"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:9
msgid ""
"BPF supports two separate entities collectively known as \"BPF iterators\": "
"BPF iterator *program type* and *open-coded* BPF iterators. The former is a "
"stand-alone BPF program type which, when attached and activated by user, "
"will be called once for each entity (task_struct, cgroup, etc) that is being "
"iterated. The latter is a set of BPF-side APIs implementing iterator "
"functionality and available across multiple BPF program types. Open-coded "
"iterators provide similar functionality to BPF iterator programs, but gives "
"more flexibility and control to all other BPF program types. BPF iterator "
"programs, on the other hand, can be used to implement anonymous or BPF FS-"
"mounted special files, whose contents are generated by attached BPF iterator "
"program, backed by seq_file functionality. Both are useful depending on "
"specific needs."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:22
msgid ""
"When adding a new BPF iterator program, it is expected that similar "
"functionality will be added as open-coded iterator for maximum flexibility. "
"It's also expected that iteration logic and code will be maximally shared "
"and reused between two iterator API surfaces."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:29
msgid "Open-coded BPF Iterators"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:31
msgid ""
"Open-coded BPF iterators are implemented as tightly-coupled trios of kfuncs "
"(constructor, next element fetch, destructor) and iterator-specific type "
"describing on-the-stack iterator state, which is guaranteed by the BPF "
"verifier to not be tampered with outside of the corresponding constructor/"
"destructor/next APIs."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:37
msgid ""
"Each kind of open-coded BPF iterator has its own associated struct "
"bpf_iter_<type>, where <type> denotes a specific type of iterator. "
"bpf_iter_<type> state needs to live on BPF program stack, so make sure it's "
"small enough to fit on BPF stack. For performance reasons its best to avoid "
"dynamic memory allocation for iterator state and size the state struct big "
"enough to fit everything necessary. But if necessary, dynamic memory "
"allocation is a way to bypass BPF stack limitations. Note, state struct size "
"is part of iterator's user-visible API, so changing it will break backwards "
"compatibility, so be deliberate about designing it."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:47
msgid ""
"All kfuncs (constructor, next, destructor) have to be named consistently as "
"bpf_iter_<type>_{new,next,destroy}(), respectively. <type> represents "
"iterator type, and iterator state should be represented as a matching "
"`struct bpf_iter_<type>` state type. Also, all iter kfuncs should have a "
"pointer to this `struct bpf_iter_<type>` as the very first argument."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:53
msgid "Additionally:"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:54
msgid ""
"Constructor, i.e., `bpf_iter_<type>_new()`, can have arbitrary extra number "
"of arguments. Return type is not enforced either."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:56
msgid ""
"Next method, i.e., `bpf_iter_<type>_next()`, has to return a pointer type "
"and should have exactly one argument: `struct bpf_iter_<type> *` (const/"
"volatile/restrict and typedefs are ignored)."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:59
msgid ""
"Destructor, i.e., `bpf_iter_<type>_destroy()`, should return void and should "
"have exactly one argument, similar to the next method."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:61
msgid ""
"`struct bpf_iter_<type>` size is enforced to be positive and a multiple of 8 "
"bytes (to fit stack slots correctly)."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:64
msgid ""
"Such strictness and consistency allows to build generic helpers abstracting "
"important, but boilerplate, details to be able to use open-coded iterators "
"effectively and ergonomically (see libbpf's bpf_for_each() macro). This is "
"enforced at kfunc registration point by the kernel."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:69
msgid "Constructor/next/destructor implementation contract is as follows:"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:70
msgid ""
"constructor, `bpf_iter_<type>_new()`, always initializes iterator state on "
"the stack. If any of the input arguments are invalid, constructor should "
"make sure to still initialize it such that subsequent next() calls will "
"return NULL. I.e., on error, *return error and construct empty iterator*. "
"Constructor kfunc is marked with KF_ITER_NEW flag."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:76
msgid ""
"next method, `bpf_iter_<type>_next()`, accepts pointer to iterator state and "
"produces an element. Next method should always return a pointer. The "
"contract between BPF verifier is that next method *guarantees* that it will "
"eventually return NULL when elements are exhausted. Once NULL is returned, "
"subsequent next calls *should keep returning NULL*. Next method is marked "
"with KF_ITER_NEXT (and should also have KF_RET_NULL as NULL-returning kfunc, "
"of course)."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:84
msgid ""
"destructor, `bpf_iter_<type>_destroy()`, is always called once. Even if "
"constructor failed or next returned nothing.  Destructor frees up any "
"resources and marks stack space used by `struct bpf_iter_<type>` as usable "
"for something else. Destructor is marked with KF_ITER_DESTROY flag."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:89
msgid ""
"Any open-coded BPF iterator implementation has to implement at least these "
"three methods. It is enforced that for any given type of iterator only "
"applicable constructor/destructor/next are callable. I.e., verifier ensures "
"you can't pass number iterator state into, say, cgroup iterator's next "
"method."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:94
msgid ""
"From a 10,000-feet BPF verification point of view, next methods are the "
"points of forking a verification state, which are conceptually similar to "
"what verifier is doing when validating conditional jumps. Verifier is "
"branching out `call bpf_iter_<type>_next` instruction and simulates two "
"outcomes: NULL (iteration is done) and non-NULL (new element is returned). "
"NULL is simulated first and is supposed to reach exit without looping. After "
"that non-NULL case is validated and it either reaches exit (for trivial "
"examples with no real loop), or reaches another `call bpf_iter_<type>_next` "
"instruction with the state equivalent to already (partially) validated one. "
"State equivalency at that point means we technically are going to be looping "
"forever without \"breaking out\" out of established \"state envelope\" (i."
"e., subsequent iterations don't add any new knowledge or constraints to the "
"verifier state, so running 1, 2, 10, or a million of them doesn't matter). "
"But taking into account the contract stating that iterator next method *has "
"to* return NULL eventually, we can conclude that loop body is safe and will "
"eventually terminate. Given we validated logic outside of the loop (NULL "
"case), and concluded that loop body is safe (though potentially looping many "
"times), verifier can claim safety of the overall program logic."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:115
msgid "BPF Iterators Motivation"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:117
msgid ""
"There are a few existing ways to dump kernel data into user space. The most "
"popular one is the ``/proc`` system. For example, ``cat /proc/net/tcp6`` "
"dumps all tcp6 sockets in the system, and ``cat /proc/net/netlink`` dumps "
"all netlink sockets in the system. However, their output format tends to be "
"fixed, and if users want more information about these sockets, they have to "
"patch the kernel, which often takes time to publish upstream and release. "
"The same is true for popular tools like `ss <https://man7.org/linux/man-"
"pages/man8/ss.8.html>`_ where any additional information needs a kernel "
"patch."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:126
msgid ""
"To solve this problem, the `drgn <https://www.kernel.org/doc/html/latest/bpf/"
"drgn.html>`_ tool is often used to dig out the kernel data with no kernel "
"change. However, the main drawback for drgn is performance, as it cannot do "
"pointer tracing inside the kernel. In addition, drgn cannot validate a "
"pointer value and may read invalid data if the pointer becomes invalid "
"inside the kernel."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:133
msgid ""
"The BPF iterator solves the above problem by providing flexibility on what "
"data (e.g., tasks, bpf_maps, etc.) to collect by calling BPF programs for "
"each kernel data object."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:139
msgid "How BPF Iterators Work"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:141
msgid ""
"A BPF iterator is a type of BPF program that allows users to iterate over "
"specific types of kernel objects. Unlike traditional BPF tracing programs "
"that allow users to define callbacks that are invoked at particular points "
"of execution in the kernel, BPF iterators allow users to define callbacks "
"that should be executed for every entry in a variety of kernel data "
"structures."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:147
msgid ""
"For example, users can define a BPF iterator that iterates over every task "
"on the system and dumps the total amount of CPU runtime currently used by "
"each of them. Another BPF task iterator may instead dump the cgroup "
"information for each task. Such flexibility is the core value of BPF "
"iterators."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:152
msgid ""
"A BPF program is always loaded into the kernel at the behest of a user space "
"process. A user space process loads a BPF program by opening and "
"initializing the program skeleton as required and then invoking a syscall to "
"have the BPF program verified and loaded by the kernel."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:157
msgid ""
"In traditional tracing programs, a program is activated by having user space "
"obtain a ``bpf_link`` to the program with ``bpf_program__attach()``. Once "
"activated, the program callback will be invoked whenever the tracepoint is "
"triggered in the main kernel. For BPF iterator programs, a ``bpf_link`` to "
"the program is obtained using ``bpf_link_create()``, and the program "
"callback is invoked by issuing system calls from user space."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:164
msgid ""
"Next, let us see how you can use the iterators to iterate on kernel objects "
"and read data."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:169
msgid "How to Use BPF iterators"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:171
msgid ""
"BPF selftests are a great resource to illustrate how to use the iterators. "
"In this section, we’ll walk through a BPF selftest which shows how to load "
"and use a BPF iterator program.   To begin, we’ll look at `bpf_iter.c "
"<https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-next.git/tree/tools/"
"testing/selftests/bpf/prog_tests/bpf_iter.c>`_, which illustrates how to "
"load and trigger BPF iterators on the user space side. Later, we’ll look at "
"a BPF program that runs in kernel space."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:178
msgid ""
"Loading a BPF iterator in the kernel from user space typically involves the "
"following steps:"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:181
msgid ""
"The BPF program is loaded into the kernel through ``libbpf``. Once the "
"kernel has verified and loaded the program, it returns a file descriptor "
"(fd) to user space."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:184
msgid ""
"Obtain a ``link_fd`` to the BPF program by calling the ``bpf_link_create()`` "
"specified with the BPF program file descriptor received from the kernel."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:186
msgid ""
"Next, obtain a BPF iterator file descriptor (``bpf_iter_fd``) by calling the "
"``bpf_iter_create()`` specified with the ``bpf_link`` received from Step 2."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:188
msgid ""
"Trigger the iteration by calling ``read(bpf_iter_fd)`` until no data is "
"available."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:190
msgid "Close the iterator fd using ``close(bpf_iter_fd)``."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:191
msgid ""
"If needed to reread the data, get a new ``bpf_iter_fd`` and do the read "
"again."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:193
msgid "The following are a few examples of selftest BPF iterator programs:"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:195
msgid ""
"`bpf_iter_tcp4.c <https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-"
"next.git/tree/tools/testing/selftests/bpf/progs/bpf_iter_tcp4.c>`_"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:196
msgid ""
"`bpf_iter_task_vmas.c <https://git.kernel.org/pub/scm/linux/kernel/git/bpf/"
"bpf-next.git/tree/tools/testing/selftests/bpf/progs/bpf_iter_task_vmas.c>`_"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:197
msgid ""
"`bpf_iter_task_file.c <https://git.kernel.org/pub/scm/linux/kernel/git/bpf/"
"bpf-next.git/tree/tools/testing/selftests/bpf/progs/bpf_iter_task_file.c>`_"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:199
msgid "Let us look at ``bpf_iter_task_file.c``, which runs in kernel space:"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:201
msgid ""
"Here is the definition of ``bpf_iter__task_file`` in `vmlinux.h <https://"
"facebookmicrosites.github.io/bpf/blog/2020/02/19/bpf-portability-and-co-re."
"html#btf>`_. Any struct name in ``vmlinux.h`` in the format "
"``bpf_iter__<iter_name>`` represents a BPF iterator. The suffix "
"``<iter_name>`` represents the type of iterator."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:222
msgid ""
"In the above code, the field 'meta' contains the metadata, which is the same "
"for all BPF iterator programs. The rest of the fields are specific to "
"different iterators. For example, for task_file iterators, the kernel layer "
"provides the 'task', 'fd' and 'file' field values. The 'task' and 'file' are "
"`reference counted <https://facebookmicrosites.github.io/bpf/blog/2018/08/31/"
"object-lifetime.html#file-descriptors-and-reference-counters>`_, so they "
"won't go away when the BPF program runs."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:230
msgid "Here is a snippet from the  ``bpf_iter_task_file.c`` file:"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:263
msgid ""
"In the above example, the section name ``SEC(iter/task_file)``, indicates "
"that the program is a BPF iterator program to iterate all files from all "
"tasks. The context of the program is ``bpf_iter__task_file`` struct."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:267
msgid ""
"The user space program invokes the BPF iterator program running in the "
"kernel by issuing a ``read()`` syscall. Once invoked, the BPF program can "
"export data to user space using a variety of BPF helper functions. You can "
"use either ``bpf_seq_printf()`` (and BPF_SEQ_PRINTF helper macro) or "
"``bpf_seq_write()`` function based on whether you need formatted output or "
"just binary data, respectively. For binary-encoded data, the user space "
"applications can process the data from ``bpf_seq_write()`` as needed. For "
"the formatted data, you can use ``cat <path>`` to print the results similar "
"to ``cat /proc/net/netlink`` after pinning the BPF iterator to the bpffs "
"mount. Later, use  ``rm -f <path>`` to remove the pinned iterator."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:278
msgid ""
"For example, you can use the following command to create a BPF iterator from "
"the ``bpf_iter_ipv6_route.o`` object file and pin it to the ``/sys/fs/bpf/"
"my_route`` path:"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:286
msgid "And then print out the results using the following command:"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:295
msgid "Implement Kernel Support for BPF Iterator Program Types"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:297
msgid ""
"To implement a BPF iterator in the kernel, the developer must make a one-"
"time change to the following key data structure defined in the `bpf.h "
"<https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-next.git/tree/"
"include/linux/bpf.h>`_ file."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:317
msgid ""
"After filling the data structure fields, call ``bpf_iter_reg_target()`` to "
"register the iterator to the main BPF iterator subsystem."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:320
msgid ""
"The following is the breakdown for each field in struct ``bpf_iter_reg``."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:326
msgid "Fields"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:327
msgid "Description"
msgstr "描述"

#: ../../../bpf/bpf_iterators.rst:328
msgid "target"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:329
msgid ""
"Specifies the name of the BPF iterator. For example: ``bpf_map``, "
"``bpf_map_elem``. The name should be different from other ``bpf_iter`` "
"target names in the kernel."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:331
msgid "attach_target and detach_target"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:332
msgid ""
"Allows for target specific ``link_create`` action since some targets may "
"need special processing. Called during the user space link_create stage."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:334
msgid "show_fdinfo and fill_link_info"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:335
msgid ""
"Called to fill target specific information when user tries to get link info "
"associated with the iterator."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:337
msgid "get_func_proto"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:338
msgid "Permits a BPF iterator to access BPF helpers specific to the iterator."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:339
msgid "ctx_arg_info_size and ctx_arg_info"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:340
msgid ""
"Specifies the verifier states for BPF program arguments associated with the "
"bpf iterator."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:342
msgid "feature"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:343
msgid ""
"Specifies certain action requests in the kernel BPF iterator infrastructure. "
"Currently, only BPF_ITER_RESCHED is supported. This means that the kernel "
"function cond_resched() is called to avoid other kernel subsystem (e.g., "
"rcu) misbehaving."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:347
msgid "seq_info"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:348
msgid ""
"Specifies the set of seq operations for the BPF iterator and helpers to "
"initialize/free the private data for the corresponding ``seq_file``."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:351
msgid ""
"`Click here <https://lore.kernel.org/bpf/20210212183107.50963-2-"
"songliubraving@fb.com/>`_ to see an implementation of the ``task_vma`` BPF "
"iterator in the kernel."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:357
msgid "Parameterizing BPF Task Iterators"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:359
msgid ""
"By default, BPF iterators walk through all the objects of the specified "
"types (processes, cgroups, maps, etc.) across the entire system to read "
"relevant kernel data. But often, there are cases where we only care about a "
"much smaller subset of iterable kernel objects, such as only iterating tasks "
"within a specific process. Therefore, BPF iterator programs support "
"filtering out objects from iteration by allowing user space to configure the "
"iterator program when it is attached."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:369
msgid "BPF Task Iterator Program"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:371
msgid ""
"The following code is a BPF iterator program to print files and task "
"information through the ``seq_file`` of the iterator. It is a standard BPF "
"iterator program that visits every file of an iterator. We will use this BPF "
"program in our example later."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:402
msgid "Creating a File Iterator with Parameters"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:404
msgid ""
"Now, let us look at how to create an iterator that includes only files of a "
"process."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:407
msgid "First,  fill the ``bpf_iter_attach_opts`` struct as shown below:"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:418
msgid ""
"``linfo.task.pid``, if it is non-zero, directs the kernel to create an "
"iterator that only includes opened files for the process with the specified "
"``pid``. In this example, we will only be iterating files for our process. "
"If ``linfo.task.pid`` is zero, the iterator will visit every opened file of "
"every process. Similarly, ``linfo.task.tid`` directs the kernel to create an "
"iterator that visits opened files of a specific thread, not a process. In "
"this example, ``linfo.task.tid`` is different from ``linfo.task.pid`` only "
"if the thread has a separate file descriptor table. In most circumstances, "
"all process threads share a single file descriptor table."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:428
msgid ""
"Now, in the userspace program, pass the pointer of struct to the "
"``bpf_program__attach_iter()``."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:436
msgid ""
"If both *tid* and *pid* are zero, an iterator created from this struct "
"``bpf_iter_attach_opts`` will include every opened file of every task in the "
"system (in the namespace, actually.) It is the same as passing a NULL as the "
"second argument to ``bpf_program__attach_iter()``."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:441
msgid "The whole program looks like the following code:"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:505
msgid "The following lines are the output of the program. ::"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:523
msgid "Without Parameters"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:525
msgid ""
"Let us look at how a BPF iterator without parameters skips files of other "
"processes in the system. In this case, the BPF program has to check the pid "
"or the tid of tasks, or it will receive every opened file in the system (in "
"the current *pid* namespace, actually). So, we usually add a global variable "
"in the BPF program to pass a *pid* to the BPF program."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:531
msgid "The BPF program would look like the following block."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:549
msgid "The user space program would look like the following block:"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:568
msgid ""
"``target_pid`` is a global variable in the BPF program. The user space "
"program should initialize the variable with a process ID to skip opened "
"files of other processes in the BPF program. When you parametrize a BPF "
"iterator, the iterator calls the BPF program fewer times which can save "
"significant resources."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:575
msgid "Parametrizing VMA Iterators"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:577
msgid ""
"By default, a BPF VMA iterator includes every VMA in every process.  "
"However, you can still specify a process or a thread to include only its "
"VMAs. Unlike files, a thread can not have a separate address space (since "
"Linux 2.6.0-test6). Here, using *tid* makes no difference from using *pid*."
msgstr ""

#: ../../../bpf/bpf_iterators.rst:584
msgid "Parametrizing Task Iterators"
msgstr ""

#: ../../../bpf/bpf_iterators.rst:586
msgid ""
"A BPF task iterator with *pid* includes all tasks (threads) of a process. "
"The BPF program receives these tasks one after another. You can specify a "
"BPF task iterator with *tid* parameter to include only the tasks that match "
"the given *tid*."
msgstr ""
