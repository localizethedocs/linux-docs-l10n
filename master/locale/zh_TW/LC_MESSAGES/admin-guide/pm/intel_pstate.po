# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../admin-guide/pm/intel_pstate.rst:6
msgid "``intel_pstate`` CPU Performance Scaling Driver"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:0
msgid "Copyright"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:8
msgid "|copy| 2017 Intel Corporation"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:0
msgid "Author"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:10
msgid "Rafael J. Wysocki <rafael.j.wysocki@intel.com>"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:14
msgid "General Information"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:16
msgid ""
"``intel_pstate`` is a part of the :doc:`CPU performance scaling subsystem "
"<cpufreq>` in the Linux kernel (``CPUFreq``).  It is a scaling driver for "
"the Sandy Bridge and later generations of Intel processors.  Note, however, "
"that some of those processors may not be supported.  [To understand "
"``intel_pstate`` it is necessary to know how ``CPUFreq`` works in general, "
"so this is the time to read Documentation/admin-guide/pm/cpufreq.rst if you "
"have not done that yet.]"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:24
msgid ""
"For the processors supported by ``intel_pstate``, the P-state concept is "
"broader than just an operating frequency or an operating performance point "
"(see the LinuxCon Europe 2015 presentation by Kristen Accardi [1]_ for more "
"information about that).  For this reason, the representation of P-states "
"used by ``intel_pstate`` internally follows the hardware specification (for "
"details refer to Intel Software Developerâ€™s Manual [2]_).  However, the "
"``CPUFreq`` core uses frequencies for identifying operating performance "
"points of CPUs and frequencies are involved in the user space interface "
"exposed by it, so ``intel_pstate`` maps its internal representation of P-"
"states to frequencies too (fortunately, that mapping is unambiguous).  At "
"the same time, it would not be practical for ``intel_pstate`` to supply the "
"``CPUFreq`` core with a table of available frequencies due to the possible "
"size of it, so the driver does not do that.  Some functionality of the core "
"is limited by that."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:38
msgid ""
"Since the hardware P-state selection interface used by ``intel_pstate`` is "
"available at the logical CPU level, the driver always works with individual "
"CPUs.  Consequently, if ``intel_pstate`` is in use, every ``CPUFreq`` policy "
"object corresponds to one logical CPU and ``CPUFreq`` policies are "
"effectively equivalent to CPUs.  In particular, this means that they become "
"\"inactive\" every time the corresponding CPU is taken offline and need to "
"be re-initialized when it goes back online."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:46
msgid ""
"``intel_pstate`` is not modular, so it cannot be unloaded, which means that "
"the only way to pass early-configuration-time parameters to it is via the "
"kernel command line.  However, its configuration can be adjusted via "
"``sysfs`` to a great extent.  In some configurations it even is possible to "
"unregister it via ``sysfs`` which allows another ``CPUFreq`` scaling driver "
"to be loaded and registered (see `below <status_attr_>`_)."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:55
msgid "Operation Modes"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:57
msgid ""
"``intel_pstate`` can operate in two different modes, active or passive.  In "
"the active mode, it uses its own internal performance scaling governor "
"algorithm or allows the hardware to do performance scaling by itself, while "
"in the passive mode it responds to requests made by a generic ``CPUFreq`` "
"governor implementing a certain performance scaling algorithm.  Which of "
"them will be in effect depends on what kernel command line options are used "
"and on the capabilities of the processor."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:66
msgid "Active Mode"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:68
msgid ""
"This is the default operation mode of ``intel_pstate`` for processors with "
"hardware-managed P-states (HWP) support.  If it works in this mode, the "
"``scaling_driver`` policy attribute in ``sysfs`` for all ``CPUFreq`` "
"policies contains the string \"intel_pstate\"."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:73
msgid ""
"In this mode the driver bypasses the scaling governors layer of ``CPUFreq`` "
"and provides its own scaling algorithms for P-state selection.  Those "
"algorithms can be applied to ``CPUFreq`` policies in the same way as generic "
"scaling governors (that is, through the ``scaling_governor`` policy "
"attribute in ``sysfs``).  [Note that different P-state selection algorithms "
"may be chosen for different policies, but that is not recommended.]"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:80
msgid ""
"They are not generic scaling governors, but their names are the same as the "
"names of some of those governors.  Moreover, confusingly enough, they "
"generally do not work in the same way as the generic governors they share "
"the names with. For example, the ``powersave`` P-state selection algorithm "
"provided by ``intel_pstate`` is not a counterpart of the generic "
"``powersave`` governor (roughly, it corresponds to the ``schedutil`` and "
"``ondemand`` governors)."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:87
msgid ""
"There are two P-state selection algorithms provided by ``intel_pstate`` in "
"the active mode: ``powersave`` and ``performance``.  The way they both "
"operate depends on whether or not the hardware-managed P-states (HWP) "
"feature has been enabled in the processor and possibly on the processor "
"model."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:92
msgid ""
"Which of the P-state selection algorithms is used by default depends on the :"
"c:macro:`CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE` kernel configuration "
"option. Namely, if that option is set, the ``performance`` algorithm will be "
"used by default, and the other one will be used by default if it is not set."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:98
msgid "Active Mode With HWP"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:100
msgid ""
"If the processor supports the HWP feature, it will be enabled during the "
"processor initialization and cannot be disabled after that.  It is possible "
"to avoid enabling it by passing the ``intel_pstate=no_hwp`` argument to the "
"kernel in the command line."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:105
msgid ""
"If the HWP feature has been enabled, ``intel_pstate`` relies on the "
"processor to select P-states by itself, but still it can give hints to the "
"processor's internal P-state selection logic.  What those hints are depends "
"on which P-state selection algorithm has been applied to the given policy "
"(or to the CPU it corresponds to)."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:111
msgid ""
"Even though the P-state selection is carried out by the processor "
"automatically, ``intel_pstate`` registers utilization update callbacks with "
"the CPU scheduler in this mode.  However, they are not used for running a P-"
"state selection algorithm, but for periodic updates of the current CPU "
"frequency information to be made available from the ``scaling_cur_freq`` "
"policy attribute in ``sysfs``."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:118
msgid "HWP + ``performance``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:120
msgid ""
"In this configuration ``intel_pstate`` will write 0 to the processor's "
"Energy-Performance Preference (EPP) knob (if supported) or its Energy-"
"Performance Bias (EPB) knob (otherwise), which means that the processor's "
"internal P-state selection logic is expected to focus entirely on "
"performance."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:125
msgid ""
"This will override the EPP/EPB setting coming from the ``sysfs`` interface "
"(see `Energy vs Performance Hints`_ below).  Moreover, any attempts to "
"change the EPP/EPB to a value different from 0 (\"performance\") via "
"``sysfs`` in this configuration will be rejected."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:130
msgid ""
"Also, in this configuration the range of P-states available to the "
"processor's internal P-state selection logic is always restricted to the "
"upper boundary (that is, the maximum P-state that the driver is allowed to "
"use)."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:135
msgid "HWP + ``powersave``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:137
msgid ""
"In this configuration ``intel_pstate`` will set the processor's Energy-"
"Performance Preference (EPP) knob (if supported) or its Energy-Performance "
"Bias (EPB) knob (otherwise) to whatever value it was previously set to via "
"``sysfs`` (or whatever default value it was set to by the platform "
"firmware).  This usually causes the processor's internal P-state selection "
"logic to be less performance-focused."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:145
msgid "Active Mode Without HWP"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:147
msgid ""
"This operation mode is optional for processors that do not support the HWP "
"feature or when the ``intel_pstate=no_hwp`` argument is passed to the kernel "
"in the command line.  The active mode is used in those cases if the "
"``intel_pstate=active`` argument is passed to the kernel in the command "
"line. In this mode ``intel_pstate`` may refuse to work with processors that "
"are not recognized by it.  [Note that ``intel_pstate`` will never refuse to "
"work with any processor with the HWP feature enabled.]"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:155
msgid ""
"In this mode ``intel_pstate`` registers utilization update callbacks with "
"the CPU scheduler in order to run a P-state selection algorithm, either "
"``powersave`` or ``performance``, depending on the ``scaling_governor`` "
"policy setting in ``sysfs``.  The current CPU frequency information to be "
"made available from the ``scaling_cur_freq`` policy attribute in ``sysfs`` "
"is periodically updated by those utilization update callbacks too."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:163
msgid "``performance``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:165
msgid ""
"Without HWP, this P-state selection algorithm is always the same regardless "
"of the processor model and platform configuration."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:168
msgid ""
"It selects the maximum P-state it is allowed to use, subject to limits set "
"via ``sysfs``, every time the driver configuration for the given CPU is "
"updated (e.g. via ``sysfs``)."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:172
msgid ""
"This is the default P-state selection algorithm if the :c:macro:"
"`CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE` kernel configuration option is set."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:177
msgid "``powersave``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:179
msgid ""
"Without HWP, this P-state selection algorithm is similar to the algorithm "
"implemented by the generic ``schedutil`` scaling governor except that the "
"utilization metric used by it is based on numbers coming from feedback "
"registers of the CPU.  It generally selects P-states proportional to the "
"current CPU utilization."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:185
msgid ""
"This algorithm is run by the driver's utilization update callback for the "
"given CPU when it is invoked by the CPU scheduler, but not more often than "
"every 10 ms.  Like in the ``performance`` case, the hardware configuration "
"is not touched if the new P-state turns out to be the same as the current "
"one."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:191
msgid ""
"This is the default P-state selection algorithm if the :c:macro:"
"`CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE` kernel configuration option is not "
"set."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:196
msgid "Passive Mode"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:198
msgid ""
"This is the default operation mode of ``intel_pstate`` for processors "
"without hardware-managed P-states (HWP) support.  It is always used if the "
"``intel_pstate=passive`` argument is passed to the kernel in the command "
"line regardless of whether or not the given processor supports HWP.  [Note "
"that the ``intel_pstate=no_hwp`` setting causes the driver to start in the "
"passive mode if it is not combined with ``intel_pstate=active``.]  Like in "
"the active mode without HWP support, in this mode ``intel_pstate`` may "
"refuse to work with processors that are not recognized by it if HWP is "
"prevented from being enabled through the kernel command line."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:208
msgid ""
"If the driver works in this mode, the ``scaling_driver`` policy attribute in "
"``sysfs`` for all ``CPUFreq`` policies contains the string "
"\"intel_cpufreq\". Then, the driver behaves like a regular ``CPUFreq`` "
"scaling driver.  That is, it is invoked by generic scaling governors when "
"necessary to talk to the hardware in order to change the P-state of a CPU "
"(in particular, the ``schedutil`` governor can invoke it directly from "
"scheduler context)."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:215
msgid ""
"While in this mode, ``intel_pstate`` can be used with all of the (generic) "
"scaling governors listed by the ``scaling_available_governors`` policy "
"attribute in ``sysfs`` (and the P-state selection algorithms described above "
"are not used).  Then, it is responsible for the configuration of policy "
"objects corresponding to CPUs and provides the ``CPUFreq`` core (and the "
"scaling governors attached to the policy objects) with accurate information "
"on the maximum and minimum operating frequencies supported by the hardware "
"(including the so-called \"turbo\" frequency ranges).  In other words, in "
"the passive mode the entire range of available P-states is exposed by "
"``intel_pstate`` to the ``CPUFreq`` core.  However, in this mode the driver "
"does not register utilization update callbacks with the CPU scheduler and "
"the ``scaling_cur_freq`` information comes from the ``CPUFreq`` core (and is "
"the last frequency selected by the current scaling governor for the given "
"policy)."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:233
msgid "Turbo P-states Support"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:235
msgid ""
"In the majority of cases, the entire range of P-states available to "
"``intel_pstate`` can be divided into two sub-ranges that correspond to "
"different types of processor behavior, above and below a boundary that will "
"be referred to as the \"turbo threshold\" in what follows."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:240
msgid ""
"The P-states above the turbo threshold are referred to as \"turbo P-states\" "
"and the whole sub-range of P-states they belong to is referred to as the "
"\"turbo range\".  These names are related to the Turbo Boost technology "
"allowing a multicore processor to opportunistically increase the P-state of "
"one or more cores if there is enough power to do that and if that is not "
"going to cause the thermal envelope of the processor package to be exceeded."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:247
msgid ""
"Specifically, if software sets the P-state of a CPU core within the turbo "
"range (that is, above the turbo threshold), the processor is permitted to "
"take over performance scaling control for that core and put it into turbo P-"
"states of its choice going forward.  However, that permission is interpreted "
"differently by different processor generations.  Namely, the Sandy Bridge "
"generation of processors will never use any P-states above the last one set "
"by software for the given core, even if it is within the turbo range, "
"whereas all of the later processor generations will take it as a license to "
"use any P-states from the turbo range, even above the one set by software.  "
"In other words, on those processors setting any P-state from the turbo range "
"will enable the processor to put the given core into all turbo P-states up "
"to and including the maximum supported one as it sees fit."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:260
msgid ""
"One important property of turbo P-states is that they are not sustainable.  "
"More precisely, there is no guarantee that any CPUs will be able to stay in "
"any of those states indefinitely, because the power distribution within the "
"processor package may change over time  or the thermal envelope it was "
"designed for might be exceeded if a turbo P-state was used for too long."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:266
msgid ""
"In turn, the P-states below the turbo threshold generally are sustainable.  "
"In fact, if one of them is set by software, the processor is not expected to "
"change it to a lower one unless in a thermal stress or a power limit "
"violation situation (a higher P-state may still be used if it is set for "
"another CPU in the same package at the same time, for example)."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:272
msgid ""
"Some processors allow multiple cores to be in turbo P-states at the same "
"time, but the maximum P-state that can be set for them generally depends on "
"the number of cores running concurrently.  The maximum turbo P-state that "
"can be set for 3 cores at the same time usually is lower than the analogous "
"maximum P-state for 2 cores, which in turn usually is lower than the maximum "
"turbo P-state that can be set for 1 core.  The one-core maximum turbo P-"
"state is thus the maximum supported one overall."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:280
msgid ""
"The maximum supported turbo P-state, the turbo threshold (the maximum "
"supported non-turbo P-state) and the minimum supported P-state are specific "
"to the processor model and can be determined by reading the processor's "
"model-specific registers (MSRs).  Moreover, some processors support the "
"Configurable TDP (Thermal Design Power) feature and, when that feature is "
"enabled, the turbo threshold effectively becomes a configurable value that "
"can be set by the platform firmware."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:288
msgid ""
"Unlike ``_PSS`` objects in the ACPI tables, ``intel_pstate`` always exposes "
"the entire range of available P-states, including the whole turbo range, to "
"the ``CPUFreq`` core and (in the passive mode) to generic scaling "
"governors.  This generally causes turbo P-states to be set more often when "
"``intel_pstate`` is used relative to ACPI-based CPU performance scaling (see "
"`below <acpi-cpufreq_>`_ for more information)."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:295
msgid ""
"Moreover, since ``intel_pstate`` always knows what the real turbo threshold "
"is (even if the Configurable TDP feature is enabled in the processor), its "
"``no_turbo`` attribute in ``sysfs`` (described `below <no_turbo_attr_>`_) "
"should work as expected in all cases (that is, if set to disable turbo P-"
"states, it always should prevent ``intel_pstate`` from using them)."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:303
msgid "Processor Support"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:305
msgid ""
"To handle a given processor ``intel_pstate`` requires a number of different "
"pieces of information on it to be known, including:"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:308
msgid "The minimum supported P-state."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:310
msgid "The maximum supported `non-turbo P-state <turbo_>`_."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:312
msgid "Whether or not turbo P-states are supported at all."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:314
msgid ""
"The maximum supported `one-core turbo P-state <turbo_>`_ (if turbo P-states "
"are supported)."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:317
msgid ""
"The scaling formula to translate the driver's internal representation of P-"
"states into frequencies and the other way around."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:320
msgid ""
"Generally, ways to obtain that information are specific to the processor "
"model or family.  Although it often is possible to obtain all of it from the "
"processor itself (using model-specific registers), there are cases in which "
"hardware manuals need to be consulted to get to it too."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:325
msgid ""
"For this reason, there is a list of supported processors in ``intel_pstate`` "
"and the driver initialization will fail if the detected processor is not in "
"that list, unless it supports the HWP feature.  [The interface to obtain all "
"of the information listed above is the same for all of the processors "
"supporting the HWP feature, which is why ``intel_pstate`` works with all of "
"them.]"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:333
msgid "Support for Hybrid Processors"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:335
msgid ""
"Some processors supported by ``intel_pstate`` contain two or more types of "
"CPU cores differing by the maximum turbo P-state, performance vs power "
"characteristics, cache sizes, and possibly other properties.  They are "
"commonly referred to as hybrid processors.  To support them, "
"``intel_pstate`` requires HWP to be enabled and it assumes the HWP "
"performance units to be the same for all CPUs in the system, so a given HWP "
"performance level always represents approximately the same physical "
"performance regardless of the core (CPU) type."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:344
msgid "Hybrid Processors with SMT"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:346
msgid ""
"On systems where SMT (Simultaneous Multithreading), also referred to as "
"HyperThreading (HT) in the context of Intel processors, is enabled on at "
"least one core, ``intel_pstate`` assigns performance-based priorities to "
"CPUs.  Namely, the priority of a given CPU reflects its highest HWP "
"performance level which causes the CPU scheduler to generally prefer more "
"performant CPUs, so the less performant CPUs are used when the other ones "
"are fully loaded.  However, SMT siblings (that is, logical CPUs sharing one "
"physical core) are treated in a special way such that if one of them is in "
"use, the effective priority of the other ones is lowered below the "
"priorities of the CPUs located in the other physical cores."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:357
msgid ""
"This approach maximizes performance in the majority of cases, but "
"unfortunately it also leads to excessive energy usage in some important "
"scenarios, like video playback, which is not generally desirable.  While "
"there is no other viable choice with SMT enabled because the effective "
"capacity and utilization of SMT siblings are hard to determine, hybrid "
"processors without SMT can be handled in more energy-efficient ways."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:367
msgid "Capacity-Aware Scheduling Support"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:369
msgid ""
"The capacity-aware scheduling (CAS) support in the CPU scheduler is enabled "
"by ``intel_pstate`` by default on hybrid processors without SMT.  CAS "
"generally causes the scheduler to put tasks on a CPU so long as there is a "
"sufficient amount of spare capacity on it, and if the utilization of a given "
"task is too high for it, the task will need to go somewhere else."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:375
msgid ""
"Since CAS takes CPU capacities into account, it does not require CPU "
"prioritization and it allows tasks to be distributed more symmetrically "
"among the more performant and less performant CPUs.  Once placed on a CPU "
"with enough capacity to accommodate it, a task may just continue to run "
"there regardless of whether or not the other CPUs are fully loaded, so on "
"average CAS reduces the utilization of the more performant CPUs which causes "
"the energy usage to be more balanced because the more performant CPUs are "
"generally less energy-efficient than the less performant ones."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:384
msgid ""
"In order to use CAS, the scheduler needs to know the capacity of each CPU in "
"the system and it needs to be able to compute scale-invariant utilization of "
"CPUs, so ``intel_pstate`` provides it with the requisite information."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:388
msgid ""
"First of all, the capacity of each CPU is represented by the ratio of its "
"highest HWP performance level, multiplied by 1024, to the highest HWP "
"performance level of the most performant CPU in the system, which works "
"because the HWP performance units are the same for all CPUs.  Second, the "
"frequency-invariance computations, carried out by the scheduler to always "
"express CPU utilization in the same units regardless of the frequency it is "
"currently running at, are adjusted to take the CPU capacity into account.  "
"All of this happens when ``intel_pstate`` has registered itself with the "
"``CPUFreq`` core and it has figured out that it is running on a hybrid "
"processor without SMT."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:399
msgid "Energy-Aware Scheduling Support"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:401
msgid ""
"If ``CONFIG_ENERGY_MODEL`` has been set during kernel configuration and "
"``intel_pstate`` runs on a hybrid processor without SMT, in addition to "
"enabling `CAS <CAS_>`_ it registers an Energy Model for the processor.  This "
"allows the Energy-Aware Scheduling (EAS) support to be enabled in the CPU "
"scheduler if ``schedutil`` is used as the  ``CPUFreq`` governor which "
"requires ``intel_pstate`` to operate in the `passive mode <Passive Mode_>`_."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:408
msgid ""
"The Energy Model registered by ``intel_pstate`` is artificial (that is, it "
"is based on abstract cost values and it does not include any real power "
"numbers) and it is relatively simple to avoid unnecessary computations in "
"the scheduler. There is a performance domain in it for every CPU in the "
"system and the cost values for these performance domains have been chosen so "
"that running a task on a less performant (small) CPU appears to be always "
"cheaper than running that task on a more performant (big) CPU.  However, for "
"two CPUs of the same type, the cost difference depends on their current "
"utilization, and the CPU whose current utilization is higher generally "
"appears to be a more expensive destination for a given task.  This helps to "
"balance the load among CPUs of the same type."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:420
msgid ""
"Since EAS works on top of CAS, high-utilization tasks are always migrated to "
"CPUs with enough capacity to accommodate them, but thanks to EAS, low-"
"utilization tasks tend to be placed on the CPUs that look less expensive to "
"the scheduler. Effectively, this causes the less performant and less loaded "
"CPUs to be preferred as long as they have enough spare capacity to run the "
"given task which generally leads to reduced energy usage."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:427
msgid ""
"The Energy Model created by ``intel_pstate`` can be inspected by looking at "
"the ``energy_model`` directory in ``debugfs`` (typlically mounted on ``/sys/"
"kernel/debug/``)."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:433
msgid "User Space Interface in ``sysfs``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:436
msgid "Global Attributes"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:438
msgid ""
"``intel_pstate`` exposes several global attributes (files) in ``sysfs`` to "
"control its functionality at the system level.  They are located in the ``/"
"sys/devices/system/cpu/intel_pstate/`` directory and affect all CPUs."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:442
msgid ""
"Some of them are not present if the ``intel_pstate=per_cpu_perf_limits`` "
"argument is passed to the kernel in the command line."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:445
msgid "``max_perf_pct``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:446
msgid ""
"Maximum P-state the driver is allowed to set in percent of the maximum "
"supported performance level (the highest supported `turbo P-state "
"<turbo_>`_)."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:450
#: ../../../admin-guide/pm/intel_pstate.rst:459
msgid ""
"This attribute will not be exposed if the "
"``intel_pstate=per_cpu_perf_limits`` argument is present in the kernel "
"command line."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:454
msgid "``min_perf_pct``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:455
msgid ""
"Minimum P-state the driver is allowed to set in percent of the maximum "
"supported performance level (the highest supported `turbo P-state "
"<turbo_>`_)."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:463
msgid "``num_pstates``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:464
msgid ""
"Number of P-states supported by the processor (between 0 and 255 inclusive) "
"including both turbo and non-turbo P-states (see `Turbo P-states Support`_)."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:468
#: ../../../admin-guide/pm/intel_pstate.rst:480
msgid ""
"This attribute is present only if the value exposed by it is the same for "
"all of the CPUs in the system."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:471
msgid ""
"The value of this attribute is not affected by the ``no_turbo`` setting "
"described `below <no_turbo_attr_>`_."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:474
#: ../../../admin-guide/pm/intel_pstate.rst:483
msgid "This attribute is read-only."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:476
msgid "``turbo_pct``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:477
msgid ""
"Ratio of the `turbo range <turbo_>`_ size to the size of the entire range of "
"supported P-states, in percent."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:487
msgid "``no_turbo``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:488
msgid ""
"If set (equal to 1), the driver is not allowed to set any turbo P-states "
"(see `Turbo P-states Support`_).  If unset (equal to 0, which is the "
"default), turbo P-states can be set by the driver. [Note that "
"``intel_pstate`` does not support the general ``boost`` attribute (supported "
"by some other scaling drivers) which is replaced by this one.]"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:495
msgid ""
"This attribute does not affect the maximum supported frequency value "
"supplied to the ``CPUFreq`` core and exposed via the policy interface, but "
"it affects the maximum possible value of per-policy P-state limits (see "
"`Interpretation of Policy Attributes`_ below for details)."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:500
msgid "``hwp_dynamic_boost``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:501
msgid ""
"This attribute is only present if ``intel_pstate`` works in the `active mode "
"with the HWP feature enabled <Active Mode With HWP_>`_ in the processor.  If "
"set (equal to 1), it causes the minimum P-state limit to be increased "
"dynamically for a short time whenever a task previously waiting on I/O is "
"selected to run on a given logical CPU (the purpose of this mechanism is to "
"improve performance)."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:508
msgid ""
"This setting has no effect on logical CPUs whose minimum P-state limit is "
"directly set to the highest non-turbo P-state or above it."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:513
msgid "``status``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:514
msgid "Operation mode of the driver: \"active\", \"passive\" or \"off\"."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:516
msgid "\"active\""
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:517
msgid "The driver is functional and in the `active mode <Active Mode_>`_."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:520
msgid "\"passive\""
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:521
msgid "The driver is functional and in the `passive mode <Passive Mode_>`_."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:524
msgid "\"off\""
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:525
msgid ""
"The driver is not functional (it is not registered as a scaling driver with "
"the ``CPUFreq`` core)."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:528
msgid ""
"This attribute can be written to in order to change the driver's operation "
"mode or to unregister it.  The string written to it must be one of the "
"possible values of it and, if successful, the write will cause the driver to "
"switch over to the operation mode represented by that string - or to be "
"unregistered in the \"off\" case.  [Actually, switching over from the active "
"mode to the passive mode or the other way around causes the driver to be "
"unregistered and registered again with a different set of callbacks, so all "
"of its settings (the global as well as the per-policy ones) are then reset "
"to their default values, possibly depending on the target operation mode.]"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:539
msgid "``energy_efficiency``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:540
msgid ""
"This attribute is only present on platforms with CPUs matching the Kaby Lake "
"or Coffee Lake desktop CPU model. By default, energy-efficiency "
"optimizations are disabled on these CPU models if HWP is enabled. Enabling "
"energy-efficiency optimizations may limit maximum operating frequency with "
"or without the HWP feature.  With HWP enabled, the optimizations are done "
"only in the turbo frequency range.  Without it, they are done in the entire "
"available frequency range.  Setting this attribute to \"1\" enables the "
"energy-efficiency optimizations and setting to \"0\" disables them."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:551
msgid "Interpretation of Policy Attributes"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:553
msgid ""
"The interpretation of some ``CPUFreq`` policy attributes described in "
"Documentation/admin-guide/pm/cpufreq.rst is special with ``intel_pstate`` as "
"the current scaling driver and it generally depends on the driver's "
"`operation mode <Operation Modes_>`_."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:558
msgid ""
"First of all, the values of the ``cpuinfo_max_freq``, ``cpuinfo_min_freq`` "
"and ``scaling_cur_freq`` attributes are produced by applying a processor-"
"specific multiplier to the internal P-state representation used by "
"``intel_pstate``. Also, the values of the ``scaling_max_freq`` and "
"``scaling_min_freq`` attributes are capped by the frequency corresponding to "
"the maximum P-state that the driver is allowed to set."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:565
msgid ""
"If the ``no_turbo`` `global attribute <no_turbo_attr_>`_ is set, the driver "
"is not allowed to use turbo P-states, so the maximum value of "
"``scaling_max_freq`` and ``scaling_min_freq`` is limited to the maximum non-"
"turbo P-state frequency. Accordingly, setting ``no_turbo`` causes "
"``scaling_max_freq`` and ``scaling_min_freq`` to go down to that value if "
"they were above it before. However, the old values of ``scaling_max_freq`` "
"and ``scaling_min_freq`` will be restored after unsetting ``no_turbo``, "
"unless these attributes have been written to after ``no_turbo`` was set."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:574
msgid ""
"If ``no_turbo`` is not set, the maximum possible value of "
"``scaling_max_freq`` and ``scaling_min_freq`` corresponds to the maximum "
"supported turbo P-state, which also is the value of ``cpuinfo_max_freq`` in "
"either case."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:578
msgid ""
"Next, the following policy attributes have special meaning if "
"``intel_pstate`` works in the `active mode <Active Mode_>`_:"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:581
msgid "``scaling_available_governors``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:582
msgid "List of P-state selection algorithms provided by ``intel_pstate``."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:584
msgid "``scaling_governor``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:585
msgid ""
"P-state selection algorithm provided by ``intel_pstate`` currently in use "
"with the given policy."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:588
msgid "``scaling_cur_freq``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:589
msgid ""
"Frequency of the average P-state of the CPU represented by the given policy "
"for the time interval between the last two invocations of the driver's "
"utilization update callback by the CPU scheduler for that CPU."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:593
msgid ""
"One more policy attribute is present if the HWP feature is enabled in the "
"processor:"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:596
msgid "``base_frequency``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:597
msgid ""
"Shows the base frequency of the CPU. Any frequency above this will be in the "
"turbo frequency range."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:600
msgid ""
"The meaning of these attributes in the `passive mode <Passive Mode_>`_ is "
"the same as for other scaling drivers."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:603
msgid ""
"Additionally, the value of the ``scaling_driver`` attribute for "
"``intel_pstate`` depends on the operation mode of the driver.  Namely, it is "
"either \"intel_pstate\" (in the `active mode <Active Mode_>`_) or "
"\"intel_cpufreq\" (in the `passive mode <Passive Mode_>`_)."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:609
msgid "Coordination of P-State Limits"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:611
msgid ""
"``intel_pstate`` allows P-state limits to be set in two ways: with the help "
"of the ``max_perf_pct`` and ``min_perf_pct`` `global attributes <Global "
"Attributes_>`_ or via the ``scaling_max_freq`` and ``scaling_min_freq`` "
"``CPUFreq`` policy attributes.  The coordination between those limits is "
"based on the following rules, regardless of the current operation mode of "
"the driver:"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:617
msgid ""
"All CPUs are affected by the global limits (that is, none of them can be "
"requested to run faster than the global maximum and none of them can be "
"requested to run slower than the global minimum)."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:621
msgid ""
"Each individual CPU is affected by its own per-policy limits (that is, it "
"cannot be requested to run faster than its own per-policy maximum and it "
"cannot be requested to run slower than its own per-policy minimum). The "
"effective performance depends on whether the platform supports per core P-"
"states, hyper-threading is enabled and on current performance requests from "
"other CPUs. When platform doesn't support per core P-states, the effective "
"performance can be more than the policy limits set on a CPU, if other CPUs "
"are requesting higher performance at that moment. Even with per core P-"
"states support, when hyper-threading is enabled, if the sibling CPU is "
"requesting higher performance, the other siblings will get higher "
"performance than their policy limits."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:633
msgid "The global and per-policy limits can be set independently."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:635
msgid ""
"In the `active mode with the HWP feature enabled <Active Mode With HWP_>`_, "
"the resulting effective values are written into hardware registers whenever "
"the limits change in order to request its internal P-state selection logic "
"to always set P-states within these limits.  Otherwise, the limits are taken "
"into account by scaling governors (in the `passive mode <Passive Mode_>`_) "
"and by the driver every time before setting a new P-state for a CPU."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:642
msgid ""
"Additionally, if the ``intel_pstate=per_cpu_perf_limits`` command line "
"argument is passed to the kernel, ``max_perf_pct`` and ``min_perf_pct`` are "
"not exposed at all and the only way to set the limits is by using the policy "
"attributes."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:648
msgid "Energy vs Performance Hints"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:650
msgid ""
"If the hardware-managed P-states (HWP) is enabled in the processor, "
"additional attributes, intended to allow user space to help ``intel_pstate`` "
"to adjust the processor's internal P-state selection logic by focusing it on "
"performance or on energy-efficiency, or somewhere between the two extremes, "
"are present in every ``CPUFreq`` policy directory in ``sysfs``.  They are :"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:656
msgid "``energy_performance_preference``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:657
msgid ""
"Current value of the energy vs performance hint for the given policy (or the "
"CPU represented by it)."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:660
msgid "The hint can be changed by writing to this attribute."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:662
msgid "``energy_performance_available_preferences``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:663
msgid ""
"List of strings that can be written to the ``energy_performance_preference`` "
"attribute."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:666
msgid ""
"They represent different energy vs performance hints and should be self-"
"explanatory, except that ``default`` represents whatever hint value was set "
"by the platform firmware."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:670
msgid ""
"Strings written to the ``energy_performance_preference`` attribute are "
"internally translated to integer values written to the processor's Energy-"
"Performance Preference (EPP) knob (if supported) or its Energy-Performance "
"Bias (EPB) knob. It is also possible to write a positive integer value "
"between 0 to 255, if the EPP feature is present. If the EPP feature is not "
"present, writing integer value to this attribute is not supported. In this "
"case, user can use the \"/sys/devices/system/cpu/cpu*/power/"
"energy_perf_bias\" interface."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:679
msgid ""
"[Note that tasks may by migrated from one CPU to another by the scheduler's "
"load-balancing algorithm and if different energy vs performance hints are "
"set for those CPUs, that may lead to undesirable outcomes.  To avoid such "
"issues it is better to set the same energy vs performance hint for all CPUs "
"or to pin every task potentially sensitive to them to a specific CPU.]"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:688
msgid "``intel_pstate`` vs ``acpi-cpufreq``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:690
msgid ""
"On the majority of systems supported by ``intel_pstate``, the ACPI tables "
"provided by the platform firmware contain ``_PSS`` objects returning "
"information that can be used for CPU performance scaling (refer to the ACPI "
"specification [3]_ for details on the ``_PSS`` objects and the format of the "
"information returned by them)."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:696
msgid ""
"The information returned by the ACPI ``_PSS`` objects is used by the ``acpi-"
"cpufreq`` scaling driver.  On systems supported by ``intel_pstate`` the "
"``acpi-cpufreq`` driver uses the same hardware CPU performance scaling "
"interface, but the set of P-states it can use is limited by the ``_PSS`` "
"output."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:702
msgid ""
"On those systems each ``_PSS`` object returns a list of P-states supported "
"by the corresponding CPU which basically is a subset of the P-states range "
"that can be used by ``intel_pstate`` on the same system, with one exception: "
"the whole `turbo range <turbo_>`_ is represented by one item in it (the "
"topmost one).  By convention, the frequency returned by ``_PSS`` for that "
"item is greater by 1 MHz than the frequency of the highest non-turbo P-state "
"listed by it, but the corresponding P-state representation (following the "
"hardware specification) returned for it matches the maximum supported turbo "
"P-state (or is the special value 255 meaning essentially \"go as high as you "
"can get\")."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:712
msgid ""
"The list of P-states returned by ``_PSS`` is reflected by the table of "
"available frequencies supplied by ``acpi-cpufreq`` to the ``CPUFreq`` core "
"and scaling governors and the minimum and maximum supported frequencies "
"reported by it come from that list as well.  In particular, given the "
"special representation of the turbo range described above, this means that "
"the maximum supported frequency reported by ``acpi-cpufreq`` is higher by 1 "
"MHz than the frequency of the highest supported non-turbo P-state listed by "
"``_PSS`` which, of course, affects decisions made by the scaling governors, "
"except for ``powersave`` and ``performance``."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:722
msgid ""
"For example, if a given governor attempts to select a frequency proportional "
"to estimated CPU load and maps the load of 100% to the maximum supported "
"frequency (possibly multiplied by a constant), then it will tend to choose P-"
"states below the turbo threshold if ``acpi-cpufreq`` is used as the scaling "
"driver, because in that case the turbo range corresponds to a small fraction "
"of the frequency band it can use (1 MHz vs 1 GHz or more).  In consequence, "
"it will only go to the turbo range for the highest loads and the other loads "
"above 50% that might benefit from running at turbo frequencies will be given "
"non-turbo P-states instead."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:732
msgid ""
"One more issue related to that may appear on systems supporting the "
"`Configurable TDP feature <turbo_>`_ allowing the platform firmware to set "
"the turbo threshold.  Namely, if that is not coordinated with the lists of P-"
"states returned by ``_PSS`` properly, there may be more than one item "
"corresponding to a turbo P-state in those lists and there may be a problem "
"with avoiding the turbo range (if desirable or necessary).  Usually, to "
"avoid using turbo P-states overall, ``acpi-cpufreq`` simply avoids using the "
"topmost state listed by ``_PSS``, but that is not sufficient when there are "
"other turbo P-states in the list returned by it."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:742
msgid ""
"Apart from the above, ``acpi-cpufreq`` works like ``intel_pstate`` in the "
"`passive mode <Passive Mode_>`_, except that the number of P-states it can "
"set is limited to the ones listed by the ACPI ``_PSS`` objects."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:748
msgid "Kernel Command Line Options for ``intel_pstate``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:750
msgid ""
"Several kernel command line options can be used to pass early-configuration-"
"time parameters to ``intel_pstate`` in order to enforce specific behavior of "
"it.  All of them have to be prepended with the ``intel_pstate=`` prefix."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:754
msgid "``disable``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:755
msgid ""
"Do not register ``intel_pstate`` as the scaling driver even if the processor "
"is supported by it."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:758
msgid "``active``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:759
msgid ""
"Register ``intel_pstate`` in the `active mode <Active Mode_>`_ to start with."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:762
msgid "``passive``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:763
msgid ""
"Register ``intel_pstate`` in the `passive mode <Passive Mode_>`_ to start "
"with."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:766
msgid "``force``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:767
msgid ""
"Register ``intel_pstate`` as the scaling driver instead of ``acpi-cpufreq`` "
"even if the latter is preferred on the given system."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:770
msgid ""
"This may prevent some platform features (such as thermal controls and power "
"capping) that rely on the availability of ACPI P-states information from "
"functioning as expected, so it should be used with caution."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:775
msgid ""
"This option does not work with processors that are not supported by "
"``intel_pstate`` and on platforms where the ``pcc-cpufreq`` scaling driver "
"is used instead of ``acpi-cpufreq``."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:779
msgid "``no_hwp``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:780
msgid ""
"Do not enable the hardware-managed P-states (HWP) feature even if it is "
"supported by the processor."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:783
msgid "``hwp_only``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:784
msgid ""
"Register ``intel_pstate`` as the scaling driver only if the hardware-managed "
"P-states (HWP) feature is supported by the processor."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:787
msgid "``support_acpi_ppc``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:788
msgid "Take ACPI ``_PPC`` performance limits into account."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:790
msgid ""
"If the preferred power management profile in the FADT (Fixed ACPI "
"Description Table) is set to \"Enterprise Server\" or \"Performance "
"Server\", the ACPI ``_PPC`` limits are taken into account by default and "
"this option has no effect."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:795
msgid "``per_cpu_perf_limits``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:796
msgid ""
"Use per-logical-CPU P-State limits (see `Coordination of P-state Limits`_ "
"for details)."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:799
msgid "``no_cas``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:800
msgid ""
"Do not enable `capacity-aware scheduling <CAS_>`_ which is enabled by "
"default on hybrid systems without SMT."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:804
msgid "Diagnostics and Tuning"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:807
msgid "Trace Events"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:809
msgid ""
"There are two static trace events that can be used for ``intel_pstate`` "
"diagnostics.  One of them is the ``cpu_frequency`` trace event generally "
"used by ``CPUFreq``, and the other one is the ``pstate_sample`` trace event "
"specific to ``intel_pstate``.  Both of them are triggered by "
"``intel_pstate`` only if it works in the `active mode <Active Mode_>`_."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:815
msgid ""
"The following sequence of shell commands can be used to enable them and see "
"their output (if the kernel is generally configured to support event "
"tracing)::"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:825
msgid ""
"If ``intel_pstate`` works in the `passive mode <Passive Mode_>`_, the "
"``cpu_frequency`` trace event will be triggered either by the ``schedutil`` "
"scaling governor (for the policies it is attached to), or by the ``CPUFreq`` "
"core (for the policies with other scaling governors)."
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:831
msgid "``ftrace``"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:833
msgid ""
"The ``ftrace`` interface can be used for low-level diagnostics of "
"``intel_pstate``.  For example, to check how often the function to set a P-"
"state is called, the ``ftrace`` filter can be set to :c:func:"
"`intel_pstate_set_pstate`::"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:864
msgid "References"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:866
msgid ""
"Kristen Accardi, *Balancing Power and Performance in the Linux Kernel*, "
"https://events.static.linuxfound.org/sites/events/files/slides/"
"LinuxConEurope_2015.pdf"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:869
msgid ""
"*IntelÂ® 64 and IA-32 Architectures Software Developerâ€™s Manual Volume 3: "
"System Programming Guide*, https://www.intel.com/content/www/us/en/"
"architecture-and-technology/64-ia-32-architectures-software-developer-system-"
"programming-manual-325384.html"
msgstr ""

#: ../../../admin-guide/pm/intel_pstate.rst:872
msgid ""
"*Advanced Configuration and Power Interface Specification*, https://uefi.org/"
"sites/default/files/resources/ACPI_6_3_final_Jan30.pdf"
msgstr ""
