# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../admin-guide/mm/memory-hotplug.rst:3
msgid "Memory Hot(Un)Plug"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:5
msgid ""
"This document describes generic Linux support for memory hot(un)plug with a "
"focus on System RAM, including ZONE_MOVABLE support."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:11
msgid "Introduction"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:13
msgid ""
"Memory hot(un)plug allows for increasing and decreasing the size of physical "
"memory available to a machine at runtime. In the simplest case, it consists "
"of physically plugging or unplugging a DIMM at runtime, coordinated with the "
"operating system."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:18
msgid "Memory hot(un)plug is used for various purposes:"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:20
msgid ""
"The physical memory available to a machine can be adjusted at runtime, up- "
"or downgrading the memory capacity. This dynamic memory resizing, sometimes "
"referred to as \"capacity on demand\", is frequently used with virtual "
"machines and logical partitions."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:25
msgid ""
"Replacing hardware, such as DIMMs or whole NUMA nodes, without downtime. One "
"example is replacing failing memory modules."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:28
msgid ""
"Reducing energy consumption either by physically unplugging memory modules "
"or by logically unplugging (parts of) memory modules from Linux."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:31
msgid ""
"Further, the basic memory hot(un)plug infrastructure in Linux is nowadays "
"also used to expose persistent memory, other performance-differentiated "
"memory and reserved memory regions as ordinary system RAM to Linux."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:35
msgid ""
"Linux only supports memory hot(un)plug on selected 64 bit architectures, "
"such as x86_64, arm64, ppc64 and s390x."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:39
msgid "Memory Hot(Un)Plug Granularity"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:41
msgid ""
"Memory hot(un)plug in Linux uses the SPARSEMEM memory model, which divides "
"the physical memory address space into chunks of the same size: memory "
"sections. The size of a memory section is architecture dependent. For "
"example, x86_64 uses 128 MiB and ppc64 uses 16 MiB."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:46
msgid ""
"Memory sections are combined into chunks referred to as \"memory blocks\". "
"The size of a memory block is architecture dependent and corresponds to the "
"smallest granularity that can be hot(un)plugged. The default size of a "
"memory block is the same as memory section size, unless an architecture "
"specifies otherwise."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:51
msgid "All memory blocks have the same size."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:54
msgid "Phases of Memory Hotplug"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:56
msgid "Memory hotplug consists of two phases:"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:58
msgid "Adding the memory to Linux"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:59
msgid "Onlining memory blocks"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:61
msgid ""
"In the first phase, metadata, such as the memory map (\"memmap\") and page "
"tables for the direct mapping, is allocated and initialized, and memory "
"blocks are created; the latter also creates sysfs files for managing newly "
"created memory blocks."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:66
msgid ""
"In the second phase, added memory is exposed to the page allocator. After "
"this phase, the memory is visible in memory statistics, such as free and "
"total memory, of the system."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:71
msgid "Phases of Memory Hotunplug"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:73
msgid "Memory hotunplug consists of two phases:"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:75
msgid "Offlining memory blocks"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:76
msgid "Removing the memory from Linux"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:78
msgid ""
"In the first phase, memory is \"hidden\" from the page allocator again, for "
"example, by migrating busy memory to other memory locations and removing all "
"relevant free pages from the page allocator After this phase, the memory is "
"no longer visible in memory statistics of the system."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:83
msgid ""
"In the second phase, the memory blocks are removed and metadata is freed."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:86
msgid "Memory Hotplug Notifications"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:88
msgid ""
"There are various ways how Linux is notified about memory hotplug events "
"such that it can start adding hotplugged memory. This description is limited "
"to systems that support ACPI; mechanisms specific to other firmware "
"interfaces or virtual machines are not described."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:94
msgid "ACPI Notifications"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:96
msgid ""
"Platforms that support ACPI, such as x86_64, can support memory hotplug "
"notifications via ACPI."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:99
msgid ""
"In general, a firmware supporting memory hotplug defines a memory class "
"object HID \"PNP0C80\". When notified about hotplug of a new memory device, "
"the ACPI driver will hotplug the memory to Linux."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:103
msgid ""
"If the firmware supports hotplug of NUMA nodes, it defines an object _HID "
"\"ACPI0004\", \"PNP0A05\", or \"PNP0A06\". When notified about an hotplug "
"event, all assigned memory devices are added to Linux by the ACPI driver."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:107
msgid ""
"Similarly, Linux can be notified about requests to hotunplug a memory device "
"or a NUMA node via ACPI. The ACPI driver will try offlining all relevant "
"memory blocks, and, if successful, hotunplug the memory from Linux."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:112
msgid "Manual Probing"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:114
msgid ""
"On some architectures, the firmware may not be able to notify the operating "
"system about a memory hotplug event. Instead, the memory has to be manually "
"probed from user space."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:118
msgid "The probe interface is located at::"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:122
msgid ""
"Only complete memory blocks can be probed. Individual memory blocks are "
"probed by providing the physical start address of the memory block::"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:127
msgid ""
"Which results in a memory block for the range [addr, addr + "
"memory_block_size) being created."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:132
msgid ""
"Using the probe interface is discouraged as it is easy to crash the kernel, "
"because Linux cannot validate user input; this interface might be removed in "
"the future."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:137
msgid "Onlining and Offlining Memory Blocks"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:139
msgid ""
"After a memory block has been created, Linux has to be instructed to "
"actually make use of that memory: the memory block has to be \"online\"."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:142
msgid ""
"Before a memory block can be removed, Linux has to stop using any memory "
"part of the memory block: the memory block has to be \"offlined\"."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:145
msgid ""
"The Linux kernel can be configured to automatically online added memory "
"blocks and drivers automatically trigger offlining of memory blocks when "
"trying hotunplug of memory. Memory blocks can only be removed once offlining "
"succeeded and drivers may trigger offlining of memory blocks when attempting "
"hotunplug of memory."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:152
msgid "Onlining Memory Blocks Manually"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:154
msgid ""
"If auto-onlining of memory blocks isn't enabled, user-space has to manually "
"trigger onlining of memory blocks. Often, udev rules are used to automate "
"this task in user space."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:158
msgid "Onlining of a memory block can be triggered via::"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:162
#: ../../../admin-guide/mm/memory-hotplug.rst:233
msgid "Or alternatively::"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:166
msgid ""
"The kernel will select the target zone automatically, depending on the "
"configured ``online_policy``."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:169
msgid ""
"One can explicitly request to associate an offline memory block with "
"ZONE_MOVABLE by::"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:174
msgid "Or one can explicitly request a kernel zone (usually ZONE_NORMAL) by::"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:178
msgid ""
"In any case, if onlining succeeds, the state of the memory block is changed "
"to be \"online\". If it fails, the state of the memory block will remain "
"unchanged and the above commands will fail."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:183
msgid "Onlining Memory Blocks Automatically"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:185
msgid ""
"The kernel can be configured to try auto-onlining of newly added memory "
"blocks. If this feature is disabled, the memory blocks will stay offline "
"until explicitly onlined from user space."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:189
msgid "The configured auto-online behavior can be observed via::"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:193
msgid ""
"Auto-onlining can be enabled by writing ``online``, ``online_kernel`` or "
"``online_movable`` to that file, like::"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:198
msgid ""
"Similarly to manual onlining, with ``online`` the kernel will select the "
"target zone automatically, depending on the configured ``online_policy``."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:201
msgid ""
"Modifying the auto-online behavior will only affect all subsequently added "
"memory blocks only."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:206
msgid ""
"In corner cases, auto-onlining can fail. The kernel won't retry. Note that "
"auto-onlining is not expected to fail in default configurations."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:211
msgid ""
"DLPAR on ppc64 ignores the ``offline`` setting and will still online added "
"memory blocks; if onlining fails, memory blocks are removed again."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:215
msgid "Offlining Memory Blocks"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:217
msgid ""
"In the current implementation, Linux's memory offlining will try migrating "
"all movable pages off the affected memory block. As most kernel allocations, "
"such as page tables, are unmovable, page migration can fail and, therefore, "
"inhibit memory offlining from succeeding."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:222
msgid ""
"Having the memory provided by memory block managed by ZONE_MOVABLE "
"significantly increases memory offlining reliability; still, memory "
"offlining can fail in some corner cases."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:226
msgid ""
"Further, memory offlining might retry for a long time (or even forever), "
"until aborted by the user."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:229
msgid "Offlining of a memory block can be triggered via::"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:237
msgid ""
"If offlining succeeds, the state of the memory block is changed to be "
"\"offline\". If it fails, the state of the memory block will remain "
"unchanged and the above commands will fail, for example, via::"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:243
msgid "or via::"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:248
msgid "Observing the State of Memory Blocks"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:250
msgid ""
"The state (online/offline/going-offline) of a memory block can be observed "
"either via::"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:255
msgid "Or alternatively (1/0) via::"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:259
msgid "For an online memory block, the managing zone can be observed via::"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:264
msgid "Configuring Memory Hot(Un)Plug"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:266
msgid ""
"There are various ways how system administrators can configure memory "
"hot(un)plug and interact with memory blocks, especially, to online them."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:270
msgid "Memory Hot(Un)Plug Configuration via Sysfs"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:272
msgid ""
"Some memory hot(un)plug properties can be configured or inspected via sysfs "
"in::"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:276
#: ../../../admin-guide/mm/memory-hotplug.rst:336
msgid "The following files are currently defined:"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:279
msgid "``auto_online_blocks``"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:279
msgid ""
"read-write: set or get the default state of new memory blocks; configure "
"auto-onlining."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:282
msgid ""
"The default value depends on the CONFIG_MHP_DEFAULT_ONLINE_TYPE kernel "
"configuration options."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:286
msgid "See the ``state`` property of memory blocks for details."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:287
msgid "``block_size_bytes``"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:287
msgid "read-only: the size in bytes of a memory block."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:288
msgid "``probe``"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:288
msgid ""
"write-only: add (probe) selected memory blocks manually from user space by "
"supplying the physical start address."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:291
msgid ""
"Availability depends on the CONFIG_ARCH_MEMORY_PROBE kernel configuration "
"option."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:293
#: ../../../admin-guide/mm/memory-hotplug.rst:362
msgid "``uevent``"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:293
msgid "read-write: generic udev file for device subsystems."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:294
msgid "``crash_hotplug``"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:294
msgid ""
"read-only: when changes to the system memory map occur due to hot un/plug of "
"memory, this file contains '1' if the kernel updates the kdump capture "
"kernel memory map itself (via elfcorehdr and other relevant kexec segments), "
"or '0' if userspace must update the kdump capture kernel memory map."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:301
msgid ""
"Availability depends on the CONFIG_MEMORY_HOTPLUG kernel configuration "
"option."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:307
msgid ""
"When the CONFIG_MEMORY_FAILURE kernel configuration option is enabled, two "
"additional files ``hard_offline_page`` and ``soft_offline_page`` are "
"available to trigger hwpoisoning of pages, for example, for testing "
"purposes. Note that this functionality is not really related to memory "
"hot(un)plug or actual offlining of memory blocks."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:314
msgid "Memory Block Configuration via Sysfs"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:316
msgid ""
"Each memory block is represented as a memory block device that can be "
"onlined or offlined. All memory blocks have their device information located "
"in sysfs. Each present memory block is listed under ``/sys/devices/system/"
"memory`` as::"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:323
msgid "where XXX is the memory block id; the number of digits is variable."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:325
msgid ""
"A present memory block indicates that some memory in the range is present; "
"however, a memory block might span memory holes. A memory block spanning "
"memory holes cannot be offlined."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:329
msgid ""
"For example, assume 1 GiB memory block size. A device for a memory starting "
"at 0x100000000 is ``/sys/devices/system/memory/memory4``::"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:334
msgid "This device covers address range [0x100000000 ... 0x140000000)"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:339
msgid "``online``"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:339
msgid ""
"read-write: simplified interface to trigger onlining / offlining and to "
"observe the state of a memory block. When onlining, the zone is selected "
"automatically."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:342
msgid "``phys_device``"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:342
msgid ""
"read-only: legacy interface only ever used on s390x to expose the covered "
"storage increment."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:344
msgid "``phys_index``"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:344
msgid "read-only: the memory block id (XXX)."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:345
msgid "``removable``"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:345
msgid ""
"read-only: legacy interface that indicated whether a memory block was likely "
"to be offlineable or not. Nowadays, the kernel return ``1`` if and only if "
"it supports memory offlining."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:349
msgid "``state``"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:349
msgid ""
"read-write: advanced interface to trigger onlining / offlining and to "
"observe the state of a memory block."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:352
msgid ""
"When writing, ``online``, ``offline``, ``online_kernel`` and "
"``online_movable`` are supported."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:355
msgid ""
"``online_movable`` specifies onlining to ZONE_MOVABLE. ``online_kernel`` "
"specifies onlining to the default kernel zone for the memory block, such as "
"ZONE_NORMAL. ``online`` let's the kernel select the zone automatically."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:360
msgid ""
"When reading, ``online``, ``offline`` and ``going-offline`` may be returned."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:362
msgid "read-write: generic uevent file for devices."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:363
msgid "``valid_zones``"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:363
msgid ""
"read-only: when a block is online, shows the zone it belongs to; when a "
"block is offline, shows what zone will manage it when the block will be "
"onlined."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:367
msgid ""
"For online memory blocks, ``DMA``, ``DMA32``, ``Normal``, ``Movable`` and "
"``none`` may be returned. ``none`` indicates that memory provided by a "
"memory block is managed by multiple zones or spans multiple nodes; such "
"memory blocks cannot be offlined. ``Movable`` indicates ZONE_MOVABLE. Other "
"values indicate a kernel zone."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:374
msgid ""
"For offline memory blocks, the first column shows the zone the kernel would "
"select when onlining the memory block right now without further specifying a "
"zone."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:378
msgid ""
"Availability depends on the CONFIG_MEMORY_HOTREMOVE kernel configuration "
"option."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:384
msgid ""
"If the CONFIG_NUMA kernel configuration option is enabled, the memoryXXX/ "
"directories can also be accessed via symbolic links located in the ``/sys/"
"devices/system/node/node*`` directories."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:388
msgid "For example::"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:392
msgid "A backlink will also be created::"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:397
msgid "Command Line Parameters"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:399
msgid ""
"Some command line parameters affect memory hot(un)plug handling. The "
"following command line parameters are relevant:"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:403
msgid "``memhp_default_state``"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:403
msgid ""
"configure auto-onlining by essentially setting ``/sys/devices/system/memory/"
"auto_online_blocks``."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:405
msgid "``movable_node``"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:405
msgid ""
"configure automatic zone selection in the kernel when using the ``contig-"
"zones`` online policy. When set, the kernel will default to ZONE_MOVABLE "
"when onlining a memory block, unless other zones can be kept contiguous."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:412
msgid ""
"See Documentation/admin-guide/kernel-parameters.txt for a more generic "
"description of these command line parameters."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:416
msgid "Module Parameters"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:418
msgid ""
"Instead of additional command line parameters or sysfs files, the "
"``memory_hotplug`` subsystem now provides a dedicated namespace for module "
"parameters. Module parameters can be set via the command line by predicating "
"them with ``memory_hotplug.`` such as::"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:425
msgid "and they can be observed (and some even modified at runtime) via::"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:429
msgid "The following module parameters are currently defined:"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:432
msgid "``memmap_on_memory``"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:432
msgid ""
"read-write: Allocate memory for the memmap from the added memory block "
"itself. Even if enabled, actual support depends on various other system "
"properties and should only be regarded as a hint whether the behavior would "
"be desired."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:438
msgid ""
"While allocating the memmap from the memory block itself makes memory "
"hotplug less likely to fail and keeps the memmap on the same NUMA node in "
"any case, it can fragment physical memory in a way that huge pages in bigger "
"granularity cannot be formed on hotplugged memory."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:446
msgid ""
"With value \"force\" it could result in memory wastage due to memmap size "
"limitations. For example, if the memmap for a memory block requires 1 MiB, "
"but the pageblock size is 2 MiB, 1 MiB of hotplugged memory will be wasted. "
"Note that there are still cases where the feature cannot be enforced: for "
"example, if the memmap is smaller than a single page, or if the architecture "
"does not support the forced mode in all configurations."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:457
msgid "``online_policy``"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:457
msgid ""
"read-write: Set the basic policy used for automatic zone selection when "
"onlining memory blocks without specifying a target zone. ``contig-zones`` "
"has been the kernel default before this parameter was added. After an online "
"policy was configured and memory was online, the policy should not be "
"changed anymore."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:466
msgid ""
"When set to ``contig-zones``, the kernel will try keeping zones contiguous. "
"If a memory block intersects multiple zones or no zone, the behavior depends "
"on the ``movable_node`` kernel command line parameter: default to "
"ZONE_MOVABLE if set, default to the applicable kernel zone (usually "
"ZONE_NORMAL) if not set."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:474
msgid ""
"When set to ``auto-movable``, the kernel will try onlining memory blocks to "
"ZONE_MOVABLE if possible according to the configuration and memory device "
"details. With this policy, one can avoid zone imbalances when eventually "
"hotplugging a lot of memory later and still wanting to be able to hotunplug "
"as much as possible reliably, very desirable in virtualized environments. "
"This policy ignores the ``movable_node`` kernel command line parameter and "
"isn't really applicable in environments that require it (e.g., bare metal "
"with hotunpluggable nodes) where hotplugged memory might be exposed via the "
"firmware-provided memory map early during boot to the system instead of "
"getting detected, added and onlined  later during boot (such as done by "
"virtio-mem or by some hypervisors implementing emulated DIMMs). As one "
"example, a hotplugged DIMM will be onlined either completely to ZONE_MOVABLE "
"or completely to ZONE_NORMAL, not a mixture. As another example, as many "
"memory blocks belonging to a virtio-mem device will be onlined to "
"ZONE_MOVABLE as possible, special-casing units of memory blocks that can "
"only get hotunplugged together. *This policy does not protect from setups "
"that are problematic with ZONE_MOVABLE and does not change the zone of "
"memory blocks dynamically after they were onlined.*"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:505
msgid "``auto_movable_ratio``"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:505
msgid ""
"read-write: Set the maximum MOVABLE:KERNEL memory ratio in % for the ``auto-"
"movable`` online policy. Whether the ratio applies only for the system "
"across all NUMA nodes or also per NUMA nodes depends on the "
"``auto_movable_numa_aware`` configuration."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:512
msgid ""
"All accounting is based on present memory pages in the zones combined with "
"accounting per memory device. Memory dedicated to the CMA allocator is "
"accounted as MOVABLE, although residing on one of the kernel zones. The "
"possible ratio depends on the actual workload. The kernel default is \"301\" "
"%, for example, allowing for hotplugging 24 GiB to a 8 GiB VM and "
"automatically onlining all hotplugged memory to ZONE_MOVABLE in many setups. "
"The additional 1% deals with some pages being not present, for example, "
"because of some firmware allocations."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:526
msgid ""
"Note that ZONE_NORMAL memory provided by one memory device does not allow "
"for more ZONE_MOVABLE memory for a different memory device. As one example, "
"onlining memory of a hotplugged DIMM to ZONE_NORMAL will not allow for "
"another hotplugged DIMM to get onlined to ZONE_MOVABLE automatically. In "
"contrast, memory hotplugged by a virtio-mem device that got onlined to "
"ZONE_NORMAL will allow for more ZONE_MOVABLE memory within *the same* virtio-"
"mem device."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:537
msgid "``auto_movable_numa_aware``"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:537
msgid ""
"read-write: Configure whether the ``auto_movable_ratio`` in the ``auto-"
"movable`` online policy also applies per NUMA node in addition to the whole "
"system across all NUMA nodes. The kernel default is \"Y\"."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:543
msgid ""
"Disabling NUMA awareness can be helpful when dealing with NUMA nodes that "
"should be completely hotunpluggable, onlining the memory completely to "
"ZONE_MOVABLE automatically if possible."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:549
msgid "Parameter availability depends on CONFIG_NUMA."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:553
msgid "ZONE_MOVABLE"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:555
msgid ""
"ZONE_MOVABLE is an important mechanism for more reliable memory offlining. "
"Further, having system RAM managed by ZONE_MOVABLE instead of one of the "
"kernel zones can increase the number of possible transparent huge pages and "
"dynamically allocated huge pages."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:560
msgid ""
"Most kernel allocations are unmovable. Important examples include the memory "
"map (usually 1/64ths of memory), page tables, and kmalloc(). Such "
"allocations can only be served from the kernel zones."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:564
msgid ""
"Most user space pages, such as anonymous memory, and page cache pages are "
"movable. Such allocations can be served from ZONE_MOVABLE and the kernel "
"zones."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:567
msgid ""
"Only movable allocations are served from ZONE_MOVABLE, resulting in "
"unmovable allocations being limited to the kernel zones. Without "
"ZONE_MOVABLE, there is absolutely no guarantee whether a memory block can be "
"offlined successfully."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:572
msgid "Zone Imbalances"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:574
msgid ""
"Having too much system RAM managed by ZONE_MOVABLE is called a zone "
"imbalance, which can harm the system or degrade performance. As one example, "
"the kernel might crash because it runs out of free memory for unmovable "
"allocations, although there is still plenty of free memory left in "
"ZONE_MOVABLE."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:579
msgid ""
"Usually, MOVABLE:KERNEL ratios of up to 3:1 or even 4:1 are fine. Ratios of "
"63:1 are definitely impossible due to the overhead for the memory map."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:582
msgid ""
"Actual safe zone ratios depend on the workload. Extreme cases, like "
"excessive long-term pinning of pages, might not be able to deal with "
"ZONE_MOVABLE at all."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:587
msgid ""
"CMA memory part of a kernel zone essentially behaves like memory in "
"ZONE_MOVABLE and similar considerations apply, especially when combining CMA "
"with ZONE_MOVABLE."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:592
msgid "ZONE_MOVABLE Sizing Considerations"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:594
msgid ""
"We usually expect that a large portion of available system RAM will actually "
"be consumed by user space, either directly or indirectly via the page cache. "
"In the normal case, ZONE_MOVABLE can be used when allocating such pages just "
"fine."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:598
msgid ""
"With that in mind, it makes sense that we can have a big portion of system "
"RAM managed by ZONE_MOVABLE. However, there are some things to consider when "
"using ZONE_MOVABLE, especially when fine-tuning zone ratios:"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:602
msgid ""
"Having a lot of offline memory blocks. Even offline memory blocks consume "
"memory for metadata and page tables in the direct map; having a lot of "
"offline memory blocks is not a typical case, though."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:606
msgid ""
"Memory ballooning without balloon compaction is incompatible with "
"ZONE_MOVABLE. Only some implementations, such as virtio-balloon and pseries "
"CMM, fully support balloon compaction."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:610
msgid ""
"Further, the CONFIG_BALLOON_COMPACTION kernel configuration option might be "
"disabled. In that case, balloon inflation will only perform unmovable "
"allocations and silently create a zone imbalance, usually triggered by "
"inflation requests from the hypervisor."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:615
msgid ""
"Gigantic pages are unmovable, resulting in user space consuming a lot of "
"unmovable memory."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:618
msgid ""
"Huge pages are unmovable when an architectures does not support huge page "
"migration, resulting in a similar issue as with gigantic pages."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:621
msgid ""
"Page tables are unmovable. Excessive swapping, mapping extremely large files "
"or ZONE_DEVICE memory can be problematic, although only really relevant in "
"corner cases. When we manage a lot of user space memory that has been "
"swapped out or is served from a file/persistent memory/... we still need a "
"lot of page tables to manage that memory once user space accessed that "
"memory."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:627
msgid ""
"In certain DAX configurations the memory map for the device memory will be "
"allocated from the kernel zones."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:630
msgid ""
"KASAN can have a significant memory overhead, for example, consuming 1/8th "
"of the total system memory size as (unmovable) tracking metadata."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:633
msgid ""
"Long-term pinning of pages. Techniques that rely on long-term pinnings "
"(especially, RDMA and vfio/mdev) are fundamentally problematic with "
"ZONE_MOVABLE, and therefore, memory offlining. Pinned pages cannot reside on "
"ZONE_MOVABLE as that would turn these pages unmovable. Therefore, they have "
"to be migrated off that zone while pinning. Pinning a page can fail even if "
"there is plenty of free memory in ZONE_MOVABLE."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:640
msgid ""
"In addition, using ZONE_MOVABLE might make page pinning more expensive, "
"because of the page migration overhead."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:643
msgid ""
"By default, all the memory configured at boot time is managed by the kernel "
"zones and ZONE_MOVABLE is not used."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:646
msgid ""
"To enable ZONE_MOVABLE to include the memory present at boot and to control "
"the ratio between movable and kernel zones there are two command line "
"options: ``kernelcore=`` and ``movablecore=``. See Documentation/admin-guide/"
"kernel-parameters.rst for their description."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:652
msgid "Memory Offlining and ZONE_MOVABLE"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:654
msgid ""
"Even with ZONE_MOVABLE, there are some corner cases where offlining a memory "
"block might fail:"
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:657
msgid ""
"Memory blocks with memory holes; this applies to memory blocks present "
"during boot and can apply to memory blocks hotplugged via the XEN balloon "
"and the Hyper-V balloon."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:661
msgid ""
"Mixed NUMA nodes and mixed zones within a single memory block prevent memory "
"offlining; this applies to memory blocks present during boot only."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:664
msgid ""
"Special memory blocks prevented by the system from getting offlined. "
"Examples include any memory available during boot on arm64 or memory blocks "
"spanning the crashkernel area on s390x; this usually applies to memory "
"blocks present during boot only."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:669
msgid ""
"Memory blocks overlapping with CMA areas cannot be offlined, this applies to "
"memory blocks present during boot only."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:672
msgid ""
"Concurrent activity that operates on the same physical memory area, such as "
"allocating gigantic pages, can result in temporary offlining failures."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:675
msgid ""
"Out of memory when dissolving huge pages, especially when HugeTLB Vmemmap "
"Optimization (HVO) is enabled."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:678
msgid ""
"Offlining code may be able to migrate huge page contents, but may not be "
"able to dissolve the source huge page because it fails allocating "
"(unmovable) pages for the vmemmap, because the system might not have free "
"memory in the kernel zones left."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:683
msgid ""
"Users that depend on memory offlining to succeed for movable zones should "
"carefully consider whether the memory savings gained from this feature are "
"worth the risk of possibly not being able to offline memory in certain "
"situations."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:688
msgid ""
"Further, when running into out of memory situations while migrating pages, "
"or when still encountering permanently unmovable pages within ZONE_MOVABLE (-"
"> BUG), memory offlining will keep retrying until it eventually succeeds."
msgstr ""

#: ../../../admin-guide/mm/memory-hotplug.rst:692
msgid ""
"When offlining is triggered from user space, the offlining context can be "
"terminated by sending a signal. A timeout based offlining can easily be "
"implemented via::"
msgstr ""
