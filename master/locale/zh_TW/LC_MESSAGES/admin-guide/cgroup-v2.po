# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-27 13:53+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../admin-guide/cgroup-v2.rst:5
msgid "Control Group v2"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:0
msgid "Date"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:7
msgid "October, 2015"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:0
msgid "Author"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:8
msgid "Tejun Heo <tj@kernel.org>"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:10
msgid ""
"This is the authoritative documentation on the design, interface and "
"conventions of cgroup v2.  It describes all userland-visible aspects of "
"cgroup including core and specific controller behaviors.  All future changes "
"must be reflected in this document.  Documentation for v1 is available "
"under :ref:`Documentation/admin-guide/cgroup-v1/index.rst <cgroup-v1>`."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:96
msgid "Introduction"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:99
msgid "Terminology"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:101
msgid ""
"\"cgroup\" stands for \"control group\" and is never capitalized.  The "
"singular form is used to designate the whole feature and also as a qualifier "
"as in \"cgroup controllers\".  When explicitly referring to multiple "
"individual control groups, the plural form \"cgroups\" is used."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:108
msgid "What is cgroup?"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:110
msgid ""
"cgroup is a mechanism to organize processes hierarchically and distribute "
"system resources along the hierarchy in a controlled and configurable manner."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:114
msgid ""
"cgroup is largely composed of two parts - the core and controllers. cgroup "
"core is primarily responsible for hierarchically organizing processes.  A "
"cgroup controller is usually responsible for distributing a specific type of "
"system resource along the hierarchy although there are utility controllers "
"which serve purposes other than resource distribution."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:121
msgid ""
"cgroups form a tree structure and every process in the system belongs to one "
"and only one cgroup.  All threads of a process belong to the same cgroup.  "
"On creation, all processes are put in the cgroup that the parent process "
"belongs to at the time.  A process can be migrated to another cgroup.  "
"Migration of a process doesn't affect already existing descendant processes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:128
msgid ""
"Following certain structural constraints, controllers may be enabled or "
"disabled selectively on a cgroup.  All controller behaviors are hierarchical "
"- if a controller is enabled on a cgroup, it affects all processes which "
"belong to the cgroups consisting the inclusive sub-hierarchy of the cgroup.  "
"When a controller is enabled on a nested cgroup, it always restricts the "
"resource distribution further.  The restrictions set closer to the root in "
"the hierarchy can not be overridden from further away."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:139
msgid "Basic Operations"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:142
msgid "Mounting"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:144
msgid ""
"Unlike v1, cgroup v2 has only single hierarchy.  The cgroup v2 hierarchy can "
"be mounted with the following mount command::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:149
msgid ""
"cgroup2 filesystem has the magic number 0x63677270 (\"cgrp\").  All "
"controllers which support v2 and are not bound to a v1 hierarchy are "
"automatically bound to the v2 hierarchy and show up at the root. Controllers "
"which are not in active use in the v2 hierarchy can be bound to other "
"hierarchies.  This allows mixing v2 hierarchy with the legacy v1 multiple "
"hierarchies in a fully backward compatible way."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:156
msgid ""
"A controller can be moved across hierarchies only after the controller is no "
"longer referenced in its current hierarchy.  Because per-cgroup controller "
"states are destroyed asynchronously and controllers may have lingering "
"references, a controller may not show up immediately on the v2 hierarchy "
"after the final umount of the previous hierarchy. Similarly, a controller "
"should be fully disabled to be moved out of the unified hierarchy and it may "
"take some time for the disabled controller to become available for other "
"hierarchies; furthermore, due to inter-controller dependencies, other "
"controllers may need to be disabled too."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:167
msgid ""
"While useful for development and manual configurations, moving controllers "
"dynamically between the v2 and other hierarchies is strongly discouraged for "
"production use.  It is recommended to decide the hierarchies and controller "
"associations before starting using the controllers after system boot."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:173
msgid ""
"During transition to v2, system management software might still automount "
"the v1 cgroup filesystem and so hijack all controllers during boot, before "
"manual intervention is possible. To make testing and experimenting easier, "
"the kernel parameter cgroup_no_v1= allows disabling controllers in v1 and "
"make them always available in v2."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:179
msgid "cgroup v2 currently supports the following mount options."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:181
msgid "nsdelegate"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:182
msgid ""
"Consider cgroup namespaces as delegation boundaries.  This option is system "
"wide and can only be set on mount or modified through remount from the init "
"namespace.  The mount option is ignored on non-init namespace mounts.  "
"Please refer to the Delegation section for details."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:188
msgid "favordynmods"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:189
msgid ""
"Reduce the latencies of dynamic cgroup modifications such as task migrations "
"and controller on/offs at the cost of making hot path operations such as "
"forks and exits more expensive. The static usage pattern of creating a "
"cgroup, enabling controllers, and then seeding it with CLONE_INTO_CGROUP is "
"not affected by this option."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:196
msgid "memory_localevents"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:197
msgid ""
"Only populate memory.events with data for the current cgroup, and not any "
"subtrees. This is legacy behaviour, the default behaviour without this "
"option is to include subtree counts. This option is system wide and can only "
"be set on mount or modified through remount from the init namespace. The "
"mount option is ignored on non-init namespace mounts."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:204
msgid "memory_recursiveprot"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:205
msgid ""
"Recursively apply memory.min and memory.low protection to entire subtrees, "
"without requiring explicit downward propagation into leaf cgroups.  This "
"allows protecting entire subtrees from one another, while retaining free "
"competition within those subtrees.  This should have been the default "
"behavior but is a mount-option to avoid regressing setups relying on the "
"original semantics (e.g. specifying bogusly high 'bypass' protection values "
"at higher tree levels)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:214
msgid "memory_hugetlb_accounting"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:215
msgid ""
"Count HugeTLB memory usage towards the cgroup's overall memory usage for the "
"memory controller (for the purpose of statistics reporting and memory "
"protetion). This is a new behavior that could regress existing setups, so it "
"must be explicitly opted in with this mount option."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:221
msgid "A few caveats to keep in mind:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:223
msgid ""
"There is no HugeTLB pool management involved in the memory controller. The "
"pre-allocated pool does not belong to anyone. Specifically, when a new "
"HugeTLB folio is allocated to the pool, it is not accounted for from the "
"perspective of the memory controller. It is only charged to a cgroup when it "
"is actually used (for e.g at page fault time). Host memory overcommit "
"management has to consider this when configuring hard limits. In general, "
"HugeTLB pool management should be done via other mechanisms (such as the "
"HugeTLB controller)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:232
msgid ""
"Failure to charge a HugeTLB folio to the memory controller results in "
"SIGBUS. This could happen even if the HugeTLB pool still has pages available "
"(but the cgroup limit is hit and reclaim attempt fails)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:236
msgid ""
"Charging HugeTLB memory towards the memory controller affects memory "
"protection and reclaim dynamics. Any userspace tuning (of low, min limits "
"for e.g) needs to take this into account."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:239
msgid ""
"HugeTLB pages utilized while this option is not selected will not be tracked "
"by the memory controller (even if cgroup v2 is remounted later on)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:243
msgid "pids_localevents"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:244
msgid ""
"The option restores v1-like behavior of pids.events:max, that is only local "
"(inside cgroup proper) fork failures are counted. Without this option pids."
"events.max represents any pids.max enforcemnt across cgroup's subtree."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:252
msgid "Organizing Processes and Threads"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:255
msgid "Processes"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:257
msgid ""
"Initially, only the root cgroup exists to which all processes belong. A "
"child cgroup can be created by creating a sub-directory::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:262
msgid ""
"A given cgroup may have multiple child cgroups forming a tree structure.  "
"Each cgroup has a read-writable interface file \"cgroup.procs\".  When read, "
"it lists the PIDs of all processes which belong to the cgroup one-per-line.  "
"The PIDs are not ordered and the same PID may show up more than once if the "
"process got moved to another cgroup and then back or the PID got recycled "
"while reading."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:269
msgid ""
"A process can be migrated into a cgroup by writing its PID to the target "
"cgroup's \"cgroup.procs\" file.  Only one process can be migrated on a "
"single write(2) call.  If a process is composed of multiple threads, writing "
"the PID of any thread migrates all threads of the process."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:275
msgid ""
"When a process forks a child process, the new process is born into the "
"cgroup that the forking process belongs to at the time of the operation.  "
"After exit, a process stays associated with the cgroup that it belonged to "
"at the time of exit until it's reaped; however, a zombie process does not "
"appear in \"cgroup.procs\" and thus can't be moved to another cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:282
msgid ""
"A cgroup which doesn't have any children or live processes can be destroyed "
"by removing the directory.  Note that a cgroup which doesn't have any "
"children and is associated only with zombie processes is considered empty "
"and can be removed::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:289
msgid ""
"\"/proc/$PID/cgroup\" lists a process's cgroup membership.  If legacy cgroup "
"is in use in the system, this file may contain multiple lines, one for each "
"hierarchy.  The entry for cgroup v2 is always in the format \"0::$PATH\"::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:298
msgid ""
"If the process becomes a zombie and the cgroup it was associated with is "
"removed subsequently, \" (deleted)\" is appended to the path::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:307
msgid "Threads"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:309
msgid ""
"cgroup v2 supports thread granularity for a subset of controllers to support "
"use cases requiring hierarchical resource distribution across the threads of "
"a group of processes.  By default, all threads of a process belong to the "
"same cgroup, which also serves as the resource domain to host resource "
"consumptions which are not specific to a process or thread.  The thread mode "
"allows threads to be spread across a subtree while still maintaining the "
"common resource domain for them."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:317
msgid ""
"Controllers which support thread mode are called threaded controllers. The "
"ones which don't are called domain controllers."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:320
msgid ""
"Marking a cgroup threaded makes it join the resource domain of its parent as "
"a threaded cgroup.  The parent may be another threaded cgroup whose resource "
"domain is further up in the hierarchy.  The root of a threaded subtree, that "
"is, the nearest ancestor which is not threaded, is called threaded domain or "
"thread root interchangeably and serves as the resource domain for the entire "
"subtree."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:327
msgid ""
"Inside a threaded subtree, threads of a process can be put in different "
"cgroups and are not subject to the no internal process constraint - threaded "
"controllers can be enabled on non-leaf cgroups whether they have threads in "
"them or not."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:332
msgid ""
"As the threaded domain cgroup hosts all the domain resource consumptions of "
"the subtree, it is considered to have internal resource consumptions whether "
"there are processes in it or not and can't have populated child cgroups "
"which aren't threaded.  Because the root cgroup is not subject to no "
"internal process constraint, it can serve both as a threaded domain and a "
"parent to domain cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:339
msgid ""
"The current operation mode or type of the cgroup is shown in the \"cgroup."
"type\" file which indicates whether the cgroup is a normal domain, a domain "
"which is serving as the domain of a threaded subtree, or a threaded cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:344
msgid ""
"On creation, a cgroup is always a domain cgroup and can be made threaded by "
"writing \"threaded\" to the \"cgroup.type\" file.  The operation is single "
"direction::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:350
msgid ""
"Once threaded, the cgroup can't be made a domain again.  To enable the "
"thread mode, the following conditions must be met."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:353
msgid ""
"As the cgroup will join the parent's resource domain.  The parent must "
"either be a valid (threaded) domain or a threaded cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:356
msgid ""
"When the parent is an unthreaded domain, it must not have any domain "
"controllers enabled or populated domain children.  The root is exempt from "
"this requirement."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:360
msgid ""
"Topology-wise, a cgroup can be in an invalid state.  Please consider the "
"following topology::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:365
msgid ""
"C is created as a domain but isn't connected to a parent which can host "
"child domains.  C can't be used until it is turned into a threaded cgroup.  "
"\"cgroup.type\" file will report \"domain (invalid)\" in these cases.  "
"Operations which fail due to invalid topology use EOPNOTSUPP as the errno."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:371
msgid ""
"A domain cgroup is turned into a threaded domain when one of its child "
"cgroup becomes threaded or threaded controllers are enabled in the \"cgroup."
"subtree_control\" file while there are processes in the cgroup. A threaded "
"domain reverts to a normal domain when the conditions clear."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:377
msgid ""
"When read, \"cgroup.threads\" contains the list of the thread IDs of all "
"threads in the cgroup.  Except that the operations are per-thread instead of "
"per-process, \"cgroup.threads\" has the same format and behaves the same way "
"as \"cgroup.procs\".  While \"cgroup.threads\" can be written to in any "
"cgroup, as it can only move threads inside the same threaded domain, its "
"operations are confined inside each threaded subtree."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:385
msgid ""
"The threaded domain cgroup serves as the resource domain for the whole "
"subtree, and, while the threads can be scattered across the subtree, all the "
"processes are considered to be in the threaded domain cgroup. \"cgroup."
"procs\" in a threaded domain cgroup contains the PIDs of all processes in "
"the subtree and is not readable in the subtree proper. However, \"cgroup."
"procs\" can be written to from anywhere in the subtree to migrate all "
"threads of the matching process to the cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:393
msgid ""
"Only threaded controllers can be enabled in a threaded subtree.  When a "
"threaded controller is enabled inside a threaded subtree, it only accounts "
"for and controls resource consumptions associated with the threads in the "
"cgroup and its descendants.  All consumptions which aren't tied to a "
"specific thread belong to the threaded domain cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:399
msgid ""
"Because a threaded subtree is exempt from no internal process constraint, a "
"threaded controller must be able to handle competition between threads in a "
"non-leaf cgroup and its child cgroups.  Each threaded controller defines how "
"such competitions are handled."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:404
msgid ""
"Currently, the following controllers are threaded and can be enabled in a "
"threaded cgroup::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:413
msgid "[Un]populated Notification"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:415
msgid ""
"Each non-root cgroup has a \"cgroup.events\" file which contains "
"\"populated\" field indicating whether the cgroup's sub-hierarchy has live "
"processes in it.  Its value is 0 if there is no live process in the cgroup "
"and its descendants; otherwise, 1.  poll and [id]notify events are triggered "
"when the value changes.  This can be used, for example, to start a clean-up "
"operation after all processes of a given sub-hierarchy have exited.  The "
"populated state updates and notifications are recursive.  Consider the "
"following sub-hierarchy where the numbers in the parentheses represent the "
"numbers of processes in each cgroup::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:429
msgid ""
"A, B and C's \"populated\" fields would be 1 while D's 0.  After the one "
"process in C exits, B and C's \"populated\" fields would flip to \"0\" and "
"file modified events will be generated on the \"cgroup.events\" files of "
"both cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:436
msgid "Controlling Controllers"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:439
msgid "Availability"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:441
msgid ""
"A controller is available in a cgroup when it is supported by the kernel (i."
"e., compiled in, not disabled and not attached to a v1 hierarchy) and listed "
"in the \"cgroup.controllers\" file. Availability means the controller's "
"interface files are exposed in the cgroup’s directory, allowing the "
"distribution of the target resource to be observed or controlled within that "
"cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:448
msgid "Enabling and Disabling"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:450
msgid ""
"Each cgroup has a \"cgroup.controllers\" file which lists all controllers "
"available for the cgroup to enable::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:456
msgid ""
"No controller is enabled by default.  Controllers can be enabled and "
"disabled by writing to the \"cgroup.subtree_control\" file::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:461
msgid ""
"Only controllers which are listed in \"cgroup.controllers\" can be enabled.  "
"When multiple operations are specified as above, either they all succeed or "
"fail.  If multiple operations on the same controller are specified, the last "
"one is effective."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:466
msgid ""
"Enabling a controller in a cgroup indicates that the distribution of the "
"target resource across its immediate children will be controlled. Consider "
"the following sub-hierarchy.  The enabled controllers are listed in "
"parentheses::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:474
msgid ""
"As A has \"cpu\" and \"memory\" enabled, A will control the distribution of "
"CPU cycles and memory to its children, in this case, B.  As B has \"memory\" "
"enabled but not \"CPU\", C and D will compete freely on CPU cycles but their "
"division of memory available to B will be controlled."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:479
msgid ""
"As a controller regulates the distribution of the target resource to the "
"cgroup's children, enabling it creates the controller's interface files in "
"the child cgroups.  In the above example, enabling \"cpu\" on B would create "
"the \"cpu.\" prefixed controller interface files in C and D.  Likewise, "
"disabling \"memory\" from B would remove the \"memory.\" prefixed controller "
"interface files from C and D.  This means that the controller interface "
"files - anything which doesn't start with \"cgroup.\" are owned by the "
"parent rather than the cgroup itself."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:490
msgid "Top-down Constraint"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:492
msgid ""
"Resources are distributed top-down and a cgroup can further distribute a "
"resource only if the resource has been distributed to it from the parent.  "
"This means that all non-root \"cgroup.subtree_control\" files can only "
"contain controllers which are enabled in the parent's \"cgroup."
"subtree_control\" file.  A controller can be enabled only if the parent has "
"the controller enabled and a controller can't be disabled if one or more "
"children have it enabled."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:502
msgid "No Internal Process Constraint"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:504
msgid ""
"Non-root cgroups can distribute domain resources to their children only when "
"they don't have any processes of their own.  In other words, only domain "
"cgroups which don't contain any processes can have domain controllers "
"enabled in their \"cgroup.subtree_control\" files."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:509
msgid ""
"This guarantees that, when a domain controller is looking at the part of the "
"hierarchy which has it enabled, processes are always only on the leaves.  "
"This rules out situations where child cgroups compete against internal "
"processes of the parent."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:514
msgid ""
"The root cgroup is exempt from this restriction.  Root contains processes "
"and anonymous resource consumption which can't be associated with any other "
"cgroups and requires special treatment from most controllers.  How resource "
"consumption in the root cgroup is governed is up to each controller (for "
"more information on this topic please refer to the Non-normative information "
"section in the Controllers chapter)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:522
msgid ""
"Note that the restriction doesn't get in the way if there is no enabled "
"controller in the cgroup's \"cgroup.subtree_control\".  This is important as "
"otherwise it wouldn't be possible to create children of a populated cgroup.  "
"To control resource distribution of a cgroup, the cgroup must create "
"children and transfer all its processes to the children before enabling "
"controllers in its \"cgroup.subtree_control\" file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:532
msgid "Delegation"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:535
msgid "Model of Delegation"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:537
msgid ""
"A cgroup can be delegated in two ways.  First, to a less privileged user by "
"granting write access of the directory and its \"cgroup.procs\", \"cgroup."
"threads\" and \"cgroup.subtree_control\" files to the user. Second, if the "
"\"nsdelegate\" mount option is set, automatically to a cgroup namespace on "
"namespace creation."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:543
msgid ""
"Because the resource control interface files in a given directory control "
"the distribution of the parent's resources, the delegatee shouldn't be "
"allowed to write to them.  For the first method, this is achieved by not "
"granting access to these files.  For the second, files outside the namespace "
"should be hidden from the delegatee by the means of at least mount "
"namespacing, and the kernel rejects writes to all files on a namespace root "
"from inside the cgroup namespace, except for those files listed in \"/sys/"
"kernel/cgroup/delegate\" (including \"cgroup.procs\", \"cgroup.threads\", "
"\"cgroup.subtree_control\", etc.)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:553
msgid ""
"The end results are equivalent for both delegation types.  Once delegated, "
"the user can build sub-hierarchy under the directory, organize processes "
"inside it as it sees fit and further distribute the resources it received "
"from the parent.  The limits and other settings of all resource controllers "
"are hierarchical and regardless of what happens in the delegated sub-"
"hierarchy, nothing can escape the resource restrictions imposed by the "
"parent."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:561
msgid ""
"Currently, cgroup doesn't impose any restrictions on the number of cgroups "
"in or nesting depth of a delegated sub-hierarchy; however, this may be "
"limited explicitly in the future."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:567
msgid "Delegation Containment"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:569
msgid ""
"A delegated sub-hierarchy is contained in the sense that processes can't be "
"moved into or out of the sub-hierarchy by the delegatee."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:572
msgid ""
"For delegations to a less privileged user, this is achieved by requiring the "
"following conditions for a process with a non-root euid to migrate a target "
"process into a cgroup by writing its PID to the \"cgroup.procs\" file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:577
msgid "The writer must have write access to the \"cgroup.procs\" file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:579
msgid ""
"The writer must have write access to the \"cgroup.procs\" file of the common "
"ancestor of the source and destination cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:582
msgid ""
"The above two constraints ensure that while a delegatee may migrate "
"processes around freely in the delegated sub-hierarchy it can't pull in from "
"or push out to outside the sub-hierarchy."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:586
msgid ""
"For an example, let's assume cgroups C0 and C1 have been delegated to user "
"U0 who created C00, C01 under C0 and C10 under C1 as follows and all "
"processes under C0 and C1 belong to U0::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:595
msgid ""
"Let's also say U0 wants to write the PID of a process which is currently in "
"C10 into \"C00/cgroup.procs\".  U0 has write access to the file; however, "
"the common ancestor of the source cgroup C10 and the destination cgroup C00 "
"is above the points of delegation and U0 would not have write access to its "
"\"cgroup.procs\" files and thus the write will be denied with -EACCES."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:602
msgid ""
"For delegations to namespaces, containment is achieved by requiring that "
"both the source and destination cgroups are reachable from the namespace of "
"the process which is attempting the migration.  If either is not reachable, "
"the migration is rejected with -ENOENT."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:609
msgid "Guidelines"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:612
msgid "Organize Once and Control"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:614
msgid ""
"Migrating a process across cgroups is a relatively expensive operation and "
"stateful resources such as memory are not moved together with the process.  "
"This is an explicit design decision as there often exist inherent trade-offs "
"between migration and various hot paths in terms of synchronization cost."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:620
msgid ""
"As such, migrating processes across cgroups frequently as a means to apply "
"different resource restrictions is discouraged.  A workload should be "
"assigned to a cgroup according to the system's logical and resource "
"structure once on start-up.  Dynamic adjustments to resource distribution "
"can be made by changing controller configuration through the interface files."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:629
msgid "Avoid Name Collisions"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:631
msgid ""
"Interface files for a cgroup and its children cgroups occupy the same "
"directory and it is possible to create children cgroups which collide with "
"interface files."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:635
msgid ""
"All cgroup core interface files are prefixed with \"cgroup.\" and each "
"controller's interface files are prefixed with the controller name and a "
"dot.  A controller's name is composed of lower case alphabets and '_'s but "
"never begins with an '_' so it can be used as the prefix character for "
"collision avoidance.  Also, interface file names won't start or end with "
"terms which are often used in categorizing workloads such as job, service, "
"slice, unit or workload."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:643
msgid ""
"cgroup doesn't do anything to prevent name collisions and it's the user's "
"responsibility to avoid them."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:648
msgid "Resource Distribution Models"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:650
msgid ""
"cgroup controllers implement several resource distribution schemes depending "
"on the resource type and expected use cases.  This section describes major "
"schemes in use along with their expected behaviors."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:656
msgid "Weights"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:658
msgid ""
"A parent's resource is distributed by adding up the weights of all active "
"children and giving each the fraction matching the ratio of its weight "
"against the sum.  As only children which can make use of the resource at the "
"moment participate in the distribution, this is work-conserving.  Due to the "
"dynamic nature, this model is usually used for stateless resources."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:665
msgid ""
"All weights are in the range [1, 10000] with the default at 100.  This "
"allows symmetric multiplicative biases in both directions at fine enough "
"granularity while staying in the intuitive range."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:669
msgid ""
"As long as the weight is in range, all configuration combinations are valid "
"and there is no reason to reject configuration changes or process migrations."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:673
msgid ""
"\"cpu.weight\" proportionally distributes CPU cycles to active children and "
"is an example of this type."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:680
msgid "Limits"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:682
msgid ""
"A child can only consume up to the configured amount of the resource. Limits "
"can be over-committed - the sum of the limits of children can exceed the "
"amount of resource available to the parent."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:686
msgid ""
"Limits are in the range [0, max] and defaults to \"max\", which is noop."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:688
msgid ""
"As limits can be over-committed, all configuration combinations are valid "
"and there is no reason to reject configuration changes or process migrations."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:692
msgid ""
"\"io.max\" limits the maximum BPS and/or IOPS that a cgroup can consume on "
"an IO device and is an example of this type."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:698
msgid "Protections"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:700
msgid ""
"A cgroup is protected up to the configured amount of the resource as long as "
"the usages of all its ancestors are under their protected levels.  "
"Protections can be hard guarantees or best effort soft boundaries.  "
"Protections can also be over-committed in which case only up to the amount "
"available to the parent is protected among children."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:707
msgid "Protections are in the range [0, max] and defaults to 0, which is noop."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:710
msgid ""
"As protections can be over-committed, all configuration combinations are "
"valid and there is no reason to reject configuration changes or process "
"migrations."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:714
msgid ""
"\"memory.low\" implements best-effort memory protection and is an example of "
"this type."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:719
msgid "Allocations"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:721
msgid ""
"A cgroup is exclusively allocated a certain amount of a finite resource.  "
"Allocations can't be over-committed - the sum of the allocations of children "
"can not exceed the amount of resource available to the parent."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:726
msgid ""
"Allocations are in the range [0, max] and defaults to 0, which is no "
"resource."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:729
msgid ""
"As allocations can't be over-committed, some configuration combinations are "
"invalid and should be rejected.  Also, if the resource is mandatory for "
"execution of processes, process migrations may be rejected."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:734
msgid ""
"\"cpu.rt.max\" hard-allocates realtime slices and is an example of this type."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:739
msgid "Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:742
msgid "Format"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:744
msgid ""
"All interface files should be in one of the following formats whenever "
"possible::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:771
msgid ""
"For a writable file, the format for writing should generally match reading; "
"however, controllers may allow omitting later fields or implement restricted "
"shortcuts for most common use cases."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:775
msgid ""
"For both flat and nested keyed files, only the values for a single key can "
"be written at a time.  For nested keyed files, the sub key pairs may be "
"specified in any order and not all pairs have to be specified."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:781
msgid "Conventions"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:783
msgid "Settings for a single feature should be contained in a single file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:785
msgid ""
"The root cgroup should be exempt from resource control and thus shouldn't "
"have resource control interface files."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:788
msgid ""
"The default time unit is microseconds.  If a different unit is ever used, an "
"explicit unit suffix must be present."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:791
msgid ""
"A parts-per quantity should use a percentage decimal with at least two digit "
"fractional part - e.g. 13.40."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:794
msgid ""
"If a controller implements weight based resource distribution, its interface "
"file should be named \"weight\" and have the range [1, 10000] with 100 as "
"the default.  The values are chosen to allow enough and symmetric bias in "
"both directions while keeping it intuitive (the default is 100%)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:800
msgid ""
"If a controller implements an absolute resource guarantee and/or limit, the "
"interface files should be named \"min\" and \"max\" respectively.  If a "
"controller implements best effort resource guarantee and/or limit, the "
"interface files should be named \"low\" and \"high\" respectively."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:806
msgid ""
"In the above four control files, the special token \"max\" should be used to "
"represent upward infinity for both reading and writing."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:809
msgid ""
"If a setting has a configurable default value and keyed specific overrides, "
"the default entry should be keyed with \"default\" and appear as the first "
"entry in the file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:813
msgid ""
"The default value can be updated by writing either \"default $VAL\" or "
"\"$VAL\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:816
msgid ""
"When writing to update a specific override, \"default\" can be used as the "
"value to indicate removal of the override.  Override entries with "
"\"default\" as the value must not appear when read."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:820
msgid ""
"For example, a setting which is keyed by major:minor device numbers with "
"integer values may look like the following::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:827
msgid "The default value can be updated by::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:831
msgid "or::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:835
msgid "An override can be set by::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:839
msgid "and cleared by::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:846
msgid ""
"For events which are not very high frequency, an interface file \"events\" "
"should be created which lists event key value pairs. Whenever a notifiable "
"event happens, file modified event should be generated on the file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:853
msgid "Core Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:855
msgid "All cgroup core files are prefixed with \"cgroup.\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:857
msgid "cgroup.type"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:858
#: ../../../admin-guide/cgroup-v2.rst:1423
#: ../../../admin-guide/cgroup-v2.rst:1810
msgid "A read-write single value file which exists on non-root cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:861
msgid ""
"When read, it indicates the current type of the cgroup, which can be one of "
"the following values."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:864
msgid "\"domain\" : A normal valid domain cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:866
msgid ""
"\"domain threaded\" : A threaded domain cgroup which is serving as the root "
"of a threaded subtree."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:869
msgid ""
"\"domain invalid\" : A cgroup which is in an invalid state. It can't be "
"populated or have controllers enabled.  It may be allowed to become a "
"threaded cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:873
msgid ""
"\"threaded\" : A threaded cgroup which is a member of a threaded subtree."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:876
msgid ""
"A cgroup can be turned into a threaded cgroup by writing \"threaded\" to "
"this file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:879
msgid "cgroup.procs"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:880
#: ../../../admin-guide/cgroup-v2.rst:906
msgid ""
"A read-write new-line separated values file which exists on all cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:883
msgid ""
"When read, it lists the PIDs of all processes which belong to the cgroup one-"
"per-line.  The PIDs are not ordered and the same PID may show up more than "
"once if the process got moved to another cgroup and then back or the PID got "
"recycled while reading."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:889
msgid ""
"A PID can be written to migrate the process associated with the PID to the "
"cgroup.  The writer should match all of the following conditions."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:893
msgid "It must have write access to the \"cgroup.procs\" file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:895
#: ../../../admin-guide/cgroup-v2.rst:924
msgid ""
"It must have write access to the \"cgroup.procs\" file of the common "
"ancestor of the source and destination cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:898
#: ../../../admin-guide/cgroup-v2.rst:927
msgid ""
"When delegating a sub-hierarchy, write access to this file should be granted "
"along with the containing directory."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:901
msgid ""
"In a threaded cgroup, reading this file fails with EOPNOTSUPP as all the "
"processes belong to the thread root.  Writing is supported and moves every "
"thread of the process to the cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:905
msgid "cgroup.threads"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:909
msgid ""
"When read, it lists the TIDs of all threads which belong to the cgroup one-"
"per-line.  The TIDs are not ordered and the same TID may show up more than "
"once if the thread got moved to another cgroup and then back or the TID got "
"recycled while reading."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:915
msgid ""
"A TID can be written to migrate the thread associated with the TID to the "
"cgroup.  The writer should match all of the following conditions."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:919
msgid "It must have write access to the \"cgroup.threads\" file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:921
msgid ""
"The cgroup that the thread is currently in must be in the same resource "
"domain as the destination cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:930
msgid "cgroup.controllers"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:931
msgid "A read-only space separated values file which exists on all cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:934
msgid ""
"It shows space separated list of all controllers available to the cgroup.  "
"The controllers are not ordered."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:937
msgid "cgroup.subtree_control"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:938
msgid ""
"A read-write space separated values file which exists on all cgroups.  "
"Starts out empty."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:941
msgid ""
"When read, it shows space separated list of the controllers which are "
"enabled to control resource distribution from the cgroup to its children."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:945
msgid ""
"Space separated list of controllers prefixed with '+' or '-' can be written "
"to enable or disable controllers.  A controller name prefixed with '+' "
"enables the controller and '-' disables.  If a controller appears more than "
"once on the list, the last one is effective.  When multiple enable and "
"disable operations are specified, either all succeed or all fail."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:952
msgid "cgroup.events"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:953
#: ../../../admin-guide/cgroup-v2.rst:1451
#: ../../../admin-guide/cgroup-v2.rst:1827
msgid ""
"A read-only flat-keyed file which exists on non-root cgroups. The following "
"entries are defined.  Unless specified otherwise, a value change in this "
"file generates a file modified event."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:958
msgid "populated"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:959
msgid ""
"1 if the cgroup or its descendants contains any live processes; otherwise, 0."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:961
msgid "frozen"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:962
msgid "1 if the cgroup is frozen; otherwise, 0."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:964
msgid "cgroup.max.descendants"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:965
#: ../../../admin-guide/cgroup-v2.rst:972
msgid "A read-write single value files.  The default is \"max\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:967
msgid ""
"Maximum allowed number of descent cgroups. If the actual number of "
"descendants is equal or larger, an attempt to create a new cgroup in the "
"hierarchy will fail."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:971
msgid "cgroup.max.depth"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:974
msgid ""
"Maximum allowed descent depth below the current cgroup. If the actual "
"descent depth is equal or larger, an attempt to create a new child cgroup "
"will fail."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:978
msgid "cgroup.stat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:979
msgid "A read-only flat-keyed file with the following entries:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:981
msgid "nr_descendants"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:982
msgid "Total number of visible descendant cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:984
msgid "nr_dying_descendants"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:985
msgid ""
"Total number of dying descendant cgroups. A cgroup becomes dying after being "
"deleted by a user. The cgroup will remain in dying state for some time "
"undefined time (which can depend on system load) before being completely "
"destroyed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:990
msgid ""
"A process can't enter a dying cgroup under any circumstances, a dying cgroup "
"can't revive."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:993
msgid ""
"A dying cgroup can consume system resources not exceeding limits, which were "
"active at the moment of cgroup deletion."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:996
msgid "nr_subsys_<cgroup_subsys>"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:997
msgid ""
"Total number of live cgroup subsystems (e.g memory cgroup) at and beneath "
"the current cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1000
msgid "nr_dying_subsys_<cgroup_subsys>"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1001
msgid ""
"Total number of dying cgroup subsystems (e.g. memory cgroup) at and beneath "
"the current cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1004
msgid "cgroup.freeze"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1005
msgid ""
"A read-write single value file which exists on non-root cgroups. Allowed "
"values are \"0\" and \"1\". The default is \"0\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1008
msgid ""
"Writing \"1\" to the file causes freezing of the cgroup and all descendant "
"cgroups. This means that all belonging processes will be stopped and will "
"not run until the cgroup will be explicitly unfrozen. Freezing of the cgroup "
"may take some time; when this action is completed, the \"frozen\" value in "
"the cgroup.events control file will be updated to \"1\" and the "
"corresponding notification will be issued."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1016
msgid ""
"A cgroup can be frozen either by its own settings, or by settings of any "
"ancestor cgroups. If any of ancestor cgroups is frozen, the cgroup will "
"remain frozen."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1020
msgid ""
"Processes in the frozen cgroup can be killed by a fatal signal. They also "
"can enter and leave a frozen cgroup: either by an explicit move by a user, "
"or if freezing of the cgroup races with fork(). If a process is moved to a "
"frozen cgroup, it stops. If a process is moved out of a frozen cgroup, it "
"becomes running."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1026
msgid ""
"Frozen status of a cgroup doesn't affect any cgroup tree operations: it's "
"possible to delete a frozen (and empty) cgroup, as well as create new sub-"
"cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1030
msgid "cgroup.kill"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1031
msgid ""
"A write-only single value file which exists in non-root cgroups. The only "
"allowed value is \"1\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1034
msgid ""
"Writing \"1\" to the file causes the cgroup and all descendant cgroups to be "
"killed. This means that all processes located in the affected cgroup tree "
"will be killed via SIGKILL."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1038
msgid ""
"Killing a cgroup tree will deal with concurrent forks appropriately and is "
"protected against migrations."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1041
msgid ""
"In a threaded cgroup, writing this file fails with EOPNOTSUPP as killing "
"cgroups is a process directed operation, i.e. it affects the whole thread-"
"group."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1045
msgid "cgroup.pressure"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1046
msgid ""
"A read-write single value file that allowed values are \"0\" and \"1\". The "
"default is \"1\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1049
msgid ""
"Writing \"0\" to the file will disable the cgroup PSI accounting. Writing "
"\"1\" to the file will re-enable the cgroup PSI accounting."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1052
msgid ""
"This control attribute is not hierarchical, so disable or enable PSI "
"accounting in a cgroup does not affect PSI accounting in descendants and "
"doesn't need pass enablement via ancestors from root."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1056
msgid ""
"The reason this control attribute exists is that PSI accounts stalls for "
"each cgroup separately and aggregates it at each level of the hierarchy. "
"This may cause non-negligible overhead for some workloads when under deep "
"level of the hierarchy, in which case this control attribute can be used to "
"disable PSI accounting in the non-leaf cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1062
msgid "irq.pressure"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1063
#: ../../../admin-guide/cgroup-v2.rst:1195
msgid "A read-write nested-keyed file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1065
msgid ""
"Shows pressure stall information for IRQ/SOFTIRQ. See :ref:`Documentation/"
"accounting/psi.rst <psi>` for details."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1069
msgid "Controllers"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1074
msgid "CPU"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1076
msgid ""
"The \"cpu\" controllers regulates distribution of CPU cycles.  This "
"controller implements weight and absolute bandwidth limit models for normal "
"scheduling policy and absolute bandwidth allocation model for realtime "
"scheduling policy."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1081
msgid ""
"In all the above models, cycles distribution is defined only on a temporal "
"base and it does not account for the frequency at which tasks are executed. "
"The (optional) utilization clamping support allows to hint the schedutil "
"cpufreq governor about the minimum desired frequency which should always be "
"provided by a CPU, as well as the maximum desired frequency, which should "
"not be exceeded by a CPU."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1088
msgid ""
"WARNING: cgroup2 cpu controller doesn't yet support the (bandwidth) control "
"of realtime processes. For a kernel built with the CONFIG_RT_GROUP_SCHED "
"option enabled for group scheduling of realtime processes, the cpu "
"controller can only be enabled when all RT processes are in the root cgroup. "
"Be aware that system management software may already have placed RT "
"processes into non-root cgroups during the system boot process, and these "
"processes may need to be moved to the root cgroup before the cpu controller "
"can be enabled with a CONFIG_RT_GROUP_SCHED enabled kernel."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1097
msgid ""
"With CONFIG_RT_GROUP_SCHED disabled, this limitation does not apply and some "
"of the interface files either affect realtime processes or account for them. "
"See the following section for details. Only the cpu controller is affected "
"by CONFIG_RT_GROUP_SCHED. Other controllers can be used for the resource "
"control of realtime processes irrespective of CONFIG_RT_GROUP_SCHED."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1105
msgid "CPU Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1107
msgid ""
"The interaction of a process with the cpu controller depends on its "
"scheduling policy and the underlying scheduler. From the point of view of "
"the cpu controller, processes can be categorized as follows:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1111
msgid "Processes under the fair-class scheduler"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1112
msgid "Processes under a BPF scheduler with the ``cgroup_set_weight`` callback"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1113
msgid ""
"Everything else: ``SCHED_{FIFO,RR,DEADLINE}`` and processes under a BPF "
"scheduler without the ``cgroup_set_weight`` callback"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1116
msgid ""
"For details on when a process is under the fair-class scheduler or a BPF "
"scheduler, check out :ref:`Documentation/scheduler/sched-ext.rst <sched-"
"ext>`."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1119
msgid ""
"For each of the following interface files, the above categories will be "
"referred to. All time durations are in microseconds."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1122
msgid "cpu.stat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1123
msgid ""
"A read-only flat-keyed file. This file exists whether the controller is "
"enabled or not."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1126
msgid ""
"It always reports the following three stats, which account for all the "
"processes in the cgroup:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1129
msgid "usage_usec"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1130
msgid "user_usec"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1131
msgid "system_usec"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1133
msgid ""
"and the following five when the controller is enabled, which account for "
"only the processes under the fair-class scheduler:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1136
msgid "nr_periods"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1137
msgid "nr_throttled"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1138
msgid "throttled_usec"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1139
msgid "nr_bursts"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1140
msgid "burst_usec"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1142
msgid "cpu.weight"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1143
msgid ""
"A read-write single value file which exists on non-root cgroups.  The "
"default is \"100\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1146
msgid ""
"For non idle groups (cpu.idle = 0), the weight is in the range [1, 10000]."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1149
msgid ""
"If the cgroup has been configured to be SCHED_IDLE (cpu.idle = 1), then the "
"weight will show as a 0."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1152
#: ../../../admin-guide/cgroup-v2.rst:1168
msgid ""
"This file affects only processes under the fair-class scheduler and a BPF "
"scheduler with the ``cgroup_set_weight`` callback depending on what the "
"callback actually does."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1156
msgid "cpu.weight.nice"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1157
#: ../../../admin-guide/cgroup-v2.rst:1187
#: ../../../admin-guide/cgroup-v2.rst:1284
#: ../../../admin-guide/cgroup-v2.rst:1310
msgid ""
"A read-write single value file which exists on non-root cgroups.  The "
"default is \"0\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1160
msgid "The nice value is in the range [-20, 19]."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1162
msgid ""
"This interface file is an alternative interface for \"cpu.weight\" and "
"allows reading and setting weight using the same values used by nice(2).  "
"Because the range is smaller and granularity is coarser for the nice values, "
"the read value is the closest approximation of the current weight."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1172
msgid "cpu.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1173
msgid ""
"A read-write two value file which exists on non-root cgroups. The default is "
"\"max 100000\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1176
msgid "The maximum bandwidth limit.  It's in the following format::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1180
msgid ""
"which indicates that the group may consume up to $MAX in each $PERIOD "
"duration.  \"max\" for $MAX indicates no limit.  If only one number is "
"written, $MAX is updated."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1184
#: ../../../admin-guide/cgroup-v2.rst:1192
#: ../../../admin-guide/cgroup-v2.rst:1244
msgid "This file affects only processes under the fair-class scheduler."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1186
msgid "cpu.max.burst"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1190
msgid "The burst in the range [0, $MAX]."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1194
msgid "cpu.pressure"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1197
msgid ""
"Shows pressure stall information for CPU. See :ref:`Documentation/accounting/"
"psi.rst <psi>` for details."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1200
msgid "This file accounts for all the processes in the cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1202
msgid "cpu.uclamp.min"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1203
msgid ""
"A read-write single value file which exists on non-root cgroups. The default "
"is \"0\", i.e. no utilization boosting."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1206
msgid ""
"The requested minimum utilization (protection) as a percentage rational "
"number, e.g. 12.34 for 12.34%."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1209
msgid ""
"This interface allows reading and setting minimum utilization clamp values "
"similar to the sched_setattr(2). This minimum utilization value is used to "
"clamp the task specific minimum utilization clamp, including those of "
"realtime processes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1214
msgid ""
"The requested minimum utilization (protection) is always capped by the "
"current value for the maximum utilization (limit), i.e. `cpu.uclamp.max`."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1218
#: ../../../admin-guide/cgroup-v2.rst:1232
msgid "This file affects all the processes in the cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1220
msgid "cpu.uclamp.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1221
msgid ""
"A read-write single value file which exists on non-root cgroups. The default "
"is \"max\". i.e. no utilization capping"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1224
msgid ""
"The requested maximum utilization (limit) as a percentage rational number, e."
"g. 98.76 for 98.76%."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1227
msgid ""
"This interface allows reading and setting maximum utilization clamp values "
"similar to the sched_setattr(2). This maximum utilization value is used to "
"clamp the task specific maximum utilization clamp, including those of "
"realtime processes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1234
msgid "cpu.idle"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1235
msgid ""
"A read-write single value file which exists on non-root cgroups. The default "
"is 0."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1238
msgid ""
"This is the cgroup analog of the per-task SCHED_IDLE sched policy. Setting "
"this value to a 1 will make the scheduling policy of the cgroup SCHED_IDLE. "
"The threads inside the cgroup will retain their own relative priorities, but "
"the cgroup itself will be treated as very low priority relative to its peers."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1247
#: ../../../admin-guide/cgroup-v2.rst:3313
msgid "Memory"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1249
msgid ""
"The \"memory\" controller regulates distribution of memory.  Memory is "
"stateful and implements both limit and protection models.  Due to the "
"intertwining between memory usage and reclaim pressure and the stateful "
"nature of memory, the distribution model is relatively complex."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1255
msgid ""
"While not completely water-tight, all major memory usages by a given cgroup "
"are tracked so that the total memory consumption can be accounted and "
"controlled to a reasonable extent.  Currently, the following types of memory "
"usages are tracked."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1260
msgid "Userland memory - page cache and anonymous memory."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1262
msgid "Kernel data structures such as dentries and inodes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1264
msgid "TCP socket buffers."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1266
msgid "The above list may expand in the future for better coverage."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1270
msgid "Memory Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1272
msgid ""
"All memory amounts are in bytes.  If a value which is not aligned to "
"PAGE_SIZE is written, the value may be rounded up to the closest PAGE_SIZE "
"multiple when read back."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1276
msgid "memory.current"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1277
#: ../../../admin-guide/cgroup-v2.rst:1787
#: ../../../admin-guide/cgroup-v2.rst:1852
#: ../../../admin-guide/cgroup-v2.rst:2357
#: ../../../admin-guide/cgroup-v2.rst:2363
msgid "A read-only single value file which exists on non-root cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1280
msgid ""
"The total amount of memory currently being used by the cgroup and its "
"descendants."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1283
msgid "memory.min"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1287
msgid ""
"Hard memory protection.  If the memory usage of a cgroup is within its "
"effective min boundary, the cgroup's memory won't be reclaimed under any "
"conditions. If there is no unprotected reclaimable memory available, OOM "
"killer is invoked. Above the effective min boundary (or effective low "
"boundary if it is higher), pages are reclaimed proportionally to the "
"overage, reducing reclaim pressure for smaller overages."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1296
msgid ""
"Effective min boundary is limited by memory.min values of all ancestor "
"cgroups. If there is memory.min overcommitment (child cgroup or cgroups are "
"requiring more protected memory than parent will allow), then each child "
"cgroup will get the part of parent's protection proportional to its actual "
"memory usage below memory.min."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1303
msgid ""
"Putting more memory than generally available under this protection is "
"discouraged and may lead to constant OOMs."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1306
msgid ""
"If a memory cgroup is not populated with processes, its memory.min is "
"ignored."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1309
msgid "memory.low"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1313
msgid ""
"Best-effort memory protection.  If the memory usage of a cgroup is within "
"its effective low boundary, the cgroup's memory won't be reclaimed unless "
"there is no reclaimable memory available in unprotected cgroups. Above the "
"effective low boundary (or effective min boundary if it is higher), pages "
"are reclaimed proportionally to the overage, reducing reclaim pressure for "
"smaller overages."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1322
msgid ""
"Effective low boundary is limited by memory.low values of all ancestor "
"cgroups. If there is memory.low overcommitment (child cgroup or cgroups are "
"requiring more protected memory than parent will allow), then each child "
"cgroup will get the part of parent's protection proportional to its actual "
"memory usage below memory.low."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1329
msgid ""
"Putting more memory than generally available under this protection is "
"discouraged."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1332
msgid "memory.high"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1333
#: ../../../admin-guide/cgroup-v2.rst:1359
#: ../../../admin-guide/cgroup-v2.rst:1794
#: ../../../admin-guide/cgroup-v2.rst:1820
#: ../../../admin-guide/cgroup-v2.rst:1859
#: ../../../admin-guide/cgroup-v2.rst:2351
msgid ""
"A read-write single value file which exists on non-root cgroups.  The "
"default is \"max\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1336
msgid ""
"Memory usage throttle limit.  If a cgroup's usage goes over the high "
"boundary, the processes of the cgroup are throttled and put under heavy "
"reclaim pressure."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1340
msgid ""
"Going over the high limit never invokes the OOM killer and under extreme "
"conditions the limit may be breached. The high limit should be used in "
"scenarios where an external process monitors the limited cgroup to alleviate "
"heavy reclaim pressure."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1346
msgid ""
"If memory.high is opened with O_NONBLOCK then the synchronous reclaim is "
"bypassed. This is useful for admin processes that need to dynamically adjust "
"the job's memory limits without expending their own CPU resources on memory "
"reclamation. The job will trigger the reclaim and/or get throttled on its "
"next charge request."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1353
#: ../../../admin-guide/cgroup-v2.rst:1382
msgid ""
"Please note that with O_NONBLOCK, there is a chance that the target memory "
"cgroup may take indefinite amount of time to reduce usage below the limit "
"due to delayed charge request or busy-hitting its memory to slow down "
"reclaim."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1358
msgid "memory.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1362
msgid ""
"Memory usage hard limit.  This is the main mechanism to limit memory usage "
"of a cgroup.  If a cgroup's memory usage reaches this limit and can't be "
"reduced, the OOM killer is invoked in the cgroup. Under certain "
"circumstances, the usage may go over the limit temporarily."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1368
msgid ""
"In default configuration regular 0-order allocations always succeed unless "
"OOM killer chooses current task as a victim."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1371
msgid ""
"Some kinds of allocations don't invoke the OOM killer. Caller could retry "
"them differently, return into userspace as -ENOMEM or silently ignore in "
"cases like disk readahead."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1375
msgid ""
"If memory.max is opened with O_NONBLOCK, then the synchronous reclaim and "
"oom-kill are bypassed. This is useful for admin processes that need to "
"dynamically adjust the job's memory limits without expending their own CPU "
"resources on memory reclamation. The job will trigger the reclaim and/or oom-"
"kill on its next charge request."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1387
msgid "memory.reclaim"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1388
msgid "A write-only nested-keyed file which exists for all cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1390
msgid ""
"This is a simple interface to trigger memory reclaim in the target cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1393
msgid "Example::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1397
msgid ""
"Please note that the kernel can over or under reclaim from the target "
"cgroup. If less bytes are reclaimed than the specified amount, -EAGAIN is "
"returned."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1401
msgid ""
"Please note that the proactive reclaim (triggered by this interface) is not "
"meant to indicate memory pressure on the memory cgroup. Therefore socket "
"memory balancing triggered by the memory reclaim normally is not exercised "
"in this case. This means that the networking layer will not adapt based on "
"reclaim induced by memory.reclaim."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1408
#: ../../../admin-guide/cgroup-v2.rst:2706
msgid "The following nested keys are defined."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1411
msgid "swappiness"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1411
msgid "Swappiness value to reclaim with"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1414
msgid ""
"Specifying a swappiness value instructs the kernel to perform the reclaim "
"with that swappiness value. Note that this has the same semantics as vm."
"swappiness applied to memcg reclaim with all the existing limitations and "
"potential future extensions."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1419
msgid ""
"The valid range for swappiness is [0-200, max], setting swappiness=max "
"exclusively reclaims anonymous memory."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1422
msgid "memory.peak"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1425
msgid ""
"The max memory usage recorded for the cgroup and its descendants since "
"either the creation of the cgroup or the most recent reset for that FD."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1428
#: ../../../admin-guide/cgroup-v2.rst:1815
msgid ""
"A write of any non-empty string to this file resets it to the current memory "
"usage for subsequent reads through the same file descriptor."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1432
msgid "memory.oom.group"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1433
msgid ""
"A read-write single value file which exists on non-root cgroups.  The "
"default value is \"0\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1436
msgid ""
"Determines whether the cgroup should be treated as an indivisible workload "
"by the OOM killer. If set, all tasks belonging to the cgroup or to its "
"descendants (if the memory cgroup is not a leaf cgroup) are killed together "
"or not at all. This can be used to avoid partial kills to guarantee workload "
"integrity."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1443
msgid ""
"Tasks with the OOM protection (oom_score_adj set to -1000) are treated as an "
"exception and are never killed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1446
msgid ""
"If the OOM killer is invoked in a cgroup, it's not going to kill any tasks "
"outside of this cgroup, regardless memory.oom.group values of ancestor "
"cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1450
msgid "memory.events"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1456
msgid ""
"Note that all fields in this file are hierarchical and the file modified "
"event can be generated due to an event down the hierarchy. For the local "
"events at the cgroup level see memory.events.local."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1461
msgid "low"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1462
msgid ""
"The number of times the cgroup is reclaimed due to high memory pressure even "
"though its usage is under the low boundary.  This usually indicates that the "
"low boundary is over-committed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1467
#: ../../../admin-guide/cgroup-v2.rst:1832
msgid "high"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1468
msgid ""
"The number of times processes of the cgroup are throttled and routed to "
"perform direct memory reclaim because the high memory boundary was "
"exceeded.  For a cgroup whose memory usage is capped by the high limit "
"rather than global memory pressure, this event's occurrences are expected."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1475
#: ../../../admin-guide/cgroup-v2.rst:1836
#: ../../../admin-guide/cgroup-v2.rst:1987
#: ../../../admin-guide/cgroup-v2.rst:2373
#: ../../../admin-guide/cgroup-v2.rst:2790
#: ../../../admin-guide/cgroup-v2.rst:2876
msgid "max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1476
msgid ""
"The number of times the cgroup's memory usage was about to go over the max "
"boundary.  If direct reclaim fails to bring it down, the cgroup goes to OOM "
"state."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1480
msgid "oom"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1481
msgid ""
"The number of time the cgroup's memory usage was reached the limit and "
"allocation was about to fail."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1484
msgid ""
"This event is not raised if the OOM killer is not considered as an option, e."
"g. for failed high-order allocations or if caller asked to not retry "
"attempts."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1488
msgid "oom_kill"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1489
msgid ""
"The number of processes belonging to this cgroup killed by any kind of OOM "
"killer."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1492
msgid "oom_group_kill"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1493
msgid "The number of times a group OOM has occurred."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1495
msgid "memory.events.local"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1496
msgid ""
"Similar to memory.events but the fields in the file are local to the cgroup "
"i.e. not hierarchical. The file modified event generated on this file "
"reflects only the local events."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1500
msgid "memory.stat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1501
#: ../../../admin-guide/cgroup-v2.rst:2788
msgid "A read-only flat-keyed file which exists on non-root cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1503
msgid ""
"This breaks down the cgroup's memory footprint into different types of "
"memory, type-specific details, and other information on the state and past "
"events of the memory management system."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1507
#: ../../../admin-guide/cgroup-v2.rst:1774
msgid "All memory amounts are in bytes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1509
#: ../../../admin-guide/cgroup-v2.rst:1780
msgid ""
"The entries are ordered to be human readable, and new entries can show up in "
"the middle. Don't rely on items remaining in a fixed position; use the keys "
"to look up specific values!"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1513
msgid ""
"If the entry has no per-node counter (or not show in the memory.numa_stat). "
"We use 'npn' (non-per-node) as the tag to indicate that it will not show in "
"the memory.numa_stat."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1517
msgid "anon"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1518
msgid ""
"Amount of memory used in anonymous mappings such as brk(), sbrk(), and "
"mmap(MAP_ANONYMOUS). Note that some kernel configurations might account "
"complete larger allocations (e.g., THP) if only some, but not all the memory "
"of such an allocation is mapped anymore."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1524
msgid "file"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1525
msgid ""
"Amount of memory used to cache filesystem data, including tmpfs and shared "
"memory."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1528
msgid "kernel (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1529
msgid ""
"Amount of total kernel memory, including (kernel_stack, pagetables, percpu, "
"vmalloc, slab) in addition to other kernel memory use cases."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1533
msgid "kernel_stack"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1534
msgid "Amount of memory allocated to kernel stacks."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1536
msgid "pagetables"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1537
msgid "Amount of memory allocated for page tables."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1539
msgid "sec_pagetables"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1540
msgid ""
"Amount of memory allocated for secondary page tables, this currently "
"includes KVM mmu allocations on x86 and arm64 and IOMMU page tables."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1544
msgid "percpu (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1545
msgid "Amount of memory used for storing per-cpu kernel data structures."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1548
msgid "sock (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1549
msgid "Amount of memory used in network transmission buffers"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1551
msgid "vmalloc (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1552
msgid "Amount of memory used for vmap backed memory."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1554
msgid "shmem"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1555
msgid ""
"Amount of cached filesystem data that is swap-backed, such as tmpfs, shm "
"segments, shared anonymous mmap()s"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1558
msgid "zswap"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1559
msgid "Amount of memory consumed by the zswap compression backend."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1561
msgid "zswapped"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1562
msgid "Amount of application memory swapped out to zswap."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1564
msgid "file_mapped"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1565
msgid ""
"Amount of cached filesystem data mapped with mmap(). Note that some kernel "
"configurations might account complete larger allocations (e.g., THP) if only "
"some, but not not all the memory of such an allocation is mapped."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1570
msgid "file_dirty"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1571
msgid ""
"Amount of cached filesystem data that was modified but not yet written back "
"to disk"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1574
msgid "file_writeback"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1575
msgid ""
"Amount of cached filesystem data that was modified and is currently being "
"written back to disk"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1578
msgid "swapcached"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1579
msgid ""
"Amount of swap cached in memory. The swapcache is accounted against both "
"memory and swap usage."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1582
msgid "anon_thp"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1583
msgid ""
"Amount of memory used in anonymous mappings backed by transparent hugepages"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1586
msgid "file_thp"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1587
msgid "Amount of cached filesystem data backed by transparent hugepages"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1590
msgid "shmem_thp"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1591
msgid ""
"Amount of shm, tmpfs, shared anonymous mmap()s backed by transparent "
"hugepages"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1594
msgid "inactive_anon, active_anon, inactive_file, active_file, unevictable"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1595
msgid ""
"Amount of memory, swap-backed and filesystem-backed, on the internal memory "
"management lists used by the page reclaim algorithm."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1599
msgid ""
"As these represent internal list state (eg. shmem pages are on anon memory "
"management lists), inactive_foo + active_foo may not be equal to the value "
"for the foo counter, since the foo counter is type-based, not list-based."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1604
msgid "slab_reclaimable"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1605
msgid "Part of \"slab\" that might be reclaimed, such as dentries and inodes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1608
msgid "slab_unreclaimable"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1609
msgid "Part of \"slab\" that cannot be reclaimed on memory pressure."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1612
msgid "slab (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1613
msgid "Amount of memory used for storing in-kernel data structures."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1616
msgid "workingset_refault_anon"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1617
msgid "Number of refaults of previously evicted anonymous pages."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1619
msgid "workingset_refault_file"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1620
msgid "Number of refaults of previously evicted file pages."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1622
msgid "workingset_activate_anon"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1623
msgid "Number of refaulted anonymous pages that were immediately activated."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1626
msgid "workingset_activate_file"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1627
msgid "Number of refaulted file pages that were immediately activated."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1629
msgid "workingset_restore_anon"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1630
msgid ""
"Number of restored anonymous pages which have been detected as an active "
"workingset before they got reclaimed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1633
msgid "workingset_restore_file"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1634
msgid ""
"Number of restored file pages which have been detected as an active "
"workingset before they got reclaimed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1637
msgid "workingset_nodereclaim"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1638
msgid "Number of times a shadow node has been reclaimed"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1640
msgid "pswpin (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1641
msgid "Number of pages swapped into memory"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1643
msgid "pswpout (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1644
msgid "Number of pages swapped out of memory"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1646
msgid "pgscan (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1647
msgid "Amount of scanned pages (in an inactive LRU list)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1649
msgid "pgsteal (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1650
msgid "Amount of reclaimed pages"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1652
msgid "pgscan_kswapd (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1653
msgid "Amount of scanned pages by kswapd (in an inactive LRU list)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1655
msgid "pgscan_direct (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1656
msgid "Amount of scanned pages directly  (in an inactive LRU list)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1658
msgid "pgscan_khugepaged (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1659
msgid "Amount of scanned pages by khugepaged  (in an inactive LRU list)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1661
msgid "pgscan_proactive (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1662
msgid "Amount of scanned pages proactively (in an inactive LRU list)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1664
msgid "pgsteal_kswapd (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1665
msgid "Amount of reclaimed pages by kswapd"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1667
msgid "pgsteal_direct (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1668
msgid "Amount of reclaimed pages directly"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1670
msgid "pgsteal_khugepaged (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1671
msgid "Amount of reclaimed pages by khugepaged"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1673
msgid "pgsteal_proactive (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1674
msgid "Amount of reclaimed pages proactively"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1676
msgid "pgfault (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1677
msgid "Total number of page faults incurred"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1679
msgid "pgmajfault (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1680
msgid "Number of major page faults incurred"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1682
msgid "pgrefill (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1683
msgid "Amount of scanned pages (in an active LRU list)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1685
msgid "pgactivate (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1686
msgid "Amount of pages moved to the active LRU list"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1688
msgid "pgdeactivate (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1689
msgid "Amount of pages moved to the inactive LRU list"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1691
msgid "pglazyfree (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1692
msgid "Amount of pages postponed to be freed under memory pressure"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1694
msgid "pglazyfreed (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1695
msgid "Amount of reclaimed lazyfree pages"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1697
msgid "swpin_zero"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1698
msgid ""
"Number of pages swapped into memory and filled with zero, where I/O was "
"optimized out because the page content was detected to be zero during "
"swapout."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1702
msgid "swpout_zero"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1703
msgid ""
"Number of zero-filled pages swapped out with I/O skipped due to the content "
"being detected as zero."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1706
msgid "zswpin"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1707
msgid "Number of pages moved in to memory from zswap."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1709
msgid "zswpout"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1710
msgid "Number of pages moved out of memory to zswap."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1712
msgid "zswpwb"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1713
msgid "Number of pages written from zswap to swap."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1715
msgid "thp_fault_alloc (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1716
msgid ""
"Number of transparent hugepages which were allocated to satisfy a page "
"fault. This counter is not present when CONFIG_TRANSPARENT_HUGEPAGE is not "
"set."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1720
msgid "thp_collapse_alloc (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1721
msgid ""
"Number of transparent hugepages which were allocated to allow collapsing an "
"existing range of pages. This counter is not present when "
"CONFIG_TRANSPARENT_HUGEPAGE is not set."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1725
msgid "thp_swpout (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1726
msgid ""
"Number of transparent hugepages which are swapout in one piece without "
"splitting."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1729
msgid "thp_swpout_fallback (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1730
msgid ""
"Number of transparent hugepages which were split before swapout. Usually "
"because failed to allocate some continuous swap space for the huge page."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1734
msgid "numa_pages_migrated (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1735
msgid "Number of pages migrated by NUMA balancing."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1737
msgid "numa_pte_updates (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1738
msgid ""
"Number of pages whose page table entries are modified by NUMA balancing to "
"produce NUMA hinting faults on access."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1741
msgid "numa_hint_faults (npn)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1742
msgid "Number of NUMA hinting faults."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1744
msgid "pgdemote_kswapd"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1745
msgid "Number of pages demoted by kswapd."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1747
msgid "pgdemote_direct"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1748
msgid "Number of pages demoted directly."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1750
msgid "pgdemote_khugepaged"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1751
msgid "Number of pages demoted by khugepaged."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1753
msgid "pgdemote_proactive"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1754
msgid "Number of pages demoted by proactively."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1756
msgid "hugetlb"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1757
msgid ""
"Amount of memory used by hugetlb pages. This metric only shows up if hugetlb "
"usage is accounted for in memory.current (i.e. cgroup is mounted with the "
"memory_hugetlb_accounting option)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1761
msgid "memory.numa_stat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1762
msgid "A read-only nested-keyed file which exists on non-root cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1764
msgid ""
"This breaks down the cgroup's memory footprint into different types of "
"memory, type-specific details, and other information per node on the state "
"of the memory management system."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1768
msgid ""
"This is useful for providing visibility into the NUMA locality information "
"within an memcg since the pages are allowed to be allocated from any "
"physical node. One of the use case is evaluating application performance by "
"combining this information with the application's CPU allocation."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1776
msgid "The output format of memory.numa_stat is::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1784
msgid "The entries can refer to the memory.stat."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1786
msgid "memory.swap.current"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1790
msgid ""
"The total amount of swap currently being used by the cgroup and its "
"descendants."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1793
msgid "memory.swap.high"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1797
msgid ""
"Swap usage throttle limit.  If a cgroup's swap usage exceeds this limit, all "
"its further allocations will be throttled to allow userspace to implement "
"custom out-of-memory procedures."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1801
msgid ""
"This limit marks a point of no return for the cgroup. It is NOT designed to "
"manage the amount of swapping a workload does during regular operation. "
"Compare to memory.swap.max, which prohibits swapping past a set amount, but "
"lets the cgroup continue unimpeded as long as other memory can be reclaimed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1807
msgid "Healthy workloads are not expected to reach this limit."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1809
msgid "memory.swap.peak"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1812
msgid ""
"The max swap usage recorded for the cgroup and its descendants since the "
"creation of the cgroup or the most recent reset for that FD."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1819
msgid "memory.swap.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1823
msgid ""
"Swap usage hard limit.  If a cgroup's swap usage reaches this limit, "
"anonymous memory of the cgroup will not be swapped out."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1826
msgid "memory.swap.events"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1833
msgid ""
"The number of times the cgroup's swap usage was over the high threshold."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1837
msgid ""
"The number of times the cgroup's swap usage was about to go over the max "
"boundary and swap allocation failed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1841
msgid "fail"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1842
msgid ""
"The number of times swap allocation failed either because of running out of "
"swap system-wide or max limit."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1846
msgid ""
"When reduced under the current usage, the existing swap entries are "
"reclaimed gradually and the swap usage may stay higher than the limit for an "
"extended period of time.  This reduces the impact on the workload and memory "
"management."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1851
msgid "memory.zswap.current"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1855
msgid "The total amount of memory consumed by the zswap compression backend."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1858
msgid "memory.zswap.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1862
msgid ""
"Zswap usage hard limit. If a cgroup's zswap pool reaches this limit, it will "
"refuse to take any more stores before existing entries fault back in or are "
"written out to disk."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1866
msgid "memory.zswap.writeback"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1867
msgid ""
"A read-write single value file. The default value is \"1\". Note that this "
"setting is hierarchical, i.e. the writeback would be implicitly disabled for "
"child cgroups if the upper hierarchy does so."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1872
msgid ""
"When this is set to 0, all swapping attempts to swapping devices are "
"disabled. This included both zswap writebacks, and swapping due to zswap "
"store failures. If the zswap store failures are recurring (for e.g if the "
"pages are incompressible), users can observe reclaim inefficiency after "
"disabling writeback (because the same pages might be rejected again and "
"again)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1879
msgid ""
"Note that this is subtly different from setting memory.swap.max to 0, as it "
"still allows for pages to be written to the zswap pool. This setting has no "
"effect if zswap is disabled, and swapping is allowed unless memory.swap.max "
"is set to 0."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1884
msgid "memory.pressure"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1885
#: ../../../admin-guide/cgroup-v2.rst:1948
#: ../../../admin-guide/cgroup-v2.rst:2124
msgid "A read-only nested-keyed file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1887
msgid ""
"Shows pressure stall information for memory. See :ref:`Documentation/"
"accounting/psi.rst <psi>` for details."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1892
msgid "Usage Guidelines"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1894
msgid ""
"\"memory.high\" is the main mechanism to control memory usage. Over-"
"committing on high limit (sum of high limits > available memory) and letting "
"global memory pressure to distribute memory according to usage is a viable "
"strategy."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1899
msgid ""
"Because breach of the high limit doesn't trigger the OOM killer but "
"throttles the offending cgroup, a management agent has ample opportunities "
"to monitor and take appropriate actions such as granting more memory or "
"terminating the workload."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1904
msgid ""
"Determining whether a cgroup has enough memory is not trivial as memory "
"usage doesn't indicate whether the workload can benefit from more memory.  "
"For example, a workload which writes data received from network to a file "
"can use all available memory but can also operate as performant with a small "
"amount of memory.  A measure of memory pressure - how much the workload is "
"being impacted due to lack of memory - is necessary to determine whether a "
"workload needs more memory; unfortunately, memory pressure monitoring "
"mechanism isn't implemented yet."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1916
msgid "Memory Ownership"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1918
msgid ""
"A memory area is charged to the cgroup which instantiated it and stays "
"charged to the cgroup until the area is released.  Migrating a process to a "
"different cgroup doesn't move the memory usages that it instantiated while "
"in the previous cgroup to the new cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1923
msgid ""
"A memory area may be used by processes belonging to different cgroups. To "
"which cgroup the area will be charged is in-deterministic; however, over "
"time, the memory area is likely to end up in a cgroup which has enough "
"memory allowance to avoid high reclaim pressure."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1928
msgid ""
"If a cgroup sweeps a considerable amount of memory which is expected to be "
"accessed repeatedly by other cgroups, it may make sense to use "
"POSIX_FADV_DONTNEED to relinquish the ownership of memory areas belonging to "
"the affected files to ensure correct memory ownership."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1935
msgid "IO"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1937
msgid ""
"The \"io\" controller regulates the distribution of IO resources.  This "
"controller implements both weight based and absolute bandwidth or IOPS limit "
"distribution; however, weight based distribution is available only if cfq-"
"iosched is in use and neither scheme is available for blk-mq devices."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1945
msgid "IO Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1947
#: ../../../admin-guide/cgroup-v2.rst:2251
msgid "io.stat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1950
msgid ""
"Lines are keyed by $MAJ:$MIN device numbers and not ordered. The following "
"nested keys are defined."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1954
msgid "rbytes"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1954
msgid "Bytes read"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1955
msgid "wbytes"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1955
msgid "Bytes written"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1956
msgid "rios"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1956
msgid "Number of read IOs"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1957
msgid "wios"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1957
msgid "Number of write IOs"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1958
msgid "dbytes"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1958
msgid "Bytes discarded"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1959
msgid "dios"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1959
msgid "Number of discard IOs"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1962
#: ../../../admin-guide/cgroup-v2.rst:2078
msgid "An example read output follows::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1967
msgid "io.cost.qos"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1968
#: ../../../admin-guide/cgroup-v2.rst:2023
msgid "A read-write nested-keyed file which exists only on the root cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1971
msgid ""
"This file configures the Quality of Service of the IO cost model based "
"controller (CONFIG_BLK_CGROUP_IOCOST) which currently implements \"io."
"weight\" proportional control.  Lines are keyed by $MAJ:$MIN device numbers "
"and not ordered.  The line for a given device is populated on the first "
"write for the device on \"io.cost.qos\" or \"io.cost.model\".  The following "
"nested keys are defined."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1980
msgid "enable"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1980
msgid "Weight-based control enable"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1981
#: ../../../admin-guide/cgroup-v2.rst:2035
msgid "ctrl"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1981
#: ../../../admin-guide/cgroup-v2.rst:2035
msgid "\"auto\" or \"user\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1982
msgid "rpct"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1982
msgid "Read latency percentile    [0, 100]"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1983
msgid "rlat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1983
msgid "Read latency threshold"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1984
msgid "wpct"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1984
msgid "Write latency percentile   [0, 100]"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1985
msgid "wlat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1985
msgid "Write latency threshold"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1986
msgid "min"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1986
msgid "Minimum scaling percentage [1, 10000]"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1987
msgid "Maximum scaling percentage [1, 10000]"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1990
msgid ""
"The controller is disabled by default and can be enabled by setting "
"\"enable\" to 1.  \"rpct\" and \"wpct\" parameters default to zero and the "
"controller uses internal device saturation state to adjust the overall IO "
"rate between \"min\" and \"max\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:1995
msgid ""
"When a better control quality is needed, latency QoS parameters can be "
"configured.  For example::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2000
msgid ""
"shows that on sdb, the controller is enabled, will consider the device "
"saturated if the 95th percentile of read completion latencies is above 75ms "
"or write 150ms, and adjust the overall IO issue rate between 50% and 150% "
"accordingly."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2005
msgid ""
"The lower the saturation point, the better the latency QoS at the cost of "
"aggregate bandwidth.  The narrower the allowed adjustment range between "
"\"min\" and \"max\", the more conformant to the cost model the IO behavior.  "
"Note that the IO issue base rate may be far off from 100% and setting "
"\"min\" and \"max\" blindly can lead to a significant loss of device "
"capacity or control quality.  \"min\" and \"max\" are useful for regulating "
"devices which show wide temporary behavior changes - e.g. a ssd which "
"accepts writes at the line speed for a while and then completely stalls for "
"multiple seconds."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2016
msgid ""
"When \"ctrl\" is \"auto\", the parameters are controlled by the kernel and "
"may change automatically.  Setting \"ctrl\" to \"user\" or setting any of "
"the percentile and latency parameters puts it into \"user\" mode and "
"disables the automatic changes.  The automatic mode can be restored by "
"setting \"ctrl\" to \"auto\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2022
msgid "io.cost.model"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2026
msgid ""
"This file configures the cost model of the IO cost model based controller "
"(CONFIG_BLK_CGROUP_IOCOST) which currently implements \"io.weight\" "
"proportional control.  Lines are keyed by $MAJ:$MIN device numbers and not "
"ordered.  The line for a given device is populated on the first write for "
"the device on \"io.cost.qos\" or \"io.cost.model\".  The following nested "
"keys are defined."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2036
msgid "model"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2036
msgid "The cost model in use - \"linear\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2039
msgid ""
"When \"ctrl\" is \"auto\", the kernel may change all parameters "
"dynamically.  When \"ctrl\" is set to \"user\" or any other parameters are "
"written to, \"ctrl\" become \"user\" and the automatic changes are disabled."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2044
msgid ""
"When \"model\" is \"linear\", the following model parameters are defined."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2048
msgid "[r|w]bps"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2048
msgid "The maximum sequential IO throughput"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2049
msgid "[r|w]seqiops"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2049
msgid "The maximum 4k sequential IOs per second"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2050
msgid "[r|w]randiops"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2050
msgid "The maximum 4k random IOs per second"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2053
msgid ""
"From the above, the builtin linear model determines the base costs of a "
"sequential and random IO and the cost coefficient for the IO size.  While "
"simple, this model can cover most common device classes acceptably."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2058
msgid ""
"The IO cost model isn't expected to be accurate in absolute sense and is "
"scaled to the device behavior dynamically."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2061
msgid ""
"If needed, tools/cgroup/iocost_coef_gen.py can be used to generate device-"
"specific coefficients."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2064
msgid "io.weight"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2065
msgid ""
"A read-write flat-keyed file which exists on non-root cgroups. The default "
"is \"default 100\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2068
msgid ""
"The first line is the default weight applied to devices without specific "
"override.  The rest are overrides keyed by $MAJ:$MIN device numbers and not "
"ordered.  The weights are in the range [1, 10000] and specifies the relative "
"amount IO time the cgroup can use in relation to its siblings."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2074
msgid ""
"The default weight can be updated by writing either \"default $WEIGHT\" or "
"simply \"$WEIGHT\".  Overrides can be set by writing \"$MAJ:$MIN $WEIGHT\" "
"and unset by writing \"$MAJ:$MIN default\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2084
msgid "io.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2085
msgid "A read-write nested-keyed file which exists on non-root cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2088
msgid ""
"BPS and IOPS based IO limit.  Lines are keyed by $MAJ:$MIN device numbers "
"and not ordered.  The following nested keys are defined."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2093
msgid "rbps"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2093
msgid "Max read bytes per second"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2094
msgid "wbps"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2094
msgid "Max write bytes per second"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2095
msgid "riops"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2095
msgid "Max read IO operations per second"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2096
msgid "wiops"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2096
msgid "Max write IO operations per second"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2099
msgid ""
"When writing, any number of nested key-value pairs can be specified in any "
"order.  \"max\" can be specified as the value to remove a specific limit.  "
"If the same key is specified multiple times, the outcome is undefined."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2104
msgid ""
"BPS and IOPS are measured in each IO direction and IOs are delayed if limit "
"is reached.  Temporary bursts are allowed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2107
msgid "Setting read limit at 2M BPS and write at 120 IOPS for 8:16::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2111
msgid "Reading returns the following::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2115
msgid "Write IOPS limit can be removed by writing the following::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2119
msgid "Reading now returns the following::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2123
msgid "io.pressure"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2126
msgid ""
"Shows pressure stall information for IO. See :ref:`Documentation/accounting/"
"psi.rst <psi>` for details."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2131
msgid "Writeback"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2133
msgid ""
"Page cache is dirtied through buffered writes and shared mmaps and written "
"asynchronously to the backing filesystem by the writeback mechanism.  "
"Writeback sits between the memory and IO domains and regulates the "
"proportion of dirty memory by balancing dirtying and write IOs."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2139
msgid ""
"The io controller, in conjunction with the memory controller, implements "
"control of page cache writeback IOs.  The memory controller defines the "
"memory domain that dirty memory ratio is calculated and maintained for and "
"the io controller defines the io domain which writes out dirty pages for the "
"memory domain.  Both system-wide and per-cgroup dirty memory states are "
"examined and the more restrictive of the two is enforced."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2147
msgid ""
"cgroup writeback requires explicit support from the underlying filesystem.  "
"Currently, cgroup writeback is implemented on ext2, ext4, btrfs, f2fs, and "
"xfs.  On other filesystems, all writeback IOs are attributed to the root "
"cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2152
msgid ""
"There are inherent differences in memory and writeback management which "
"affects how cgroup ownership is tracked.  Memory is tracked per page while "
"writeback per inode.  For the purpose of writeback, an inode is assigned to "
"a cgroup and all IO requests to write dirty pages from the inode are "
"attributed to that cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2158
msgid ""
"As cgroup ownership for memory is tracked per page, there can be pages which "
"are associated with different cgroups than the one the inode is associated "
"with.  These are called foreign pages.  The writeback constantly keeps track "
"of foreign pages and, if a particular foreign cgroup becomes the majority "
"over a certain period of time, switches the ownership of the inode to that "
"cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2165
msgid ""
"While this model is enough for most use cases where a given inode is mostly "
"dirtied by a single cgroup even when the main writing cgroup changes over "
"time, use cases where multiple cgroups write to a single inode "
"simultaneously are not supported well.  In such circumstances, a significant "
"portion of IOs are likely to be attributed incorrectly. As memory controller "
"assigns page ownership on the first use and doesn't update it until the page "
"is released, even if writeback strictly follows page ownership, multiple "
"cgroups dirtying overlapping areas wouldn't work as expected.  It's "
"recommended to avoid such usage patterns."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2176
msgid ""
"The sysctl knobs which affect writeback behavior are applied to cgroup "
"writeback as follows."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2179
msgid "vm.dirty_background_ratio, vm.dirty_ratio"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2180
msgid ""
"These ratios apply the same to cgroup writeback with the amount of available "
"memory capped by limits imposed by the memory controller and system-wide "
"clean memory."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2184
msgid "vm.dirty_background_bytes, vm.dirty_bytes"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2185
msgid ""
"For cgroup writeback, this is calculated into ratio against total available "
"memory and applied the same way as vm.dirty[_background]_ratio."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2191
msgid "IO Latency"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2193
msgid ""
"This is a cgroup v2 controller for IO workload protection.  You provide a "
"group with a latency target, and if the average latency exceeds that target "
"the controller will throttle any peers that have a lower latency target than "
"the protected workload."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2198
msgid ""
"The limits are only applied at the peer level in the hierarchy.  This means "
"that in the diagram below, only groups A, B, and C will influence each "
"other, and groups D and F will influence each other.  Group G will influence "
"nobody::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2209
msgid ""
"So the ideal way to configure this is to set io.latency in groups A, B, and "
"C. Generally you do not want to set a value lower than the latency your "
"device supports.  Experiment to find the value that works best for your "
"workload. Start at higher than the expected latency for your device and "
"watch the avg_lat value in io.stat for your workload group to get an idea of "
"the latency you see during normal operation.  Use the avg_lat value as a "
"basis for your real setting, setting at 10-15% higher than the value in io."
"stat."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2218
msgid "How IO Latency Throttling Works"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2220
msgid ""
"io.latency is work conserving; so as long as everybody is meeting their "
"latency target the controller doesn't do anything.  Once a group starts "
"missing its target it begins throttling any peer group that has a higher "
"target than itself. This throttling takes 2 forms:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2225
msgid ""
"Queue depth throttling.  This is the number of outstanding IO's a group is "
"allowed to have.  We will clamp down relatively quickly, starting at no "
"limit and going all the way down to 1 IO at a time."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2229
msgid ""
"Artificial delay induction.  There are certain types of IO that cannot be "
"throttled without possibly adversely affecting higher priority groups.  This "
"includes swapping and metadata IO.  These types of IO are allowed to occur "
"normally, however they are \"charged\" to the originating group.  If the "
"originating group is being throttled you will see the use_delay and delay "
"fields in io.stat increase.  The delay value is how many microseconds that "
"are being added to any process that runs in this group.  Because this number "
"can grow quite large if there is a lot of swapping or metadata IO occurring "
"we limit the individual delay events to 1 second at a time."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2239
msgid ""
"Once the victimized group starts meeting its latency target again it will "
"start unthrottling any peer groups that were throttled previously.  If the "
"victimized group simply stops doing IO the global counter will unthrottle "
"appropriately."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2244
msgid "IO Latency Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2246
msgid "io.latency"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2247
msgid "This takes a similar format as the other controllers."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2249
msgid "\"MAJOR:MINOR target=<target time in microseconds>\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2252
msgid ""
"If the controller is enabled you will see extra stats in io.stat in addition "
"to the normal ones."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2255
msgid "depth"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2256
msgid "This is the current queue depth for the group."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2258
msgid "avg_lat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2259
msgid ""
"This is an exponential moving average with a decay rate of 1/exp bound by "
"the sampling interval.  The decay rate interval can be calculated by "
"multiplying the win value in io.stat by the corresponding number of samples "
"based on the win value."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2264
msgid "win"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2265
msgid ""
"The sampling window size in milliseconds.  This is the minimum duration of "
"time between evaluation events.  Windows only elapse with IO activity.  Idle "
"periods extend the most recent window."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2270
msgid "IO Priority"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2272
msgid ""
"A single attribute controls the behavior of the I/O priority cgroup policy, "
"namely the io.prio.class attribute. The following values are accepted for "
"that attribute:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2276
#: ../../../admin-guide/cgroup-v2.rst:2300
msgid "no-change"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2277
msgid "Do not modify the I/O priority class."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2279
#: ../../../admin-guide/cgroup-v2.rst:2302
msgid "promote-to-rt"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2280
msgid ""
"For requests that have a non-RT I/O priority class, change it into RT. Also "
"change the priority level of these requests to 4. Do not modify the I/O "
"priority of requests that have priority class RT."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2284
#: ../../../admin-guide/cgroup-v2.rst:2304
msgid "restrict-to-be"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2285
msgid ""
"For requests that do not have an I/O priority class or that have I/O "
"priority class RT, change it into BE. Also change the priority level of "
"these requests to 0. Do not modify the I/O priority class of requests that "
"have priority class IDLE."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2290
#: ../../../admin-guide/cgroup-v2.rst:2306
msgid "idle"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2291
msgid ""
"Change the I/O priority class of all requests into IDLE, the lowest I/O "
"priority class."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2294
msgid "none-to-rt"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2295
msgid "Deprecated. Just an alias for promote-to-rt."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2297
msgid ""
"The following numerical values are associated with the I/O priority policies:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2300
#: ../../../admin-guide/cgroup-v2.rst:2312
msgid "0"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2302
#: ../../../admin-guide/cgroup-v2.rst:2314
msgid "1"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2304
#: ../../../admin-guide/cgroup-v2.rst:2316
msgid "2"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2306
#: ../../../admin-guide/cgroup-v2.rst:2318
msgid "3"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2309
msgid ""
"The numerical value that corresponds to each I/O priority class is as "
"follows:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2312
msgid "IOPRIO_CLASS_NONE"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2314
msgid "IOPRIO_CLASS_RT (real-time)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2316
msgid "IOPRIO_CLASS_BE (best effort)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2318
msgid "IOPRIO_CLASS_IDLE"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2321
msgid ""
"The algorithm to set the I/O priority class for a request is as follows:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2323
msgid ""
"If I/O priority class policy is promote-to-rt, change the request I/O "
"priority class to IOPRIO_CLASS_RT and change the request I/O priority level "
"to 4."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2326
msgid ""
"If I/O priority class policy is not promote-to-rt, translate the I/O "
"priority class policy into a number, then change the request I/O priority "
"class into the maximum of the I/O priority class policy number and the "
"numerical I/O priority class."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2332
msgid "PID"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2334
msgid ""
"The process number controller is used to allow a cgroup to stop any new "
"tasks from being fork()'d or clone()'d after a specified limit is reached."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2338
msgid ""
"The number of tasks in a cgroup can be exhausted in ways which other "
"controllers cannot prevent, thus warranting its own controller.  For "
"example, a fork bomb is likely to exhaust the number of tasks before hitting "
"memory restrictions."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2343
msgid ""
"Note that PIDs used in this controller refer to TIDs, process IDs as used by "
"the kernel."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2348
msgid "PID Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2350
msgid "pids.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2354
msgid "Hard limit of number of processes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2356
msgid "pids.current"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2359
msgid "The number of processes currently in the cgroup and its descendants."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2362
msgid "pids.peak"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2365
msgid ""
"The maximum value that the number of processes in the cgroup and its "
"descendants has ever reached."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2368
msgid "pids.events"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2369
msgid ""
"A read-only flat-keyed file which exists on non-root cgroups. Unless "
"specified otherwise, a value change in this file generates a file modified "
"event. The following entries are defined."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2374
msgid ""
"The number of times the cgroup's total number of processes hit the pids.max "
"limit (see also pids_localevents)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2377
msgid "pids.events.local"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2378
msgid ""
"Similar to pids.events but the fields in the file are local to the cgroup i."
"e. not hierarchical. The file modified event generated on this file reflects "
"only the local events."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2382
msgid ""
"Organisational operations are not blocked by cgroup policies, so it is "
"possible to have pids.current > pids.max.  This can be done by either "
"setting the limit to be smaller than pids.current, or attaching enough "
"processes to the cgroup such that pids.current is larger than pids.max.  "
"However, it is not possible to violate a cgroup PID policy through fork() or "
"clone(). These will return -EAGAIN if the creation of a new process would "
"cause a cgroup policy to be violated."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2392
msgid "Cpuset"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2394
msgid ""
"The \"cpuset\" controller provides a mechanism for constraining the CPU and "
"memory node placement of tasks to only the resources specified in the cpuset "
"interface files in a task's current cgroup. This is especially valuable on "
"large NUMA systems where placing jobs on properly sized subsets of the "
"systems with careful processor and memory placement to reduce cross-node "
"memory access and contention can improve overall system performance."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2402
msgid ""
"The \"cpuset\" controller is hierarchical.  That means the controller cannot "
"use CPUs or memory nodes not allowed in its parent."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2407
msgid "Cpuset Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2409
msgid "cpuset.cpus"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2410
#: ../../../admin-guide/cgroup-v2.rst:2449
#: ../../../admin-guide/cgroup-v2.rst:2499
msgid ""
"A read-write multiple values file which exists on non-root cpuset-enabled "
"cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2413
msgid ""
"It lists the requested CPUs to be used by tasks within this cgroup.  The "
"actual list of CPUs to be granted, however, is subjected to constraints "
"imposed by its parent and can differ from the requested CPUs."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2418
msgid "The CPU numbers are comma-separated numbers or ranges. For example::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2424
msgid ""
"An empty value indicates that the cgroup is using the same setting as the "
"nearest cgroup ancestor with a non-empty \"cpuset.cpus\" or all the "
"available CPUs if none is found."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2428
msgid ""
"The value of \"cpuset.cpus\" stays constant until the next update and won't "
"be affected by any CPU hotplug events."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2431
msgid "cpuset.cpus.effective"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2432
#: ../../../admin-guide/cgroup-v2.rst:2483
msgid ""
"A read-only multiple values file which exists on all cpuset-enabled cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2435
msgid ""
"It lists the onlined CPUs that are actually granted to this cgroup by its "
"parent.  These CPUs are allowed to be used by tasks within the current "
"cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2439
msgid ""
"If \"cpuset.cpus\" is empty, the \"cpuset.cpus.effective\" file shows all "
"the CPUs from the parent cgroup that can be available to be used by this "
"cgroup.  Otherwise, it should be a subset of \"cpuset.cpus\" unless none of "
"the CPUs listed in \"cpuset.cpus\" can be granted.  In this case, it will be "
"treated just like an empty \"cpuset.cpus\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2446
msgid "Its value will be affected by CPU hotplug events."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2448
msgid "cpuset.mems"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2452
msgid ""
"It lists the requested memory nodes to be used by tasks within this cgroup.  "
"The actual list of memory nodes granted, however, is subjected to "
"constraints imposed by its parent and can differ from the requested memory "
"nodes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2457
msgid ""
"The memory node numbers are comma-separated numbers or ranges. For example::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2463
msgid ""
"An empty value indicates that the cgroup is using the same setting as the "
"nearest cgroup ancestor with a non-empty \"cpuset.mems\" or all the "
"available memory nodes if none is found."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2468
msgid ""
"The value of \"cpuset.mems\" stays constant until the next update and won't "
"be affected by any memory nodes hotplug events."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2471
msgid ""
"Setting a non-empty value to \"cpuset.mems\" causes memory of tasks within "
"the cgroup to be migrated to the designated nodes if they are currently "
"using memory outside of the designated nodes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2475
msgid ""
"There is a cost for this memory migration.  The migration may not be "
"complete and some memory pages may be left behind. So it is recommended that "
"\"cpuset.mems\" should be set properly before spawning new tasks into the "
"cpuset.  Even if there is a need to change \"cpuset.mems\" with active "
"tasks, it shouldn't be done frequently."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2482
msgid "cpuset.mems.effective"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2486
msgid ""
"It lists the onlined memory nodes that are actually granted to this cgroup "
"by its parent. These memory nodes are allowed to be used by tasks within the "
"current cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2490
msgid ""
"If \"cpuset.mems\" is empty, it shows all the memory nodes from the parent "
"cgroup that will be available to be used by this cgroup. Otherwise, it "
"should be a subset of \"cpuset.mems\" unless none of the memory nodes listed "
"in \"cpuset.mems\" can be granted.  In this case, it will be treated just "
"like an empty \"cpuset.mems\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2496
msgid "Its value will be affected by memory nodes hotplug events."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2498
msgid "cpuset.cpus.exclusive"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2502
msgid ""
"It lists all the exclusive CPUs that are allowed to be used to create a new "
"cpuset partition.  Its value is not used unless the cgroup becomes a valid "
"partition root.  See the \"cpuset.cpus.partition\" section below for a "
"description of what a cpuset partition is."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2508
msgid ""
"When the cgroup becomes a partition root, the actual exclusive CPUs that are "
"allocated to that partition are listed in \"cpuset.cpus.exclusive."
"effective\" which may be different from \"cpuset.cpus.exclusive\".  If "
"\"cpuset.cpus.exclusive\" has previously been set, \"cpuset.cpus.exclusive."
"effective\" is always a subset of it."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2515
msgid ""
"Users can manually set it to a value that is different from \"cpuset."
"cpus\".  One constraint in setting it is that the list of CPUs must be "
"exclusive with respect to \"cpuset.cpus.exclusive\" of its sibling.  If "
"\"cpuset.cpus.exclusive\" of a sibling cgroup isn't set, its \"cpuset.cpus\" "
"value, if set, cannot be a subset of it to leave at least one CPU available "
"when the exclusive CPUs are taken away."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2523
msgid ""
"For a parent cgroup, any one of its exclusive CPUs can only be distributed "
"to at most one of its child cgroups.  Having an exclusive CPU appearing in "
"two or more of its child cgroups is not allowed (the exclusivity rule).  A "
"value that violates the exclusivity rule will be rejected with a write error."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2529
msgid ""
"The root cgroup is a partition root and all its available CPUs are in its "
"exclusive CPU set."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2532
msgid "cpuset.cpus.exclusive.effective"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2533
msgid ""
"A read-only multiple values file which exists on all non-root cpuset-enabled "
"cgroups."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2536
msgid ""
"This file shows the effective set of exclusive CPUs that can be used to "
"create a partition root.  The content of this file will always be a subset "
"of its parent's \"cpuset.cpus.exclusive.effective\" if its parent is not the "
"root cgroup.  It will also be a subset of \"cpuset.cpus.exclusive\" if it is "
"set.  If \"cpuset.cpus.exclusive\" is not set, it is treated to have an "
"implicit value of \"cpuset.cpus\" in the formation of local partition."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2545
msgid "cpuset.cpus.isolated"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2546
msgid "A read-only and root cgroup only multiple values file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2548
msgid ""
"This file shows the set of all isolated CPUs used in existing isolated "
"partitions. It will be empty if no isolated partition is created."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2552
msgid "cpuset.cpus.partition"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2553
msgid ""
"A read-write single value file which exists on non-root cpuset-enabled "
"cgroups.  This flag is owned by the parent cgroup and is not delegatable."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2557
msgid "It accepts only the following input values when written to."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2560
#: ../../../admin-guide/cgroup-v2.rst:2612
msgid "\"member\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2560
#: ../../../admin-guide/cgroup-v2.rst:2612
msgid "Non-root member of a partition"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2561
#: ../../../admin-guide/cgroup-v2.rst:2613
msgid "\"root\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2561
#: ../../../admin-guide/cgroup-v2.rst:2613
msgid "Partition root"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2562
#: ../../../admin-guide/cgroup-v2.rst:2614
msgid "\"isolated\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2562
#: ../../../admin-guide/cgroup-v2.rst:2614
msgid "Partition root without load balancing"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2565
msgid ""
"A cpuset partition is a collection of cpuset-enabled cgroups with a "
"partition root at the top of the hierarchy and its descendants except those "
"that are separate partition roots themselves and their descendants.  A "
"partition has exclusive access to the set of exclusive CPUs allocated to "
"it.  Other cgroups outside of that partition cannot use any CPUs in that set."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2572
msgid ""
"There are two types of partitions - local and remote.  A local partition is "
"one whose parent cgroup is also a valid partition root.  A remote partition "
"is one whose parent cgroup is not a valid partition root itself.  Writing to "
"\"cpuset.cpus.exclusive\" is optional for the creation of a local partition "
"as its \"cpuset.cpus.exclusive\" file will assume an implicit value that is "
"the same as \"cpuset.cpus\" if it is not set.  Writing the proper \"cpuset."
"cpus.exclusive\" values down the cgroup hierarchy before the target "
"partition root is mandatory for the creation of a remote partition."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2583
msgid ""
"Currently, a remote partition cannot be created under a local partition.  "
"All the ancestors of a remote partition root except the root cgroup cannot "
"be a partition root."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2587
msgid ""
"The root cgroup is always a partition root and its state cannot be changed.  "
"All other non-root cgroups start out as \"member\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2590
msgid ""
"When set to \"root\", the current cgroup is the root of a new partition or "
"scheduling domain.  The set of exclusive CPUs is determined by the value of "
"its \"cpuset.cpus.exclusive.effective\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2594
msgid ""
"When set to \"isolated\", the CPUs in that partition will be in an isolated "
"state without any load balancing from the scheduler and excluded from the "
"unbound workqueues.  Tasks placed in such a partition with multiple CPUs "
"should be carefully distributed and bound to each of the individual CPUs for "
"optimal performance."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2600
msgid ""
"A partition root (\"root\" or \"isolated\") can be in one of the two "
"possible states - valid or invalid.  An invalid partition root is in a "
"degraded state where some state information may be retained, but behaves "
"more like a \"member\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2605
msgid ""
"All possible state transitions among \"member\", \"root\" and \"isolated\" "
"are allowed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2608
msgid ""
"On read, the \"cpuset.cpus.partition\" file can show the following values."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2615
msgid "\"root invalid (<reason>)\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2615
msgid "Invalid partition root"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2616
msgid "\"isolated invalid (<reason>)\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2616
msgid "Invalid isolated partition root"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2619
msgid ""
"In the case of an invalid partition root, a descriptive string on why the "
"partition is invalid is included within parentheses."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2622
msgid ""
"For a local partition root to be valid, the following conditions must be met."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2625
msgid "The parent cgroup is a valid partition root."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2626
msgid ""
"The \"cpuset.cpus.exclusive.effective\" file cannot be empty, though it may "
"contain offline CPUs."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2628
msgid ""
"The \"cpuset.cpus.effective\" cannot be empty unless there is no task "
"associated with this partition."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2631
msgid ""
"For a remote partition root to be valid, all the above conditions except the "
"first one must be met."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2634
msgid ""
"External events like hotplug or changes to \"cpuset.cpus\" or \"cpuset.cpus."
"exclusive\" can cause a valid partition root to become invalid and vice "
"versa.  Note that a task cannot be moved to a cgroup with empty \"cpuset."
"cpus.effective\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2639
msgid ""
"A valid non-root parent partition may distribute out all its CPUs to its "
"child local partitions when there is no task associated with it."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2643
msgid ""
"Care must be taken to change a valid partition root to \"member\" as all its "
"child local partitions, if present, will become invalid causing disruption "
"to tasks running in those child partitions. These inactivated partitions "
"could be recovered if their parent is switched back to a partition root with "
"a proper value in \"cpuset.cpus\" or \"cpuset.cpus.exclusive\"."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2650
msgid ""
"Poll and inotify events are triggered whenever the state of \"cpuset.cpus."
"partition\" changes.  That includes changes caused by write to \"cpuset.cpus."
"partition\", cpu hotplug or other changes that modify the validity status of "
"the partition. This will allow user space agents to monitor unexpected "
"changes to \"cpuset.cpus.partition\" without the need to do continuous "
"polling."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2658
msgid ""
"A user can pre-configure certain CPUs to an isolated state with load "
"balancing disabled at boot time with the \"isolcpus\" kernel boot command "
"line option.  If those CPUs are to be put into a partition, they have to be "
"used in an isolated partition."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2665
msgid "Device controller"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2667
msgid ""
"Device controller manages access to device files. It includes both creation "
"of new device files (using mknod), and access to the existing device files."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2671
msgid ""
"Cgroup v2 device controller has no interface files and is implemented on top "
"of cgroup BPF. To control access to device files, a user may create bpf "
"programs of type BPF_PROG_TYPE_CGROUP_DEVICE and attach them to cgroups with "
"BPF_CGROUP_DEVICE flag. On an attempt to access a device file, corresponding "
"BPF programs will be executed, and depending on the return value the attempt "
"will succeed or fail with -EPERM."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2678
msgid ""
"A BPF_PROG_TYPE_CGROUP_DEVICE program takes a pointer to the "
"bpf_cgroup_dev_ctx structure, which describes the device access attempt: "
"access type (mknod/read/write) and device (type, major and minor numbers). "
"If the program returns 0, the attempt fails with -EPERM, otherwise it "
"succeeds."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2684
msgid ""
"An example of BPF_PROG_TYPE_CGROUP_DEVICE program may be found in tools/"
"testing/selftests/bpf/progs/dev_cgroup.c in the kernel source tree."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2689
msgid "RDMA"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2691
msgid ""
"The \"rdma\" controller regulates the distribution and accounting of RDMA "
"resources."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2695
msgid "RDMA Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2697
msgid "rdma.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2698
msgid ""
"A readwrite nested-keyed file that exists for all the cgroups except root "
"that describes current configured resource limit for a RDMA/IB device."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2702
msgid ""
"Lines are keyed by device name and are not ordered. Each line contains space "
"separated resource name and its configured limit that can be distributed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2709
msgid "hca_handle"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2709
msgid "Maximum number of HCA Handles"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2710
msgid "hca_object"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2710
msgid "Maximum number of HCA Objects"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2713
#: ../../../admin-guide/cgroup-v2.rst:2722
msgid "An example for mlx4 and ocrdma device follows::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2718
msgid "rdma.current"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2719
#: ../../../admin-guide/cgroup-v2.rst:2762
msgid ""
"A read-only file that describes current resource usage. It exists for all "
"the cgroup except root."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2728
msgid "DMEM"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2730
msgid ""
"The \"dmem\" controller regulates the distribution and accounting of device "
"memory regions. Because each memory region may have its own page size, which "
"does not have to be equal to the system page size, the units are always "
"bytes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2735
msgid "DMEM Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2737
msgid "dmem.max, dmem.min, dmem.low"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2738
msgid ""
"A readwrite nested-keyed file that exists for all the cgroups except root "
"that describes current configured resource limit for a region."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2742
#: ../../../admin-guide/cgroup-v2.rst:2756
#: ../../../admin-guide/cgroup-v2.rst:2765
msgid "An example for xe follows::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2747
msgid ""
"The semantics are the same as for the memory cgroup controller, and are "
"calculated in the same way."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2750
msgid "dmem.capacity"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2751
msgid ""
"A read-only file that describes maximum region capacity. It only exists on "
"the root cgroup. Not all memory can be allocated by cgroups, as the kernel "
"reserves some for internal use."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2761
msgid "dmem.current"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2771
msgid "HugeTLB"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2773
msgid ""
"The HugeTLB controller allows to limit the HugeTLB usage per control group "
"and enforces the controller limit during page fault."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2777
msgid "HugeTLB Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2779
msgid "hugetlb.<hugepagesize>.current"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2780
msgid ""
"Show current usage for \"hugepagesize\" hugetlb.  It exists for all the "
"cgroup except root."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2783
msgid "hugetlb.<hugepagesize>.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2784
msgid ""
"Set/show the hard limit of \"hugepagesize\" hugetlb usage. The default value "
"is \"max\".  It exists for all the cgroup except root."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2787
msgid "hugetlb.<hugepagesize>.events"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2791
msgid "The number of allocation failure due to HugeTLB limit"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2793
msgid "hugetlb.<hugepagesize>.events.local"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2794
msgid ""
"Similar to hugetlb.<hugepagesize>.events but the fields in the file are "
"local to the cgroup i.e. not hierarchical. The file modified event generated "
"on this file reflects only the local events."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2798
msgid "hugetlb.<hugepagesize>.numa_stat"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2799
msgid ""
"Similar to memory.numa_stat, it shows the numa information of the hugetlb "
"pages of <hugepagesize> in this cgroup.  Only active in use hugetlb pages "
"are included.  The per-node values are in bytes."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2804
msgid "Misc"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2806
msgid ""
"The Miscellaneous cgroup provides the resource limiting and tracking "
"mechanism for the scalar resources which cannot be abstracted like the other "
"cgroup resources. Controller is enabled by the CONFIG_CGROUP_MISC config "
"option."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2811
msgid ""
"A resource can be added to the controller via enum misc_res_type{} in the "
"include/linux/misc_cgroup.h file and the corresponding name via "
"misc_res_name[] in the kernel/cgroup/misc.c file. Provider of the resource "
"must set its capacity prior to using the resource by calling "
"misc_cg_set_capacity()."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2816
msgid ""
"Once a capacity is set then the resource usage can be updated using charge "
"and uncharge APIs. All of the APIs to interact with misc controller are in "
"include/linux/misc_cgroup.h."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2821
msgid "Misc Interface Files"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2823
msgid ""
"Miscellaneous controller provides 3 interface files. If two misc resources "
"(res_a and res_b) are registered then:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2825
msgid "misc.capacity"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2826
msgid ""
"A read-only flat-keyed file shown only in the root cgroup.  It shows "
"miscellaneous scalar resources available on the platform along with their "
"quantities::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2834
msgid "misc.current"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2835
msgid ""
"A read-only flat-keyed file shown in the all cgroups.  It shows the current "
"usage of the resources in the cgroup and its children.::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2842
msgid "misc.peak"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2843
msgid ""
"A read-only flat-keyed file shown in all cgroups.  It shows the historical "
"maximum usage of the resources in the cgroup and its children.::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2851
msgid "misc.max"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2852
msgid ""
"A read-write flat-keyed file shown in the non root cgroups. Allowed maximum "
"usage of the resources in the cgroup and its children.::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2859
msgid "Limit can be set by::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2863
msgid "Limit can be set to max by::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2867
msgid ""
"Limits can be set higher than the capacity value in the misc.capacity file."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2870
msgid "misc.events"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2871
msgid ""
"A read-only flat-keyed file which exists on non-root cgroups. The following "
"entries are defined. Unless specified otherwise, a value change in this file "
"generates a file modified event. All fields in this file are hierarchical."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2877
msgid ""
"The number of times the cgroup's resource usage was about to go over the max "
"boundary."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2880
msgid "misc.events.local"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2881
msgid ""
"Similar to misc.events but the fields in the file are local to the cgroup i."
"e. not hierarchical. The file modified event generated on this file reflects "
"only the local events."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2886
msgid "Migration and Ownership"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2888
msgid ""
"A miscellaneous scalar resource is charged to the cgroup in which it is used "
"first, and stays charged to that cgroup until that resource is freed. "
"Migrating a process to a different cgroup does not move the charge to the "
"destination cgroup where the process has moved."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2894
msgid "Others"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2897
msgid "perf_event"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2899
msgid ""
"perf_event controller, if not mounted on a legacy hierarchy, is "
"automatically enabled on the v2 hierarchy so that perf events can always be "
"filtered by cgroup v2 path.  The controller can still be moved to a legacy "
"hierarchy after v2 hierarchy is populated."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2906
msgid "Non-normative information"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2908
msgid ""
"This section contains information that isn't considered to be a part of the "
"stable kernel API and so is subject to change."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2913
msgid "CPU controller root cgroup process behaviour"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2915
msgid ""
"When distributing CPU cycles in the root cgroup each thread in this cgroup "
"is treated as if it was hosted in a separate child cgroup of the root "
"cgroup. This child cgroup weight is dependent on its thread nice level."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2920
msgid ""
"For details of this mapping see sched_prio_to_weight array in kernel/sched/"
"core.c file (values from this array should be scaled appropriately so the "
"neutral - nice 0 - value is 100 instead of 1024)."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2926
msgid "IO controller root cgroup process behaviour"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2928
msgid ""
"Root cgroup processes are hosted in an implicit leaf child node. When "
"distributing IO resources this implicit child node is taken into account as "
"if it was a normal child cgroup of the root cgroup with a weight value of "
"200."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2935
msgid "Namespace"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2938
msgid "Basics"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2940
msgid ""
"cgroup namespace provides a mechanism to virtualize the view of the \"/proc/"
"$PID/cgroup\" file and cgroup mounts.  The CLONE_NEWCGROUP clone flag can be "
"used with clone(2) and unshare(2) to create a new cgroup namespace.  The "
"process running inside the cgroup namespace will have its \"/proc/$PID/"
"cgroup\" output restricted to cgroupns root.  The cgroupns root is the "
"cgroup of the process at the time of creation of the cgroup namespace."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2948
msgid ""
"Without cgroup namespace, the \"/proc/$PID/cgroup\" file shows the complete "
"path of the cgroup of a process.  In a container setup where a set of "
"cgroups and namespaces are intended to isolate processes the \"/proc/$PID/"
"cgroup\" file may leak potential system level information to the isolated "
"processes.  For example::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2957
msgid ""
"The path '/batchjobs/container_id1' can be considered as system-data and "
"undesirable to expose to the isolated processes.  cgroup namespace can be "
"used to restrict visibility of this path.  For example, before creating a "
"cgroup namespace, one would see::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2967
msgid "After unsharing a new namespace, the view changes::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2974
msgid ""
"When some thread from a multi-threaded process unshares its cgroup "
"namespace, the new cgroupns gets applied to the entire process (all the "
"threads).  This is natural for the v2 hierarchy; however, for the legacy "
"hierarchies, this may be unexpected."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2979
msgid ""
"A cgroup namespace is alive as long as there are processes inside or mounts "
"pinning it.  When the last usage goes away, the cgroup namespace is "
"destroyed.  The cgroupns root and the actual cgroups remain."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2986
msgid "The Root and Views"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2988
msgid ""
"The 'cgroupns root' for a cgroup namespace is the cgroup in which the "
"process calling unshare(2) is running.  For example, if a process in /"
"batchjobs/container_id1 cgroup calls unshare, cgroup /batchjobs/"
"container_id1 becomes the cgroupns root.  For the init_cgroup_ns, this is "
"the real root ('/') cgroup."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:2994
msgid ""
"The cgroupns root cgroup does not change even if the namespace creator "
"process later moves to a different cgroup::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3005
msgid "Each process gets its namespace-specific view of \"/proc/$PID/cgroup\""
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3007
msgid ""
"Processes running inside the cgroup namespace will be able to see cgroup "
"paths (in /proc/self/cgroup) only inside their root cgroup. From within an "
"unshared cgroupns::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3017
msgid ""
"From the initial cgroup namespace, the real cgroup path will be visible::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3023
msgid ""
"From a sibling cgroup namespace (that is, a namespace rooted at a different "
"cgroup), the cgroup path relative to its own cgroup namespace root will be "
"shown.  For instance, if PID 7353's cgroup namespace root is at '/batchjobs/"
"container_id2', then it will see::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3031
msgid ""
"Note that the relative path always starts with '/' to indicate that its "
"relative to the cgroup namespace root of the caller."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3036
msgid "Migration and setns(2)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3038
msgid ""
"Processes inside a cgroup namespace can move into and out of the namespace "
"root if they have proper access to external cgroups.  For example, from "
"inside a namespace with cgroupns root at /batchjobs/container_id1, and "
"assuming that the global hierarchy is still accessible inside cgroupns::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3050
msgid ""
"Note that this kind of setup is not encouraged.  A task inside cgroup "
"namespace should only be exposed to its own cgroupns hierarchy."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3053
msgid "setns(2) to another cgroup namespace is allowed when:"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3055
msgid "the process has CAP_SYS_ADMIN against its current user namespace"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3056
msgid ""
"the process has CAP_SYS_ADMIN against the target cgroup namespace's userns"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3059
msgid ""
"No implicit cgroup changes happen with attaching to another cgroup "
"namespace.  It is expected that the someone moves the attaching process "
"under the target cgroup namespace root."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3065
msgid "Interaction with Other Namespaces"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3067
msgid ""
"Namespace specific cgroup hierarchy can be mounted by a process running "
"inside a non-init cgroup namespace::"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3072
msgid ""
"This will mount the unified cgroup hierarchy with cgroupns root as the "
"filesystem root.  The process needs CAP_SYS_ADMIN against its user and mount "
"namespaces."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3076
msgid ""
"The virtualization of /proc/self/cgroup file combined with restricting the "
"view of cgroup hierarchy by namespace-private cgroupfs mount provides a "
"properly isolated cgroup view inside the container."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3082
msgid "Information on Kernel Programming"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3084
msgid ""
"This section contains kernel programming information in the areas where "
"interacting with cgroup is necessary.  cgroup core and controllers are not "
"covered."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3090
msgid "Filesystem Support for Writeback"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3092
msgid ""
"A filesystem can support cgroup writeback by updating "
"address_space_operations->writepages() to annotate bio's using the following "
"two functions."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3096
msgid "wbc_init_bio(@wbc, @bio)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3097
msgid ""
"Should be called for each bio carrying writeback data and associates the bio "
"with the inode's owner cgroup and the corresponding request queue.  This "
"must be called after a queue (device) has been associated with the bio and "
"before submission."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3103
msgid "wbc_account_cgroup_owner(@wbc, @folio, @bytes)"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3104
msgid ""
"Should be called for each data segment being written out. While this "
"function doesn't care exactly when it's called during the writeback session, "
"it's the easiest and most natural to call it as data segments are added to a "
"bio."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3109
msgid ""
"With writeback bio's annotated, cgroup support can be enabled per "
"super_block by setting SB_I_CGROUPWB in ->s_iflags.  This allows for "
"selective disabling of cgroup writeback support which is helpful when "
"certain filesystem features, e.g. journaled data mode, are incompatible."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3115
msgid ""
"wbc_init_bio() binds the specified bio to its cgroup.  Depending on the "
"configuration, the bio may be executed at a lower priority and if the "
"writeback session is holding shared resources, e.g. a journal entry, may "
"lead to priority inversion.  There is no one easy solution for the problem.  "
"Filesystems can try to work around specific problem cases by skipping "
"wbc_init_bio() and using bio_associate_blkg() directly."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3125
msgid "Deprecated v1 Core Features"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3127
msgid "Multiple hierarchies including named ones are not supported."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3129
msgid "All v1 mount options are not supported."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3131
msgid "The \"tasks\" file is removed and \"cgroup.procs\" is not sorted."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3133
msgid "\"cgroup.clone_children\" is removed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3135
msgid ""
"/proc/cgroups is meaningless for v2.  Use \"cgroup.controllers\" or \"cgroup."
"stat\" files at the root instead."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3140
msgid "Issues with v1 and Rationales for v2"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3143
msgid "Multiple Hierarchies"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3145
msgid ""
"cgroup v1 allowed an arbitrary number of hierarchies and each hierarchy "
"could host any number of controllers.  While this seemed to provide a high "
"level of flexibility, it wasn't useful in practice."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3149
msgid ""
"For example, as there is only one instance of each controller, utility type "
"controllers such as freezer which can be useful in all hierarchies could "
"only be used in one.  The issue is exacerbated by the fact that controllers "
"couldn't be moved to another hierarchy once hierarchies were populated.  "
"Another issue was that all controllers bound to a hierarchy were forced to "
"have exactly the same view of the hierarchy.  It wasn't possible to vary the "
"granularity depending on the specific controller."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3158
msgid ""
"In practice, these issues heavily limited which controllers could be put on "
"the same hierarchy and most configurations resorted to putting each "
"controller on its own hierarchy.  Only closely related ones, such as the cpu "
"and cpuacct controllers, made sense to be put on the same hierarchy.  This "
"often meant that userland ended up managing multiple similar hierarchies "
"repeating the same steps on each hierarchy whenever a hierarchy management "
"operation was necessary."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3166
msgid ""
"Furthermore, support for multiple hierarchies came at a steep cost. It "
"greatly complicated cgroup core implementation but more importantly the "
"support for multiple hierarchies restricted how cgroup could be used in "
"general and what controllers was able to do."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3171
msgid ""
"There was no limit on how many hierarchies there might be, which meant that "
"a thread's cgroup membership couldn't be described in finite length.  The "
"key might contain any number of entries and was unlimited in length, which "
"made it highly awkward to manipulate and led to addition of controllers "
"which existed only to identify membership, which in turn exacerbated the "
"original problem of proliferating number of hierarchies."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3179
msgid ""
"Also, as a controller couldn't have any expectation regarding the topologies "
"of hierarchies other controllers might be on, each controller had to assume "
"that all other controllers were attached to completely orthogonal "
"hierarchies.  This made it impossible, or at least very cumbersome, for "
"controllers to cooperate with each other."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3185
msgid ""
"In most use cases, putting controllers on hierarchies which are completely "
"orthogonal to each other isn't necessary.  What usually is called for is the "
"ability to have differing levels of granularity depending on the specific "
"controller.  In other words, hierarchy may be collapsed from leaf towards "
"root when viewed from specific controllers.  For example, a given "
"configuration might not care about how memory is distributed beyond a "
"certain level while still wanting to control how CPU cycles are distributed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3196
msgid "Thread Granularity"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3198
msgid ""
"cgroup v1 allowed threads of a process to belong to different cgroups. This "
"didn't make sense for some controllers and those controllers ended up "
"implementing different ways to ignore such situations but much more "
"importantly it blurred the line between API exposed to individual "
"applications and system management interface."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3204
msgid ""
"Generally, in-process knowledge is available only to the process itself; "
"thus, unlike service-level organization of processes, categorizing threads "
"of a process requires active participation from the application which owns "
"the target process."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3209
msgid ""
"cgroup v1 had an ambiguously defined delegation model which got abused in "
"combination with thread granularity.  cgroups were delegated to individual "
"applications so that they can create and manage their own sub-hierarchies "
"and control resource distributions along them.  This effectively raised "
"cgroup to the status of a syscall-like API exposed to lay programs."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3216
msgid ""
"First of all, cgroup has a fundamentally inadequate interface to be exposed "
"this way.  For a process to access its own knobs, it has to extract the path "
"on the target hierarchy from /proc/self/cgroup, construct the path by "
"appending the name of the knob to the path, open and then read and/or write "
"to it.  This is not only extremely clunky and unusual but also inherently "
"racy.  There is no conventional way to define transaction across the "
"required steps and nothing can guarantee that the process would actually be "
"operating on its own sub-hierarchy."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3225
msgid ""
"cgroup controllers implemented a number of knobs which would never be "
"accepted as public APIs because they were just adding control knobs to "
"system-management pseudo filesystem.  cgroup ended up with interface knobs "
"which were not properly abstracted or refined and directly revealed kernel "
"internal details.  These knobs got exposed to individual applications "
"through the ill-defined delegation mechanism effectively abusing cgroup as a "
"shortcut to implementing public APIs without going through the required "
"scrutiny."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3234
msgid ""
"This was painful for both userland and kernel.  Userland ended up with "
"misbehaving and poorly abstracted interfaces and kernel exposing and locked "
"into constructs inadvertently."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3240
msgid "Competition Between Inner Nodes and Threads"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3242
msgid ""
"cgroup v1 allowed threads to be in any cgroups which created an interesting "
"problem where threads belonging to a parent cgroup and its children cgroups "
"competed for resources.  This was nasty as two different types of entities "
"competed and there was no obvious way to settle it.  Different controllers "
"did different things."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3248
msgid ""
"The cpu controller considered threads and cgroups as equivalents and mapped "
"nice levels to cgroup weights.  This worked for some cases but fell flat "
"when children wanted to be allocated specific ratios of CPU cycles and the "
"number of internal threads fluctuated - the ratios constantly changed as the "
"number of competing entities fluctuated. There also were other issues.  The "
"mapping from nice level to weight wasn't obvious or universal, and there "
"were various other knobs which simply weren't available for threads."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3257
msgid ""
"The io controller implicitly created a hidden leaf node for each cgroup to "
"host the threads.  The hidden leaf had its own copies of all the knobs with "
"``leaf_`` prefixed.  While this allowed equivalent control over internal "
"threads, it was with serious drawbacks.  It always added an extra layer of "
"nesting which wouldn't be necessary otherwise, made the interface messy and "
"significantly complicated the implementation."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3265
msgid ""
"The memory controller didn't have a way to control what happened between "
"internal tasks and child cgroups and the behavior was not clearly defined.  "
"There were attempts to add ad-hoc behaviors and knobs to tailor the behavior "
"to specific workloads which would have led to problems extremely difficult "
"to resolve in the long term."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3271
msgid ""
"Multiple controllers struggled with internal tasks and came up with "
"different ways to deal with it; unfortunately, all the approaches were "
"severely flawed and, furthermore, the widely different behaviors made cgroup "
"as a whole highly inconsistent."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3276
msgid ""
"This clearly is a problem which needs to be addressed from cgroup core in a "
"uniform way."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3281
msgid "Other Interface Issues"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3283
msgid ""
"cgroup v1 grew without oversight and developed a large number of "
"idiosyncrasies and inconsistencies.  One issue on the cgroup core side was "
"how an empty cgroup was notified - a userland helper binary was forked and "
"executed for each event.  The event delivery wasn't recursive or "
"delegatable.  The limitations of the mechanism also led to in-kernel event "
"delivery filtering mechanism further complicating the interface."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3291
msgid ""
"Controller interfaces were problematic too.  An extreme example is "
"controllers completely ignoring hierarchical organization and treating all "
"cgroups as if they were all located directly under the root cgroup.  Some "
"controllers exposed a large amount of inconsistent implementation details to "
"userland."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3297
msgid ""
"There also was no consistency across controllers.  When a new cgroup was "
"created, some controllers defaulted to not imposing extra restrictions while "
"others disallowed any resource usage until explicitly configured.  "
"Configuration knobs for the same type of control used widely differing "
"naming schemes and formats.  Statistics and information knobs were named "
"arbitrarily and used different formats and units even in the same controller."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3305
msgid ""
"cgroup v2 establishes common conventions where appropriate and updates "
"controllers so that they expose minimal and consistent interfaces."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3310
msgid "Controller Issues and Remedies"
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3315
msgid ""
"The original lower boundary, the soft limit, is defined as a limit that is "
"per default unset.  As a result, the set of cgroups that global reclaim "
"prefers is opt-in, rather than opt-out.  The costs for optimizing these "
"mostly negative lookups are so high that the implementation, despite its "
"enormous size, does not even provide the basic desirable behavior.  First "
"off, the soft limit has no hierarchical meaning.  All configured groups are "
"organized in a global rbtree and treated like equal peers, regardless where "
"they are located in the hierarchy.  This makes subtree delegation "
"impossible.  Second, the soft limit reclaim pass is so aggressive that it "
"not just introduces high allocation latencies into the system, but also "
"impacts system performance due to overreclaim, to the point where the "
"feature becomes self-defeating."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3329
msgid ""
"The memory.low boundary on the other hand is a top-down allocated reserve.  "
"A cgroup enjoys reclaim protection when it's within its effective low, which "
"makes delegation of subtrees possible. It also enjoys having reclaim "
"pressure proportional to its overage when above its effective low."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3335
msgid ""
"The original high boundary, the hard limit, is defined as a strict limit "
"that can not budge, even if the OOM killer has to be called. But this "
"generally goes against the goal of making the most out of the available "
"memory.  The memory consumption of workloads varies during runtime, and that "
"requires users to overcommit.  But doing that with a strict upper limit "
"requires either a fairly accurate prediction of the working set size or "
"adding slack to the limit.  Since working set size estimation is hard and "
"error prone, and getting it wrong results in OOM kills, most users tend to "
"err on the side of a looser limit and end up wasting precious resources."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3346
msgid ""
"The memory.high boundary on the other hand can be set much more "
"conservatively.  When hit, it throttles allocations by forcing them into "
"direct reclaim to work off the excess, but it never invokes the OOM killer.  "
"As a result, a high boundary that is chosen too aggressively will not "
"terminate the processes, but instead it will lead to gradual performance "
"degradation.  The user can monitor this and make corrections until the "
"minimal memory footprint that still gives acceptable performance is found."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3355
msgid ""
"In extreme cases, with many concurrent allocations and a complete breakdown "
"of reclaim progress within the group, the high boundary can be exceeded.  "
"But even then it's mostly better to satisfy the allocation from the slack "
"available in other groups or the rest of the system than killing the group.  "
"Otherwise, memory.max is there to limit this type of spillover and "
"ultimately contain buggy or even malicious applications."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3363
msgid ""
"Setting the original memory.limit_in_bytes below the current usage was "
"subject to a race condition, where concurrent charges could cause the limit "
"setting to fail. memory.max on the other hand will first set the limit to "
"prevent new charges, and then reclaim and OOM kill until the new limit is "
"met - or the task writing to memory.max is killed."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3369
msgid ""
"The combined memory+swap accounting and limiting is replaced by real control "
"over swap space."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3372
msgid ""
"The main argument for a combined memory+swap facility in the original cgroup "
"design was that global or parental pressure would always be able to swap all "
"anonymous memory of a child group, regardless of the child's own (possibly "
"untrusted) configuration.  However, untrusted groups can sabotage swapping "
"by other means - such as referencing its anonymous memory in a tight loop - "
"and an admin can not assume full swappability when overcommitting untrusted "
"jobs."
msgstr ""

#: ../../../admin-guide/cgroup-v2.rst:3380
msgid ""
"For trusted jobs, on the other hand, a combined counter is not an intuitive "
"userspace interface, and it flies in the face of the idea that cgroup "
"controllers should account and limit specific physical resources.  Swap "
"space is a resource like all others in the system, and that's why unified "
"hierarchy allows distributing it separately."
msgstr ""
