<!DOCTYPE html>

<html lang="zh-TW" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Memory hotplug &#8212; The Linux Kernel  說明文件</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=adfc0c0d" />
    <script src="../_static/documentation_options.js?v=0d9984b1"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=cbf116e0"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/linux-docs-l10n/core-api/memory-hotplug.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜尋" href="../search.html" />
    <link rel="next" title="Linux generic IRQ handling" href="genericirq.html" />
    <link rel="prev" title="CPU hotplug in the Kernel" href="cpu_hotplug.html" />

   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

<script type="text/javascript" src="../ltd-provenance.js"></script>
<script type="text/javascript" src="../ltd-current.js"></script>
<script type="text/javascript" src="../../../ltd-config.js"></script>
<script type="text/javascript" src="../../../ltd-flyout.js"></script>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo of The Linux Kernel"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.18.0-rc2</p>







<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜尋</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="前往" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>


<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">提交補釘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">行為守則</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">維護者手冊</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">核心 API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#core-utilities">Core utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#data-structures-and-low-level-utilities">Data structures and low-level utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#low-level-entry-and-exit">Low level entry and exit</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#concurrency-primitives">Concurrency primitives</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#low-level-hardware-management">Low-level hardware management</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="cachetlb.html">Cache and TLB Flushing Under Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="cpu_hotplug.html">CPU hotplug in the Kernel</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Memory hotplug</a></li>
<li class="toctree-l3"><a class="reference internal" href="genericirq.html">Linux generic IRQ handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="protection-keys.html">Memory Protection Keys</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#memory-management">Memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interfaces-for-kernel-debugging">Interfaces for kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#everything-else">Everything else</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">子系統</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="index.html">核心 API 文件</a></li>
<li class="toctree-l3"><a class="reference internal" href="../driver-api/index.html">Driver implementer's API guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mm/index.html">記憶體管理文件</a></li>
<li class="toctree-l3"><a class="reference internal" href="../power/index.html">電源管理</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scheduler/index.html">Scheduler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../timers/index.html">計時器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">Other subsystems</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">撰寫文件</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">開發工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">測試指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">建置系統</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">回報議題</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">使用者空間工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">使用者空間 API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">韌體</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">韌體與裝置樹</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU 架構</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">未排序的文件</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>本頁</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/core-api/memory-hotplug.rst.txt"
            rel="nofollow">顯示原始碼</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="memory-hotplug">
<span id="id1"></span><h1>Memory hotplug<a class="headerlink" href="#memory-hotplug" title="連結到這個標頭">¶</a></h1>
<section id="memory-hotplug-event-notifier">
<h2>Memory hotplug event notifier<a class="headerlink" href="#memory-hotplug-event-notifier" title="連結到這個標頭">¶</a></h2>
<p>Hotplugging events are sent to a notification queue.</p>
<section id="memory-notifier">
<h3>Memory notifier<a class="headerlink" href="#memory-notifier" title="連結到這個標頭">¶</a></h3>
<p>There are six types of notification defined in <code class="docutils literal notranslate"><span class="pre">include/linux/memory.h</span></code>:</p>
<dl class="simple">
<dt>MEM_GOING_ONLINE</dt><dd><p>Generated before new memory becomes available in order to be able to
prepare subsystems to handle memory. The page allocator is still unable
to allocate from the new memory.</p>
</dd>
<dt>MEM_CANCEL_ONLINE</dt><dd><p>Generated if MEM_GOING_ONLINE fails.</p>
</dd>
<dt>MEM_ONLINE</dt><dd><p>Generated when memory has successfully brought online. The callback may
allocate pages from the new memory.</p>
</dd>
<dt>MEM_GOING_OFFLINE</dt><dd><p>Generated to begin the process of offlining memory. Allocations are no
longer possible from the memory but some of the memory to be offlined
is still in use. The callback can be used to free memory known to a
subsystem from the indicated memory block.</p>
</dd>
<dt>MEM_CANCEL_OFFLINE</dt><dd><p>Generated if MEM_GOING_OFFLINE fails. Memory is available again from
the memory block that we attempted to offline.</p>
</dd>
<dt>MEM_OFFLINE</dt><dd><p>Generated after offlining memory is complete.</p>
</dd>
</dl>
<p>A callback routine can be registered by calling:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>hotplug_memory_notifier(callback_func, priority)
</pre></div>
</div>
<p>Callback functions with higher values of priority are called before callback
functions with lower values.</p>
<p>A callback function must have the following prototype:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int callback_func(
  struct notifier_block *self, unsigned long action, void *arg);
</pre></div>
</div>
<p>The first argument of the callback function (self) is a pointer to the block
of the notifier chain that points to the callback function itself.
The second argument (action) is one of the event types described above.
The third argument (arg) passes a pointer of <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">memory_notify</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct memory_notify {
        unsigned long start_pfn;
        unsigned long nr_pages;
}
</pre></div>
</div>
<ul class="simple">
<li><p>start_pfn is start_pfn of online/offline memory.</p></li>
<li><p>nr_pages is # of pages of online/offline memory.</p></li>
</ul>
<p>It is possible to get notified for MEM_CANCEL_ONLINE without having been notified
for MEM_GOING_ONLINE, and the same applies to MEM_CANCEL_OFFLINE and
MEM_GOING_OFFLINE.
This can happen when a consumer fails, meaning we break the callchain and we
stop calling the remaining consumers of the notifier.
It is then important that users of memory_notify make no assumptions and get
prepared to handle such cases.</p>
<p>The callback routine shall return one of the values
NOTIFY_DONE, NOTIFY_OK, NOTIFY_BAD, NOTIFY_STOP
defined in <code class="docutils literal notranslate"><span class="pre">include/linux/notifier.h</span></code></p>
<p>NOTIFY_DONE and NOTIFY_OK have no effect on the further processing.</p>
<p>NOTIFY_BAD is used as response to the MEM_GOING_ONLINE, MEM_GOING_OFFLINE,
MEM_ONLINE, or MEM_OFFLINE action to cancel hotplugging. It stops
further processing of the notification queue.</p>
<p>NOTIFY_STOP stops further processing of the notification queue.</p>
</section>
<section id="numa-node-notifier">
<h3>Numa node notifier<a class="headerlink" href="#numa-node-notifier" title="連結到這個標頭">¶</a></h3>
<p>There are six types of notification defined in <code class="docutils literal notranslate"><span class="pre">include/linux/node.h</span></code>:</p>
<dl class="simple">
<dt>NODE_ADDING_FIRST_MEMORY</dt><dd><p>Generated before memory becomes available to this node for the first time.</p>
</dd>
<dt>NODE_CANCEL_ADDING_FIRST_MEMORY</dt><dd><p>Generated if NODE_ADDING_FIRST_MEMORY fails.</p>
</dd>
<dt>NODE_ADDED_FIRST_MEMORY</dt><dd><p>Generated when memory has become available fo this node for the first time.</p>
</dd>
<dt>NODE_REMOVING_LAST_MEMORY</dt><dd><p>Generated when the last memory available to this node is about to be offlined.</p>
</dd>
<dt>NODE_CANCEL_REMOVING_LAST_MEMORY</dt><dd><p>Generated when NODE_CANCEL_REMOVING_LAST_MEMORY fails.</p>
</dd>
<dt>NODE_REMOVED_LAST_MEMORY</dt><dd><p>Generated when the last memory available to this node has been offlined.</p>
</dd>
</dl>
<p>A callback routine can be registered by calling:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>hotplug_node_notifier(callback_func, priority)
</pre></div>
</div>
<p>Callback functions with higher values of priority are called before callback
functions with lower values.</p>
<p>A callback function must have the following prototype:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int callback_func(

  struct notifier_block *self, unsigned long action, void *arg);
</pre></div>
</div>
<p>The first argument of the callback function (self) is a pointer to the block
of the notifier chain that points to the callback function itself.
The second argument (action) is one of the event types described above.
The third argument (arg) passes a pointer of <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">node_notify</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct node_notify {
        int nid;
}
</pre></div>
</div>
<ul class="simple">
<li><p>nid is the node we are adding or removing memory to.</p></li>
</ul>
<p>It is possible to get notified for NODE_CANCEL_ADDING_FIRST_MEMORY without
having been notified for NODE_ADDING_FIRST_MEMORY, and the same applies to
NODE_CANCEL_REMOVING_LAST_MEMORY and NODE_REMOVING_LAST_MEMORY.
This can happen when a consumer fails, meaning we break the callchain and we
stop calling the remaining consumers of the notifier.
It is then important that users of node_notify make no assumptions and get
prepared to handle such cases.</p>
<p>The callback routine shall return one of the values
NOTIFY_DONE, NOTIFY_OK, NOTIFY_BAD, NOTIFY_STOP
defined in <code class="docutils literal notranslate"><span class="pre">include/linux/notifier.h</span></code></p>
<p>NOTIFY_DONE and NOTIFY_OK have no effect on the further processing.</p>
<p>NOTIFY_BAD is used as response to the NODE_ADDING_FIRST_MEMORY,
NODE_REMOVING_LAST_MEMORY, NODE_ADDED_FIRST_MEMORY or
NODE_REMOVED_LAST_MEMORY action to cancel hotplugging.
It stops further processing of the notification queue.</p>
<p>NOTIFY_STOP stops further processing of the notification queue.</p>
<p>Please note that we should not fail for NODE_ADDED_FIRST_MEMORY /
NODE_REMOVED_FIRST_MEMORY, as memory_hotplug code cannot rollback at that
point anymore.</p>
</section>
</section>
<section id="locking-internals">
<h2>Locking Internals<a class="headerlink" href="#locking-internals" title="連結到這個標頭">¶</a></h2>
<p>When adding/removing memory that uses memory block devices (i.e. ordinary RAM),
the device_hotplug_lock should be held to:</p>
<ul class="simple">
<li><p>synchronize against online/offline requests (e.g. via sysfs). This way, memory
block devices can only be accessed (.online/.state attributes) by user
space once memory has been fully added. And when removing memory, we
know nobody is in critical sections.</p></li>
<li><p>synchronize against CPU hotplug and similar (e.g. relevant for ACPI and PPC)</p></li>
</ul>
<p>Especially, there is a possible lock inversion that is avoided using
device_hotplug_lock when adding memory and user space tries to online that
memory faster than expected:</p>
<ul class="simple">
<li><p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">device_online()</span></code> will first take the <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">device_lock()</span></code>, followed by
mem_hotplug_lock</p></li>
<li><p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">add_memory_resource()</span></code> will first take the mem_hotplug_lock, followed by
the <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">device_lock()</span></code> (while creating the devices, during <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">bus_add_device()</span></code>).</p></li>
</ul>
<p>As the device is visible to user space before taking the <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">device_lock()</span></code>, this
can result in a lock inversion.</p>
<p>onlining/offlining of memory should be done via <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">device_online()</span></code>/
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">device_offline()</span></code> - to make sure it is properly synchronized to actions
via sysfs. Holding device_hotplug_lock is advised (to e.g. protect online_type)</p>
<p>When adding/removing/onlining/offlining memory or adding/removing
heterogeneous/device memory, we should always hold the mem_hotplug_lock in
write mode to serialise memory hotplug (e.g. access to global/zone
variables).</p>
<p>In addition, mem_hotplug_lock (in contrast to device_hotplug_lock) in read
mode allows for a quite efficient get_online_mems/put_online_mems
implementation, so code accessing memory can protect from that memory
vanishing.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;The kernel development community.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/core-api/memory-hotplug.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>