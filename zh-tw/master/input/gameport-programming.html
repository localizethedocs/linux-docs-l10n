<!DOCTYPE html>

<html lang="zh-TW" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>2. Programming gameport drivers &#8212; The Linux Kernel unknown version 說明文件</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=adfc0c0d" />
    <script src="../_static/documentation_options.js?v=b446b479"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=cbf116e0"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/linux-docs-l10n/input/gameport-programming.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜尋" href="../search.html" />
    <link rel="next" title="3. Keyboard notifier" href="notifier.html" />
    <link rel="prev" title="1. Creating an input device driver" href="input-programming.html" />

   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

<script type="text/javascript" src="../ltd-provenance.js"></script>
<script type="text/javascript" src="../ltd-current.js"></script>
<script type="text/javascript" src="../../../ltd-config.js"></script>
<script type="text/javascript" src="../../../ltd-flyout.js"></script>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo of The Linux Kernel"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.19.0</p>







<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜尋</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="前往" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>


<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">提交補釘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">行為守則</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">維護者手冊</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">核心 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">子系統</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="index.html">輸入文件</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hid/index.html">Human Interface Devices (HID)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../sound/index.html">Sound Subsystem Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../gpu/index.html">GPU Driver Developer's Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../fb/index.html">Frame Buffer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../leds/index.html">LEDs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">其他子系統</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">撰寫文件</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">開發工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">測試指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">即時補釘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">建置系統</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">回報議題</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">使用者空間工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">使用者空間 API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">韌體</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">韌體與裝置樹</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU 架構</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">未排序的文件</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>本頁</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/input/gameport-programming.rst.txt"
            rel="nofollow">顯示原始碼</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="programming-gameport-drivers">
<h1><span class="section-number">2. </span>Programming gameport drivers<a class="headerlink" href="#programming-gameport-drivers" title="連結到這個標頭">¶</a></h1>
<section id="a-basic-classic-gameport">
<h2><span class="section-number">2.1. </span>A basic classic gameport<a class="headerlink" href="#a-basic-classic-gameport" title="連結到這個標頭">¶</a></h2>
<p>If the gameport doesn't provide more than the <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">inb()</span></code>/<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">outb()</span></code> functionality,
the code needed to register it with the joystick drivers is simple:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gameport gameport;

gameport.io = MY_IO_ADDRESS;
gameport_register_port(&amp;gameport);
</pre></div>
</div>
<p>Make sure <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">gameport</span></code> is initialized to 0 in all other fields. The
gameport generic code will take care of the rest.</p>
<p>If your hardware supports more than one io address, and your driver can
choose which one to program the hardware to, starting from the more exotic
addresses is preferred, because the likelihood of clashing with the standard
0x201 address is smaller.</p>
<p>E.g. if your driver supports addresses 0x200, 0x208, 0x210 and 0x218, then
0x218 would be the address of first choice.</p>
<p>If your hardware supports a gameport address that is not mapped to ISA io
space (is above 0x1000), use that one, and don't map the ISA mirror.</p>
<p>Also, always <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">request_region()</span></code> on the whole io space occupied by the
gameport. Although only one ioport is really used, the gameport usually
occupies from one to sixteen addresses in the io space.</p>
<p>Please also consider enabling the gameport on the card in the -&gt;open()
callback if the io is mapped to ISA space - this way it'll occupy the io
space only when something really is using it. Disable it again in the
-&gt;close() callback. You also can select the io address in the -&gt;open()
callback, so that it doesn't fail if some of the possible addresses are
already occupied by other gameports.</p>
</section>
<section id="memory-mapped-gameport">
<h2><span class="section-number">2.2. </span>Memory mapped gameport<a class="headerlink" href="#memory-mapped-gameport" title="連結到這個標頭">¶</a></h2>
<p>When a gameport can be accessed through MMIO, this way is preferred, because
it is faster, allowing more reads per second. Registering such a gameport
isn't as easy as a basic IO one, but not so much complex:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gameport gameport;

void my_trigger(struct gameport *gameport)
{
        my_mmio = 0xff;
}

unsigned char my_read(struct gameport *gameport)
{
        return my_mmio;
}

gameport.read = my_read;
gameport.trigger = my_trigger;
gameport_register_port(&amp;gameport);
</pre></div>
</div>
</section>
<section id="cooked-mode-gameport">
<span id="gameport-pgm-cooked-mode"></span><h2><span class="section-number">2.3. </span>Cooked mode gameport<a class="headerlink" href="#cooked-mode-gameport" title="連結到這個標頭">¶</a></h2>
<p>There are gameports that can report the axis values as numbers, that means
the driver doesn't have to measure them the old way - an ADC is built into
the gameport. To register a cooked gameport:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gameport gameport;

int my_cooked_read(struct gameport *gameport, int *axes, int *buttons)
{
        int i;

        for (i = 0; i &lt; 4; i++)
                axes[i] = my_mmio[i];
        buttons[0] = my_mmio[4];
}

int my_open(struct gameport *gameport, int mode)
{
        return -(mode != GAMEPORT_MODE_COOKED);
}

gameport.cooked_read = my_cooked_read;
gameport.open = my_open;
gameport.fuzz = 8;
gameport_register_port(&amp;gameport);
</pre></div>
</div>
<p>The only confusing thing here is the fuzz value. Best determined by
experimentation, it is the amount of noise in the ADC data. Perfect
gameports can set this to zero, most common have fuzz between 8 and 32.
See analog.c and input.c for handling of fuzz - the fuzz value determines
the size of a gaussian filter window that is used to eliminate the noise
in the data.</p>
</section>
<section id="more-complex-gameports">
<h2><span class="section-number">2.4. </span>More complex gameports<a class="headerlink" href="#more-complex-gameports" title="連結到這個標頭">¶</a></h2>
<p>Gameports can support both raw and cooked modes. In that case combine either
examples 1+2 or 1+3. Gameports can support internal calibration - see below,
and also lightning.c and analog.c on how that works. If your driver supports
more than one gameport instance simultaneously, use the -&gt;private member of
the gameport <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">to</span></code> point to your data.</p>
</section>
<section id="unregistering-a-gameport">
<h2><span class="section-number">2.5. </span>Unregistering a gameport<a class="headerlink" href="#unregistering-a-gameport" title="連結到這個標頭">¶</a></h2>
<p>Simple:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>gameport_unregister_port(&amp;gameport);
</pre></div>
</div>
</section>
<section id="the-gameport-structure">
<h2><span class="section-number">2.6. </span>The gameport structure<a class="headerlink" href="#the-gameport-structure" title="連結到這個標頭">¶</a></h2>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct gameport {

    void *port_data;
</pre></div>
</div>
<p>A private pointer for free use in the gameport driver. (Not the joystick
driver!)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>char name[32];
</pre></div>
</div>
<p>Driver's name as set by driver calling <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">gameport_set_name()</span></code>. Informational
purpose only.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>char phys[32];
</pre></div>
</div>
<p>gameport's physical name/description as set by driver calling <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">gameport_set_phys()</span></code>.
Informational purpose only.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int io;
</pre></div>
</div>
<p>I/O address for use with raw mode. You have to either set this, or -&gt;read()
to some value if your gameport supports raw mode.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int speed;
</pre></div>
</div>
<p>Raw mode speed of the gameport reads in thousands of reads per second.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int fuzz;
</pre></div>
</div>
<p>If the gameport supports cooked mode, this should be set to a value that
represents the amount of noise in the data. See
<a class="reference internal" href="#gameport-pgm-cooked-mode"><span class="std std-ref">Cooked mode gameport</span></a>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*trigger)(struct gameport *);
</pre></div>
</div>
<p>Trigger. This function should trigger the ns558 oneshots. If set to NULL,
outb(0xff, io) will be used.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>unsigned char (*read)(struct gameport *);
</pre></div>
</div>
<p>Read the buttons and ns558 oneshot bits. If set to NULL, inb(io) will be
used instead.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*cooked_read)(struct gameport *, int *axes, int *buttons);
</pre></div>
</div>
<p>If the gameport supports cooked mode, it should point this to its cooked
read function. It should fill axes[0..3] with four values of the joystick axes
and buttons[0] with four bits representing the buttons.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*calibrate)(struct gameport *, int *axes, int *max);
</pre></div>
</div>
<p>Function for calibrating the ADC hardware. When called, axes[0..3] should be
pre-filled by cooked data by the caller, max[0..3] should be pre-filled with
expected maximums for each axis. The <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">calibrate()</span></code> function should set the
sensitivity of the ADC hardware so that the maximums fit in its range and
recompute the axes[] values to match the new sensitivity or re-read them from
the hardware so that they give valid values.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int (*open)(struct gameport *, int mode);
</pre></div>
</div>
<p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">Open()</span></code> serves two purposes. First a driver either opens the port in raw or
in cooked mode, the open() callback can decide which modes are supported.
Second, resource allocation can happen here. The port can also be enabled
here. Prior to this call, other fields of the gameport struct (namely the io
member) need not to be valid.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>void (*close)(struct gameport *);
</pre></div>
</div>
<p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">Close()</span></code> should free the resources allocated by open, possibly disabling the
gameport.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct timer_list poll_timer;
unsigned int poll_interval;     /* in msecs */
spinlock_t timer_lock;
unsigned int poll_cnt;
void (*poll_handler)(struct gameport *);
struct gameport *parent, *child;
struct gameport_driver *drv;
struct mutex drv_mutex;         /* protects serio-&gt;drv so attributes can pin driver */
struct device dev;
struct list_head node;
</pre></div>
</div>
<p>For internal use by the gameport layer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>};
</pre></div>
</div>
<p>Enjoy!</p>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;The kernel development community.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/input/gameport-programming.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>