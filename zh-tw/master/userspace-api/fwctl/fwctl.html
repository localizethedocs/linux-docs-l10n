<!DOCTYPE html>

<html lang="zh-TW" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>fwctl subsystem &#8212; The Linux Kernel unknown version 說明文件</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=adfc0c0d" />
    <script src="../../_static/documentation_options.js?v=b446b479"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/translations.js?v=cbf116e0"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/linux-docs-l10n/userspace-api/fwctl/fwctl.html" />
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜尋" href="../../search.html" />
    <link rel="next" title="fwctl cxl driver" href="fwctl-cxl.html" />
    <link rel="prev" title="Firmware Control (FWCTL) Userspace API" href="index.html" />

   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

<script type="text/javascript" src="../../ltd-provenance.js"></script>
<script type="text/javascript" src="../../ltd-current.js"></script>
<script type="text/javascript" src="../../../../ltd-config.js"></script>
<script type="text/javascript" src="../../../../ltd-flyout.js"></script>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo of The Linux Kernel"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.19.0</p>







<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜尋</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="前往" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>


<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">提交補釘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">行為守則</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">維護者手冊</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">核心 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../subsystem-apis.html">子系統</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">撰寫文件</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">開發工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">測試指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">即時補釘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">建置系統</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">回報議題</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">使用者空間工具</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">使用者空間 API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../index.html#system-calls">System calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#security-related-interfaces">Security-related interfaces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html#devices-and-i-o">Devices and I/O</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../accelerators/ocxl.html">OpenCAPI (Open Coherent Accelerator Processor Interface)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dma-buf-heaps.html">Allocating dma-buf using heaps</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dma-buf-alloc-exchange.html">Exchanging pixel buffers</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Firmware Control (FWCTL) Userspace API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../gpio/index.html">GPIO</a></li>
<li class="toctree-l3"><a class="reference internal" href="../iommufd.html">IOMMUFD</a></li>
<li class="toctree-l3"><a class="reference internal" href="../media/index.html">Linux Media Infrastructure userspace API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../dcdbas.html">Dell Systems Management Base Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../vduse.html">VDUSE - &quot;vDPA Device in Userspace&quot;</a></li>
<li class="toctree-l3"><a class="reference internal" href="../isapnp.html">ISA Plug &amp; Play support</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#everything-else">Everything else</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">韌體</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">韌體與裝置樹</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU 架構</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">未排序的文件</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>本頁</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/userspace-api/fwctl/fwctl.rst.txt"
            rel="nofollow">顯示原始碼</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="fwctl-subsystem">
<h1>fwctl subsystem<a class="headerlink" href="#fwctl-subsystem" title="連結到這個標頭">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">作者<span class="colon">:</span></dt>
<dd class="field-odd"><p>Jason Gunthorpe</p>
</dd>
</dl>
<section id="overview">
<h2>概覽<a class="headerlink" href="#overview" title="連結到這個標頭">¶</a></h2>
<p>Modern devices contain extensive amounts of FW, and in many cases, are largely
software-defined pieces of hardware. The evolution of this approach is largely a
reaction to Moore's Law where a chip tape out is now highly expensive, and the
chip design is extremely large. Replacing fixed HW logic with a flexible and
tightly coupled FW/HW combination is an effective risk mitigation against chip
respin. Problems in the HW design can be counteracted in device FW. This is
especially true for devices which present a stable and backwards compatible
interface to the operating system driver (such as NVMe).</p>
<p>The FW layer in devices has grown to incredible size and devices frequently
integrate clusters of fast processors to run it. For example, mlx5 devices have
over 30MB of FW code, and big configurations operate with over 1GB of FW managed
runtime state.</p>
<p>The availability of such a flexible layer has created quite a variety in the
industry where single pieces of silicon are now configurable software-defined
devices and can operate in substantially different ways depending on the need.
Further, we often see cases where specific sites wish to operate devices in ways
that are highly specialized and require applications that have been tailored to
their unique configuration.</p>
<p>Further, devices have become multi-functional and integrated to the point they
no longer fit neatly into the kernel's division of subsystems. Modern
multi-functional devices have drivers, such as bnxt/ice/mlx5/pds, that span many
subsystems while sharing the underlying hardware using the auxiliary device
system.</p>
<p>All together this creates a challenge for the operating system, where devices
have an expansive FW environment that needs robust device-specific debugging
support, and FW-driven functionality that is not well suited to “generic”
interfaces. fwctl seeks to allow access to the full device functionality from
user space in the areas of debuggability, management, and first-boot/nth-boot
provisioning.</p>
<p>fwctl is aimed at the common device design pattern where the OS and FW
communicate via an RPC message layer constructed with a queue or mailbox scheme.
In this case the driver will typically have some layer to deliver RPC messages
and collect RPC responses from device FW. The in-kernel subsystem drivers that
operate the device for its primary purposes will use these RPCs to build their
drivers, but devices also usually have a set of ancillary RPCs that don't really
fit into any specific subsystem. For example, a HW RAID controller is primarily
operated by the block layer but also comes with a set of RPCs to administer the
construction of drives within the HW RAID.</p>
<p>In the past when devices were more single function, individual subsystems would
grow different approaches to solving some of these common problems. For instance,
monitoring device health, manipulating its FLASH, debugging the FW,
provisioning, all have various unique interfaces across the kernel.</p>
<p>fwctl's purpose is to define a common set of limited rules, described below,
that allow user space to securely construct and execute RPCs inside device FW.
The rules serve as an agreement between the operating system and FW on how to
correctly design the RPC interface. As a uAPI the subsystem provides a thin
layer of discovery and a generic uAPI to deliver the RPCs and collect the
response. It supports a system of user space libraries and tools which will
use this interface to control the device using the device native protocols.</p>
<section id="scope-of-action">
<h3>Scope of Action<a class="headerlink" href="#scope-of-action" title="連結到這個標頭">¶</a></h3>
<p>fwctl drivers are strictly restricted to being a way to operate the device FW.
It is not an avenue to access random kernel internals, or other operating system
SW states.</p>
<p>fwctl instances must operate on a well-defined device function, and the device
should have a well-defined security model for what scope within the physical
device the function is permitted to access. For instance, the most complex PCIe
device today may broadly have several function-level scopes:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>A privileged function with full access to the on-device global state and
configuration</p></li>
<li><p>Multiple hypervisor functions with control over itself and child functions
used with VMs</p></li>
<li><p>Multiple VM functions tightly scoped within the VM</p></li>
</ol>
</div></blockquote>
<p>The device may create a logical parent/child relationship between these scopes.
For instance, a child VM's FW may be within the scope of the hypervisor FW. It is
quite common in the VFIO world that the hypervisor environment has a complex
provisioning/profiling/configuration responsibility for the function VFIO
assigns to the VM.</p>
<p>Further, within the function, devices often have RPC commands that fall within
some general scopes of action (see <a class="reference internal" href="#c.fwctl_rpc_scope" title="fwctl_rpc_scope"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">fwctl_rpc_scope</span></code></a>):</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Access to function &amp; child configuration, FLASH, etc. that becomes live at a
function reset. Access to function &amp; child runtime configuration that is
transparent or non-disruptive to any driver or VM.</p></li>
<li><p>Read-only access to function debug information that may report on FW objects
in the function &amp; child, including FW objects owned by other kernel
subsystems.</p></li>
<li><p>Write access to function &amp; child debug information strictly compatible with
the principles of kernel lockdown and kernel integrity protection. Triggers
a kernel taint.</p></li>
<li><p>Full debug device access. Triggers a kernel taint, requires CAP_SYS_RAWIO.</p></li>
</ol>
</div></blockquote>
<p>User space will provide a scope label on each RPC and the kernel must enforce the
above CAPs and taints based on that scope. A combination of kernel and FW can
enforce that RPCs are placed in the correct scope by user space.</p>
</section>
<section id="disallowed-behavior">
<h3>Disallowed behavior<a class="headerlink" href="#disallowed-behavior" title="連結到這個標頭">¶</a></h3>
<p>There are many things this interface must not allow user space to do (without a
taint or CAP), broadly derived from the principles of kernel lockdown. Some
examples:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>DMA to/from arbitrary memory, hang the system, compromise FW integrity with
untrusted code, or otherwise compromise device or system security and
integrity.</p></li>
<li><p>Provide an abnormal “back door” to kernel drivers. No manipulation of kernel
objects owned by kernel drivers.</p></li>
<li><p>Directly configure or otherwise control kernel drivers. A subsystem kernel
driver can react to the device configuration at function reset/driver load
time, but otherwise must not be coupled to fwctl.</p></li>
<li><p>Operate the HW in a way that overlaps with the core purpose of another
primary kernel subsystem, such as read/write to LBAs, send/receive of
network packets, or operate an accelerator's data plane.</p></li>
</ol>
</div></blockquote>
<p>fwctl is not a replacement for device direct access subsystems like uacce or
VFIO.</p>
<p>Operations exposed through fwctl's non-tainting interfaces should be fully
sharable with other users of the device. For instance, exposing a RPC through
fwctl should never prevent a kernel subsystem from also concurrently using that
same RPC or hardware unit down the road. In such cases fwctl will be less
important than proper kernel subsystems that eventually emerge. Mistakes in this
area resulting in clashes will be resolved in favour of a kernel implementation.</p>
</section>
</section>
<section id="fwctl-user-api">
<h2>fwctl User API<a class="headerlink" href="#fwctl-user-api" title="連結到這個標頭">¶</a></h2>
<p id="general-ioctl-format"><strong>General ioctl format</strong></p>
<p>The ioctl interface follows a general format to allow for extensibility. Each
ioctl is passed a structure pointer as the argument providing the size of
the structure in the first u32. The kernel checks that any structure space
beyond what it understands is 0. This allows userspace to use the backward
compatible portion while consistently using the newer, larger, structures.</p>
<p>ioctls use a standard meaning for common errnos:</p>
<blockquote>
<div><ul class="simple">
<li><p>ENOTTY: The IOCTL number itself is not supported at all</p></li>
<li><p>E2BIG: The IOCTL number is supported, but the provided structure has
non-zero in a part the kernel does not understand.</p></li>
<li><p>EOPNOTSUPP: The IOCTL number is supported, and the structure is
understood, however a known field has a value the kernel does not
understand or support.</p></li>
<li><p>EINVAL: Everything about the IOCTL was understood, but a field is not
correct.</p></li>
<li><p>ENOMEM: Out of memory.</p></li>
<li><dl class="simple">
<dt>ENODEV: The underlying device has been hot-unplugged and the FD is</dt><dd><p>orphaned.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>As well as additional errnos, within specific ioctls.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.fwctl_info">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fwctl_info</span></span></span><a class="headerlink" href="#c.fwctl_info" title="連結到這個定義">¶</a><br /></dt>
<dd><p>ioctl(FWCTL_INFO)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fwctl_info {
    __u32 size;
    __u32 flags;
    __u32 out_device_type;
    __u32 device_data_len;
    __aligned_u64 out_device_data;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>sizeof(<a class="reference internal" href="#c.fwctl_info" title="fwctl_info"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwctl_info</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">flags</span></code></dt><dd><p>Must be 0</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out_device_type</span></code></dt><dd><p>Returns the type of the device from <code class="xref c c-enum broken_xref docutils literal notranslate"><span class="pre">enum</span> <span class="pre">fwctl_device_type</span></code></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">device_data_len</span></code></dt><dd><p>On input the length of the out_device_data memory. On
output the size of the kernel's device_data which may be larger or
smaller than the input. Maybe 0 on input.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out_device_data</span></code></dt><dd><p>Pointer to a memory of device_data_len bytes. Kernel will
fill the entire memory, zeroing as required.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Returns basic information about this fwctl instance, particularly what driver
is being used to define the device_data format.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.fwctl_rpc_scope">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fwctl_rpc_scope</span></span></span><a class="headerlink" href="#c.fwctl_rpc_scope" title="連結到這個定義">¶</a><br /></dt>
<dd><p>Scope of access for the RPC</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">FWCTL_RPC_CONFIGURATION</span></code></dt><dd><p>Device configuration access scope</p>
<p>Read/write access to device configuration. When configuration
is written to the device it remains in a fully supported state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FWCTL_RPC_DEBUG_READ_ONLY</span></code></dt><dd><p>Read only access to debug information</p>
<p>Readable debug information. Debug information is compatible with
kernel lockdown, and does not disclose any sensitive information. For
instance exposing any encryption secrets from this information is
forbidden.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FWCTL_RPC_DEBUG_WRITE</span></code></dt><dd><p>Writable access to lockdown compatible debug information</p>
<p>Allows write access to data in the device which may leave a fully
supported state. This is intended to permit intensive and possibly
invasive debugging. This scope will taint the kernel.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FWCTL_RPC_DEBUG_WRITE_FULL</span></code></dt><dd><p>Write access to all debug information</p>
<p>Allows read/write access to everything. Requires CAP_SYS_RAW_IO, so
it is not required to follow lockdown principals. If in doubt
debugging should be placed in this scope. This scope will taint the
kernel.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Refer to <a class="reference internal" href="#"><span class="doc">fwctl subsystem</span></a> for a more detailed discussion of these scopes.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.fwctl_rpc">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fwctl_rpc</span></span></span><a class="headerlink" href="#c.fwctl_rpc" title="連結到這個定義">¶</a><br /></dt>
<dd><p>ioctl(FWCTL_RPC)</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fwctl_rpc {
    __u32 size;
    __u32 scope;
    __u32 in_len;
    __u32 out_len;
    __aligned_u64 in;
    __aligned_u64 out;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><p>sizeof(<a class="reference internal" href="#c.fwctl_rpc" title="fwctl_rpc"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwctl_rpc</span></code></a>)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">scope</span></code></dt><dd><p>One of <a class="reference internal" href="#c.fwctl_rpc_scope" title="fwctl_rpc_scope"><code class="xref c c-enum docutils literal notranslate"><span class="pre">enum</span> <span class="pre">fwctl_rpc_scope</span></code></a>, required scope for the RPC</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">in_len</span></code></dt><dd><p>Length of the in memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out_len</span></code></dt><dd><p>Length of the out memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">in</span></code></dt><dd><p>Request message in device specific format</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out</span></code></dt><dd><p>Response message in device specific format</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Deliver a Remote Procedure Call to the device FW and return the response. The
call's parameters and return are marshaled into linear buffers of memory. Any
errno indicates that delivery of the RPC to the device failed. Return status
originating in the device during a successful delivery must be encoded into
out.</p>
<p>The format of the buffers matches the out_device_type from FWCTL_INFO.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.fwctl_info_mlx5">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fwctl_info_mlx5</span></span></span><a class="headerlink" href="#c.fwctl_info_mlx5" title="連結到這個定義">¶</a><br /></dt>
<dd><p>ioctl(FWCTL_INFO) out_device_data</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fwctl_info_mlx5 {
    __u32 uid;
    __u32 uctx_caps;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uid</span></code></dt><dd><p>The FW UID this FD is bound to. Each command header will force
this value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uctx_caps</span></code></dt><dd><p>The FW capabilities that are enabled for the uid.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Return basic information about the FW interface available.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.fwctl_info_pds">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fwctl_info_pds</span></span></span><a class="headerlink" href="#c.fwctl_info_pds" title="連結到這個定義">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fwctl_info_pds {
    __u32 uctx_caps;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">uctx_caps</span></code></dt><dd><p>bitmap of firmware capabilities</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Return basic information about the FW interface available.</p>
<dl class="c enum">
<dt class="sig sig-object c" id="c.pds_fwctl_capabilities">
<span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">pds_fwctl_capabilities</span></span></span><a class="headerlink" href="#c.pds_fwctl_capabilities" title="連結到這個定義">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Constants</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">PDS_FWCTL_QUERY_CAP</span></code></dt><dd><p>firmware can be queried for information</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PDS_FWCTL_SEND_CAP</span></code></dt><dd><p>firmware can be sent commands</p>
</dd>
</dl>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.fwctl_rpc_pds">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fwctl_rpc_pds</span></span></span><a class="headerlink" href="#c.fwctl_rpc_pds" title="連結到這個定義">¶</a><br /></dt>
<dd></dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fwctl_rpc_pds {
    struct {
        __u32 op;
        __u32 ep;
        __u32 rsvd;
        __u32 len;
        __aligned_u64 payload;
    } in;
    struct {
        __u32 retval;
        __u32 rsvd[2];
        __u32 len;
        __aligned_u64 payload;
    } out;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">in</span></code></dt><dd><p>rpc in parameters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">in.op</span></code></dt><dd><p>requested operation code</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">in.ep</span></code></dt><dd><p>firmware endpoint to operate on</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">in.rsvd</span></code></dt><dd><p>reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">in.len</span></code></dt><dd><p>length of payload data</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">in.payload</span></code></dt><dd><p>address of payload buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out</span></code></dt><dd><p>rpc out parameters</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out.retval</span></code></dt><dd><p>operation result value</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out.rsvd</span></code></dt><dd><p>reserved</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out.len</span></code></dt><dd><p>length of result data buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">out.payload</span></code></dt><dd><p>address of payload data buffer</p>
</dd>
</dl>
</div>
<section id="sysfs-class">
<h3>sysfs Class<a class="headerlink" href="#sysfs-class" title="連結到這個標頭">¶</a></h3>
<p>fwctl has a sysfs class (/sys/class/fwctl/fwctlNN/) and character devices
(/dev/fwctl/fwctlNN) with a simple numbered scheme. The character device
operates the iotcl uAPI described above.</p>
<p>fwctl devices can be related to driver components in other subsystems through
sysfs:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ls /sys/class/fwctl/fwctl0/device/infiniband/
ibp0s10f0

$ ls /sys/class/infiniband/ibp0s10f0/device/fwctl/
fwctl0/

$ ls /sys/devices/pci0000:00/0000:00:0a.0/fwctl/fwctl0
dev  device  power  subsystem  uevent
</pre></div>
</div>
</section>
<section id="user-space-community">
<h3>User space Community<a class="headerlink" href="#user-space-community" title="連結到這個標頭">¶</a></h3>
<p>Drawing inspiration from nvme-cli, participating in the kernel side must come
with a user space in a common TBD git tree, at a minimum to usefully operate the
kernel driver. Providing such an implementation is a pre-condition to merging a
kernel driver.</p>
<p>The goal is to build user space community around some of the shared problems
we all have, and ideally develop some common user space programs with some
starting themes of:</p>
<blockquote>
<div><ul class="simple">
<li><p>Device in-field debugging</p></li>
<li><p>HW provisioning</p></li>
<li><p>VFIO child device profiling before VM boot</p></li>
<li><p>Confidential Compute topics (attestation, secure provisioning)</p></li>
</ul>
</div></blockquote>
<p>that stretch across all subsystems in the kernel. fwupd is a great example of
how an excellent user space experience can emerge out of kernel-side diversity.</p>
</section>
</section>
<section id="fwctl-kernel-api">
<h2>fwctl Kernel API<a class="headerlink" href="#fwctl-kernel-api" title="連結到這個標頭">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fwctl_register">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fwctl_register</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.fwctl_device" title="fwctl_device"><span class="n"><span class="pre">fwctl_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fwctl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fwctl_register" title="連結到這個定義">¶</a><br /></dt>
<dd><p>Register a new device to the subsystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwctl_device</span> <span class="pre">*fwctl</span></code></dt><dd><p>Previously allocated fwctl_device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>On return the device is visible through sysfs and /dev, driver ops may be
called.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.fwctl_unregister">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fwctl_unregister</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#c.fwctl_device" title="fwctl_device"><span class="n"><span class="pre">fwctl_device</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fwctl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fwctl_unregister" title="連結到這個定義">¶</a><br /></dt>
<dd><p>Unregister a device from the subsystem</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwctl_device</span> <span class="pre">*fwctl</span></code></dt><dd><p>Previously allocated and registered fwctl_device</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>Undoes <a class="reference internal" href="#c.fwctl_register" title="fwctl_register"><code class="xref c c-func docutils literal notranslate"><span class="pre">fwctl_register()</span></code></a>. On return no driver ops will be called. The
caller must still call <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">fwctl_put()</span></code> to free the fwctl.</p>
<p>Unregister will return even if userspace still has file descriptors open.
This will call ops-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">close_uctx()</span></code> on any open FDs and after return no driver
op will be called. The FDs remain open but all fops will return -ENODEV.</p>
<p>The design of fwctl allows this sort of disassociation of the driver from the
subsystem primarily by keeping memory allocations owned by the core subsytem.
The fwctl_device and fwctl_uctx can both be freed without requiring a driver
callback. This allows the module to remain unlocked while FDs are open.</p>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.fwctl_ops">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fwctl_ops</span></span></span><a class="headerlink" href="#c.fwctl_ops" title="連結到這個定義">¶</a><br /></dt>
<dd><p>Driver provided operations</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fwctl_ops {
    enum fwctl_device_type device_type;
    size_t uctx_size;
    int (*open_uctx)(struct fwctl_uctx *uctx);
    void (*close_uctx)(struct fwctl_uctx *uctx);
    void *(*info)(struct fwctl_uctx *uctx, size_t *length);
    void *(*fw_rpc)(struct fwctl_uctx *uctx, enum fwctl_rpc_scope scope, void *rpc_in, size_t in_len, size_t *out_len);
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">device_type</span></code></dt><dd><p>The drivers assigned device_type number. This is uABI.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uctx_size</span></code></dt><dd><p>The size of the fwctl_uctx <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">to</span></code> allocate. The first
bytes of this memory will be a fwctl_uctx. The driver can use the
remaining bytes as its private memory.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">open_uctx</span></code></dt><dd><p>Called when a file descriptor is opened before the uctx
is ever used.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">close_uctx</span></code></dt><dd><p>Called when the uctx is destroyed, usually when the FD
is closed.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">info</span></code></dt><dd><p>Implement FWCTL_INFO. Return a <a class="reference internal" href="../../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> memory that is copied
to out_device_data. On input length indicates the size of the user
buffer on output it indicates the size of the memory. The driver can
ignore length on input, the core code will handle everything.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">fw_rpc</span></code></dt><dd><p>Implement FWCTL_RPC. Deliver rpc_in/in_len to the FW and
return the response and set out_len. rpc_in can be returned as the
response pointer. Otherwise the returned pointer is freed with
<a class="reference internal" href="../../core-api/mm-api.html#c.kvfree" title="kvfree"><code class="xref c c-func docutils literal notranslate"><span class="pre">kvfree()</span></code></a>.</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p><a class="reference internal" href="#c.fwctl_unregister" title="fwctl_unregister"><code class="xref c c-func docutils literal notranslate"><span class="pre">fwctl_unregister()</span></code></a> will wait until all excuting ops are completed before it
returns. Drivers should be mindful to not let their ops run for too long as
it will block device hot unplug and module unloading.</p>
<dl class="c struct">
<dt class="sig sig-object c" id="c.fwctl_device">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fwctl_device</span></span></span><a class="headerlink" href="#c.fwctl_device" title="連結到這個定義">¶</a><br /></dt>
<dd><p>Per-driver registration struct</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fwctl_device {
    struct device dev;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">dev</span></code></dt><dd><p>The sysfs (class/fwctl/fwctlXX) device</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Each driver instance will have one of these structs with the driver private
data following immediately after. This <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">is</span></code> refcounted, it is freed by
calling <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">fwctl_put()</span></code>.</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.fwctl_alloc_device">
<span class="sig-name descname"><span class="n"><span class="pre">fwctl_alloc_device</span></span></span><a class="headerlink" href="#c.fwctl_alloc_device" title="連結到這個定義">¶</a><br /></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">fwctl_alloc_device</span> <span class="pre">(parent,</span> <span class="pre">ops,</span> <span class="pre">drv_struct,</span> <span class="pre">member)</span></code></p>
<blockquote>
<div><p>Allocate a fwctl</p>
</div></blockquote>
<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">parent</span></code></dt><dd><p>Physical device that provides the FW interface</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ops</span></code></dt><dd><p>Driver ops to register</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">drv_struct</span></code></dt><dd><p>'<code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">driver_fwctl</span></code>' that holds the <a class="reference internal" href="#c.fwctl_device" title="fwctl_device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwctl_device</span></code></a></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">member</span></code></dt><dd><p>Name of the <a class="reference internal" href="#c.fwctl_device" title="fwctl_device"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fwctl_device</span></code></a> in <strong>drv_struct</strong></p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>This allocates and initializes the fwctl_device embedded in the drv_struct.
Upon success the pointer must be freed via <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">fwctl_put()</span></code>. Returns a 'drv_struct
*' on success, NULL on error.</p>
</div>
<dl class="c struct">
<dt class="sig sig-object c" id="c.fwctl_uctx">
<span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fwctl_uctx</span></span></span><a class="headerlink" href="#c.fwctl_uctx" title="連結到這個定義">¶</a><br /></dt>
<dd><p>Per user FD context</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Definition</strong>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct fwctl_uctx {
    struct fwctl_device *fwctl;
};
</pre></div>
</div>
<p><strong>Members</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">fwctl</span></code></dt><dd><p>fwctl instance that owns the context</p>
</dd>
</dl>
</div>
<p><strong>Description</strong></p>
<p>Every FD opened by userspace will get a unique context allocation. Any driver
private data will follow immediately after.</p>
<section id="fwctl-driver-design">
<h3>fwctl Driver design<a class="headerlink" href="#fwctl-driver-design" title="連結到這個標頭">¶</a></h3>
<p>In many cases a fwctl driver is going to be part of a larger cross-subsystem
device possibly using the auxiliary_device mechanism. In that case several
subsystems are going to be sharing the same device and FW interface layer so the
device design must already provide for isolation and cooperation between kernel
subsystems. fwctl should fit into that same model.</p>
<p>Part of the driver should include a description of how its scope restrictions
and security model work. The driver and FW together must ensure that RPCs
provided by user space are mapped to the appropriate scope. If the validation is
done in the driver then the validation can read a 'command effects' report from
the device, or hardwire the enforcement. If the validation is done in the FW,
then the driver should pass the fwctl_rpc_scope to the FW along with the command.</p>
<p>The driver and FW must cooperate to ensure that either fwctl cannot allocate
any FW resources, or any resources it does allocate are freed on FD closure.  A
driver primarily constructed around FW RPCs may find that its core PCI function
and RPC layer belongs under fwctl with auxiliary devices connecting to other
subsystems.</p>
<p>Each device type must be mindful of Linux's philosophy for stable ABI. The FW
RPC interface does not have to meet a strictly stable ABI, but it does need to
meet an expectation that user space tools that are deployed and in significant
use don't needlessly break. FW upgrade and kernel upgrade should keep widely
deployed tooling working.</p>
<p>Development and debugging focused RPCs under more permissive scopes can have
less stability if the tools using them are only run under exceptional
circumstances and not for every day use of the device. Debugging tools may even
require exact version matching as they may require something similar to DWARF
debug information from the FW binary.</p>
</section>
</section>
<section id="security-response">
<h2>Security Response<a class="headerlink" href="#security-response" title="連結到這個標頭">¶</a></h2>
<p>The kernel remains the gatekeeper for this interface. If violations of the
scopes, security or isolation principles are found, we have options to let
devices fix them with a FW update, push a kernel patch to parse and block RPC
commands or push a kernel patch to block entire firmware versions/devices.</p>
<p>While the kernel can always directly parse and restrict RPCs, it is expected
that the existing kernel pattern of allowing drivers to delegate validation to
FW to be a useful design.</p>
</section>
<section id="existing-similar-examples">
<h2>Existing Similar Examples<a class="headerlink" href="#existing-similar-examples" title="連結到這個標頭">¶</a></h2>
<p>The approach described in this document is not a new idea. Direct, or near
direct device access has been offered by the kernel in different areas for
decades. With more devices wanting to follow this design pattern it is becoming
clear that it is not entirely well understood and, more importantly, the
security considerations are not well defined or agreed upon.</p>
<p>Some examples:</p>
<blockquote>
<div><ul class="simple">
<li><p>HW RAID controllers. This includes RPCs to do things like compose drives into
a RAID volume, configure RAID parameters, monitor the HW and more.</p></li>
<li><p>Baseboard managers. RPCs for configuring settings in the device and more.</p></li>
<li><p>NVMe vendor command capsules. nvme-cli provides access to some monitoring
functions that different products have defined, but more exist.</p></li>
<li><p>CXL also has a NVMe-like vendor command system.</p></li>
<li><p>DRM allows user space drivers to send commands to the device via kernel
mediation.</p></li>
<li><p>RDMA allows user space drivers to directly push commands to the device
without kernel involvement.</p></li>
<li><p>Various “raw” APIs, raw HID (SDL2), raw USB, NVMe Generic Interface, etc.</p></li>
</ul>
</div></blockquote>
<p>The first 4 are examples of areas that fwctl intends to cover. The latter three
are examples of disallowed behavior as they fully overlap with the primary purpose
of a kernel subsystem.</p>
<p>Some key lessons learned from these past efforts are the importance of having a
common user space project to use as a pre-condition for obtaining a kernel
driver. Developing good community around useful software in user space is key to
getting companies to fund participation to enable their products.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;The kernel development community.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../../_sources/userspace-api/fwctl/fwctl.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>