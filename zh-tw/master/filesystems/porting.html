<!DOCTYPE html>

<html lang="zh-TW" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Changes since 2.5.0: &#8212; The Linux Kernel unknown version 說明文件</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=adfc0c0d" />
    <script src="../_static/documentation_options.js?v=b446b479"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=cbf116e0"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/linux-docs-l10n/filesystems/porting.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜尋" href="../search.html" />
    <link rel="next" title="Buffer Heads" href="buffer.html" />
    <link rel="prev" title="Cache on Already Mounted Filesystem" href="caching/cachefiles.html" />

   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

<script type="text/javascript" src="../ltd-provenance.js"></script>
<script type="text/javascript" src="../ltd-current.js"></script>
<script type="text/javascript" src="../../../ltd-config.js"></script>
<script type="text/javascript" src="../../../ltd-flyout.js"></script>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo of The Linux Kernel"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.19.0</p>







<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜尋</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="前往" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>


<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">提交補釘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">行為守則</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">維護者手冊</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">核心 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">子系統</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Linux 內核中的檔案系統</a></li>
<li class="toctree-l3"><a class="reference internal" href="../block/index.html">Block</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cdrom/index.html">CD-ROM</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scsi/index.html">SCSI Subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../target/index.html">TCM 虛擬裝置</a></li>
<li class="toctree-l3"><a class="reference internal" href="../nvme/index.html">NVMe Subsystem</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">其他子系統</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">撰寫文件</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">開發工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">測試指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">即時補釘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">建置系統</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">回報議題</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">使用者空間工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">使用者空間 API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">韌體</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">韌體與裝置樹</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU 架構</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">未排序的文件</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>本頁</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/filesystems/porting.rst.txt"
            rel="nofollow">顯示原始碼</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="changes-since-2-5-0">
<h1>Changes since 2.5.0:<a class="headerlink" href="#changes-since-2-5-0" title="連結到這個標頭">¶</a></h1>
<p>---</p>
<p><strong>recommended</strong></p>
<p>New helpers: <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">sb_bread()</span></code>, <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">sb_getblk()</span></code>, <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">sb_find_get_block()</span></code>, <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">set_bh()</span></code>,
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">sb_set_blocksize()</span></code> and <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">sb_min_blocksize()</span></code>.</p>
<p>Use them.</p>
<p>(<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">sb_find_get_block()</span></code> replaces 2.4's <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">get_hash_table()</span></code>)</p>
<p>---</p>
<p><strong>recommended</strong></p>
<p>New methods: -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">alloc_inode()</span></code> and -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">destroy_inode()</span></code>.</p>
<p>Remove inode-&gt;u.foo_inode_i</p>
<p>Declare:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct foo_inode_info {
        /* fs-private stuff */
        struct inode vfs_inode;
};
static inline struct foo_inode_info *FOO_I(struct inode *inode)
{
        return list_entry(inode, struct foo_inode_info, vfs_inode);
}
</pre></div>
</div>
<p>Use FOO_I(inode) instead of &amp;inode-&gt;u.foo_inode_i;</p>
<p>Add <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">foo_alloc_inode()</span></code> and <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">foo_destroy_inode()</span></code> - the former should allocate
foo_inode_info and return the address of -&gt;vfs_inode, the latter should free
FOO_I(inode) (see in-tree filesystems for examples).</p>
<p>Make them -&gt;alloc_inode and -&gt;destroy_inode in your super_operations.</p>
<p>Keep in mind that now you need explicit initialization of private data
typically between calling <a class="reference internal" href="api-summary.html#c.iget_locked" title="iget_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">iget_locked()</span></code></a> and unlocking the inode.</p>
<p>At some point that will become mandatory.</p>
<p><strong>mandatory</strong></p>
<p>The foo_inode_info should always be allocated through <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">alloc_inode_sb()</span></code> rather
than <a class="reference internal" href="../core-api/mm-api.html#c.kmem_cache_alloc" title="kmem_cache_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmem_cache_alloc()</span></code></a> or <a class="reference internal" href="../core-api/mm-api.html#c.kmalloc" title="kmalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">kmalloc()</span></code></a> related to set up the inode reclaim context
correctly.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>Change of file_system_type method (-&gt;read_super to -&gt;get_sb)</p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">read_super()</span></code> is no more.  Ditto for DECLARE_FSTYPE and DECLARE_FSTYPE_DEV.</p>
<p>Turn your <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">foo_read_super()</span></code> into a function that would return 0 in case of
success and negative number in case of error (-EINVAL unless you have more
informative error value to report).  Call it <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">foo_fill_super()</span></code>.  Now declare:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int foo_get_sb(struct file_system_type *fs_type,
      int flags, const char *dev_name, void *data, struct vfsmount *mnt)
{
      return get_sb_bdev(fs_type, flags, dev_name, data, foo_fill_super,
                         mnt);
}
</pre></div>
</div>
<p>(or similar with s/bdev/nodev/ or s/bdev/single/, depending on the kind of
filesystem).</p>
<p>Replace DECLARE_FSTYPE... with explicit initializer and have -&gt;get_sb set as
foo_get_sb.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>Locking change: -&gt;s_vfs_rename_sem is taken only by cross-directory renames.
Most likely there is no need to change anything, but if you relied on
global exclusion between renames for some internal purpose - you need to
change your internal locking.  Otherwise exclusion warranties remain the
same (i.e. parents and victim are locked, etc.).</p>
<p>---</p>
<p><strong>informational</strong></p>
<p>Now we have the exclusion between -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">lookup()</span></code> and directory removal (by
-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">rmdir()</span></code> and -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">rename()</span></code>).  If you used to need that exclusion and do
it by internal locking (most of filesystems couldn't care less) - you
can relax your locking.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">lookup()</span></code>, -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">truncate()</span></code>, -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">create()</span></code>, -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">unlink()</span></code>, -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">mknod()</span></code>, -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">mkdir()</span></code>,
-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">rmdir()</span></code>, -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">link()</span></code>, -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">lseek()</span></code>, -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">symlink()</span></code>, -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">rename()</span></code>
and -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">readdir()</span></code> are called without BKL now.  Grab it on entry, drop upon return
- that will guarantee the same locking you used to have.  If your method or its
parts do not need BKL - better yet, now you can shift <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">lock_kernel()</span></code> and
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">unlock_kernel()</span></code> so that they would protect exactly what needs to be
protected.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>BKL is also moved from around sb operations. BKL should have been shifted into
individual fs sb_op functions.  If you don't need it, remove it.</p>
<p>---</p>
<p><strong>informational</strong></p>
<p>check for -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">link()</span></code> target not being a directory is done by callers.  Feel
free to drop it...</p>
<p>---</p>
<p><strong>informational</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">link()</span></code> callers hold -&gt;i_mutex on the object we are linking to.  Some of your
problems might be over...</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>new file_system_type method - kill_sb(superblock).  If you are converting
an existing filesystem, set it according to -&gt;fs_flags:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>FS_REQUIRES_DEV         -       kill_block_super
FS_LITTER               -       kill_litter_super
neither                 -       kill_anon_super
</pre></div>
</div>
<p>FS_LITTER is gone - just remove it from fs_flags.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>FS_SINGLE is gone (actually, that had happened back when -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">get_sb()</span></code>
went in - and hadn't been documented ;-/).  Just remove it from fs_flags
(and see -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">get_sb()</span></code> entry for other actions).</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">setattr()</span></code> is called without BKL now.  Caller _always_ holds -&gt;i_mutex, so
watch for -&gt;i_mutex-grabbing code that might be used by your -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">setattr()</span></code>.
Callers of <a class="reference internal" href="api-summary.html#c.notify_change" title="notify_change"><code class="xref c c-func docutils literal notranslate"><span class="pre">notify_change()</span></code></a> need -&gt;i_mutex now.</p>
<p>---</p>
<p><strong>recommended</strong></p>
<p>New super_block field <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">export_operations</span> <span class="pre">*s_export_op</span></code> for
explicit support for exporting, e.g. via NFS.  The structure is fully
documented at its declaration in include/linux/fs.h, and in
<a class="reference internal" href="nfs/exporting.html"><span class="doc">Making Filesystems Exportable</span></a>.</p>
<p>Briefly it allows for the definition of decode_fh and encode_fh operations
to encode and decode filehandles, and allows the filesystem to use
a standard helper function for decode_fh, and provide file-system specific
support for this helper, particularly get_parent.</p>
<p>It is planned that this will be required for exporting once the code
settles down a bit.</p>
<p><strong>mandatory</strong></p>
<p>s_export_op is now required for exporting a filesystem.
isofs, ext2, ext3, fat
can be used as examples of very different filesystems.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">iget4()</span></code> and the read_inode2 callback have been superseded by <a class="reference internal" href="api-summary.html#c.iget5_locked" title="iget5_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">iget5_locked()</span></code></a>
which has the following prototype:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct inode *iget5_locked(struct super_block *sb, unsigned long ino,
                            int (*test)(struct inode *, void *),
                            int (*set)(struct inode *, void *),
                            void *data);
</pre></div>
</div>
<p>'test' is an additional function that can be used when the inode
number is not sufficient to identify the actual file object. 'set'
should be a non-blocking function that initializes those parts of a
newly created inode to allow the test function to succeed. 'data' is
passed as an opaque value to both test and set functions.</p>
<p>When the inode has been created by <a class="reference internal" href="api-summary.html#c.iget5_locked" title="iget5_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">iget5_locked()</span></code></a>, it will be returned with the
I_NEW flag set and will still be locked.  The filesystem then needs to finalize
the initialization. Once the inode is initialized it must be unlocked by
calling <a class="reference internal" href="api-summary.html#c.unlock_new_inode" title="unlock_new_inode"><code class="xref c c-func docutils literal notranslate"><span class="pre">unlock_new_inode()</span></code></a>.</p>
<p>The filesystem is responsible for setting (and possibly testing) i_ino
when appropriate. There is also a simpler iget_locked function that
just takes the superblock and inode number as arguments and does the
test and set for you.</p>
<p>e.g.:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>inode = iget_locked(sb, ino);
if (inode_state_read_once(inode) &amp; I_NEW) {
        err = read_inode_from_disk(inode);
        if (err &lt; 0) {
                iget_failed(inode);
                return err;
        }
        unlock_new_inode(inode);
}
</pre></div>
</div>
<p>Note that if the process of setting up a new inode fails, then <a class="reference internal" href="api-summary.html#c.iget_failed" title="iget_failed"><code class="xref c c-func docutils literal notranslate"><span class="pre">iget_failed()</span></code></a>
should be called on the inode to render it dead, and an appropriate error
should be passed back to the caller.</p>
<p>---</p>
<p><strong>recommended</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">getattr()</span></code> finally getting used.  See instances in nfs, minix, etc.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">revalidate()</span></code> is gone.  If your filesystem had it - provide -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">getattr()</span></code>
and let it call whatever you had as -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">revlidate()</span></code> + (for symlinks that
had -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">revalidate()</span></code>) add calls in -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">follow_link()</span></code>/-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">readlink()</span></code>.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;d_parent changes are not protected by BKL anymore.  Read access is safe
if at least one of the following is true:</p>
<blockquote>
<div><ul class="simple">
<li><p>filesystem has no cross-directory <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">rename()</span></code></p></li>
<li><p>we know that parent had been locked (e.g. we are looking at
-&gt;d_parent of -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">lookup()</span></code> argument).</p></li>
<li><p>we are called from -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">rename()</span></code>.</p></li>
<li><p>the child's -&gt;d_lock is held</p></li>
</ul>
</div></blockquote>
<p>Audit your code and add locking if needed.  Notice that any place that is
not protected by the conditions above is risky even in the old tree - you
had been relying on BKL and that's prone to screwups.  Old tree had quite
a few holes of that kind - unprotected access to -&gt;d_parent leading to
anything from oops to silent memory corruption.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>FS_NOMOUNT is gone.  If you use it - just set SB_NOUSER in flags
(see rootfs for one kind of solution and bdev/socket/pipe for another).</p>
<p>---</p>
<p><strong>recommended</strong></p>
<p>Use bdev_read_only(bdev) instead of is_read_only(kdev).  The latter
is still alive, but only because of the mess in drivers/s390/block/dasd.c.
As soon as it gets fixed <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">is_read_only()</span></code> will die.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">permission()</span></code> is called without BKL now. Grab it on entry, drop upon
return - that will guarantee the same locking you used to have.  If
your method or its parts do not need BKL - better yet, now you can
shift <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">lock_kernel()</span></code> and <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">unlock_kernel()</span></code> so that they would protect
exactly what needs to be protected.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">statfs()</span></code> is now called without BKL held.  BKL should have been
shifted into individual fs sb_op functions where it's not clear that
it's safe to remove it.  If you don't need it, remove it.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">is_read_only()</span></code> is gone; use <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">bdev_read_only()</span></code> instead.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">destroy_buffers()</span></code> is gone; use <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">invalidate_bdev()</span></code>.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">fsync_dev()</span></code> is gone; use <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">fsync_bdev()</span></code>.  NOTE: lvm breakage is
deliberate; as soon as <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span></code> * is propagated in a reasonable
way by that code fixing will become trivial; until then nothing can be
done.</p>
<p><strong>mandatory</strong></p>
<p>block truncation on error exit from -&gt;write_begin, and -&gt;direct_IO
moved from generic methods (block_write_begin, cont_write_begin,
nobh_write_begin, blockdev_direct_IO*) to callers.  Take a look at
ext2_write_failed and callers for an example.</p>
<p><strong>mandatory</strong></p>
<p>-&gt;truncate is gone.  The whole truncate sequence needs to be
implemented in -&gt;setattr, which is now mandatory for filesystems
implementing on-disk size changes.  Start with a copy of the old inode_setattr
and vmtruncate, and the reorder the vmtruncate + foofs_vmtruncate sequence to
be in order of zeroing blocks using block_truncate_page or similar helpers,
size update and on finally on-disk truncation which should not fail.
setattr_prepare (which used to be inode_change_ok) now includes the size checks
for ATTR_SIZE and must be called in the beginning of -&gt;setattr unconditionally.</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">clear_inode()</span></code> and -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">delete_inode()</span></code> are gone; -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">evict_inode()</span></code> should
be used instead.  It gets called whenever the inode is evicted, whether it has
remaining links or not.  Caller does <em>not</em> evict the pagecache or inode-associated
metadata buffers; the method has to use <a class="reference internal" href="../core-api/mm-api.html#c.truncate_inode_pages_final" title="truncate_inode_pages_final"><code class="xref c c-func docutils literal notranslate"><span class="pre">truncate_inode_pages_final()</span></code></a> to get rid
of those. Caller makes sure async writeback cannot be running for the inode while
(or after) -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">evict_inode()</span></code> is called.</p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">drop_inode()</span></code> returns int now; it's called on final <a class="reference internal" href="api-summary.html#c.iput" title="iput"><code class="xref c c-func docutils literal notranslate"><span class="pre">iput()</span></code></a> with
inode-&gt;i_lock held and it returns true if filesystems wants the inode to be
dropped.  As before, <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">inode_generic_drop()</span></code> is still the default and it's been
updated appropriately.  <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">inode_just_drop()</span></code> is also alive and it consists
simply of return 1.  Note that all actual eviction work is done by caller after
-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">drop_inode()</span></code> returns.</p>
<p>As before, <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">clear_inode()</span></code> must be called exactly once on each call of
-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">evict_inode()</span></code> (as it used to be for each call of -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">delete_inode()</span></code>).  Unlike
before, if you are using inode-associated metadata buffers (i.e.
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">mark_buffer_dirty_inode()</span></code>), it's your responsibility to call
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">invalidate_inode_buffers()</span></code> before <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">clear_inode()</span></code>.</p>
<p>NOTE: checking i_nlink in the beginning of -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">write_inode()</span></code> and bailing out
if it's zero is not <em>and</em> <em>never</em> <em>had</em> <em>been</em> enough.  Final <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">unlink()</span></code> and <a class="reference internal" href="api-summary.html#c.iput" title="iput"><code class="xref c c-func docutils literal notranslate"><span class="pre">iput()</span></code></a>
may happen while the inode is in the middle of -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">write_inode()</span></code>; e.g. if you blindly
free the on-disk inode, you may end up doing that while -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">write_inode()</span></code> is writing
to it.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>.<a class="reference internal" href="api-summary.html#c.d_delete" title="d_delete"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_delete()</span></code></a> now only advises the dcache as to whether or not to cache
unreferenced dentries, and is now only called when the dentry refcount goes to
0. Even on 0 refcount transition, it must be able to tolerate being called 0,
1, or more times (eg. constant, idempotent).</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>.<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">d_compare()</span></code> calling convention and locking rules are significantly
changed. Read updated documentation in <a class="reference internal" href="vfs.html"><span class="doc">Linux 虛擬檔案系統概覽</span></a> (and
look at examples of other filesystems) for guidance.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>.<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">d_hash()</span></code> calling convention and locking rules are significantly
changed. Read updated documentation in <a class="reference internal" href="vfs.html"><span class="doc">Linux 虛擬檔案系統概覽</span></a> (and
look at examples of other filesystems) for guidance.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>dcache_lock is gone, replaced by fine grained locks. See fs/dcache.c
for details of what locks to replace dcache_lock with in order to protect
particular things. Most of the time, a filesystem only needs -&gt;d_lock, which
protects <em>all</em> the dcache state of a given dentry.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>Filesystems must RCU-free their inodes, if they can have been accessed
via rcu-walk path walk (basically, if the file can have had a path name in the
vfs namespace).</p>
<p>Even though i_dentry and i_rcu share storage in a union, we will
initialize the former in <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">inode_init_always()</span></code>, so just leave it alone in
the callback.  It used to be necessary to clean it there, but not anymore
(starting at 3.2).</p>
<p>---</p>
<p><strong>recommended</strong></p>
<p>vfs now tries to do path walking in &quot;rcu-walk mode&quot;, which avoids
atomic operations and scalability hazards on dentries and inodes (see
<a class="reference internal" href="path-lookup.html"><span class="doc">Pathname lookup</span></a>). d_hash and d_compare changes
(above) are examples of the changes required to support this. For more complex
filesystem callbacks, the vfs drops out of rcu-walk mode before the fs call, so
no changes are required to the filesystem. However, this is costly and loses
the benefits of rcu-walk mode. We will begin to add filesystem callbacks that
are rcu-walk aware, shown below. Filesystems should take advantage of this
where possible.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>d_revalidate is a callback that is made on every path element (if
the filesystem provides it), which requires dropping out of rcu-walk mode. This
may now be called in rcu-walk mode (nd-&gt;flags &amp; LOOKUP_RCU). -ECHILD should be
returned if the filesystem cannot handle rcu-walk. See
<a class="reference internal" href="vfs.html"><span class="doc">Linux 虛擬檔案系統概覽</span></a> for more details.</p>
<p>permission is an inode permission check that is called on many or all
directory inodes on the way down a path walk (to check for exec permission). It
must now be rcu-walk aware (mask &amp; MAY_NOT_BLOCK).  See
<a class="reference internal" href="vfs.html"><span class="doc">Linux 虛擬檔案系統概覽</span></a> for more details.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>In -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">fallocate()</span></code> you must check the mode option passed in.  If your
filesystem does not support hole punching (deallocating space in the middle of a
file) you must return -EOPNOTSUPP if FALLOC_FL_PUNCH_HOLE is set in mode.
Currently you can only have FALLOC_FL_PUNCH_HOLE with FALLOC_FL_KEEP_SIZE set,
so the i_size should not change when hole punching, even when puching the end of
a file off.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">get_sb()</span></code> is gone.  Switch to use of -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">mount()</span></code>.  Typically it's just
a matter of switching from calling <code class="docutils literal notranslate"><span class="pre">get_sb_</span></code>... to <code class="docutils literal notranslate"><span class="pre">mount_</span></code>... and changing
the function type.  If you were doing it manually, just switch from setting
-&gt;mnt_root to some pointer to returning that pointer.  On errors return
ERR_PTR(...).</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">permission()</span></code> and <a class="reference internal" href="api-summary.html#c.generic_permission" title="generic_permission"><code class="xref c c-func docutils literal notranslate"><span class="pre">generic_permission()</span></code></a>have lost flags
argument; instead of passing IPERM_FLAG_RCU we add MAY_NOT_BLOCK into mask.</p>
<p><a class="reference internal" href="api-summary.html#c.generic_permission" title="generic_permission"><code class="xref c c-func docutils literal notranslate"><span class="pre">generic_permission()</span></code></a> has also lost the check_acl argument; ACL checking
has been taken to VFS and filesystems need to provide a non-NULL
-&gt;i_op-&gt;get_inode_acl to read an ACL from disk.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>If you implement your own -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">llseek()</span></code> you must handle SEEK_HOLE and
SEEK_DATA.  You can handle this by returning -EINVAL, but it would be nicer to
support it in some way.  The generic handler assumes that the entire file is
data and there is a virtual hole at the end of the file.  So if the provided
offset is less than i_size and SEEK_DATA is specified, return the same offset.
If the above is true for the offset and you are given SEEK_HOLE, return the end
of the file.  If the offset is i_size or greater return -ENXIO in either case.</p>
<p><strong>mandatory</strong></p>
<p>If you have your own -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">fsync()</span></code> you must make sure to call
<a class="reference internal" href="../core-api/mm-api.html#c.filemap_write_and_wait_range" title="filemap_write_and_wait_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">filemap_write_and_wait_range()</span></code></a> so that all dirty pages are synced out properly.
You must also keep in mind that -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">fsync()</span></code> is not called with i_mutex held
anymore, so if you require i_mutex locking you must make sure to take it and
release it yourself.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">d_alloc_root()</span></code> is gone, along with a lot of bugs caused by code
misusing it.  Replacement: d_make_root(inode).  On success d_make_root(inode)
allocates and returns a new dentry instantiated with the passed in inode.
On failure NULL is returned and the passed in inode is dropped so the reference
to inode is consumed in all cases and failure handling need not do any cleanup
for the inode.  If d_make_root(inode) is passed a NULL inode it returns NULL
and also requires no further error handling. Typical usage is:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>inode = foofs_new_inode(....);
s-&gt;s_root = d_make_root(inode);
if (!s-&gt;s_root)
        /* Nothing needed for the inode cleanup */
        return -ENOMEM;
...
</pre></div>
</div>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>The witch is dead!  Well, 2/3 of it, anyway.  -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">d_revalidate()</span></code> and
-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">lookup()</span></code> do <em>not</em> take <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nameidata</span></code> anymore; just the flags.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">create()</span></code> doesn't take <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">nameidata</span> <span class="pre">*</span></code>; unlike the previous
two, it gets &quot;is it an O_EXCL or equivalent?&quot; boolean argument.  Note that
local filesystems can ignore this argument - they are guaranteed that the
object doesn't exist.  It's remote/distributed ones that might care...</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>FS_REVAL_DOT is gone; if you used to have it, add -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">d_weak_revalidate()</span></code>
in your dentry operations instead.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">vfs_readdir()</span></code> is gone; switch to <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">iterate_dir()</span></code> instead</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">readdir()</span></code> is gone now; switch to -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">iterate_shared()</span></code></p>
<p><strong>mandatory</strong></p>
<p>vfs_follow_link has been removed.  Filesystems must use nd_set_link
from -&gt;follow_link for normal symlinks, or nd_jump_link for magic
/proc/&lt;pid&gt; style links.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p><a class="reference internal" href="api-summary.html#c.iget5_locked" title="iget5_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">iget5_locked()</span></code></a>/<a class="reference internal" href="api-summary.html#c.ilookup5" title="ilookup5"><code class="xref c c-func docutils literal notranslate"><span class="pre">ilookup5()</span></code></a>/<a class="reference internal" href="api-summary.html#c.ilookup5_nowait" title="ilookup5_nowait"><code class="xref c c-func docutils literal notranslate"><span class="pre">ilookup5_nowait()</span></code></a> <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">test()</span></code> callback used to be
called with both -&gt;i_lock and inode_hash_lock held; the former is <em>not</em>
taken anymore, so verify that your callbacks do not rely on it (none
of the in-tree instances did).  inode_hash_lock is still held,
of course, so they are still serialized wrt removal from inode hash,
as well as wrt <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">set()</span></code> callback of <a class="reference internal" href="api-summary.html#c.iget5_locked" title="iget5_locked"><code class="xref c c-func docutils literal notranslate"><span class="pre">iget5_locked()</span></code></a>.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">d_materialise_unique()</span></code> is gone; <a class="reference internal" href="api-summary.html#c.d_splice_alias" title="d_splice_alias"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_splice_alias()</span></code></a> does everything you
need now.  Remember that they have opposite orders of arguments ;-/</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>f_dentry is gone; use f_path.dentry, or, better yet, see if you can avoid
it entirely.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>never call -&gt;read() and -&gt;write() directly; use __vfs_{read,write} or
wrappers; instead of checking for -&gt;write or -&gt;read being NULL, look for
FMODE_CAN_{WRITE,READ} in file-&gt;f_mode.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>do _not_ use new_sync_{read,write} for -&gt;read/-&gt;write; leave it NULL
instead.</p>
<p>---</p>
<dl class="simple">
<dt><strong>mandatory</strong></dt><dd><p>-&gt;aio_read/-&gt;aio_write are gone.  Use -&gt;read_iter/-&gt;write_iter.</p>
</dd>
</dl>
<p>---</p>
<p><strong>recommended</strong></p>
<p>for embedded (&quot;fast&quot;) symlinks just set inode-&gt;i_link to wherever the
symlink body is and use <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">simple_follow_link()</span></code> as -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">follow_link()</span></code>.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>calling conventions for -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">follow_link()</span></code> have changed.  Instead of returning
cookie and using <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">nd_set_link()</span></code> to store the body to traverse, we return
the body to traverse and store the cookie using explicit void ** argument.
nameidata isn't passed at all - <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">nd_jump_link()</span></code> doesn't need it and
nd_[gs]<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">et_link()</span></code> is gone.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>calling conventions for -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">put_link()</span></code> have changed.  It gets inode instead of
dentry,  it does not get nameidata at all and it gets called only when cookie
is non-NULL.  Note that link body isn't available anymore, so if you need it,
store it as cookie.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>any symlink that might use page_follow_link_light/<a class="reference internal" href="api-summary.html#c.page_put_link" title="page_put_link"><code class="xref c c-func docutils literal notranslate"><span class="pre">page_put_link()</span></code></a> must
have inode_nohighmem(inode) called before anything might start playing with
its pagecache.  No highmem pages should end up in the pagecache of such
symlinks.  That includes any preseeding that might be done during symlink
creation.  <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">page_symlink()</span></code> will honour the mapping gfp flags, so once
you've done <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">inode_nohighmem()</span></code> it's safe to use, but if you allocate and
insert the page manually, make sure to use the right gfp flags.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">follow_link()</span></code> is replaced with -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">get_link()</span></code>; same API, except that</p>
<blockquote>
<div><ul class="simple">
<li><p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">get_link()</span></code> gets inode as a separate argument</p></li>
<li><p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">get_link()</span></code> may be called in RCU mode - in that case NULL
dentry is passed</p></li>
</ul>
</div></blockquote>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">get_link()</span></code> gets <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">delayed_call</span></code> <code class="docutils literal notranslate"><span class="pre">*done</span></code> now, and should do
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">set_delayed_call()</span></code> where it used to set <code class="docutils literal notranslate"><span class="pre">*cookie</span></code>.</p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">put_link()</span></code> is gone - just give the destructor to <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">set_delayed_call()</span></code>
in -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">get_link()</span></code>.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">getxattr()</span></code> and xattr_handler.<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">get()</span></code> get dentry and inode passed separately.
dentry might be yet to be attached to inode, so do _not_ use its -&gt;d_inode
in the instances.  Rationale: !&#64;#!&#64;# <a class="reference internal" href="../security/lsm-development.html#c.security_d_instantiate" title="security_d_instantiate"><code class="xref c c-func docutils literal notranslate"><span class="pre">security_d_instantiate()</span></code></a> needs to be
called before we attach dentry to inode.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>symlinks are no longer the only inodes that do <em>not</em> have i_bdev/i_cdev/
i_pipe/i_link <code class="xref c c-union broken_xref docutils literal notranslate"><span class="pre">union</span> <span class="pre">zeroed</span></code> out at inode eviction.  As the result, you can't
assume that non-NULL value in -&gt;i_nlink at -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">destroy_inode()</span></code> implies that
it's a symlink.  Checking -&gt;i_mode is really needed now.  In-tree we had
to fix <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">shmem_destroy_callback()</span></code> that used to take that kind of shortcut;
watch out, since that shortcut is no longer valid.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;i_mutex is replaced with -&gt;i_rwsem now.  <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">inode_lock()</span></code> et.al. work as
they used to - they just take it exclusive.  However, -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">lookup()</span></code> may be
called with parent locked shared.  Its instances must not</p>
<blockquote>
<div><ul class="simple">
<li><p>use d_instantiate) and <a class="reference internal" href="api-summary.html#c.d_rehash" title="d_rehash"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_rehash()</span></code></a> separately - use <a class="reference internal" href="api-summary.html#c.d_add" title="d_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_add()</span></code></a> or
<a class="reference internal" href="api-summary.html#c.d_splice_alias" title="d_splice_alias"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_splice_alias()</span></code></a> instead.</p></li>
<li><p>use <a class="reference internal" href="api-summary.html#c.d_rehash" title="d_rehash"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_rehash()</span></code></a> alone - call d_add(new_dentry, NULL) instead.</p></li>
<li><p>in the unlikely case when (read-only) access to filesystem
data structures needs exclusion for some reason, arrange it
yourself.  None of the in-tree filesystems needed that.</p></li>
<li><p>rely on -&gt;d_parent and -&gt;d_name not changing after dentry has
been fed to <a class="reference internal" href="api-summary.html#c.d_add" title="d_add"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_add()</span></code></a> or <a class="reference internal" href="api-summary.html#c.d_splice_alias" title="d_splice_alias"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_splice_alias()</span></code></a>.  Again, none of the
in-tree instances relied upon that.</p></li>
</ul>
</div></blockquote>
<p>We are guaranteed that lookups of the same name in the same directory
will not happen in parallel (&quot;same&quot; in the sense of your -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">d_compare()</span></code>).
Lookups on different names in the same directory can and do happen in
parallel now.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">iterate_shared()</span></code> is added.
Exclusion on <a class="reference internal" href="api-summary.html#c.file" title="file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code></a> level is still provided (as well as that
between it and lseek on the same <a class="reference internal" href="api-summary.html#c.file" title="file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code></a>), but if your directory
has been opened several times, you can get these called in parallel.
Exclusion between that method and all directory-modifying ones is
still provided, of course.</p>
<p>If you have any per-inode or per-dentry in-core data structures modified
by -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">iterate_shared()</span></code>, you might need something to serialize the access
to them.  If you do dcache pre-seeding, you'll need to switch to
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">d_alloc_parallel()</span></code> for that; look for in-tree examples.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">atomic_open()</span></code> calls without O_CREAT may happen in parallel.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">setxattr()</span></code> and xattr_handler.<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">set()</span></code> get dentry and inode passed separately.
The xattr_handler.<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">set()</span></code> gets passed the user namespace of the mount the inode
is seen from so filesystems can idmap the i_uid and i_gid accordingly.
dentry might be yet to be attached to inode, so do _not_ use its -&gt;d_inode
in the instances.  Rationale: !&#64;#!&#64;# <a class="reference internal" href="../security/lsm-development.html#c.security_d_instantiate" title="security_d_instantiate"><code class="xref c c-func docutils literal notranslate"><span class="pre">security_d_instantiate()</span></code></a> needs to be
called before we attach dentry to inode and !&#64;#!&#64;##!&#64;$!$#!&#64;#$!&#64;$!&#64;$ smack
-&gt;<a class="reference internal" href="api-summary.html#c.d_instantiate" title="d_instantiate"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_instantiate()</span></code></a> uses not just -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">getxattr()</span></code> but -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">setxattr()</span></code> as well.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">d_compare()</span></code> doesn't get parent as a separate argument anymore.  If you
used it for finding the <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">super_block</span></code> involved, dentry-&gt;d_sb will
work just as well; if it's something more complicated, use dentry-&gt;d_parent.
Just be careful not to assume that fetching it more than once will yield
the same value - in RCU mode it could change under you.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">rename()</span></code> has an added flags argument.  Any flags not handled by the
filesystem should result in EINVAL being returned.</p>
<p>---</p>
<p><strong>recommended</strong></p>
<p>-&gt;readlink is optional for symlinks.  Don't set, unless filesystem needs
to fake something for readlink(2).</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">getattr()</span></code> is now passed a <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">path</span></code> rather than a vfsmount and
dentry separately, and it now has request_mask and query_flags arguments
to specify the fields and sync type requested by statx.  Filesystems not
supporting any statx-specific features may ignore the new arguments.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">atomic_open()</span></code> calling conventions have changed.  Gone is <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*opened</span></code>,
along with FILE_OPENED/FILE_CREATED.  In place of those we have
FMODE_OPENED/FMODE_CREATED, set in file-&gt;f_mode.  Additionally, return
value for 'called <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">finish_no_open()</span></code>, open it yourself' case has become
0, not 1.  Since <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">finish_no_open()</span></code> itself is returning 0 now, that part
does not need any changes in -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">atomic_open()</span></code> instances.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">alloc_file()</span></code> has become static now; two wrappers are to be used instead.
alloc_file_pseudo(inode, vfsmount, name, flags, ops) is for the cases
when dentry needs to be created; that's the majority of old <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">alloc_file()</span></code>
users.  Calling conventions: on success a reference to new <a class="reference internal" href="api-summary.html#c.file" title="file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code></a>
is returned and callers reference to inode is subsumed by that.  On
failure, <a class="reference internal" href="../core-api/kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a> is returned and no caller's references are affected,
so the caller needs to drop the inode reference it held.
alloc_file_clone(file, flags, ops) does not affect any caller's references.
On success you get a new <a class="reference internal" href="api-summary.html#c.file" title="file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code></a> sharing the mount/dentry with the
original, on failure - <a class="reference internal" href="../core-api/kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a>.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">clone_file_range()</span></code> and -&gt;dedupe_file_range have been replaced with
-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">remap_file_range()</span></code>.  See <a class="reference internal" href="vfs.html"><span class="doc">Linux 虛擬檔案系統概覽</span></a> for more
information.</p>
<p>---</p>
<p><strong>recommended</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">lookup()</span></code> instances doing an equivalent of:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>if (IS_ERR(inode))
        return ERR_CAST(inode);
return d_splice_alias(inode, dentry);
</pre></div>
</div>
<p>don't need to bother with the check - <a class="reference internal" href="api-summary.html#c.d_splice_alias" title="d_splice_alias"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_splice_alias()</span></code></a> will do the
right thing when given ERR_PTR(...) as inode.  Moreover, passing NULL
inode to <a class="reference internal" href="api-summary.html#c.d_splice_alias" title="d_splice_alias"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_splice_alias()</span></code></a> will also do the right thing (equivalent of
d_add(dentry, NULL); return NULL;), so that kind of special cases
also doesn't need a separate treatment.</p>
<p>---</p>
<p><strong>strongly recommended</strong></p>
<p>take the RCU-delayed parts of -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">destroy_inode()</span></code> into a new method -
-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">free_inode()</span></code>.  If -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">destroy_inode()</span></code> becomes empty - all the better,
just get rid of it.  Synchronous work (e.g. the stuff that can't
be done from an RCU callback, or any <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">WARN_ON()</span></code> where we want the
stack trace) <em>might</em> be movable to -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">evict_inode()</span></code>; however,
that goes only for the things that are not needed to balance something
done by -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">alloc_inode()</span></code>.  IOW, if it's cleaning up the stuff that
might have accumulated over the life of in-core inode, -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">evict_inode()</span></code>
might be a fit.</p>
<p>Rules for inode destruction:</p>
<blockquote>
<div><ul class="simple">
<li><p>if -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">destroy_inode()</span></code> is non-NULL, it gets called</p></li>
<li><p>if -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">free_inode()</span></code> is non-NULL, it gets scheduled by <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a></p></li>
<li><p>combination of NULL -&gt;destroy_inode and NULL -&gt;free_inode is
treated as NULL/free_inode_nonrcu, to preserve the compatibility.</p></li>
</ul>
</div></blockquote>
<p>Note that the callback (be it via -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">free_inode()</span></code> or explicit <a class="reference internal" href="../core-api/kernel-api.html#c.call_rcu" title="call_rcu"><code class="xref c c-func docutils literal notranslate"><span class="pre">call_rcu()</span></code></a>
in -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">destroy_inode()</span></code>) is <em>NOT</em> ordered wrt superblock destruction;
as the matter of fact, the superblock and all associated structures
might be already gone.  The filesystem driver is guaranteed to be still
there, but that's it.  Freeing memory in the callback is fine; doing
more than that is possible, but requires a lot of care and is best
avoided.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>DCACHE_RCUACCESS is gone; having an RCU delay on dentry freeing is the
default.  DCACHE_NORCU opts out, and only <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">d_alloc_pseudo()</span></code> has any
business doing so.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">d_alloc_pseudo()</span></code> is internal-only; uses outside of <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">alloc_file_pseudo()</span></code> are
very suspect (and won't work in modules).  Such uses are very likely to
be misspelled <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">d_alloc_anon()</span></code>.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>[should've been added in 2016] stale comment in <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">finish_open()</span></code> notwithstanding,
failure exits in -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">atomic_open()</span></code> instances should <em>NOT</em> <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">fput()</span></code> the file,
no matter what.  Everything is handled by the caller.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p><a class="reference internal" href="api-summary.html#c.clone_private_mount" title="clone_private_mount"><code class="xref c c-func docutils literal notranslate"><span class="pre">clone_private_mount()</span></code></a> returns a longterm mount now, so the proper destructor of
its result is <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">kern_unmount()</span></code> or <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">kern_unmount_array()</span></code>.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>zero-length bvec segments are disallowed, they must be filtered out before
passed on to an iterator.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>For bvec based itererators <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">bio_iov_iter_get_pages()</span></code> now doesn't copy bvecs but
uses the one provided. Anyone issuing kiocb-I/O should ensure that the bvec and
page references stay until I/O has completed, i.e. until -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">ki_complete()</span></code> has
been called or returned with non -EIOCBQUEUED code.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p><a class="reference internal" href="api-summary.html#c.mnt_want_write_file" title="mnt_want_write_file"><code class="xref c c-func docutils literal notranslate"><span class="pre">mnt_want_write_file()</span></code></a> can now only be paired with <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">mnt_drop_write_file()</span></code>,
whereas previously it could be paired with <a class="reference internal" href="api-summary.html#c.mnt_drop_write" title="mnt_drop_write"><code class="xref c c-func docutils literal notranslate"><span class="pre">mnt_drop_write()</span></code></a> as well.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">iov_iter_copy_from_user_atomic()</span></code> is gone; use <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">copy_page_from_iter_atomic()</span></code>.
The difference is <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">copy_page_from_iter_atomic()</span></code> advances the iterator and
you don't need <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">iov_iter_advance()</span></code> after it.  However, if you decide to use
only a part of obtained data, you should do <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">iov_iter_revert()</span></code>.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>Calling conventions for <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">file_open_root()</span></code> changed; now it takes <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">path</span></code> *
instead of passing mount and dentry separately.  For callers that used to
pass &lt;mnt, mnt-&gt;mnt_root&gt; pair (i.e. the root of given mount), a new helper
is provided - <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">file_open_root_mnt()</span></code>.  In-tree users adjusted.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>no_llseek is gone; don't set .llseek to that - just leave it NULL instead.
Checks for &quot;does that file have llseek(2), or should it fail with ESPIPE&quot;
should be done by looking at FMODE_LSEEK in file-&gt;f_mode.</p>
<p>---</p>
<p><em>mandatory</em></p>
<p>filldir_t (readdir callbacks) calling conventions have changed.  Instead of
returning 0 or -E... it returns bool now.  false means &quot;no more&quot; (as -E... used
to) and true - &quot;keep going&quot; (as 0 in old calling conventions).  Rationale:
callers never looked at specific -E... values anyway. -&gt; <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">iterate_shared()</span></code>
instances require no changes at all, all filldir_t ones in the tree
converted.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>Calling conventions for -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">tmpfile()</span></code> have changed.  It now takes a <a class="reference internal" href="api-summary.html#c.file" title="file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">file</span></code></a> pointer instead of <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">dentry</span></code> pointer.  <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">d_tmpfile()</span></code> is similarly
changed to simplify callers.  The passed file is in a non-open state and on
success must be opened before returning (e.g. by calling
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">finish_open_simple()</span></code>).</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>Calling convention for -&gt;huge_fault has changed.  It now takes a page
order instead of an <code class="xref c c-enum broken_xref docutils literal notranslate"><span class="pre">enum</span> <span class="pre">page_entry_size</span></code>, and it may be called without the
mmap_lock held.  All in-tree users have been audited and do not seem to
depend on the mmap_lock being held, but out of tree users should verify
for themselves.  If they do need it, they can return VM_FAULT_RETRY to
be called with the mmap_lock held.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>The order of opening block devices and matching or creating superblocks has
changed.</p>
<p>The old logic opened block devices first and then tried to find a
suitable superblock to reuse based on the block device pointer.</p>
<p>The new logic tries to find a suitable superblock first based on the device
number, and opening the block device afterwards.</p>
<p>Since opening block devices cannot happen under s_umount because of lock
ordering requirements s_umount is now dropped while opening block devices and
reacquired before calling <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">fill_super()</span></code>.</p>
<p>In the old logic concurrent mounters would find the superblock on the list of
superblocks for the filesystem type. Since the first opener of the block device
would hold s_umount they would wait until the superblock became either born or
was discarded due to initialization failure.</p>
<p>Since the new logic drops s_umount concurrent mounters could grab s_umount and
would spin. Instead they are now made to wait using an explicit wait-wake
mechanism without having to hold s_umount.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>The holder of a block device is now the superblock.</p>
<p>The holder of a block device used to be the file_system_type which wasn't
particularly useful. It wasn't possible to go from block device to owning
superblock without matching on the device pointer stored in the superblock.
This mechanism would only work for a single device so the block layer couldn't
find the owning superblock of any additional devices.</p>
<p>In the old mechanism reusing or creating a superblock for a racing mount(2) and
umount(2) relied on the file_system_type as the holder. This was severely
underdocumented however:</p>
<ol class="arabic simple">
<li><p>Any concurrent mounter that managed to grab an active reference on an
existing superblock was made to wait until the superblock either became
ready or until the superblock was removed from the list of superblocks of
the filesystem type. If the superblock is ready the caller would simple
reuse it.</p></li>
<li><p>If the mounter came after <a class="reference internal" href="api-summary.html#c.deactivate_locked_super" title="deactivate_locked_super"><code class="xref c c-func docutils literal notranslate"><span class="pre">deactivate_locked_super()</span></code></a> but before
the superblock had been removed from the list of superblocks of the
filesystem type the mounter would wait until the superblock was shutdown,
reuse the block device and allocate a new superblock.</p></li>
<li><p>If the mounter came after <a class="reference internal" href="api-summary.html#c.deactivate_locked_super" title="deactivate_locked_super"><code class="xref c c-func docutils literal notranslate"><span class="pre">deactivate_locked_super()</span></code></a> and after
the superblock had been removed from the list of superblocks of the
filesystem type the mounter would reuse the block device and allocate a new
superblock (the bd_holder point may still be set to the filesystem type).</p></li>
</ol>
<p>Because the holder of the block device was the file_system_type any concurrent
mounter could open the block devices of any superblock of the same
file_system_type without risking seeing EBUSY because the block device was
still in use by another superblock.</p>
<p>Making the superblock the owner of the block device changes this as the holder
is now a unique superblock and thus block devices associated with it cannot be
reused by concurrent mounters. So a concurrent mounter in (2) could suddenly
see EBUSY when trying to open a block device whose holder was a different
superblock.</p>
<p>The new logic thus waits until the superblock and the devices are shutdown in
-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">kill_sb()</span></code>. Removal of the superblock from the list of superblocks of the
filesystem type is now moved to a later point when the devices are closed:</p>
<ol class="arabic simple">
<li><p>Any concurrent mounter managing to grab an active reference on an existing
superblock is made to wait until the superblock is either ready or until
the superblock and all devices are shutdown in -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">kill_sb()</span></code>. If the
superblock is ready the caller will simply reuse it.</p></li>
<li><p>If the mounter comes after <a class="reference internal" href="api-summary.html#c.deactivate_locked_super" title="deactivate_locked_super"><code class="xref c c-func docutils literal notranslate"><span class="pre">deactivate_locked_super()</span></code></a> but before
the superblock has been removed from the list of superblocks of the
filesystem type the mounter is made to wait until the superblock and the
devices are shut down in -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">kill_sb()</span></code> and the superblock is removed from the
list of superblocks of the filesystem type. The mounter will allocate a new
superblock and grab ownership of the block device (the bd_holder pointer of
the block device will be set to the newly allocated superblock).</p></li>
<li><p>This case is now collapsed into (2) as the superblock is left on the list
of superblocks of the filesystem type until all devices are shutdown in
-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">kill_sb()</span></code>. In other words, if the superblock isn't on the list of
superblock of the filesystem type anymore then it has given up ownership of
all associated block devices (the bd_holder pointer is NULL).</p></li>
</ol>
<p>As this is a VFS level change it has no practical consequences for filesystems
other than that all of them must use one of the provided <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">kill_litter_super()</span></code>,
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">kill_anon_super()</span></code>, or <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">kill_block_super()</span></code> helpers.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>Lock ordering has been changed so that s_umount ranks above open_mutex again.
All places where s_umount was taken under open_mutex have been fixed up.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>export_operations -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">encode_fh()</span></code> no longer has a default implementation to
encode FILEID_INO32_GEN* file handles.
Filesystems that used the default implementation may use the generic helper
<a class="reference internal" href="api-summary.html#c.generic_encode_ino32_fh" title="generic_encode_ino32_fh"><code class="xref c c-func docutils literal notranslate"><span class="pre">generic_encode_ino32_fh()</span></code></a> explicitly.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>If -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">rename()</span></code> update of .. on cross-directory move needs an exclusion with
directory modifications, do <em>not</em> lock the subdirectory in question in your
-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">rename()</span></code> - it's done by the caller now [that item should've been added in
28eceeda130f &quot;fs: Lock moved directories&quot;].</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>On same-directory -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">rename()</span></code> the (tautological) update of .. is not protected
by any locks; just don't do it if the old parent is the same as the new one.
We really can't lock two subdirectories in same-directory rename - not without
deadlocks.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">lock_rename()</span></code> and <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">lock_rename_child()</span></code> may fail in cross-directory case, if
their arguments do not have a common ancestor.  In that case ERR_PTR(-EXDEV)
is returned, with no locks taken.  In-tree users updated; out-of-tree ones
would need to do so.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>The list of children anchored in parent dentry got turned into hlist now.
Field names got changed (-&gt;d_children/-&gt;d_sib instead of -&gt;d_subdirs/-&gt;d_child
for anchor/entries resp.), so any affected places will be immediately caught
by compiler.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<a class="reference internal" href="api-summary.html#c.d_delete" title="d_delete"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_delete()</span></code></a> instances are now called for dentries with -&gt;d_lock held
and refcount equal to 0.  They are not permitted to drop/regain -&gt;d_lock.
None of in-tree instances did anything of that sort.  Make sure yours do not...</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">d_prune()</span></code> instances are now called without -&gt;d_lock held on the parent.
-&gt;d_lock on dentry itself is still held; if you need per-parent exclusions (none
of the in-tree instances did), use your own spinlock.</p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">d_iput()</span></code> and -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">d_release()</span></code> are called with victim dentry still in the
list of parent's children.  It is still unhashed, marked killed, etc., just not
removed from parent's -&gt;d_children yet.</p>
<p>Anyone iterating through the list of children needs to be aware of the
half-killed dentries that might be seen there; taking -&gt;d_lock on those will
see them negative, unhashed and with negative refcount, which means that most
of the in-kernel users would've done the right thing anyway without any adjustment.</p>
<p>---</p>
<p><strong>recommended</strong></p>
<p>Block device freezing and thawing have been moved to holder operations.</p>
<p>Before this change, <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">get_active_super()</span></code> would only be able to find the
superblock of the main block device, i.e., the one stored in sb-&gt;s_bdev. Block
device freezing now works for any block device owned by a given superblock, not
just the main block device. The <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">get_active_super()</span></code> helper and bd_fsfreeze_sb
pointer are gone.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">set_blocksize()</span></code> takes opened <a class="reference internal" href="api-summary.html#c.file" title="file"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">file</span></code></a> instead of <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">block_device</span></code> now
and it <em>must</em> be opened exclusive.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">d_revalidate()</span></code> gets two extra arguments - inode of parent directory and
name our dentry is expected to have.  Both are stable (dir is pinned in
non-RCU case and will stay around during the call in RCU case, and name
is guaranteed to stay unchanging).  Your instance doesn't have to use
either, but it often helps to avoid a lot of painful boilerplate.
Note that while name-&gt;name is stable and NUL-terminated, it may (and
often will) have name-&gt;name[name-&gt;len] equal to '/' rather than '0' -
in normal case it points into the pathname being looked up.
NOTE: if you need something like full path from the root of filesystem,
you are still on your own - this assists with simple cases, but it's not
magic.</p>
<p>---</p>
<p><strong>recommended</strong></p>
<p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">kern_path_locked()</span></code> and <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">user_path_locked()</span></code> no longer return a negative
dentry so this doesn't need to be checked.  If the name cannot be found,
ERR_PTR(-ENOENT) is returned.</p>
<p>---</p>
<p><strong>recommended</strong></p>
<p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">lookup_one_qstr_excl()</span></code> is changed to return errors in more cases, so
these conditions don't require explicit checks:</p>
<blockquote>
<div><ul class="simple">
<li><p>if LOOKUP_CREATE is NOT given, then the dentry won't be negative,
ERR_PTR(-ENOENT) is returned instead</p></li>
<li><p>if LOOKUP_EXCL IS given, then the dentry won't be positive,
ERR_PTR(-EEXIST) is rreturned instread</p></li>
</ul>
</div></blockquote>
<p>LOOKUP_EXCL now means &quot;target must not exist&quot;.  It can be combined with
LOOK_CREATE or LOOKUP_RENAME_TARGET.</p>
<p>---</p>
<p><strong>mandatory</strong>
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">invalidate_inodes()</span></code> is gone use <a class="reference internal" href="api-summary.html#c.evict_inodes" title="evict_inodes"><code class="xref c c-func docutils literal notranslate"><span class="pre">evict_inodes()</span></code></a> instead.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>-&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">mkdir()</span></code> now returns a dentry.  If the created inode is found to
already be in cache and have a dentry (often <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">IS_ROOT()</span></code>), it will need to
be spliced into the given name in place of the given dentry. That dentry
now needs to be returned.  If the original dentry is used, NULL should
be returned.  Any error should be returned with <a class="reference internal" href="../core-api/kernel-api.html#c.ERR_PTR" title="ERR_PTR"><code class="xref c c-func docutils literal notranslate"><span class="pre">ERR_PTR()</span></code></a>.</p>
<p>In general, filesystems which use <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">d_instantiate_new()</span></code> to install the new
inode can safely return NULL.  Filesystems which may not have an I_NEW inode
should use <a class="reference internal" href="api-summary.html#c.d_drop" title="d_drop"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_drop()</span></code></a>;<a class="reference internal" href="api-summary.html#c.d_splice_alias" title="d_splice_alias"><code class="xref c c-func docutils literal notranslate"><span class="pre">d_splice_alias()</span></code></a> and return the result of the latter.</p>
<p>If a positive dentry cannot be returned for some reason, in-kernel
clients such as cachefiles, nfsd, smb/server may not perform ideally but
will fail-safe.</p>
<p>---</p>
<p>** mandatory**</p>
<p><a class="reference internal" href="api-summary.html#c.lookup_one" title="lookup_one"><code class="xref c c-func docutils literal notranslate"><span class="pre">lookup_one()</span></code></a>, <a class="reference internal" href="api-summary.html#c.lookup_one_unlocked" title="lookup_one_unlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">lookup_one_unlocked()</span></code></a>, <a class="reference internal" href="api-summary.html#c.lookup_one_positive_unlocked" title="lookup_one_positive_unlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">lookup_one_positive_unlocked()</span></code></a> now
take a qstr instead of a name and len.  These, not the &quot;one_len&quot;
versions, should be used whenever accessing a filesystem from outside
that filesysmtem, through a mount point - which will have a mnt_idmap.</p>
<p>---</p>
<p>** mandatory**</p>
<p>Functions <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">try_lookup_one_len()</span></code>, <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">lookup_one_len()</span></code>,
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">lookup_one_len_unlocked()</span></code> and <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">lookup_positive_unlocked()</span></code> have been
renamed to <a class="reference internal" href="api-summary.html#c.try_lookup_noperm" title="try_lookup_noperm"><code class="xref c c-func docutils literal notranslate"><span class="pre">try_lookup_noperm()</span></code></a>, <a class="reference internal" href="api-summary.html#c.lookup_noperm" title="lookup_noperm"><code class="xref c c-func docutils literal notranslate"><span class="pre">lookup_noperm()</span></code></a>,
<a class="reference internal" href="api-summary.html#c.lookup_noperm_unlocked" title="lookup_noperm_unlocked"><code class="xref c c-func docutils literal notranslate"><span class="pre">lookup_noperm_unlocked()</span></code></a>, <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">lookup_noperm_positive_unlocked()</span></code>.  They now
take a qstr instead of separate name and length.  <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">QSTR()</span></code> can be used
when <a class="reference internal" href="../core-api/kernel-api.html#c.strlen" title="strlen"><code class="xref c c-func docutils literal notranslate"><span class="pre">strlen()</span></code></a> is needed for the length.</p>
<p>These function no longer do any permission checking - they previously
checked that the caller has 'X' permission on the parent.  They must
ONLY be used internally by a filesystem on itself when it knows that
permissions are irrelevant or in a context where permission checks have
already been performed such as after <a class="reference internal" href="api-summary.html#c.vfs_path_parent_lookup" title="vfs_path_parent_lookup"><code class="xref c c-func docutils literal notranslate"><span class="pre">vfs_path_parent_lookup()</span></code></a></p>
<p>---</p>
<p>** mandatory**</p>
<p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">d_hash_and_lookup()</span></code> is no longer exported or available outside the VFS.
Use <a class="reference internal" href="api-summary.html#c.try_lookup_noperm" title="try_lookup_noperm"><code class="xref c c-func docutils literal notranslate"><span class="pre">try_lookup_noperm()</span></code></a> instead.  This adds name validation and takes
arguments in the opposite order but is otherwise identical.</p>
<p>Using <a class="reference internal" href="api-summary.html#c.try_lookup_noperm" title="try_lookup_noperm"><code class="xref c c-func docutils literal notranslate"><span class="pre">try_lookup_noperm()</span></code></a> will require linux/namei.h to be included.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>Calling conventions for -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">d_automount()</span></code> have changed; we should <em>not</em> grab
an extra reference to new mount - it should be returned with refcount 1.</p>
<p>---</p>
<p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">collect_mounts()</span></code>/<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">drop_collected_mounts()</span></code>/<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">iterate_mounts()</span></code> are gone now.
Replacement is <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">collect_paths()</span></code>/<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">drop_collected_path()</span></code>, with no special
iterator needed.  Instead of a cloned mount tree, the new interface returns
an array of <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">path</span></code>, one for each mount <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">collect_mounts()</span></code> would've
created.  These <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">path</span></code> point to locations in the caller's namespace
that would be roots of the cloned mounts.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>If your filesystem sets the default dentry_operations, use <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">set_default_d_op()</span></code>
rather than manually setting sb-&gt;s_d_op.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">d_set_d_op()</span></code> is no longer exported (or public, for that matter); _if_
your filesystem really needed that, make use of <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">d_splice_alias_ops()</span></code>
to have them set.  Better yet, think hard whether you need different
-&gt;d_op for different dentries - if not, just use <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">set_default_d_op()</span></code>
at mount time and be done with that.  Currently procfs is the only
thing that really needs -&gt;d_op varying between dentries.</p>
<p>---</p>
<p><strong>highly recommended</strong></p>
<p>The file operations mmap() callback is deprecated in favour of
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">mmap_prepare()</span></code>. This passes a pointer to a vm_area_desc to the callback
rather than a VMA, as the VMA at this stage is not yet valid.</p>
<p>The vm_area_desc provides the minimum required information for a filesystem
to initialise state upon memory mapping of a file-backed region, and output
parameters for the file system to set this state.</p>
<p>In nearly all cases, this is all that is required for a filesystem. However, if
a filesystem needs to perform an operation such a pre-population of page tables,
then that action can be specified in the vm_area_desc-&gt;action field, which can
be configured using the mmap_action_*() helpers.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>Several functions are renamed:</p>
<ul class="simple">
<li><p>kern_path_locked -&gt; start_removing_path</p></li>
<li><p>kern_path_create -&gt; start_creating_path</p></li>
<li><p>user_path_create -&gt; start_creating_user_path</p></li>
<li><p>user_path_locked_at -&gt; start_removing_user_path_at</p></li>
<li><p>done_path_create -&gt; end_creating_path</p></li>
</ul>
<p>---</p>
<p><strong>mandatory</strong></p>
<p>Calling conventions for <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">vfs_parse_fs_string()</span></code> have changed; it does <em>not</em>
take length anymore (value ? strlen(value) : 0 is used).  If you want
a different length, use</p>
<blockquote>
<div><p>vfs_parse_fs_qstr(fc, key, &amp;QSTR_LEN(value, len))</p>
</div></blockquote>
<p>instead.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p><a class="reference internal" href="api-summary.html#c.vfs_mkdir" title="vfs_mkdir"><code class="xref c c-func docutils literal notranslate"><span class="pre">vfs_mkdir()</span></code></a> now returns a dentry - the one returned by -&gt;<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">mkdir()</span></code>.  If
that dentry is different from the dentry passed in, including if it is
an <a class="reference internal" href="../core-api/kernel-api.html#c.IS_ERR" title="IS_ERR"><code class="xref c c-func docutils literal notranslate"><span class="pre">IS_ERR()</span></code></a> dentry pointer, the original dentry is <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">dput()</span></code>.</p>
<p>When <a class="reference internal" href="api-summary.html#c.vfs_mkdir" title="vfs_mkdir"><code class="xref c c-func docutils literal notranslate"><span class="pre">vfs_mkdir()</span></code></a> returns an error, and so both <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">dputs()</span></code> the original
dentry and doesn't provide a replacement, it also unlocks the parent.
Consequently the return value from <a class="reference internal" href="api-summary.html#c.vfs_mkdir" title="vfs_mkdir"><code class="xref c c-func docutils literal notranslate"><span class="pre">vfs_mkdir()</span></code></a> can be passed to
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">end_creating()</span></code> and the parent will be unlocked precisely when necessary.</p>
<p>---</p>
<p><strong>mandatory</strong></p>
<p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">kill_litter_super()</span></code> is gone; convert to DCACHE_PERSISTENT use (as all
in-tree filesystems have done).</p>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;The kernel development community.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/filesystems/porting.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>