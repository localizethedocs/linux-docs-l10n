<!DOCTYPE html>

<html lang="zh-TW" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>CXL Access Coordinates Computation &#8212; The Linux Kernel unknown version 說明文件</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=adfc0c0d" />
    <script src="../../../_static/documentation_options.js?v=b446b479"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/translations.js?v=cbf116e0"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/linux-docs-l10n/driver-api/cxl/linux/access-coordinates.html" />
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜尋" href="../../../search.html" />
    <link rel="next" title="DAX Devices" href="../allocation/dax.html" />
    <link rel="prev" title="記憶體熱插拔" href="memory-hotplug.html" />

   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

<script type="text/javascript" src="../../../ltd-provenance.js"></script>
<script type="text/javascript" src="../../../ltd-current.js"></script>
<script type="text/javascript" src="../../../../../ltd-config.js"></script>
<script type="text/javascript" src="../../../../../ltd-flyout.js"></script>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/logo.svg" alt="Logo of The Linux Kernel"/>
            </a></p>
<h1 class="logo"><a href="../../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.19.0</p>







<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜尋</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="前往" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>


<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/submitting-patches.html">提交補釘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/code-of-conduct.html">行為守則</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../maintainer/index.html">維護者手冊</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../core-api/index.html">核心 API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Driver APIs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../index.html#general-information-for-driver-authors">General information for driver authors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../index.html#useful-support-libraries">Useful support libraries</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../index.html#bus-level-documentation">Bus-level documentation</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../auxiliary_bus.html">Auxiliary Bus</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../index.html">Compute Express Link</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../eisa.html">EISA bus support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../firewire.html">Firewire (IEEE 1394) driver Interface Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../i3c/index.html">I3C subsystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../isa.html">ISA Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../men-chameleon-bus.html">MEN Chameleon Bus</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../pci/index.html">The Linux PCI driver implementer's API guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../rapidio/index.html">Linux RapidIO 子系統</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../slimbus.html">Linux kernel SLIMbus support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../usb/index.html">Linux USB API</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../virtio/index.html">Virtio</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../vme.html">VME Device Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../w1.html">W1: Dallas' 1-wire bus</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../xillybus.html">Xillybus driver for generic FPGA interface</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../index.html#subsystem-specific-apis">Subsystem-specific APIs</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../../../subsystem-apis.html">子系統</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../../../subsystem-apis.html#core-subsystems">Core subsystems</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../../core-api/index.html">核心 API 文件</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../../index.html">Driver implementer's API guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../mm/index.html">記憶體管理文件</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../power/index.html">電源管理</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../scheduler/index.html">Scheduler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../timers/index.html">計時器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../locking/index.html">Locking</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../subsystem-apis.html#other-subsystems">其他子系統</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../doc-guide/index.html">撰寫文件</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev-tools/index.html">開發工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev-tools/testing-overview.html">測試指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../livepatch/index.html">即時補釘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kbuild/index.html">建置系統</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/reporting-issues.html">回報議題</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tools/index.html">使用者空間工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userspace-api/index.html">使用者空間 API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../firmware-guide/index.html">韌體</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../devicetree/index.html">韌體與裝置樹</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../arch/index.html">CPU 架構</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../staging/index.html">未排序的文件</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>本頁</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/driver-api/cxl/linux/access-coordinates.rst.txt"
            rel="nofollow">顯示原始碼</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="cxl-access-coordinates-computation">
<h1>CXL Access Coordinates Computation<a class="headerlink" href="#cxl-access-coordinates-computation" title="連結到這個標頭">¶</a></h1>
<section id="latency-and-bandwidth-calculation">
<h2>Latency and Bandwidth Calculation<a class="headerlink" href="#latency-and-bandwidth-calculation" title="連結到這個標頭">¶</a></h2>
<p>A memory region performance coordinates (latency and bandwidth) are typically
provided via ACPI tables <a class="reference internal" href="../platform/acpi/srat.html"><span class="doc">SRAT</span></a> and
<a class="reference internal" href="../platform/acpi/hmat.html"><span class="doc">HMAT</span></a>. However, the platform firmware (BIOS) is
not able to annotate those for CXL devices that are hot-plugged since they do
not exist during platform firmware initialization. The CXL driver can compute
the performance coordinates by retrieving data from several components.</p>
<p>The <a class="reference internal" href="../platform/acpi/srat.html"><span class="doc">SRAT</span></a> provides a Generic Port Affinity
subtable that ties a proximity domain to a device handle, which in this case
would be the CXL hostbridge. Using this association, the performance
coordinates for the Generic Port can be retrieved from the
<a class="reference internal" href="../platform/acpi/hmat.html"><span class="doc">HMAT</span></a> subtable. This piece represents the
performance coordinates between a CPU and a Generic Port (CXL hostbridge).</p>
<p>The <a class="reference internal" href="../platform/cdat.html"><span class="doc">CDAT</span></a> provides the performance coordinates for
the CXL device itself. That is the bandwidth and latency to access that device's
memory region. The DSMAS subtable provides a DSMADHandle that is tied to a
Device Physical Address (DPA) range. The DSLBIS subtable provides the
performance coordinates that's tied to a DSMADhandle and this ties the two
table entries together to provide the performance coordinates for each DPA
region. For example, if a device exports a DRAM region and a PMEM region,
then there would be different performance characteristsics for each of those
regions.</p>
<p>If there's a CXL switch in the topology, then the performance coordinates for the
switch is provided by SSLBIS subtable. This provides the bandwidth and latency
for traversing the switch between the switch upstream port and the switch
downstream port that points to the endpoint device.</p>
<p>Simple topology example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>GP0/HB0/ACPI0016-0
       RP0
        |
        | L0
        |
    SW 0 / USP0
    SW 0 / DSP0
        |
        | L1
        |
       EP0
</pre></div>
</div>
<p>In this example, there is a CXL switch between an endpoint and a root port.
Latency in this example is calculated as such:
L(EP0) - Latency from EP0 CDAT DSMAS+DSLBIS
L(L1) - Link latency between EP0 and SW0DSP0
L(SW0) - Latency for the switch from SW0 CDAT SSLBIS.
L(L0) - Link latency between SW0 and RP0
L(RP0) - Latency from root port to CPU via SRAT and HMAT (Generic Port).
Total read and write latencies are the sum of all these parts.</p>
<p>Bandwidth in this example is calculated as such:
B(EP0) - Bandwidth from EP0 CDAT DSMAS+DSLBIS
B(L1) - Link bandwidth between EP0 and SW0DSP0
B(SW0) - Bandwidth for the switch from SW0 CDAT SSLBIS.
B(L0) - Link bandwidth between SW0 and RP0
B(RP0) - Bandwidth from root port to CPU via SRAT and HMAT (Generic Port).
The total read and write bandwidth is the <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">min()</span></code> of all these parts.</p>
<p>To calculate the link bandwidth:
LinkOperatingFrequency (GT/s) is the current negotiated link speed.
DataRatePerLink (MB/s) = LinkOperatingFrequency / 8
Bandwidth (MB/s) = PCIeCurrentLinkWidth * DataRatePerLink
Where PCIeCurrentLinkWidth is the number of lanes in the link.</p>
<p>To calculate the link latency:
LinkLatency (picoseconds) = FlitSize / LinkBandwidth (MB/s)</p>
<p>See <a class="reference external" href="https://www.intel.com/content/www/us/en/content-details/643805/cxl-memory-device-software-guide.html">CXL Memory Device SW Guide r1.0</a>,
section 2.11.3 and 2.11.4 for details.</p>
<p>In the end, the access coordinates for a constructed memory region is calculated from one
or more memory partitions from each of the CXL device(s).</p>
</section>
<section id="shared-upstream-link-calculation">
<h2>Shared Upstream Link Calculation<a class="headerlink" href="#shared-upstream-link-calculation" title="連結到這個標頭">¶</a></h2>
<p>For certain CXL region construction with endpoints behind CXL switches (SW) or
Root Ports (RP), there is the possibility of the total bandwidth for all
the endpoints behind a switch being more than the switch upstream link.
A similar situation can occur within the host, upstream of the root ports.
The CXL driver performs an additional pass after all the targets have
arrived for a region in order to recalculate the bandwidths with possible
upstream link being a limiting factor in mind.</p>
<p>The algorithm assumes the configuration is a symmetric topology as that
maximizes performance. When asymmetric topology is detected, the calculation
is aborted. An asymmetric topology is detected during topology walk where the
number of RPs detected as a grandparent is not equal to the number of devices
iterated in the same iteration loop. The assumption is made that subtle
asymmetry in properties does not happen and all paths to EPs are equal.</p>
<p>There can be multiple switches under an RP. There can be multiple RPs under
a CXL Host Bridge (HB). There can be multiple HBs under a CXL Fixed Memory
Window Structure (CFMWS) in the <a class="reference internal" href="../platform/acpi/cedt.html"><span class="doc">CEDT</span></a>.</p>
<p>An example hierarchy:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>               CFMWS 0
                 |
        _________|_________
       |                   |
   ACPI0017-0          ACPI0017-1
GP0/HB0/ACPI0016-0   GP1/HB1/ACPI0016-1
   |          |        |           |
  RP0        RP1      RP2         RP3
   |          |        |           |
 SW 0       SW 1     SW 2        SW 3
 |   |      |   |    |   |       |   |
EP0 EP1    EP2 EP3  EP4  EP5    EP6 EP7
</pre></div>
</div>
<p>Computation for the example hierarchy:</p>
<dl class="simple">
<dt>Min (GP0 to CPU BW,</dt><dd><dl class="simple">
<dt>Min(SW 0 Upstream Link to RP0 BW,</dt><dd><p>Min(SW0SSLBIS for SW0DSP0 (EP0), EP0 DSLBIS, EP0 Upstream Link) +
Min(SW0SSLBIS for SW0DSP1 (EP1), EP1 DSLBIS, EP1 Upstream link)) +</p>
</dd>
<dt>Min(SW 1 Upstream Link to RP1 BW,</dt><dd><p>Min(SW1SSLBIS for SW1DSP0 (EP2), EP2 DSLBIS, EP2 Upstream Link) +
Min(SW1SSLBIS for SW1DSP1 (EP3), EP3 DSLBIS, EP3 Upstream link))) +</p>
</dd>
</dl>
</dd>
<dt>Min (GP1 to CPU BW,</dt><dd><dl class="simple">
<dt>Min(SW 2 Upstream Link to RP2 BW,</dt><dd><p>Min(SW2SSLBIS for SW2DSP0 (EP4), EP4 DSLBIS, EP4 Upstream Link) +
Min(SW2SSLBIS for SW2DSP1 (EP5), EP5 DSLBIS, EP5 Upstream link)) +</p>
</dd>
<dt>Min(SW 3 Upstream Link to RP3 BW,</dt><dd><p>Min(SW3SSLBIS for SW3DSP0 (EP6), EP6 DSLBIS, EP6 Upstream Link) +
Min(SW3SSLBIS for SW3DSP1 (EP7), EP7 DSLBIS, EP7 Upstream link))))</p>
</dd>
</dl>
</dd>
</dl>
<p>The calculation starts at <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">cxl_region_shared_upstream_perf_update()</span></code>. A xarray
is created to collect all the endpoint bandwidths via the
<a class="reference internal" href="../theory-of-operation.html#c.cxl_endpoint_gather_bandwidth" title="cxl_endpoint_gather_bandwidth"><code class="xref c c-func docutils literal notranslate"><span class="pre">cxl_endpoint_gather_bandwidth()</span></code></a> function. The <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">min()</span></code> of bandwidth from the
endpoint CDAT and the upstream link bandwidth is calculated. If the endpoint
has a CXL switch as a parent, then <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">min()</span></code> of calculated bandwidth and the
bandwidth from the SSLBIS for the switch downstream port that is associated
with the endpoint is calculated. The final bandwidth is stored in a
'<code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cxl_perf_ctx</span></code>' in the xarray indexed by a device pointer. If the
endpoint is direct attached to a root port (RP), the device pointer would be an
RP device. If the endpoint is behind a switch, the device pointer would be the
upstream device of the parent switch.</p>
<p>At the next stage, the code walks through one or more switches if they exist
in the topology. For endpoints directly attached to RPs, this step is skipped.
If there is another switch upstream, the code takes the <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">min()</span></code> of the current
gathered bandwidth and the upstream link bandwidth. If there's a switch
upstream, then the SSLBIS of the upstream switch.</p>
<p>Once the topology walk reaches the RP, whether it's direct attached endpoints
or walking through the switch(es), <a class="reference internal" href="../theory-of-operation.html#c.cxl_rp_gather_bandwidth" title="cxl_rp_gather_bandwidth"><code class="xref c c-func docutils literal notranslate"><span class="pre">cxl_rp_gather_bandwidth()</span></code></a> is called. At
this point all the bandwidths are aggregated per each host bridge, which is
also the index for the resulting xarray.</p>
<p>The next step is to take the <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">min()</span></code> of the per host bridge bandwidth and the
bandwidth from the Generic Port (GP). The bandwidths for the GP are retrieved
via ACPI tables (<a class="reference internal" href="../platform/acpi/srat.html"><span class="doc">SRAT</span></a> and
<a class="reference internal" href="../platform/acpi/hmat.html"><span class="doc">HMAT</span></a>). The minimum bandwidth are aggregated
under the same ACPI0017 device to form a new xarray.</p>
<p>Finally, the <a class="reference internal" href="../theory-of-operation.html#c.cxl_region_update_bandwidth" title="cxl_region_update_bandwidth"><code class="xref c c-func docutils literal notranslate"><span class="pre">cxl_region_update_bandwidth()</span></code></a> is called and the aggregated
bandwidth from all the members of the last xarray is updated for the
access coordinates residing in the cxl region (cxlr) context.</p>
</section>
<section id="qtg-id">
<h2>QTG ID<a class="headerlink" href="#qtg-id" title="連結到這個標頭">¶</a></h2>
<p>Each <a class="reference internal" href="../platform/acpi/cedt.html"><span class="doc">CEDT</span></a> has a QTG ID field. This field provides
the ID that associates with a QoS Throttling Group (QTG) for the CFMWS window.
Once the access coordinates are calculated, an ACPI Device Specific Method can
be issued to the ACPI0016 device to retrieve the QTG ID depends on the access
coordinates provided. The QTG ID for the device can be used as guidance to match
to the CFMWS to setup the best Linux root decoder for the device performance.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;The kernel development community.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../../../_sources/driver-api/cxl/linux/access-coordinates.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>