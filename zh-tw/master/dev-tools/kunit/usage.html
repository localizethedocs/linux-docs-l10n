<!DOCTYPE html>

<html lang="zh-TW" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Writing Tests &#8212; The Linux Kernel unknown version 說明文件</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=adfc0c0d" />
    <script src="../../_static/documentation_options.js?v=b446b479"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/translations.js?v=cbf116e0"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/linux-docs-l10n/dev-tools/kunit/usage.html" />
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜尋" href="../../search.html" />
    <link rel="next" title="API Reference" href="api/index.html" />
    <link rel="prev" title="Run Tests without kunit_tool" href="run_manual.html" />

   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

<script type="text/javascript" src="../../ltd-provenance.js"></script>
<script type="text/javascript" src="../../ltd-current.js"></script>
<script type="text/javascript" src="../../../../ltd-config.js"></script>
<script type="text/javascript" src="../../../../ltd-flyout.js"></script>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo of The Linux Kernel"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.19.0</p>







<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜尋</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="前往" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>


<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">提交補釘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">行為守則</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">維護者手冊</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">核心 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../subsystem-apis.html">子系統</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">撰寫文件</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">開發工具</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../testing-overview.html">內核測試指南</a></li>
<li class="toctree-l2"><a class="reference internal" href="../checkpatch.html">Checkpatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../clang-format.html">clang-format</a></li>
<li class="toctree-l2"><a class="reference internal" href="../coccinelle.html">Coccinelle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sparse.html">Sparse</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kcov.html">KCOV: code coverage for fuzzing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gcov.html">Using gcov with the Linux kernel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kasan.html">Kernel Address Sanitizer (KASAN)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kmsan.html">Kernel Memory Sanitizer (KMSAN)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ubsan.html">Undefined Behavior Sanitizer - UBSAN</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kmemleak.html">Kernel Memory Leak Detector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kcsan.html">Kernel Concurrency Sanitizer (KCSAN)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lkmm/index.html">Linux Kernel Memory Consistency Model (LKMM)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kfence.html">Kernel Electric-Fence (KFENCE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kselftest.html">Linux Kernel Selftests</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">KUnit - Linux Kernel Unit Testing</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="start.html">Getting Started</a></li>
<li class="toctree-l3"><a class="reference internal" href="architecture.html">KUnit Architecture</a></li>
<li class="toctree-l3"><a class="reference internal" href="run_wrapper.html">Running tests with kunit_tool</a></li>
<li class="toctree-l3"><a class="reference internal" href="run_manual.html">Run Tests without kunit_tool</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Writing Tests</a></li>
<li class="toctree-l3"><a class="reference internal" href="#common-patterns">Common Patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="api/index.html">API Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="style.html">Test Style and Nomenclature</a></li>
<li class="toctree-l3"><a class="reference internal" href="faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l3"><a class="reference internal" href="running_tips.html">Tips For Running KUnit Tests</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#introduction">介紹</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#unit-testing">Unit Testing</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#how-do-i-use-it">How do I use it?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../ktap.html">The Kernel Test Anything Protocol (KTAP), version 1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../checkuapi.html">UAPI Checker</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gpio-sloppy-logic-analyzer.html">Linux Kernel GPIO based sloppy logic analyzer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../autofdo.html">Using AutoFDO with the Linux kernel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../propeller.html">Using Propeller with the Linux kernel</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../testing-overview.html">測試指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">即時補釘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">建置系統</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">回報議題</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">使用者空間工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">使用者空間 API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">韌體</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">韌體與裝置樹</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">CPU 架構</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">未排序的文件</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>本頁</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/dev-tools/kunit/usage.rst.txt"
            rel="nofollow">顯示原始碼</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="writing-tests">
<h1>Writing Tests<a class="headerlink" href="#writing-tests" title="連結到這個標頭">¶</a></h1>
<section id="test-cases">
<h2>Test Cases<a class="headerlink" href="#test-cases" title="連結到這個標頭">¶</a></h2>
<p>The fundamental unit in KUnit is the test case. A test case is a function with
the signature <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">kunit</span> <span class="pre">*test)</span></code>. It calls the function under test
and then sets <em>expectations</em> for what should happen. For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">example_test_success</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">example_test_failure</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="n">KUNIT_FAIL</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;This test never passes.&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the above example, <code class="docutils literal notranslate"><span class="pre">example_test_success</span></code> always passes because it does
nothing; no expectations are set, and therefore all expectations pass. On the
other hand <code class="docutils literal notranslate"><span class="pre">example_test_failure</span></code> always fails because it calls <code class="docutils literal notranslate"><span class="pre">KUNIT_FAIL</span></code>,
which is a special expectation that logs a message and causes the test case to
fail.</p>
<section id="expectations">
<h3>Expectations<a class="headerlink" href="#expectations" title="連結到這個標頭">¶</a></h3>
<p>An <em>expectation</em> specifies that we expect a piece of code to do something in a
test. An expectation is called like a function. A test is made by setting
expectations about the behavior of a piece of code under test. When one or more
expectations fail, the test case fails and information about the failure is
logged. For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">add_test_basic</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the above example, <code class="docutils literal notranslate"><span class="pre">add_test_basic</span></code> makes a number of assertions about the
behavior of a function called <code class="docutils literal notranslate"><span class="pre">add</span></code>. The first parameter is always of type
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kunit</span> <span class="pre">*</span></code>, which contains information about the current test context.
The second parameter, in this case, is what the value is expected to be. The
last value is what the value actually is. If <code class="docutils literal notranslate"><span class="pre">add</span></code> passes all of these
expectations, the test case, <code class="docutils literal notranslate"><span class="pre">add_test_basic</span></code> will pass; if any one of these
expectations fails, the test case will fail.</p>
<p>A test case <em>fails</em> when any expectation is violated; however, the test will
continue to run, and try other expectations until the test case ends or is
otherwise terminated. This is as opposed to <em>assertions</em> which are discussed
later.</p>
<p>To learn about more KUnit expectations, see <a class="reference internal" href="api/test.html"><span class="doc">Test API</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>A single test case should be short, easy to understand, and focused on a
single behavior.</p>
</div>
<p>For example, if we want to rigorously test the <code class="docutils literal notranslate"><span class="pre">add</span></code> function above, create
additional tests cases which would test each property that an <code class="docutils literal notranslate"><span class="pre">add</span></code> function
should have as shown below:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">add_test_basic</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">add_test_negative</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">add_test_max</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">INT_MAX</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">INT_MAX</span><span class="p">));</span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="n">INT_MAX</span><span class="p">,</span><span class="w"> </span><span class="n">INT_MIN</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">add_test_overflow</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">INT_MIN</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="n">INT_MAX</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="assertions">
<h3>Assertions<a class="headerlink" href="#assertions" title="連結到這個標頭">¶</a></h3>
<p>An assertion is like an expectation, except that the assertion immediately
terminates the test case if the condition is not satisfied. For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">test_sort</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kunit_kmalloc_array</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">TEST_LEN</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="w">        </span><span class="n">KUNIT_ASSERT_NOT_ERR_OR_NULL</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">TEST_LEN</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">725861</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">6599</span><span class="p">;</span>
<span class="w">                </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">TEST_LEN</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="n">cmpint</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">TEST_LEN</span><span class="mi">-1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">                </span><span class="n">KUNIT_EXPECT_LE</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, we need to be able to allocate an array to test the <code class="docutils literal notranslate"><span class="pre">sort()</span></code>
function. So we use <code class="docutils literal notranslate"><span class="pre">KUNIT_ASSERT_NOT_ERR_OR_NULL()</span></code> to abort the test if
there's an allocation error.</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>In other test frameworks, <code class="docutils literal notranslate"><span class="pre">ASSERT</span></code> macros are often implemented by calling
<code class="docutils literal notranslate"><span class="pre">return</span></code> so they only work from the test function. In KUnit, we stop the
current kthread on failure, so you can call them from anywhere.</p>
</div>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>Warning: There is an exception to the above rule. You shouldn't use assertions
in the suite's <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">exit()</span></code> function, or in the free function for a resource. These
run when a test is shutting down, and an assertion here prevents further
cleanup code from running, potentially leading to a memory leak.</p>
</div>
</section>
</section>
<section id="customizing-error-messages">
<h2>Customizing error messages<a class="headerlink" href="#customizing-error-messages" title="連結到這個標頭">¶</a></h2>
<p>Each of the <code class="docutils literal notranslate"><span class="pre">KUNIT_EXPECT</span></code> and <code class="docutils literal notranslate"><span class="pre">KUNIT_ASSERT</span></code> macros have a <code class="docutils literal notranslate"><span class="pre">_MSG</span></code>
variant.  These take a format string and arguments to provide additional
context to the automatically generated error messages.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span><span class="w"> </span><span class="n">some_str</span><span class="p">[</span><span class="mi">41</span><span class="p">];</span>
<span class="n">generate_sha1_hex_string</span><span class="p">(</span><span class="n">some_str</span><span class="p">);</span>

<span class="cm">/* Before. Not easy to tell why the test failed. */</span>
<span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">some_str</span><span class="p">),</span><span class="w"> </span><span class="mi">40</span><span class="p">);</span>

<span class="cm">/* After. Now we see the offending string. */</span>
<span class="n">KUNIT_EXPECT_EQ_MSG</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">some_str</span><span class="p">),</span><span class="w"> </span><span class="mi">40</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;some_str=&#39;%s&#39;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">some_str</span><span class="p">);</span>
</pre></div>
</div>
<p>Alternatively, one can take full control over the error message by using
<code class="docutils literal notranslate"><span class="pre">KUNIT_FAIL()</span></code>, e.g.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Before */</span>
<span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">some_setup_function</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="cm">/* After: full control over the failure message. */</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">some_setup_function</span><span class="p">())</span>
<span class="w">        </span><span class="n">KUNIT_FAIL</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to setup thing for testing&quot;</span><span class="p">);</span>
</pre></div>
</div>
<section id="test-suites">
<h3>Test Suites<a class="headerlink" href="#test-suites" title="連結到這個標頭">¶</a></h3>
<p>We need many test cases covering all the unit's behaviors. It is common to have
many similar tests. In order to reduce duplication in these closely related
tests, most unit testing frameworks (including KUnit) provide the concept of a
<em>test suite</em>. A test suite is a collection of test cases for a unit of code
with optional setup and teardown functions that run before/after the whole
suite and/or every test case.</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>A test case will only run if it is associated with a test suite.</p>
</div>
<p>For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit_case</span><span class="w"> </span><span class="n">example_test_cases</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">KUNIT_CASE</span><span class="p">(</span><span class="n">example_test_foo</span><span class="p">),</span>
<span class="w">        </span><span class="n">KUNIT_CASE</span><span class="p">(</span><span class="n">example_test_bar</span><span class="p">),</span>
<span class="w">        </span><span class="n">KUNIT_CASE</span><span class="p">(</span><span class="n">example_test_baz</span><span class="p">),</span>
<span class="w">        </span><span class="p">{}</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit_suite</span><span class="w"> </span><span class="n">example_test_suite</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;example&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">example_test_init</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">exit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">example_test_exit</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">suite_init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">example_suite_init</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">suite_exit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">example_suite_exit</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">test_cases</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">example_test_cases</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">kunit_test_suite</span><span class="p">(</span><span class="n">example_test_suite</span><span class="p">);</span>
</pre></div>
</div>
<p>In the above example, the test suite <code class="docutils literal notranslate"><span class="pre">example_test_suite</span></code> would first run
<code class="docutils literal notranslate"><span class="pre">example_suite_init</span></code>, then run the test cases <code class="docutils literal notranslate"><span class="pre">example_test_foo</span></code>,
<code class="docutils literal notranslate"><span class="pre">example_test_bar</span></code>, and <code class="docutils literal notranslate"><span class="pre">example_test_baz</span></code>. Each would have
<code class="docutils literal notranslate"><span class="pre">example_test_init</span></code> called immediately before it and <code class="docutils literal notranslate"><span class="pre">example_test_exit</span></code>
called immediately after it. Finally, <code class="docutils literal notranslate"><span class="pre">example_suite_exit</span></code> would be called
after everything else. <code class="docutils literal notranslate"><span class="pre">kunit_test_suite(example_test_suite)</span></code> registers the
test suite with the KUnit test framework.</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>The <code class="docutils literal notranslate"><span class="pre">exit</span></code> and <code class="docutils literal notranslate"><span class="pre">suite_exit</span></code> functions will run even if <code class="docutils literal notranslate"><span class="pre">init</span></code> or
<code class="docutils literal notranslate"><span class="pre">suite_init</span></code> fail. Make sure that they can handle any inconsistent
state which may result from <code class="docutils literal notranslate"><span class="pre">init</span></code> or <code class="docutils literal notranslate"><span class="pre">suite_init</span></code> encountering errors
or exiting early.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">kunit_test_suite(...)</span></code> is a macro which tells the linker to put the
specified test suite in a special linker section so that it can be run by KUnit
either after <code class="docutils literal notranslate"><span class="pre">late_init</span></code>, or when the test module is loaded (if the test was
built as a module).</p>
<p>For more information, see <a class="reference internal" href="api/test.html"><span class="doc">Test API</span></a>.</p>
</section>
</section>
<section id="writing-tests-for-other-architectures">
<span id="kunit-on-non-uml"></span><h2>Writing Tests For Other Architectures<a class="headerlink" href="#writing-tests-for-other-architectures" title="連結到這個標頭">¶</a></h2>
<p>It is better to write tests that run on UML to tests that only run under a
particular architecture. It is better to write tests that run under QEMU or
another easy to obtain (and monetarily free) software environment to a specific
piece of hardware.</p>
<p>Nevertheless, there are still valid reasons to write a test that is architecture
or hardware specific. For example, we might want to test code that really
belongs in <code class="docutils literal notranslate"><span class="pre">arch/some-arch/*</span></code>. Even so, try to write the test so that it does
not depend on physical hardware. Some of our test cases may not need hardware,
only few tests actually require the hardware to test it. When hardware is not
available, instead of disabling tests, we can skip them.</p>
<p>Now that we have narrowed down exactly what bits are hardware specific, the
actual procedure for writing and running the tests is same as writing normal
KUnit tests.</p>
<div class="admonition important">
<p class="admonition-title">重要</p>
<p>We may have to reset hardware state. If this is not possible, we may only
be able to run one test case per invocation.</p>
</div>
</section>
</section>
<section id="common-patterns">
<h1>Common Patterns<a class="headerlink" href="#common-patterns" title="連結到這個標頭">¶</a></h1>
<section id="isolating-behavior">
<h2>Isolating Behavior<a class="headerlink" href="#isolating-behavior" title="連結到這個標頭">¶</a></h2>
<p>Unit testing limits the amount of code under test to a single unit. It controls
what code gets run when the unit under test calls a function. Where a function
is exposed as part of an API such that the definition of that function can be
changed without affecting the rest of the code base. In the kernel, this comes
from two constructs: classes, which are structs that contain function pointers
provided by the implementer, and architecture-specific functions, which have
definitions selected at compile time.</p>
<section id="classes">
<h3>Classes<a class="headerlink" href="#classes" title="連結到這個標頭">¶</a></h3>
<p>Classes are not a construct that is built into the C programming language;
however, it is an easily derived concept. Accordingly, in most cases, every
project that does not use a standardized object oriented library (like GNOME's
GObject) has their own slightly different way of doing object oriented
programming; the Linux kernel is no exception.</p>
<p>The central concept in kernel object oriented programming is the class. In the
kernel, a <em>class</em> is a <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">that</span></code> contains function pointers. This creates a
contract between <em>implementers</em> and <em>users</em> since it forces them to use the
same function signature without having to call the function directly. To be a
class, the function pointers must specify that a pointer to the class, known as
a <em>class handle</em>, be one of the parameters. Thus the member functions (also
known as <em>methods</em>) have access to member variables (also known as <em>fields</em>)
allowing the same implementation to have multiple <em>instances</em>.</p>
<p>A class can be <em>overridden</em> by <em>child classes</em> by embedding the <em>parent class</em>
in the child class. Then when the child class <em>method</em> is called, the child
implementation knows that the pointer passed to it is of a parent contained
within the child. Thus, the child can compute the pointer to itself because the
pointer to the parent is always a fixed offset from the pointer to the child.
This offset is the offset of the parent contained in the child struct. For
example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">shape</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">area</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">shape</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">shape</span><span class="w"> </span><span class="n">parent</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">rectangle_area</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">shape</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">container_of</span><span class="p">(</span><span class="n">this</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="p">,</span><span class="w"> </span><span class="n">parent</span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">self</span><span class="o">-&gt;</span><span class="n">length</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">self</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">rectangle_new</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="n">self</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">.</span><span class="n">area</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rectangle_area</span><span class="p">;</span>
<span class="w">        </span><span class="n">self</span><span class="o">-&gt;</span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="p">;</span>
<span class="w">        </span><span class="n">self</span><span class="o">-&gt;</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, computing the pointer to the child from the pointer to the
parent is done by <code class="docutils literal notranslate"><span class="pre">container_of</span></code>.</p>
</section>
<section id="faking-classes">
<h3>Faking Classes<a class="headerlink" href="#faking-classes" title="連結到這個標頭">¶</a></h3>
<p>In order to unit test a piece of code that calls a method in a class, the
behavior of the method must be controllable, otherwise the test ceases to be a
unit test and becomes an integration test.</p>
<p>A fake class implements a piece of code that is different than what runs in a
production instance, but behaves identical from the standpoint of the callers.
This is done to replace a dependency that is hard to deal with, or is slow. For
example, implementing a fake EEPROM that stores the &quot;contents&quot; in an
internal buffer. Assume we have a class that represents an EEPROM:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>
<span class="w">        </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>And we want to test code that buffers writes to the EEPROM:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="nf">flush</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">);</span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">flush_count</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Flushes when buffer exceeds flush_count. */</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">new_eeprom_buffer</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">eeprom</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">destroy_eeprom_buffer</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">eeprom</span><span class="p">);</span>
</pre></div>
</div>
<p>We can test this code by <em>faking out</em> the underlying EEPROM:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">fake_eeprom</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom</span><span class="w"> </span><span class="n">parent</span><span class="p">;</span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="n">contents</span><span class="p">[</span><span class="n">FAKE_EEPROM_CONTENTS_SIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="kt">ssize_t</span><span class="w"> </span><span class="nf">fake_eeprom_read</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">parent</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">fake_eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">container_of</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">fake_eeprom</span><span class="p">,</span><span class="w"> </span><span class="n">parent</span><span class="p">);</span>

<span class="w">        </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">FAKE_EEPROM_CONTENTS_SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">offset</span><span class="p">);</span>
<span class="w">        </span><span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">this</span><span class="o">-&gt;</span><span class="n">contents</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">ssize_t</span><span class="w"> </span><span class="nf">fake_eeprom_write</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">parent</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">fake_eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">container_of</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">fake_eeprom</span><span class="p">,</span><span class="w"> </span><span class="n">parent</span><span class="p">);</span>

<span class="w">        </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">FAKE_EEPROM_CONTENTS_SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">offset</span><span class="p">);</span>
<span class="w">        </span><span class="n">memcpy</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">contents</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">fake_eeprom_init</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">fake_eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="n">this</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">.</span><span class="n">read</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fake_eeprom_read</span><span class="p">;</span>
<span class="w">        </span><span class="n">this</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">.</span><span class="n">write</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fake_eeprom_write</span><span class="p">;</span>
<span class="w">        </span><span class="n">memset</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">FAKE_EEPROM_CONTENTS_SIZE</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can now use it to test <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">eeprom_buffer</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer_test</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">fake_eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">fake_eeprom</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">eeprom_buffer</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">eeprom_buffer_test_does_not_write_until_flush</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer_test</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">test</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">eeprom_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">eeprom_buffer</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">fake_eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">fake_eeprom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fake_eeprom</span><span class="p">;</span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="n">buffer</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">0xff</span><span class="p">};</span>

<span class="w">        </span><span class="n">eeprom_buffer</span><span class="o">-&gt;</span><span class="n">flush_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SIZE_MAX</span><span class="p">;</span>

<span class="w">        </span><span class="n">eeprom_buffer</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">eeprom_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_eeprom</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">        </span><span class="n">eeprom_buffer</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">eeprom_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_eeprom</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">        </span><span class="n">eeprom_buffer</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">(</span><span class="n">eeprom_buffer</span><span class="p">);</span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_eeprom</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mh">0xff</span><span class="p">);</span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_eeprom</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="mh">0xff</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">eeprom_buffer_test_flushes_after_flush_count_met</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer_test</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">test</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">eeprom_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">eeprom_buffer</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">fake_eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">fake_eeprom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fake_eeprom</span><span class="p">;</span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="n">buffer</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">0xff</span><span class="p">};</span>

<span class="w">        </span><span class="n">eeprom_buffer</span><span class="o">-&gt;</span><span class="n">flush_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="w">        </span><span class="n">eeprom_buffer</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">eeprom_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_eeprom</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">        </span><span class="n">eeprom_buffer</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">eeprom_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_eeprom</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mh">0xff</span><span class="p">);</span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_eeprom</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="mh">0xff</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">eeprom_buffer_test_flushes_increments_of_flush_count</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer_test</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">test</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">eeprom_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">eeprom_buffer</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">fake_eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">fake_eeprom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fake_eeprom</span><span class="p">;</span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="n">buffer</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">0xff</span><span class="p">,</span><span class="w"> </span><span class="mh">0xff</span><span class="p">};</span>

<span class="w">        </span><span class="n">eeprom_buffer</span><span class="o">-&gt;</span><span class="n">flush_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="w">        </span><span class="n">eeprom_buffer</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">eeprom_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_eeprom</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">        </span><span class="n">eeprom_buffer</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">eeprom_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_eeprom</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mh">0xff</span><span class="p">);</span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_eeprom</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="mh">0xff</span><span class="p">);</span>
<span class="w">        </span><span class="cm">/* Should have only flushed the first two bytes. */</span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_eeprom</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">eeprom_buffer_test_init</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer_test</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="p">;</span>

<span class="w">        </span><span class="n">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kunit_kzalloc</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ctx</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="w">        </span><span class="n">KUNIT_ASSERT_NOT_ERR_OR_NULL</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">ctx</span><span class="p">);</span>

<span class="w">        </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fake_eeprom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kunit_kzalloc</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fake_eeprom</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="w">        </span><span class="n">KUNIT_ASSERT_NOT_ERR_OR_NULL</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fake_eeprom</span><span class="p">);</span>
<span class="w">        </span><span class="n">fake_eeprom_init</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fake_eeprom</span><span class="p">);</span>

<span class="w">        </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">eeprom_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_eeprom_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fake_eeprom</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
<span class="w">        </span><span class="n">KUNIT_ASSERT_NOT_ERR_OR_NULL</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">eeprom_buffer</span><span class="p">);</span>

<span class="w">        </span><span class="n">test</span><span class="o">-&gt;</span><span class="n">priv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="p">;</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">eeprom_buffer_test_exit</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer_test</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">test</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

<span class="w">        </span><span class="n">destroy_eeprom_buffer</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">eeprom_buffer</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="testing-against-multiple-inputs">
<h2>Testing Against Multiple Inputs<a class="headerlink" href="#testing-against-multiple-inputs" title="連結到這個標頭">¶</a></h2>
<p>Testing just a few inputs is not enough to ensure that the code works correctly,
for example: testing a hash function.</p>
<p>We can write a helper macro or function. The function is called for each input.
For example, to test <code class="docutils literal notranslate"><span class="pre">sha1sum(1)</span></code>, we can write:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define TEST_SHA1(in, want) \</span>
<span class="cp">        sha1sum(in, out); \</span>
<span class="cp">        KUNIT_EXPECT_STREQ_MSG(test, out, want, &quot;sha1sum(%s)&quot;, in);</span>

<span class="kt">char</span><span class="w"> </span><span class="n">out</span><span class="p">[</span><span class="mi">40</span><span class="p">];</span>
<span class="n">TEST_SHA1</span><span class="p">(</span><span class="s">&quot;hello world&quot;</span><span class="p">,</span><span class="w">  </span><span class="s">&quot;2aae6c35c94fcfb415dbe95f408b9ce91ee846ed&quot;</span><span class="p">);</span>
<span class="n">TEST_SHA1</span><span class="p">(</span><span class="s">&quot;hello world!&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;430ce34d020724ed75a196dfc2ad67c77772d169&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Note the use of the <code class="docutils literal notranslate"><span class="pre">_MSG</span></code> version of <code class="docutils literal notranslate"><span class="pre">KUNIT_EXPECT_STREQ</span></code> to print a more
detailed error and make the assertions clearer within the helper macros.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">_MSG</span></code> variants are useful when the same expectation is called multiple
times (in a loop or helper function) and thus the line number is not enough to
identify what failed, as shown below.</p>
<p>In complicated cases, we recommend using a <em>table-driven test</em> compared to the
helper macro variation, for example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="kt">char</span><span class="w"> </span><span class="n">out</span><span class="p">[</span><span class="mi">40</span><span class="p">];</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">sha1_test_case</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">sha1</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">sha1_test_case</span><span class="w"> </span><span class="n">cases</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">                </span><span class="p">.</span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello world&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">sha1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;2aae6c35c94fcfb415dbe95f408b9ce91ee846ed&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">                </span><span class="p">.</span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello world!&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">sha1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;430ce34d020724ed75a196dfc2ad67c77772d169&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span>
<span class="p">};</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">cases</span><span class="p">);</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sha1sum</span><span class="p">(</span><span class="n">cases</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">);</span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_STREQ_MSG</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">cases</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sha1</span><span class="p">,</span>
<span class="w">                              </span><span class="s">&quot;sha1sum(%s)&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cases</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">str</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is more boilerplate code involved, but it can:</p>
<ul class="simple">
<li><p>be more readable when there are multiple inputs/outputs (due to field names).</p>
<ul>
<li><p>For example, see <code class="docutils literal notranslate"><span class="pre">fs/ext4/inode-test.c</span></code>.</p></li>
</ul>
</li>
<li><p>reduce duplication if test cases are shared across multiple tests.</p>
<ul>
<li><p>For example: if we want to test <code class="docutils literal notranslate"><span class="pre">sha256sum</span></code>, we could add a <code class="docutils literal notranslate"><span class="pre">sha256</span></code>
field and reuse <code class="docutils literal notranslate"><span class="pre">cases</span></code>.</p></li>
</ul>
</li>
<li><p>be converted to a &quot;parameterized test&quot;.</p></li>
</ul>
<section id="parameterized-testing">
<h3>Parameterized Testing<a class="headerlink" href="#parameterized-testing" title="連結到這個標頭">¶</a></h3>
<p>To run a test case against multiple inputs, KUnit provides a parameterized
testing framework. This feature formalizes and extends the concept of
table-driven tests discussed previously.</p>
<p>A KUnit test is determined to be parameterized if a parameter generator function
is provided when registering the test case. A test user can either write their
own generator function or use one that is provided by KUnit. The generator
function is stored in  <code class="docutils literal notranslate"><span class="pre">kunit_case-&gt;generate_params</span></code> and can be set using the
macros described in the section below.</p>
<p>To establish the terminology, a &quot;parameterized test&quot; is a test which is run
multiple times (once per &quot;parameter&quot; or &quot;parameter run&quot;). Each parameter run has
both its own independent <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kunit</span></code> (the &quot;parameter run context&quot;) and
access to a shared parent <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kunit</span></code> (the &quot;parameterized test context&quot;).</p>
<section id="passing-parameters-to-a-test">
<h4>Passing Parameters to a Test<a class="headerlink" href="#passing-parameters-to-a-test" title="連結到這個標頭">¶</a></h4>
<p>There are three ways to provide the parameters to a test:</p>
<p>Array Parameter Macros:</p>
<blockquote>
<div><p>KUnit provides special support for the common table-driven testing pattern.
By applying either <code class="docutils literal notranslate"><span class="pre">KUNIT_ARRAY_PARAM</span></code> or <code class="docutils literal notranslate"><span class="pre">KUNIT_ARRAY_PARAM_DESC</span></code> to the
<code class="docutils literal notranslate"><span class="pre">cases</span></code> array from the previous section, we can create a parameterized test
as shown below:</p>
</div></blockquote>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// This is copy-pasted from above.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">sha1_test_case</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">sha1</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sha1_test_case</span><span class="w"> </span><span class="n">cases</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">                </span><span class="p">.</span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello world&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">sha1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;2aae6c35c94fcfb415dbe95f408b9ce91ee846ed&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">                </span><span class="p">.</span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello world!&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="p">.</span><span class="n">sha1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;430ce34d020724ed75a196dfc2ad67c77772d169&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="p">},</span>
<span class="p">};</span>

<span class="c1">// Creates `sha1_gen_params()` to iterate over `cases` while using</span>
<span class="c1">// the struct member `str` for the case description.</span>
<span class="n">KUNIT_ARRAY_PARAM_DESC</span><span class="p">(</span><span class="n">sha1</span><span class="p">,</span><span class="w"> </span><span class="n">cases</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="p">);</span>

<span class="c1">// Looks no different from a normal test.</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">sha1_test</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="c1">// This function can just contain the body of the for-loop.</span>
<span class="w">        </span><span class="c1">// The former `cases[i]` is accessible under test-&gt;param_value.</span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="n">out</span><span class="p">[</span><span class="mi">40</span><span class="p">];</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">sha1_test_case</span><span class="w"> </span><span class="o">*</span><span class="n">test_param</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sha1_test_case</span><span class="w"> </span><span class="o">*</span><span class="p">)(</span><span class="n">test</span><span class="o">-&gt;</span><span class="n">param_value</span><span class="p">);</span>

<span class="w">        </span><span class="n">sha1sum</span><span class="p">(</span><span class="n">test_param</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">);</span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_STREQ_MSG</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">test_param</span><span class="o">-&gt;</span><span class="n">sha1</span><span class="p">,</span>
<span class="w">                              </span><span class="s">&quot;sha1sum(%s)&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">test_param</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Instead of KUNIT_CASE, we use KUNIT_CASE_PARAM and pass in the</span>
<span class="c1">// function declared by KUNIT_ARRAY_PARAM or KUNIT_ARRAY_PARAM_DESC.</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit_case</span><span class="w"> </span><span class="n">sha1_test_cases</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">KUNIT_CASE_PARAM</span><span class="p">(</span><span class="n">sha1_test</span><span class="p">,</span><span class="w"> </span><span class="n">sha1_gen_params</span><span class="p">),</span>
<span class="w">        </span><span class="p">{}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Custom Parameter Generator Function:</p>
<blockquote>
<div><p>The generator function is responsible for generating parameters one-by-one
and has the following signature:
<code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void*</span> <span class="pre">(*)(struct</span> <span class="pre">kunit</span> <span class="pre">*test,</span> <span class="pre">const</span> <span class="pre">void</span> <span class="pre">*prev,</span> <span class="pre">char</span> <span class="pre">*desc)</span></code>.
You can pass the generator function to the <code class="docutils literal notranslate"><span class="pre">KUNIT_CASE_PARAM</span></code>
or <code class="docutils literal notranslate"><span class="pre">KUNIT_CASE_PARAM_WITH_INIT</span></code> macros.</p>
<p>The function receives the previously generated parameter as the <code class="docutils literal notranslate"><span class="pre">prev</span></code> argument
(which is <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on the first call) and can also access the parameterized
test context passed as the <code class="docutils literal notranslate"><span class="pre">test</span></code> argument. KUnit calls this function
repeatedly until it returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, which signifies that a parameterized
test ended.</p>
<p>Below is an example of how it works:</p>
</div></blockquote>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define MAX_TEST_BUFFER_SIZE 8</span>

<span class="c1">// Example generator function. It produces a sequence of buffer sizes that</span>
<span class="c1">// are powers of two, starting at 1 (e.g., 1, 2, 4, 8).</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">buffer_size_gen_params</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="n">prev_buffer_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">prev</span><span class="p">;</span>
<span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="n">next_buffer_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// Start with an initial size of 1.</span>

<span class="w">        </span><span class="c1">// Stop generating parameters if the limit is reached or exceeded.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prev_buffer_size</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">MAX_TEST_BUFFER_SIZE</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// For subsequent calls, calculate the next size by doubling the previous one.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">prev</span><span class="p">)</span>
<span class="w">                </span><span class="n">next_buffer_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev_buffer_size</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">next_buffer_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Simple test to validate that kunit_kzalloc provides zeroed memory.</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">buffer_zero_test</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="n">buffer_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">test</span><span class="o">-&gt;</span><span class="n">param_value</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// Use kunit_kzalloc to allocate a zero-initialized buffer. This makes the</span>
<span class="w">        </span><span class="c1">// memory &quot;parameter run managed,&quot; meaning it&#39;s automatically cleaned up at</span>
<span class="w">        </span><span class="c1">// the end of each parameter run.</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kunit_kzalloc</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_size</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Ensure the allocation was successful.</span>
<span class="w">        </span><span class="n">KUNIT_ASSERT_NOT_NULL</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Loop through the buffer and confirm every element is zero.</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">buffer_size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">                </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit_case</span><span class="w"> </span><span class="n">buffer_test_cases</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">KUNIT_CASE_PARAM</span><span class="p">(</span><span class="n">buffer_zero_test</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_size_gen_params</span><span class="p">),</span>
<span class="w">        </span><span class="p">{}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Runtime Parameter Array Registration in the Init Function:</p>
<blockquote>
<div><p>For scenarios where you might need to initialize a parameterized test, you
can directly register a parameter array to the parameterized test context.</p>
<p>To do this, you must pass the parameterized test context, the array itself,
the array size, and a <code class="docutils literal notranslate"><span class="pre">get_description()</span></code> function to the
<code class="docutils literal notranslate"><span class="pre">kunit_register_params_array()</span></code> macro. This macro populates
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kunit_params</span></code> within the parameterized test context, effectively
storing a parameter array object. The <code class="docutils literal notranslate"><span class="pre">get_description()</span></code> function will
be used for populating parameter descriptions and has the following signature:
<code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">kunit</span> <span class="pre">*test,</span> <span class="pre">const</span> <span class="pre">void</span> <span class="pre">*param,</span> <span class="pre">char</span> <span class="pre">*desc)</span></code>. Note that it
also has access to the parameterized test context.</p>
<blockquote>
<div><div class="admonition important">
<p class="admonition-title">重要</p>
<p>When using this way to register a parameter array, you will need to
manually pass <code class="docutils literal notranslate"><span class="pre">kunit_array_gen_params()</span></code> as the generator function to
<code class="docutils literal notranslate"><span class="pre">KUNIT_CASE_PARAM_WITH_INIT</span></code>. <code class="docutils literal notranslate"><span class="pre">kunit_array_gen_params()</span></code> is a KUnit
helper that will use the registered array to generate the parameters.</p>
<p>If needed, instead of passing the KUnit helper, you can also pass your
own custom generator function that utilizes the parameter array. To
access the parameter array from within the parameter generator
function use <code class="docutils literal notranslate"><span class="pre">test-&gt;params_array.params</span></code>.</p>
</div>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">kunit_register_params_array()</span></code> macro should be called within a
<code class="docutils literal notranslate"><span class="pre">param_init()</span></code> function that initializes the parameterized test and has
the following signature <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">kunit</span> <span class="pre">*test)</span></code>. For a detailed
explanation of this mechanism please refer to the &quot;Adding Shared Resources&quot;
section that is after this one. This method supports registering both
dynamically built and static parameter arrays.</p>
<p>The code snippet below shows the <code class="docutils literal notranslate"><span class="pre">example_param_init_dynamic_arr</span></code> test that
utilizes <code class="docutils literal notranslate"><span class="pre">make_fibonacci_params()</span></code> to create a dynamic array, which is then
registered using <code class="docutils literal notranslate"><span class="pre">kunit_register_params_array()</span></code>. To see the full code
please refer to lib/kunit/kunit-example-test.c.</p>
</div></blockquote>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">* Example of a parameterized test param_init() function that registers a dynamic</span>
<span class="cm">* array of parameters.</span>
<span class="cm">*/</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">example_param_init_dynamic_arr</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">seq_size</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">fibonacci_params</span><span class="p">;</span>

<span class="w">        </span><span class="n">kunit_info</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;initializing parameterized test</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">        </span><span class="n">seq_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span>
<span class="w">        </span><span class="n">fibonacci_params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_fibonacci_params</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">seq_size</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">fibonacci_params</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="w">        </span><span class="cm">/*</span>
<span class="cm">        * Passes the dynamic parameter array information to the parameterized test</span>
<span class="cm">        * context struct kunit. The array and its metadata will be stored in</span>
<span class="cm">        * test-&gt;parent-&gt;params_array. The array itself will be located in</span>
<span class="cm">        * params_data.params.</span>
<span class="cm">        */</span>
<span class="w">        </span><span class="n">kunit_register_params_array</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fibonacci_params</span><span class="p">,</span><span class="w"> </span><span class="n">seq_size</span><span class="p">,</span>
<span class="w">                                </span><span class="n">example_param_dynamic_arr_get_desc</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit_case</span><span class="w"> </span><span class="n">example_test_cases</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * Note how we pass kunit_array_gen_params() to use the array we</span>
<span class="cm">         * registered in example_param_init_dynamic_arr() to generate</span>
<span class="cm">         * parameters.</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="n">KUNIT_CASE_PARAM_WITH_INIT</span><span class="p">(</span><span class="n">example_params_test_with_init_dynamic_arr</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">kunit_array_gen_params</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">example_param_init_dynamic_arr</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">example_param_exit_dynamic_arr</span><span class="p">),</span>
<span class="w">        </span><span class="p">{}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="adding-shared-resources">
<h4>Adding Shared Resources<a class="headerlink" href="#adding-shared-resources" title="連結到這個標頭">¶</a></h4>
<p>All parameter runs in this framework hold a reference to the parameterized test
context, which can be accessed using the parent <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kunit</span></code> pointer. The
parameterized test context is not used to execute any test logic itself; instead,
it serves as a container for shared resources.</p>
<p>It's possible to add resources to share between parameter runs within a
parameterized test by using <code class="docutils literal notranslate"><span class="pre">KUNIT_CASE_PARAM_WITH_INIT</span></code>, to which you pass
custom <code class="docutils literal notranslate"><span class="pre">param_init()</span></code> and <code class="docutils literal notranslate"><span class="pre">param_exit()</span></code> functions. These functions run once
before and once after the parameterized test, respectively.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">param_init()</span></code> function, with the signature <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">(*)(struct</span> <span class="pre">kunit</span> <span class="pre">*test)</span></code>,
can be used for adding resources to the <code class="docutils literal notranslate"><span class="pre">resources</span></code> or <code class="docutils literal notranslate"><span class="pre">priv</span></code> fields of
the parameterized test context, registering the parameter array, and any other
initialization logic.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">param_exit()</span></code> function, with the signature <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">kunit</span> <span class="pre">*test)</span></code>,
can be used to release any resources that were not parameterized test managed (i.e.
not automatically cleaned up after the parameterized test ends) and for any other
exit logic.</p>
<p>Both <code class="docutils literal notranslate"><span class="pre">param_init()</span></code> and <code class="docutils literal notranslate"><span class="pre">param_exit()</span></code> are passed the parameterized test
context behind the scenes. However, the test case function receives the parameter
run context. Therefore, to manage and access shared resources from within a test
case function, you must use <code class="docutils literal notranslate"><span class="pre">test-&gt;parent</span></code>.</p>
<p>For instance, finding a shared resource allocated by the Resource API requires
passing <code class="docutils literal notranslate"><span class="pre">test-&gt;parent</span></code> to <code class="docutils literal notranslate"><span class="pre">kunit_find_resource()</span></code>. This principle extends to
all other APIs that might be used in the test case function, including
<code class="docutils literal notranslate"><span class="pre">kunit_kzalloc()</span></code>, <code class="docutils literal notranslate"><span class="pre">kunit_kmalloc_array()</span></code>, and others (see
<a class="reference internal" href="api/test.html"><span class="doc">Test API</span></a> and the
<a class="reference internal" href="api/resource.html"><span class="doc">Resource API</span></a>).</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>The <code class="docutils literal notranslate"><span class="pre">suite-&gt;init()</span></code> function, which executes before each parameter run,
receives the parameter run context. Therefore, any resources set up in
<code class="docutils literal notranslate"><span class="pre">suite-&gt;init()</span></code> are cleaned up after each parameter run.</p>
</div>
<p>The code below shows how you can add the shared resources. Note that this code
utilizes the Resource API, which you can read more about here:
<a class="reference internal" href="api/resource.html"><span class="doc">Resource API</span></a>. To see the full version of this
code please refer to lib/kunit/kunit-example-test.c.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">example_resource_init</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit_resource</span><span class="w"> </span><span class="o">*</span><span class="n">res</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="p">...</span><span class="w"> </span><span class="cm">/* Code that allocates memory and stores context in res-&gt;data. */</span>
<span class="p">}</span>

<span class="cm">/* This function deallocates memory for the kunit_resource-&gt;data field. */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">example_resource_free</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit_resource</span><span class="w"> </span><span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="n">kfree</span><span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This match function locates a test resource based on defined criteria. */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">example_resource_alloc_match</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit_resource</span><span class="w"> </span><span class="o">*</span><span class="n">res</span><span class="p">,</span>
<span class="w">                                         </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">match_data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">res</span><span class="o">-&gt;</span><span class="n">free</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">example_resource_free</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Function to initialize the parameterized test. */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">example_param_init</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Data to be stored. */</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kunit_alloc_resource</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">example_resource_init</span><span class="p">,</span>
<span class="w">                                          </span><span class="n">example_resource_free</span><span class="p">,</span>
<span class="w">                                          </span><span class="n">GFP_KERNEL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="w">        </span><span class="n">kunit_register_params_array</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">example_params_array</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">example_params_array</span><span class="p">));</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Example test that uses shared resources in test-&gt;resources. */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">example_params_test_with_init</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">threshold</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">example_param</span><span class="w"> </span><span class="o">*</span><span class="n">param</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">test</span><span class="o">-&gt;</span><span class="n">param_value</span><span class="p">;</span>
<span class="w">        </span><span class="cm">/*  Here we pass test-&gt;parent to access the parameterized test context. */</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit_resource</span><span class="w"> </span><span class="o">*</span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kunit_find_resource</span><span class="p">(</span><span class="n">test</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span>
<span class="w">                                                         </span><span class="n">example_resource_alloc_match</span><span class="p">,</span>
<span class="w">                                                         </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">        </span><span class="n">threshold</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="w">        </span><span class="n">KUNIT_ASSERT_LE</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">param</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">threshold</span><span class="p">);</span>
<span class="w">        </span><span class="n">kunit_put_resource</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit_case</span><span class="w"> </span><span class="n">example_test_cases</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">KUNIT_CASE_PARAM_WITH_INIT</span><span class="p">(</span><span class="n">example_params_test_with_init</span><span class="p">,</span><span class="w"> </span><span class="n">kunit_array_gen_params</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">example_param_init</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">),</span>
<span class="w">        </span><span class="p">{}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>As an alternative to using the KUnit Resource API for sharing resources, you can
place them in <code class="docutils literal notranslate"><span class="pre">test-&gt;parent-&gt;priv</span></code>. This serves as a more lightweight method
for resource storage, best for scenarios where complex resource management is
not required.</p>
<p>As stated previously <code class="docutils literal notranslate"><span class="pre">param_init()</span></code> and <code class="docutils literal notranslate"><span class="pre">param_exit()</span></code> get the parameterized
test context. So, you can directly use <code class="docutils literal notranslate"><span class="pre">test-&gt;priv</span></code> within <code class="docutils literal notranslate"><span class="pre">param_init/exit</span></code>
to manage shared resources. However, from within the test case function, you must
navigate up to the parent <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kunit</span></code> i.e. the parameterized test context.
Therefore, you need to use <code class="docutils literal notranslate"><span class="pre">test-&gt;parent-&gt;priv</span></code> to access those same
resources.</p>
<p>The resources placed in <code class="docutils literal notranslate"><span class="pre">test-&gt;parent-&gt;priv</span></code> will need to be allocated in
memory to persist across the parameter runs. If memory is allocated using the
KUnit memory allocation APIs (described more in the &quot;Allocating Memory&quot; section
below), you won't need to worry about deallocation. The APIs will make the memory
parameterized test 'managed', ensuring that it will automatically get cleaned up
after the parameterized test concludes.</p>
<p>The code below demonstrates example usage of the <code class="docutils literal notranslate"><span class="pre">priv</span></code> field for shared
resources:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">example_param</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">example_params_array</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">},</span>
<span class="p">};</span>

<span class="cm">/* Initialize the parameterized test context. */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">example_param_init_priv</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Data to be stored. */</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">arr_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">example_params_array</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * Allocate memory using kunit_kzalloc(). Since the `param_init`</span>
<span class="cm">         * function receives the parameterized test context, this memory</span>
<span class="cm">         * allocation will be scoped to the lifetime of the parameterized test.</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="n">test</span><span class="o">-&gt;</span><span class="n">priv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kunit_kzalloc</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* Assign the context value to test-&gt;priv.*/</span>
<span class="w">        </span><span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">test</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* Register the parameter array. */</span>
<span class="w">        </span><span class="n">kunit_register_params_array</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">example_params_array</span><span class="p">,</span><span class="w"> </span><span class="n">arr_size</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">example_params_test_with_init_priv</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">threshold</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">example_param</span><span class="w"> </span><span class="o">*</span><span class="n">param</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">test</span><span class="o">-&gt;</span><span class="n">param_value</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* By design, test-&gt;parent will not be NULL. */</span>
<span class="w">        </span><span class="n">KUNIT_ASSERT_NOT_NULL</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">test</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* Here we use test-&gt;parent-&gt;priv to access the shared resource. */</span>
<span class="w">        </span><span class="n">threshold</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">test</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

<span class="w">        </span><span class="n">KUNIT_ASSERT_LE</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">param</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">threshold</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit_case</span><span class="w"> </span><span class="n">example_tests</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">KUNIT_CASE_PARAM_WITH_INIT</span><span class="p">(</span><span class="n">example_params_test_with_init_priv</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">kunit_array_gen_params</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">example_param_init_priv</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">),</span>
<span class="w">        </span><span class="p">{}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="allocating-memory">
<h2>Allocating Memory<a class="headerlink" href="#allocating-memory" title="連結到這個標頭">¶</a></h2>
<p>Where you might use <code class="docutils literal notranslate"><span class="pre">kzalloc</span></code>, you can instead use <code class="docutils literal notranslate"><span class="pre">kunit_kzalloc</span></code> as KUnit
will then ensure that the memory is freed once the test completes.</p>
<p>This is useful because it lets us use the <code class="docutils literal notranslate"><span class="pre">KUNIT_ASSERT_EQ</span></code> macros to exit
early from a test without having to worry about remembering to call <code class="docutils literal notranslate"><span class="pre">kfree</span></code>.
For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">example_test_allocation</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kunit_kzalloc</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="w">        </span><span class="cm">/* Ensure allocation succeeded. */</span>
<span class="w">        </span><span class="n">KUNIT_ASSERT_NOT_ERR_OR_NULL</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">);</span>

<span class="w">        </span><span class="n">KUNIT_ASSERT_STREQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="registering-cleanup-actions">
<h2>Registering Cleanup Actions<a class="headerlink" href="#registering-cleanup-actions" title="連結到這個標頭">¶</a></h2>
<p>If you need to perform some cleanup beyond simple use of <code class="docutils literal notranslate"><span class="pre">kunit_kzalloc</span></code>,
you can register a custom &quot;deferred action&quot;, which is a cleanup function
run when the test exits (whether cleanly, or via a failed assertion).</p>
<p>Actions are simple functions with no return value, and a single <code class="docutils literal notranslate"><span class="pre">void*</span></code>
context argument, and fulfill the same role as &quot;cleanup&quot; functions in Python
and Go tests, &quot;defer&quot; statements in languages which support them, and
(in some cases) destructors in RAII languages.</p>
<p>These are very useful for unregistering things from global lists, closing
files or other resources, or freeing resources.</p>
<p>For example:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">cleanup_device</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">ctx</span><span class="p">;</span>

<span class="w">        </span><span class="n">device_unregister</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">example_device_test</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">my_device</span><span class="w"> </span><span class="n">dev</span><span class="p">;</span>

<span class="w">        </span><span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>

<span class="w">        </span><span class="n">kunit_add_action</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cleanup_device</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that, for functions like device_unregister which only accept a single
pointer-sized argument, it's possible to automatically generate a wrapper
with the <code class="docutils literal notranslate"><span class="pre">KUNIT_DEFINE_ACTION_WRAPPER()</span></code> macro, for example:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">KUNIT_DEFINE_ACTION_WRAPPER</span><span class="p">(</span><span class="n">device_unregister</span><span class="p">,</span><span class="w"> </span><span class="n">device_unregister_wrapper</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="n">kunit_add_action</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">device_unregister_wrapper</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
</pre></div>
</div>
<p>You should do this in preference to manually casting to the <code class="docutils literal notranslate"><span class="pre">kunit_action_t</span></code> type,
as casting function pointers will break Control Flow Integrity (CFI).</p>
<p><code class="docutils literal notranslate"><span class="pre">kunit_add_action</span></code> can fail if, for example, the system is out of memory.
You can use <code class="docutils literal notranslate"><span class="pre">kunit_add_action_or_reset</span></code> instead which runs the action
immediately if it cannot be deferred.</p>
<p>If you need more control over when the cleanup function is called, you
can trigger it early using <code class="docutils literal notranslate"><span class="pre">kunit_release_action</span></code>, or cancel it entirely
with <code class="docutils literal notranslate"><span class="pre">kunit_remove_action</span></code>.</p>
</section>
<section id="testing-static-functions">
<h2>Testing Static Functions<a class="headerlink" href="#testing-static-functions" title="連結到這個標頭">¶</a></h2>
<p>If you want to test static functions without exposing those functions outside of
testing, one option is conditionally export the symbol. When KUnit is enabled,
the symbol is exposed but remains static otherwise. To use this method, follow
the template below.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* In the file containing functions to test &quot;my_file.c&quot; */</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;kunit/visibility.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;my_file.h&gt;</span>
<span class="p">...</span>
<span class="n">VISIBLE_IF_KUNIT</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">do_interesting_thing</span><span class="p">()</span>
<span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_IF_KUNIT</span><span class="p">(</span><span class="n">do_interesting_thing</span><span class="p">);</span>

<span class="cm">/* In the header file &quot;my_file.h&quot; */</span>

<span class="cp">#if IS_ENABLED(CONFIG_KUNIT)</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="nf">do_interesting_thing</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* In the KUnit test file &quot;my_file_test.c&quot; */</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;kunit/visibility.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;my_file.h&gt;</span>
<span class="p">...</span>
<span class="n">MODULE_IMPORT_NS</span><span class="p">(</span><span class="s">&quot;EXPORTED_FOR_KUNIT_TESTING&quot;</span><span class="p">);</span>
<span class="p">...</span>
<span class="c1">// Use do_interesting_thing() in tests</span>
</pre></div>
</div>
<p>For a full example, see this <a class="reference external" href="https://lore.kernel.org/all/20221207014024.340230-3-rmoar&#64;google.com/">patch</a>
where a test is modified to conditionally expose static functions for testing
using the macros above.</p>
<p>As an <strong>alternative</strong> to the method above, you could conditionally <code class="docutils literal notranslate"><span class="pre">#include</span></code>
the test file at the end of your .c file. This is not recommended but works
if needed. For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* In &quot;my_file.c&quot; */</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">do_interesting_thing</span><span class="p">();</span>

<span class="cp">#ifdef CONFIG_MY_KUNIT_TEST</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;my_kunit_test.c&quot;</span>
<span class="cp">#endif</span>
</pre></div>
</div>
</section>
<section id="injecting-test-only-code">
<h2>Injecting Test-Only Code<a class="headerlink" href="#injecting-test-only-code" title="連結到這個標頭">¶</a></h2>
<p>Similar to as shown above, we can add test-specific logic. For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* In my_file.h */</span>

<span class="cp">#ifdef CONFIG_MY_KUNIT_TEST</span>
<span class="cm">/* Defined in my_kunit_test.c */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">test_only_hook</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">test_only_hook</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>This test-only code can be made more useful by accessing the current <code class="docutils literal notranslate"><span class="pre">kunit_test</span></code>
as shown in next section: <em>Accessing The Current Test</em>.</p>
</section>
<section id="accessing-the-current-test">
<h2>Accessing The Current Test<a class="headerlink" href="#accessing-the-current-test" title="連結到這個標頭">¶</a></h2>
<p>In some cases, we need to call test-only code from outside the test file.  This
is helpful, for example, when providing a fake implementation of a function, or
to fail any current test from within an error handler.
We can do this via the <code class="docutils literal notranslate"><span class="pre">kunit_test</span></code> field in <code class="docutils literal notranslate"><span class="pre">task_struct</span></code>, which we can
access using the <code class="docutils literal notranslate"><span class="pre">kunit_get_current_test()</span></code> function in <code class="docutils literal notranslate"><span class="pre">kunit/test-bug.h</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">kunit_get_current_test()</span></code> is safe to call even if KUnit is not enabled. If
KUnit is not enabled, or if no test is running in the current task, it will
return <code class="docutils literal notranslate"><span class="pre">NULL</span></code>. This compiles down to either a no-op or a static key check,
so will have a negligible performance impact when no test is running.</p>
<p>The example below uses this to implement a &quot;mock&quot; implementation of a function, <code class="docutils literal notranslate"><span class="pre">foo</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;kunit/test-bug.h&gt;</span><span class="c1"> /* for kunit_get_current_test */</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">test_data</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">foo_result</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">want_foo_called_with</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">fake_foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kunit_get_current_test</span><span class="p">();</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">test_data</span><span class="w"> </span><span class="o">*</span><span class="n">test_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">test</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">test_data</span><span class="o">-&gt;</span><span class="n">want_foo_called_with</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">test_data</span><span class="o">-&gt;</span><span class="n">foo_result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">example_simple_test</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="cm">/* Assume priv (private, a member used to pass test data from</span>
<span class="cm">         * the init function) is allocated in the suite&#39;s .init */</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">test_data</span><span class="w"> </span><span class="o">*</span><span class="n">test_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">test</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span>

<span class="w">        </span><span class="n">test_data</span><span class="o">-&gt;</span><span class="n">foo_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<span class="w">        </span><span class="n">test_data</span><span class="o">-&gt;</span><span class="n">want_foo_called_with</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* In a real test, we&#39;d probably pass a pointer to fake_foo somewhere</span>
<span class="cm">         * like an ops struct, etc. instead of calling it directly. */</span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_foo</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mi">42</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, we are using the <code class="docutils literal notranslate"><span class="pre">priv</span></code> member of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kunit</span></code> as a way
of passing data to the test from the init function. In general <code class="docutils literal notranslate"><span class="pre">priv</span></code> is
pointer that can be used for any user data. This is preferred over static
variables, as it avoids concurrency issues.</p>
<p>Had we wanted something more flexible, we could have used a named <code class="docutils literal notranslate"><span class="pre">kunit_resource</span></code>.
Each test can have multiple resources which have string names providing the same
flexibility as a <code class="docutils literal notranslate"><span class="pre">priv</span></code> member, but also, for example, allowing helper
functions to create resources without conflicting with each other. It is also
possible to define a clean up function for each resource, making it easy to
avoid resource leaks. For more information, see <a class="reference internal" href="api/resource.html"><span class="doc">Resource API</span></a>.</p>
</section>
<section id="failing-the-current-test">
<h2>Failing The Current Test<a class="headerlink" href="#failing-the-current-test" title="連結到這個標頭">¶</a></h2>
<p>If we want to fail the current test, we can use <code class="docutils literal notranslate"><span class="pre">kunit_fail_current_test(fmt,</span> <span class="pre">args...)</span></code>
which is defined in <code class="docutils literal notranslate"><span class="pre">&lt;kunit/test-bug.h&gt;</span></code> and does not require pulling in <code class="docutils literal notranslate"><span class="pre">&lt;kunit/test.h&gt;</span></code>.
For example, we have an option to enable some extra debug checks on some data
structures as shown below:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;kunit/test-bug.h&gt;</span>

<span class="cp">#ifdef CONFIG_EXTRA_DEBUG_CHECKS</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">validate_my_data</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">data</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_valid</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="w">                </span><span class="k">return</span><span class="p">;</span>

<span class="w">        </span><span class="n">kunit_fail_current_test</span><span class="p">(</span><span class="s">&quot;data %p is invalid&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* Normal, non-KUnit, error reporting code here. */</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">my_debug_function</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">kunit_fail_current_test()</span></code> is safe to call even if KUnit is not enabled. If
KUnit is not enabled, or if no test is running in the current task, it will do
nothing. This compiles down to either a no-op or a static key check, so will
have a negligible performance impact when no test is running.</p>
</section>
<section id="managing-fake-devices-and-drivers">
<h2>Managing Fake Devices and Drivers<a class="headerlink" href="#managing-fake-devices-and-drivers" title="連結到這個標頭">¶</a></h2>
<p>When testing drivers or code which interacts with drivers, many functions will
require a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device</span></code> or <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span></code>. In many cases, setting
up a real device is not required to test any given function, so a fake device
can be used instead.</p>
<p>KUnit provides helper functions to create and manage these fake devices, which
are internally of type <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kunit_device</span></code>, and are attached to a special
<code class="docutils literal notranslate"><span class="pre">kunit_bus</span></code>. These devices support managed device resources (devres), as
described in <a class="reference internal" href="../../driver-api/driver-model/devres.html"><span class="doc">Devres - Managed Device Resource</span></a></p>
<p>To create a KUnit-managed <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">device_driver</span></code>, use <code class="docutils literal notranslate"><span class="pre">kunit_driver_create()</span></code>,
which will create a driver with the given name, on the <code class="docutils literal notranslate"><span class="pre">kunit_bus</span></code>. This driver
will automatically be destroyed when the corresponding test finishes, but can also
be manually destroyed with <code class="docutils literal notranslate"><span class="pre">driver_unregister()</span></code>.</p>
<p>To create a fake device, use the <code class="docutils literal notranslate"><span class="pre">kunit_device_register()</span></code>, which will create
and register a device, using a new KUnit-managed driver created with <code class="docutils literal notranslate"><span class="pre">kunit_driver_create()</span></code>.
To provide a specific, non-KUnit-managed driver, use <code class="docutils literal notranslate"><span class="pre">kunit_device_register_with_driver()</span></code>
instead. Like with managed drivers, KUnit-managed fake devices are automatically
cleaned up when the test finishes, but can be manually cleaned up early with
<code class="docutils literal notranslate"><span class="pre">kunit_device_unregister()</span></code>.</p>
<p>The KUnit devices should be used in preference to <code class="docutils literal notranslate"><span class="pre">root_device_register()</span></code>, and
instead of <code class="docutils literal notranslate"><span class="pre">platform_device_register()</span></code> in cases where the device is not otherwise
a platform device.</p>
<p>For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;kunit/device.h&gt;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">test_my_device</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">fake_device</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">dev_managed_string</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Create a fake device.</span>
<span class="w">        </span><span class="n">fake_device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kunit_device_register</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;my_device&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">KUNIT_ASSERT_NOT_ERR_OR_NULL</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_device</span><span class="p">)</span>

<span class="w">        </span><span class="c1">// Pass it to functions which need a device.</span>
<span class="w">        </span><span class="n">dev_managed_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devm_kstrdup</span><span class="p">(</span><span class="n">fake_device</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Hello, World!&quot;</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Everything is cleaned up automatically when the test ends.</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;The kernel development community.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../../_sources/dev-tools/kunit/usage.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>