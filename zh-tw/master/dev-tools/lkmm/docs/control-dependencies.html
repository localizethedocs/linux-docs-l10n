<!DOCTYPE html>

<html lang="zh-TW" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Control Dependencies &#8212; The Linux Kernel  說明文件</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=adfc0c0d" />
    <script src="../../../_static/documentation_options.js?v=0d9984b1"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/translations.js?v=cbf116e0"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/linux-docs-l10n/dev-tools/lkmm/docs/control-dependencies.html" />
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜尋" href="../../../search.html" />
    <link rel="next" title="Access Marking" href="access-marking.html" />
    <link rel="prev" title="Recipes" href="recipes.html" />

   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

<script type="text/javascript" src="../../../ltd-provenance.js"></script>
<script type="text/javascript" src="../../../ltd-current.js"></script>
<script type="text/javascript" src="../../../../../ltd-config.js"></script>
<script type="text/javascript" src="../../../../../ltd-flyout.js"></script>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/logo.svg" alt="Logo of The Linux Kernel"/>
            </a></p>
<h1 class="logo"><a href="../../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.18.0-rc2</p>







<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜尋</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="前往" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>


<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/submitting-patches.html">提交補釘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/code-of-conduct.html">行為守則</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../maintainer/index.html">維護者手冊</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/index.html">All development-process docs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../core-api/index.html">核心 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../subsystem-apis.html">子系統</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../locking/index.html">Locking</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../doc-guide/index.html">撰寫文件</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">開發工具</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../testing-overview.html">Kernel Testing Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../checkpatch.html">Checkpatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../clang-format.html">clang-format</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../coccinelle.html">Coccinelle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../sparse.html">Sparse</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kcov.html">KCOV: code coverage for fuzzing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../gcov.html">Using gcov with the Linux kernel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kasan.html">Kernel Address Sanitizer (KASAN)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kmsan.html">Kernel Memory Sanitizer (KMSAN)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ubsan.html">Undefined Behavior Sanitizer - UBSAN</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kmemleak.html">Kernel Memory Leak Detector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kcsan.html">Kernel Concurrency Sanitizer (KCSAN)</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">Linux Kernel Memory Consistency Model (LKMM)</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../readme.html">README (for LKMM)</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Documentation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../kfence.html">Kernel Electric-Fence (KFENCE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kselftest.html">Linux Kernel Selftests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kunit/index.html">KUnit - Linux Kernel Unit Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ktap.html">The Kernel Test Anything Protocol (KTAP), version 1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../checkuapi.html">UAPI Checker</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../gpio-sloppy-logic-analyzer.html">Linux Kernel GPIO based sloppy logic analyzer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../autofdo.html">Using AutoFDO with the Linux kernel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../propeller.html">Using Propeller with the Linux kernel</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../testing-overview.html">測試指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kbuild/index.html">建置系統</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/reporting-issues.html">回報議題</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tools/index.html">使用者空間工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userspace-api/index.html">使用者空間 API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../firmware-guide/index.html">韌體</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../devicetree/index.html">韌體與裝置樹</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../arch/index.html">CPU 架構</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../staging/index.html">未排序的文件</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>本頁</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/dev-tools/lkmm/docs/control-dependencies.rst.txt"
            rel="nofollow">顯示原始碼</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="control-dependencies">
<h1>Control Dependencies<a class="headerlink" href="#control-dependencies" title="連結到這個標頭">¶</a></h1>
<p>Literal include of <code class="docutils literal notranslate"><span class="pre">tools/memory-model/Documentation/control-dependencies.txt</span></code>.</p>
<hr class="docutils" />
<pre class="literal-block">CONTROL DEPENDENCIES
====================

A major difficulty with control dependencies is that current compilers
do not support them.  One purpose of this document is therefore to
help you prevent your compiler from breaking your code.  However,
control dependencies also pose other challenges, which leads to the
second purpose of this document, namely to help you to avoid breaking
your own code, even in the absence of help from your compiler.

One such challenge is that control dependencies order only later stores.
Therefore, a load-load control dependency will not preserve ordering
unless a read memory barrier is provided.  Consider the following code:

        q = READ_ONCE(a);
        if (q)
                p = READ_ONCE(b);

This is not guaranteed to provide any ordering because some types of CPUs
are permitted to predict the result of the load from &quot;b&quot;.  This prediction
can cause other CPUs to see this load as having happened before the load
from &quot;a&quot;.  This means that an explicit read barrier is required, for example
as follows:

        q = READ_ONCE(a);
        if (q) {
                smp_rmb();
                p = READ_ONCE(b);
        }

However, stores are not speculated.  This means that ordering is
(usually) guaranteed for load-store control dependencies, as in the
following example:

        q = READ_ONCE(a);
        if (q)
                WRITE_ONCE(b, 1);

Control dependencies can pair with each other and with other types
of ordering.  But please note that neither the READ_ONCE() nor the
WRITE_ONCE() are optional.  Without the READ_ONCE(), the compiler might
fuse the load from &quot;a&quot; with other loads.  Without the WRITE_ONCE(),
the compiler might fuse the store to &quot;b&quot; with other stores.  Worse yet,
the compiler might convert the store into a load and a check followed
by a store, and this compiler-generated load would not be ordered by
the control dependency.

Furthermore, if the compiler is able to prove that the value of variable
&quot;a&quot; is always non-zero, it would be well within its rights to optimize
the original example by eliminating the &quot;if&quot; statement as follows:

        q = a;
        b = 1;  /* BUG: Compiler and CPU can both reorder!!! */

So don't leave out either the READ_ONCE() or the WRITE_ONCE().
In particular, although READ_ONCE() does force the compiler to emit a
load, it does *not* force the compiler to actually use the loaded value.

It is tempting to try use control dependencies to enforce ordering on
identical stores on both branches of the &quot;if&quot; statement as follows:

        q = READ_ONCE(a);
        if (q) {
                barrier();
                WRITE_ONCE(b, 1);
                do_something();
        } else {
                barrier();
                WRITE_ONCE(b, 1);
                do_something_else();
        }

Unfortunately, current compilers will transform this as follows at high
optimization levels:

        q = READ_ONCE(a);
        barrier();
        WRITE_ONCE(b, 1);  /* BUG: No ordering vs. load from a!!! */
        if (q) {
                /* WRITE_ONCE(b, 1); -- moved up, BUG!!! */
                do_something();
        } else {
                /* WRITE_ONCE(b, 1); -- moved up, BUG!!! */
                do_something_else();
        }

Now there is no conditional between the load from &quot;a&quot; and the store to
&quot;b&quot;, which means that the CPU is within its rights to reorder them:  The
conditional is absolutely required, and must be present in the final
assembly code, after all of the compiler and link-time optimizations
have been applied.  Therefore, if you need ordering in this example,
you must use explicit memory ordering, for example, smp_store_release():

        q = READ_ONCE(a);
        if (q) {
                smp_store_release(&amp;b, 1);
                do_something();
        } else {
                smp_store_release(&amp;b, 1);
                do_something_else();
        }

Without explicit memory ordering, control-dependency-based ordering is
guaranteed only when the stores differ, for example:

        q = READ_ONCE(a);
        if (q) {
                WRITE_ONCE(b, 1);
                do_something();
        } else {
                WRITE_ONCE(b, 2);
                do_something_else();
        }

The initial READ_ONCE() is still required to prevent the compiler from
knowing too much about the value of &quot;a&quot;.

But please note that you need to be careful what you do with the local
variable &quot;q&quot;, otherwise the compiler might be able to guess the value
and again remove the conditional branch that is absolutely required to
preserve ordering.  For example:

        q = READ_ONCE(a);
        if (q % MAX) {
                WRITE_ONCE(b, 1);
                do_something();
        } else {
                WRITE_ONCE(b, 2);
                do_something_else();
        }

If MAX is compile-time defined to be 1, then the compiler knows that
(q % MAX) must be equal to zero, regardless of the value of &quot;q&quot;.
The compiler is therefore within its rights to transform the above code
into the following:

        q = READ_ONCE(a);
        WRITE_ONCE(b, 2);
        do_something_else();

Given this transformation, the CPU is not required to respect the ordering
between the load from variable &quot;a&quot; and the store to variable &quot;b&quot;.  It is
tempting to add a barrier(), but this does not help.  The conditional
is gone, and the barrier won't bring it back.  Therefore, if you need
to relying on control dependencies to produce this ordering, you should
make sure that MAX is greater than one, perhaps as follows:

        q = READ_ONCE(a);
        BUILD_BUG_ON(MAX &lt;= 1); /* Order load from a with store to b. */
        if (q % MAX) {
                WRITE_ONCE(b, 1);
                do_something();
        } else {
                WRITE_ONCE(b, 2);
                do_something_else();
        }

Please note once again that each leg of the &quot;if&quot; statement absolutely
must store different values to &quot;b&quot;.  As in previous examples, if the two
values were identical, the compiler could pull this store outside of the
&quot;if&quot; statement, destroying the control dependency's ordering properties.

You must also be careful avoid relying too much on boolean short-circuit
evaluation.  Consider this example:

        q = READ_ONCE(a);
        if (q || 1 &gt; 0)
                WRITE_ONCE(b, 1);

Because the first condition cannot fault and the second condition is
always true, the compiler can transform this example as follows, again
destroying the control dependency's ordering:

        q = READ_ONCE(a);
        WRITE_ONCE(b, 1);

This is yet another example showing the importance of preventing the
compiler from out-guessing your code.  Again, although READ_ONCE() really
does force the compiler to emit code for a given load, the compiler is
within its rights to discard the loaded value.

In addition, control dependencies apply only to the then-clause and
else-clause of the &quot;if&quot; statement in question.  In particular, they do
not necessarily order the code following the entire &quot;if&quot; statement:

        q = READ_ONCE(a);
        if (q) {
                WRITE_ONCE(b, 1);
        } else {
                WRITE_ONCE(b, 2);
        }
        WRITE_ONCE(c, 1);  /* BUG: No ordering against the read from &quot;a&quot;. */

It is tempting to argue that there in fact is ordering because the
compiler cannot reorder volatile accesses and also cannot reorder
the writes to &quot;b&quot; with the condition.  Unfortunately for this line
of reasoning, the compiler might compile the two writes to &quot;b&quot; as
conditional-move instructions, as in this fanciful pseudo-assembly
language:

        ld r1,a
        cmp r1,$0
        cmov,ne r4,$1
        cmov,eq r4,$2
        st r4,b
        st $1,c

The control dependencies would then extend only to the pair of cmov
instructions and the store depending on them.  This means that a weakly
ordered CPU would have no dependency of any sort between the load from
&quot;a&quot; and the store to &quot;c&quot;.  In short, control dependencies provide ordering
only to the stores in the then-clause and else-clause of the &quot;if&quot; statement
in question (including functions invoked by those two clauses), and not
to code following that &quot;if&quot; statement.


In summary:

  (*) Control dependencies can order prior loads against later stores.
      However, they do *not* guarantee any other sort of ordering:
      Not prior loads against later loads, nor prior stores against
      later anything.  If you need these other forms of ordering, use
      smp_load_acquire(), smp_store_release(), or, in the case of prior
      stores and later loads, smp_mb().

  (*) If both legs of the &quot;if&quot; statement contain identical stores to
      the same variable, then you must explicitly order those stores,
      either by preceding both of them with smp_mb() or by using
      smp_store_release().  Please note that it is *not* sufficient to use
      barrier() at beginning and end of each leg of the &quot;if&quot; statement
      because, as shown by the example above, optimizing compilers can
      destroy the control dependency while respecting the letter of the
      barrier() law.

  (*) Control dependencies require at least one run-time conditional
      between the prior load and the subsequent store, and this
      conditional must involve the prior load.  If the compiler is able
      to optimize the conditional away, it will have also optimized
      away the ordering.  Careful use of READ_ONCE() and WRITE_ONCE()
      can help to preserve the needed conditional.

  (*) Control dependencies require that the compiler avoid reordering the
      dependency into nonexistence.  Careful use of READ_ONCE() or
      atomic{,64}_read() can help to preserve your control dependency.

  (*) Control dependencies apply only to the then-clause and else-clause
      of the &quot;if&quot; statement containing the control dependency, including
      any functions that these two clauses call.  Control dependencies
      do *not* apply to code beyond the end of that &quot;if&quot; statement.

  (*) Control dependencies pair normally with other types of barriers.

  (*) Control dependencies do *not* provide multicopy atomicity.  If you
      need all the CPUs to agree on the ordering of a given store against
      all other accesses, use smp_mb().

  (*) Compilers do not understand control dependencies.  It is therefore
      your job to ensure that they do not break your code.
</pre>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;The kernel development community.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../../../_sources/dev-tools/lkmm/docs/control-dependencies.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>