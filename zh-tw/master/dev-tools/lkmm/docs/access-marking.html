<!DOCTYPE html>

<html lang="zh-TW" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Access Marking &#8212; The Linux Kernel  說明文件</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=adfc0c0d" />
    <script src="../../../_static/documentation_options.js?v=0d9984b1"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/translations.js?v=cbf116e0"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/linux-docs-l10n/dev-tools/lkmm/docs/access-marking.html" />
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜尋" href="../../../search.html" />
    <link rel="next" title="Cheatsheet" href="cheatsheet.html" />
    <link rel="prev" title="Control Dependencies" href="control-dependencies.html" />

   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

<script type="text/javascript" src="../../../ltd-provenance.js"></script>
<script type="text/javascript" src="../../../ltd-current.js"></script>
<script type="text/javascript" src="../../../../../ltd-config.js"></script>
<script type="text/javascript" src="../../../../../ltd-flyout.js"></script>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/logo.svg" alt="Logo of The Linux Kernel"/>
            </a></p>
<h1 class="logo"><a href="../../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.18.0-rc2</p>







<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜尋</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="前往" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>


<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/submitting-patches.html">提交補釘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/code-of-conduct.html">行為守則</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../maintainer/index.html">維護者手冊</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/index.html">All development-process docs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../core-api/index.html">核心 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../subsystem-apis.html">子系統</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../locking/index.html">Locking</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../doc-guide/index.html">撰寫文件</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">開發工具</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../testing-overview.html">Kernel Testing Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../checkpatch.html">Checkpatch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../clang-format.html">clang-format</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../coccinelle.html">Coccinelle</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../sparse.html">Sparse</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kcov.html">KCOV: code coverage for fuzzing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../gcov.html">Using gcov with the Linux kernel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kasan.html">Kernel Address Sanitizer (KASAN)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kmsan.html">Kernel Memory Sanitizer (KMSAN)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ubsan.html">Undefined Behavior Sanitizer - UBSAN</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kmemleak.html">Kernel Memory Leak Detector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kcsan.html">Kernel Concurrency Sanitizer (KCSAN)</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">Linux Kernel Memory Consistency Model (LKMM)</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../readme.html">README (for LKMM)</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Documentation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../kfence.html">Kernel Electric-Fence (KFENCE)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kselftest.html">Linux Kernel Selftests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../kunit/index.html">KUnit - Linux Kernel Unit Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ktap.html">The Kernel Test Anything Protocol (KTAP), version 1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../checkuapi.html">UAPI Checker</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../gpio-sloppy-logic-analyzer.html">Linux Kernel GPIO based sloppy logic analyzer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../autofdo.html">Using AutoFDO with the Linux kernel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../propeller.html">Using Propeller with the Linux kernel</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../testing-overview.html">測試指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../livepatch/index.html">Livepatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kbuild/index.html">建置系統</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/reporting-issues.html">回報議題</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tools/index.html">使用者空間工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userspace-api/index.html">使用者空間 API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../firmware-guide/index.html">韌體</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../devicetree/index.html">韌體與裝置樹</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../arch/index.html">CPU 架構</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../staging/index.html">未排序的文件</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>本頁</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/dev-tools/lkmm/docs/access-marking.rst.txt"
            rel="nofollow">顯示原始碼</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="access-marking">
<h1>Access Marking<a class="headerlink" href="#access-marking" title="連結到這個標頭">¶</a></h1>
<p>Literal include of <code class="docutils literal notranslate"><span class="pre">tools/memory-model/Documentation/access-marking.txt</span></code>.</p>
<hr class="docutils" />
<pre class="literal-block">MARKING SHARED-MEMORY ACCESSES
==============================

This document provides guidelines for marking intentionally concurrent
normal accesses to shared memory, that is &quot;normal&quot; as in accesses that do
not use read-modify-write atomic operations.  It also describes how to
document these accesses, both with comments and with special assertions
processed by the Kernel Concurrency Sanitizer (KCSAN).  This discussion
builds on an earlier LWN article [1] and Linux Foundation mentorship
session [2].


ACCESS-MARKING OPTIONS
======================

The Linux kernel provides the following access-marking options:

1.      Plain C-language accesses (unmarked), for example, &quot;a = b;&quot;

2.      Data-race marking, for example, &quot;data_race(a = b);&quot;

3.      READ_ONCE(), for example, &quot;a = READ_ONCE(b);&quot;
        The various forms of atomic_read() also fit in here.

4.      WRITE_ONCE(), for example, &quot;WRITE_ONCE(a, b);&quot;
        The various forms of atomic_set() also fit in here.

5.      __data_racy, for example &quot;int __data_racy a;&quot;

6.      KCSAN's negative-marking assertions, ASSERT_EXCLUSIVE_ACCESS()
        and ASSERT_EXCLUSIVE_WRITER(), are described in the
        &quot;ACCESS-DOCUMENTATION OPTIONS&quot; section below.

These may be used in combination, as shown in this admittedly improbable
example:

        WRITE_ONCE(a, b + data_race(c + d) + READ_ONCE(e));

Neither plain C-language accesses nor data_race() (#1 and #2 above) place
any sort of constraint on the compiler's choice of optimizations [3].
In contrast, READ_ONCE() and WRITE_ONCE() (#3 and #4 above) restrict the
compiler's use of code-motion and common-subexpression optimizations.
Therefore, if a given access is involved in an intentional data race,
using READ_ONCE() for loads and WRITE_ONCE() for stores is usually
preferable to data_race(), which in turn is usually preferable to plain
C-language accesses.  It is permissible to combine #2 and #3, for example,
data_race(READ_ONCE(a)), which will both restrict compiler optimizations
and disable KCSAN diagnostics.

KCSAN will complain about many types of data races involving plain
C-language accesses, but marking all accesses involved in a given data
race with one of data_race(), READ_ONCE(), or WRITE_ONCE(), will prevent
KCSAN from complaining.  Of course, lack of KCSAN complaints does not
imply correct code.  Therefore, please take a thoughtful approach
when responding to KCSAN complaints.  Churning the code base with
ill-considered additions of data_race(), READ_ONCE(), and WRITE_ONCE()
is unhelpful.

In fact, the following sections describe situations where use of
data_race() and even plain C-language accesses is preferable to
READ_ONCE() and WRITE_ONCE().


Use of the data_race() Macro
----------------------------

Here are some situations where data_race() should be used instead of
READ_ONCE() and WRITE_ONCE():

1.      Data-racy loads from shared variables whose values are used only
        for diagnostic purposes.

2.      Data-racy reads whose values are checked against marked reload.

3.      Reads whose values feed into error-tolerant heuristics.

4.      Writes setting values that feed into error-tolerant heuristics.


Data-Racy Reads for Approximate Diagnostics

Approximate diagnostics include lockdep reports, monitoring/statistics
(including /proc and /sys output), WARN*()/BUG*() checks whose return
values are ignored, and other situations where reads from shared variables
are not an integral part of the core concurrency design.

In fact, use of data_race() instead READ_ONCE() for these diagnostic
reads can enable better checking of the remaining accesses implementing
the core concurrency design.  For example, suppose that the core design
prevents any non-diagnostic reads from shared variable x from running
concurrently with updates to x.  Then using plain C-language writes
to x allows KCSAN to detect reads from x from within regions of code
that fail to exclude the updates.  In this case, it is important to use
data_race() for the diagnostic reads because otherwise KCSAN would give
false-positive warnings about these diagnostic reads.

If it is necessary to both restrict compiler optimizations and disable
KCSAN diagnostics, use both data_race() and READ_ONCE(), for example,
data_race(READ_ONCE(a)).

In theory, plain C-language loads can also be used for this use case.
However, in practice this will have the disadvantage of causing KCSAN
to generate false positives because KCSAN will have no way of knowing
that the resulting data race was intentional.


Data-Racy Reads That Are Checked Against Marked Reload

The values from some reads are not implicitly trusted.  They are instead
fed into some operation that checks the full value against a later marked
load from memory, which means that the occasional arbitrarily bogus value
is not a problem.  For example, if a bogus value is fed into cmpxchg(),
all that happens is that this cmpxchg() fails, which normally results
in a retry.  Unless the race condition that resulted in the bogus value
recurs, this retry will with high probability succeed, so no harm done.

However, please keep in mind that a data_race() load feeding into
a cmpxchg_relaxed() might still be subject to load fusing on some
architectures.  Therefore, it is best to capture the return value from
the failing cmpxchg() for the next iteration of the loop, an approach
that provides the compiler much less scope for mischievous optimizations.
Capturing the return value from cmpxchg() also saves a memory reference
in many cases.

In theory, plain C-language loads can also be used for this use case.
However, in practice this will have the disadvantage of causing KCSAN
to generate false positives because KCSAN will have no way of knowing
that the resulting data race was intentional.


Reads Feeding Into Error-Tolerant Heuristics

Values from some reads feed into heuristics that can tolerate occasional
errors.  Such reads can use data_race(), thus allowing KCSAN to focus on
the other accesses to the relevant shared variables.  But please note
that data_race() loads are subject to load fusing, which can result in
consistent errors, which in turn are quite capable of breaking heuristics.
Therefore use of data_race() should be limited to cases where some other
code (such as a barrier() call) will force the occasional reload.

Note that this use case requires that the heuristic be able to handle
any possible error.  In contrast, if the heuristics might be fatally
confused by one or more of the possible erroneous values, use READ_ONCE()
instead of data_race().

In theory, plain C-language loads can also be used for this use case.
However, in practice this will have the disadvantage of causing KCSAN
to generate false positives because KCSAN will have no way of knowing
that the resulting data race was intentional.


Writes Setting Values Feeding Into Error-Tolerant Heuristics

The values read into error-tolerant heuristics come from somewhere,
for example, from sysfs.  This means that some code in sysfs writes
to this same variable, and these writes can also use data_race().
After all, if the heuristic can tolerate the occasional bogus value
due to compiler-mangled reads, it can also tolerate the occasional
compiler-mangled write, at least assuming that the proper value is in
place once the write completes.

Plain C-language stores can also be used for this use case.  However,
in kernels built with CONFIG_KCSAN_ASSUME_PLAIN_WRITES_ATOMIC=n, this
will have the disadvantage of causing KCSAN to generate false positives
because KCSAN will have no way of knowing that the resulting data race
was intentional.


Use of Plain C-Language Accesses
--------------------------------

Here are some example situations where plain C-language accesses should
used instead of READ_ONCE(), WRITE_ONCE(), and data_race():

1.      Accesses protected by mutual exclusion, including strict locking
        and sequence locking.

2.      Initialization-time and cleanup-time accesses.  This covers a
        wide variety of situations, including the uniprocessor phase of
        system boot, variables to be used by not-yet-spawned kthreads,
        structures not yet published to reference-counted or RCU-protected
        data structures, and the cleanup side of any of these situations.

3.      Per-CPU variables that are not accessed from other CPUs.

4.      Private per-task variables, including on-stack variables, some
        fields in the task_struct structure, and task-private heap data.

5.      Any other loads for which there is not supposed to be a concurrent
        store to that same variable.

6.      Any other stores for which there should be neither concurrent
        loads nor concurrent stores to that same variable.

        But note that KCSAN makes two explicit exceptions to this rule
        by default, refraining from flagging plain C-language stores:

        a.      No matter what.  You can override this default by building
                with CONFIG_KCSAN_ASSUME_PLAIN_WRITES_ATOMIC=n.

        b.      When the store writes the value already contained in
                that variable.  You can override this default by building
                with CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY=n.

        c.      When one of the stores is in an interrupt handler and
                the other in the interrupted code.  You can override this
                default by building with CONFIG_KCSAN_INTERRUPT_WATCHER=y.

Note that it is important to use plain C-language accesses in these cases,
because doing otherwise prevents KCSAN from detecting violations of your
code's synchronization rules.


Use of __data_racy
------------------

Adding the __data_racy type qualifier to the declaration of a variable
causes KCSAN to treat all accesses to that variable as if they were
enclosed by data_race().  However, __data_racy does not affect the
compiler, though one could imagine hardened kernel builds treating the
__data_racy type qualifier as if it was the volatile keyword.

Note well that __data_racy is subject to the same pointer-declaration
rules as are other type qualifiers such as const and volatile.
For example:

        int __data_racy *p; // Pointer to data-racy data.
        int *__data_racy p; // Data-racy pointer to non-data-racy data.


ACCESS-DOCUMENTATION OPTIONS
============================

It is important to comment marked accesses so that people reading your
code, yourself included, are reminded of the synchronization design.
However, it is even more important to comment plain C-language accesses
that are intentionally involved in data races.  Such comments are
needed to remind people reading your code, again, yourself included,
of how the compiler has been prevented from optimizing those accesses
into concurrency bugs.

It is also possible to tell KCSAN about your synchronization design.
For example, ASSERT_EXCLUSIVE_ACCESS(foo) tells KCSAN that any
concurrent access to variable foo by any other CPU is an error, even
if that concurrent access is marked with READ_ONCE().  In addition,
ASSERT_EXCLUSIVE_WRITER(foo) tells KCSAN that although it is OK for there
to be concurrent reads from foo from other CPUs, it is an error for some
other CPU to be concurrently writing to foo, even if that concurrent
write is marked with data_race() or WRITE_ONCE().

Note that although KCSAN will call out data races involving either
ASSERT_EXCLUSIVE_ACCESS() or ASSERT_EXCLUSIVE_WRITER() on the one hand
and data_race() writes on the other, KCSAN will not report the location
of these data_race() writes.


EXAMPLES
========

As noted earlier, the goal is to prevent the compiler from destroying
your concurrent algorithm, to help the human reader, and to inform
KCSAN of aspects of your concurrency design.  This section looks at a
few examples showing how this can be done.


Lock Protection With Lockless Diagnostic Access
-----------------------------------------------

For example, suppose a shared variable &quot;foo&quot; is read only while a
reader-writer spinlock is read-held, written only while that same
spinlock is write-held, except that it is also read locklessly for
diagnostic purposes.  The code might look as follows:

        int foo;
        DEFINE_RWLOCK(foo_rwlock);

        void update_foo(int newval)
        {
                write_lock(&amp;foo_rwlock);
                foo = newval;
                do_something(newval);
                write_unlock(&amp;foo_rwlock);
        }

        int read_foo(void)
        {
                int ret;

                read_lock(&amp;foo_rwlock);
                do_something_else();
                ret = foo;
                read_unlock(&amp;foo_rwlock);
                return ret;
        }

        void read_foo_diagnostic(void)
        {
                pr_info(&quot;Current value of foo: %d\n&quot;, data_race(foo));
        }

The reader-writer lock prevents the compiler from introducing concurrency
bugs into any part of the main algorithm using foo, which means that
the accesses to foo within both update_foo() and read_foo() can (and
should) be plain C-language accesses.  One benefit of making them be
plain C-language accesses is that KCSAN can detect any erroneous lockless
reads from or updates to foo.  The data_race() in read_foo_diagnostic()
tells KCSAN that data races are expected, and should be silently
ignored.  This data_race() also tells the human reading the code that
read_foo_diagnostic() might sometimes return a bogus value.

If it is necessary to suppress compiler optimization and also detect
buggy lockless writes, read_foo_diagnostic() can be updated as follows:

        void read_foo_diagnostic(void)
        {
                pr_info(&quot;Current value of foo: %d\n&quot;, data_race(READ_ONCE(foo)));
        }

Alternatively, given that KCSAN is to ignore all accesses in this function,
this function can be marked __no_kcsan and the data_race() can be dropped:

        void __no_kcsan read_foo_diagnostic(void)
        {
                pr_info(&quot;Current value of foo: %d\n&quot;, READ_ONCE(foo));
        }

However, in order for KCSAN to detect buggy lockless writes, your kernel
must be built with CONFIG_KCSAN_ASSUME_PLAIN_WRITES_ATOMIC=n.  If you
need KCSAN to detect such a write even if that write did not change
the value of foo, you also need CONFIG_KCSAN_REPORT_VALUE_CHANGE_ONLY=n.
If you need KCSAN to detect such a write happening in an interrupt handler
running on the same CPU doing the legitimate lock-protected write, you
also need CONFIG_KCSAN_INTERRUPT_WATCHER=y.  With some or all of these
Kconfig options set properly, KCSAN can be quite helpful, although
it is not necessarily a full replacement for hardware watchpoints.
On the other hand, neither are hardware watchpoints a full replacement
for KCSAN because it is not always easy to tell hardware watchpoint to
conditionally trap on accesses.


Lock-Protected Writes With Lockless Reads
-----------------------------------------

For another example, suppose a shared variable &quot;foo&quot; is updated only
while holding a spinlock, but is read locklessly.  The code might look
as follows:

        int foo;
        DEFINE_SPINLOCK(foo_lock);

        void update_foo(int newval)
        {
                spin_lock(&amp;foo_lock);
                WRITE_ONCE(foo, newval);
                ASSERT_EXCLUSIVE_WRITER(foo);
                do_something(newval);
                spin_unlock(&amp;foo_wlock);
        }

        int read_foo(void)
        {
                do_something_else();
                return READ_ONCE(foo);
        }

Because foo is read locklessly, all accesses are marked.  The purpose
of the ASSERT_EXCLUSIVE_WRITER() is to allow KCSAN to check for a buggy
concurrent write, whether marked or not.


Lock-Protected Writes With Heuristic Lockless Reads
---------------------------------------------------

For another example, suppose that the code can normally make use of
a per-data-structure lock, but there are times when a global lock
is required.  These times are indicated via a global flag.  The code
might look as follows, and is based loosely on nf_conntrack_lock(),
nf_conntrack_all_lock(), and nf_conntrack_all_unlock():

        bool global_flag;
        DEFINE_SPINLOCK(global_lock);
        struct foo {
                spinlock_t f_lock;
                int f_data;
        };

        /* All foo structures are in the following array. */
        int nfoo;
        struct foo *foo_array;

        void do_something_locked(struct foo *fp)
        {
                /* This works even if data_race() returns nonsense. */
                if (!data_race(global_flag)) {
                        spin_lock(&amp;fp-&gt;f_lock);
                        if (!smp_load_acquire(&amp;global_flag)) {
                                do_something(fp);
                                spin_unlock(&amp;fp-&gt;f_lock);
                                return;
                        }
                        spin_unlock(&amp;fp-&gt;f_lock);
                }
                spin_lock(&amp;global_lock);
                /* global_lock held, thus global flag cannot be set. */
                spin_lock(&amp;fp-&gt;f_lock);
                spin_unlock(&amp;global_lock);
                /*
                 * global_flag might be set here, but begin_global()
                 * will wait for -&gt;f_lock to be released.
                 */
                do_something(fp);
                spin_unlock(&amp;fp-&gt;f_lock);
        }

        void begin_global(void)
        {
                int i;

                spin_lock(&amp;global_lock);
                WRITE_ONCE(global_flag, true);
                for (i = 0; i &lt; nfoo; i++) {
                        /*
                         * Wait for pre-existing local locks.  One at
                         * a time to avoid lockdep limitations.
                         */
                        spin_lock(&amp;fp-&gt;f_lock);
                        spin_unlock(&amp;fp-&gt;f_lock);
                }
        }

        void end_global(void)
        {
                smp_store_release(&amp;global_flag, false);
                spin_unlock(&amp;global_lock);
        }

All code paths leading from the do_something_locked() function's first
read from global_flag acquire a lock, so endless load fusing cannot
happen.

If the value read from global_flag is true, then global_flag is
rechecked while holding -&gt;f_lock, which, if global_flag is now false,
prevents begin_global() from completing.  It is therefore safe to invoke
do_something().

Otherwise, if either value read from global_flag is true, then after
global_lock is acquired global_flag must be false.  The acquisition of
-&gt;f_lock will prevent any call to begin_global() from returning, which
means that it is safe to release global_lock and invoke do_something().

For this to work, only those foo structures in foo_array[] may be passed
to do_something_locked().  The reason for this is that the synchronization
with begin_global() relies on momentarily holding the lock of each and
every foo structure.

The smp_load_acquire() and smp_store_release() are required because
changes to a foo structure between calls to begin_global() and
end_global() are carried out without holding that structure's -&gt;f_lock.
The smp_load_acquire() and smp_store_release() ensure that the next
invocation of do_something() from do_something_locked() will see those
changes.


Lockless Reads and Writes
-------------------------

For another example, suppose a shared variable &quot;foo&quot; is both read and
updated locklessly.  The code might look as follows:

        int foo;

        int update_foo(int newval)
        {
                int ret;

                ret = xchg(&amp;foo, newval);
                do_something(newval);
                return ret;
        }

        int read_foo(void)
        {
                do_something_else();
                return READ_ONCE(foo);
        }

Because foo is accessed locklessly, all accesses are marked.  It does
not make sense to use ASSERT_EXCLUSIVE_WRITER() in this case because
there really can be concurrent lockless writers.  KCSAN would
flag any concurrent plain C-language reads from foo, and given
CONFIG_KCSAN_ASSUME_PLAIN_WRITES_ATOMIC=n, also any concurrent plain
C-language writes to foo.


Lockless Reads and Writes, But With Single-Threaded Initialization
------------------------------------------------------------------

For yet another example, suppose that foo is initialized in a
single-threaded manner, but that a number of kthreads are then created
that locklessly and concurrently access foo.  Some snippets of this code
might look as follows:

        int foo;

        void initialize_foo(int initval, int nkthreads)
        {
                int i;

                foo = initval;
                ASSERT_EXCLUSIVE_ACCESS(foo);
                for (i = 0; i &lt; nkthreads; i++)
                        kthread_run(access_foo_concurrently, ...);
        }

        /* Called from access_foo_concurrently(). */
        int update_foo(int newval)
        {
                int ret;

                ret = xchg(&amp;foo, newval);
                do_something(newval);
                return ret;
        }

        /* Also called from access_foo_concurrently(). */
        int read_foo(void)
        {
                do_something_else();
                return READ_ONCE(foo);
        }

The initialize_foo() uses a plain C-language write to foo because there
are not supposed to be concurrent accesses during initialization.  The
ASSERT_EXCLUSIVE_ACCESS() allows KCSAN to flag buggy concurrent unmarked
reads, and the ASSERT_EXCLUSIVE_ACCESS() call further allows KCSAN to
flag buggy concurrent writes, even if:  (1) Those writes are marked or
(2) The kernel was built with CONFIG_KCSAN_ASSUME_PLAIN_WRITES_ATOMIC=y.


Checking Stress-Test Race Coverage
----------------------------------

When designing stress tests it is important to ensure that race conditions
of interest really do occur.  For example, consider the following code
fragment:

        int foo;

        int update_foo(int newval)
        {
                return xchg(&amp;foo, newval);
        }

        int xor_shift_foo(int shift, int mask)
        {
                int old, new, newold;

                newold = data_race(foo); /* Checked by cmpxchg(). */
                do {
                        old = newold;
                        new = (old &lt;&lt; shift) ^ mask;
                        newold = cmpxchg(&amp;foo, old, new);
                } while (newold != old);
                return old;
        }

        int read_foo(void)
        {
                return READ_ONCE(foo);
        }

If it is possible for update_foo(), xor_shift_foo(), and read_foo() to be
invoked concurrently, the stress test should force this concurrency to
actually happen.  KCSAN can evaluate the stress test when the above code
is modified to read as follows:

        int foo;

        int update_foo(int newval)
        {
                ASSERT_EXCLUSIVE_ACCESS(foo);
                return xchg(&amp;foo, newval);
        }

        int xor_shift_foo(int shift, int mask)
        {
                int old, new, newold;

                newold = data_race(foo); /* Checked by cmpxchg(). */
                do {
                        old = newold;
                        new = (old &lt;&lt; shift) ^ mask;
                        ASSERT_EXCLUSIVE_ACCESS(foo);
                        newold = cmpxchg(&amp;foo, old, new);
                } while (newold != old);
                return old;
        }


        int read_foo(void)
        {
                ASSERT_EXCLUSIVE_ACCESS(foo);
                return READ_ONCE(foo);
        }

If a given stress-test run does not result in KCSAN complaints from
each possible pair of ASSERT_EXCLUSIVE_ACCESS() invocations, the
stress test needs improvement.  If the stress test was to be evaluated
on a regular basis, it would be wise to place the above instances of
ASSERT_EXCLUSIVE_ACCESS() under #ifdef so that they did not result in
false positives when not evaluating the stress test.


REFERENCES
==========

[1] &quot;Concurrency bugs should fear the big bad data-race detector (part 2)&quot;
    https://lwn.net/Articles/816854/

[2] &quot;The Kernel Concurrency Sanitizer&quot;
    https://www.linuxfoundation.org/webinars/the-kernel-concurrency-sanitizer

[3] &quot;Who's afraid of a big bad optimizing compiler?&quot;
    https://lwn.net/Articles/793253/
</pre>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;The kernel development community.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../../../_sources/dev-tools/lkmm/docs/access-marking.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>