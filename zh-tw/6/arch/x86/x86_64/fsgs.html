<!DOCTYPE html>

<html lang="zh-TW" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>30.7. Using FS and GS segments in user space applications &#8212; The Linux Kernel unknown version 說明文件</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=adfc0c0d" />
    <script src="../../../_static/documentation_options.js?v=b446b479"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/translations.js?v=cbf116e0"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/linux-docs-l10n/arch/x86/x86_64/fsgs.html" />
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜尋" href="../../../search.html" />
    <link rel="next" title="30.8. Flexible Return and Event Delivery (FRED)" href="fred.html" />
    <link rel="prev" title="30.6. Configurable sysfs parameters for the x86-64 machine check code" href="machinecheck.html" />

   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

<script type="text/javascript" src="../../../ltd-provenance.js"></script>
<script type="text/javascript" src="../../../ltd-current.js"></script>
<script type="text/javascript" src="../../../../../ltd-config.js"></script>
<script type="text/javascript" src="../../../../../ltd-flyout.js"></script>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/logo.svg" alt="Logo of The Linux Kernel"/>
            </a></p>
<h1 class="logo"><a href="../../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.19.0</p>







<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜尋</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="前往" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>


<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/submitting-patches.html">提交補釘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/code-of-conduct.html">行為守則</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../maintainer/index.html">維護者手冊</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../process/index.html">All development-process docs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../core-api/index.html">核心 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../subsystem-apis.html">子系統</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../doc-guide/index.html">撰寫文件</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev-tools/index.html">開發工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev-tools/testing-overview.html">測試指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../livepatch/index.html">即時補釘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../kbuild/index.html">建置系統</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../admin-guide/reporting-issues.html">回報議題</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tools/index.html">使用者空間工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userspace-api/index.html">使用者空間 API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../firmware-guide/index.html">韌體</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../devicetree/index.html">韌體與裝置樹</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">CPU 架構</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../arc/index.html">ARC 架構</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../arm/index.html">ARM 架構</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../arm64/index.html">ARM64 架構</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../loongarch/index.html">LoongArch 架構</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../m68k/index.html">m68k 架構</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../nios2/index.html">Nios II Specific Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../openrisc/index.html">OpenRISC 架構</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../parisc/index.html">PA-RISC 架構</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../powerpc/index.html">powerpc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../riscv/index.html">RISC-V 架構</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../s390/index.html">s390 架構</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../sparc/index.html">Sparc 架構</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">x86-specific Documentation</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../boot.html">1. The Linux/x86 Boot Protocol</a></li>
<li class="toctree-l3"><a class="reference internal" href="../booting-dt.html">2. DeviceTree Booting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cpuinfo.html">3. x86 Feature Flags</a></li>
<li class="toctree-l3"><a class="reference internal" href="../topology.html">4. x86 Topology</a></li>
<li class="toctree-l3"><a class="reference internal" href="../exception-tables.html">5. Kernel level exception handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="../kernel-stacks.html">6. Kernel Stacks</a></li>
<li class="toctree-l3"><a class="reference internal" href="../entry_64.html">7. Kernel Entries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../earlyprintk.html">8. Early Printk</a></li>
<li class="toctree-l3"><a class="reference internal" href="../orc-unwinder.html">9. ORC unwinder</a></li>
<li class="toctree-l3"><a class="reference internal" href="../zero-page.html">10. Zero Page</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tlb.html">11. The TLB</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mtrr.html">12. MTRR (Memory Type Range Register) control</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pat.html">13. PAT (Page Attribute Table)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../intel-hfi.html">14. Hardware-Feedback Interface for scheduling on Intel Hardware</a></li>
<li class="toctree-l3"><a class="reference internal" href="../shstk.html">15. Control-flow Enforcement Technology (CET) Shadow Stack</a></li>
<li class="toctree-l3"><a class="reference internal" href="../iommu.html">16. x86 IOMMU Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../intel_txt.html">17. Intel(R) TXT Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="../amd-debugging.html">18. Debugging AMD Zen systems</a></li>
<li class="toctree-l3"><a class="reference internal" href="../amd-memory-encryption.html">19. AMD Memory Encryption</a></li>
<li class="toctree-l3"><a class="reference internal" href="../amd_hsmp.html">20. AMD HSMP interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../amd-hfi.html">21. Hardware Feedback Interface For Hetero Core Scheduling On AMD Platform</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tdx.html">22. Intel Trust Domain Extensions (TDX)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pti.html">23. Page Table Isolation (PTI)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mds.html">24. Microarchitectural Data Sampling (MDS) mitigation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../microcode.html">25. The Linux Microcode Loader</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tsx_async_abort.html">26. TSX Async Abort (TAA) mitigation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../buslock.html">27. Bus lock detection and handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="../usb-legacy-support.html">28. USB Legacy support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../i386/index.html">29. i386 Support</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">30. x86_64 Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ifs.html">31. In-Field Scan</a></li>
<li class="toctree-l3"><a class="reference internal" href="../sva.html">32. Shared Virtual Addressing (SVA) with ENQCMD</a></li>
<li class="toctree-l3"><a class="reference internal" href="../sgx.html">33. Software Guard eXtensions (SGX)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../features.html">34. Feature status on x86 architecture</a></li>
<li class="toctree-l3"><a class="reference internal" href="../elf_auxvec.html">35. x86-specific ELF Auxiliary Vectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../xstate.html">36. Using XSTATE features in user space applications</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../xtensa/index.html">Xtensa 架構</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../staging/index.html">未排序的文件</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>本頁</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/arch/x86/x86_64/fsgs.rst.txt"
            rel="nofollow">顯示原始碼</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="using-fs-and-gs-segments-in-user-space-applications">
<h1><span class="section-number">30.7. </span>Using FS and GS segments in user space applications<a class="headerlink" href="#using-fs-and-gs-segments-in-user-space-applications" title="連結到這個標頭">¶</a></h1>
<p>The x86 architecture supports segmentation. Instructions which access
memory can use segment register based addressing mode. The following
notation is used to address a byte within a segment:</p>
<blockquote>
<div><p>Segment-register:Byte-address</p>
</div></blockquote>
<p>The segment base address is added to the Byte-address to compute the
resulting virtual address which is accessed. This allows to access multiple
instances of data with the identical Byte-address, i.e. the same code. The
selection of a particular instance is purely based on the base-address in
the segment register.</p>
<p>In 32-bit mode the CPU provides 6 segments, which also support segment
limits. The limits can be used to enforce address space protections.</p>
<p>In 64-bit mode the CS/SS/DS/ES segments are ignored and the base address is
always 0 to provide a full 64bit address space. The FS and GS segments are
still functional in 64-bit mode.</p>
<section id="common-fs-and-gs-usage">
<h2><span class="section-number">30.7.1. </span>Common FS and GS usage<a class="headerlink" href="#common-fs-and-gs-usage" title="連結到這個標頭">¶</a></h2>
<p>The FS segment is commonly used to address Thread Local Storage (TLS). FS
is usually managed by runtime code or a threading library. Variables
declared with the '__thread' storage class specifier are instantiated per
thread and the compiler emits the FS: address prefix for accesses to these
variables. Each thread has its own FS base address so common code can be
used without complex address offset calculations to access the per thread
instances. Applications should not use FS for other purposes when they use
runtimes or threading libraries which manage the per thread FS.</p>
<p>The GS segment has no common use and can be used freely by
applications. GCC and Clang support GS based addressing via address space
identifiers.</p>
</section>
<section id="reading-and-writing-the-fs-gs-base-address">
<h2><span class="section-number">30.7.2. </span>Reading and writing the FS/GS base address<a class="headerlink" href="#reading-and-writing-the-fs-gs-base-address" title="連結到這個標頭">¶</a></h2>
<p>There exist two mechanisms to read and write the FS/GS base address:</p>
<blockquote>
<div><ul class="simple">
<li><p>the <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">arch_prctl()</span></code> system call</p></li>
<li><p>the FSGSBASE instruction family</p></li>
</ul>
</div></blockquote>
</section>
<section id="accessing-fs-gs-base-with-arch-prctl">
<h2><span class="section-number">30.7.3. </span>Accessing FS/GS base with arch_prctl()<a class="headerlink" href="#accessing-fs-gs-base-with-arch-prctl" title="連結到這個標頭">¶</a></h2>
<blockquote>
<div><p>The arch_prctl(2) based mechanism is available on all 64-bit CPUs and all
kernel versions.</p>
<p>Reading the base:</p>
<blockquote>
<div><p>arch_prctl(ARCH_GET_FS, &amp;fsbase);
arch_prctl(ARCH_GET_GS, &amp;gsbase);</p>
</div></blockquote>
<p>Writing the base:</p>
<blockquote>
<div><p>arch_prctl(ARCH_SET_FS, fsbase);
arch_prctl(ARCH_SET_GS, gsbase);</p>
</div></blockquote>
<p>The ARCH_SET_GS prctl may be disabled depending on kernel configuration
and security settings.</p>
</div></blockquote>
</section>
<section id="accessing-fs-gs-base-with-the-fsgsbase-instructions">
<h2><span class="section-number">30.7.4. </span>Accessing FS/GS base with the FSGSBASE instructions<a class="headerlink" href="#accessing-fs-gs-base-with-the-fsgsbase-instructions" title="連結到這個標頭">¶</a></h2>
<blockquote>
<div><p>With the Ivy Bridge CPU generation Intel introduced a new set of
instructions to access the FS and GS base registers directly from user
space. These instructions are also supported on AMD Family 17H CPUs. The
following instructions are available:</p>
<blockquote>
<div><table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>RDFSBASE %reg</p></td>
<td><p>Read the FS base register</p></td>
</tr>
<tr class="row-even"><td><p>RDGSBASE %reg</p></td>
<td><p>Read the GS base register</p></td>
</tr>
<tr class="row-odd"><td><p>WRFSBASE %reg</p></td>
<td><p>Write the FS base register</p></td>
</tr>
<tr class="row-even"><td><p>WRGSBASE %reg</p></td>
<td><p>Write the GS base register</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The instructions avoid the overhead of the <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">arch_prctl()</span></code> syscall and allow
more flexible usage of the FS/GS addressing modes in user space
applications. This does not prevent conflicts between threading libraries
and runtimes which utilize FS and applications which want to use it for
their own purpose.</p>
</div></blockquote>
<section id="fsgsbase-instructions-enablement">
<h3><span class="section-number">30.7.4.1. </span>FSGSBASE instructions enablement<a class="headerlink" href="#fsgsbase-instructions-enablement" title="連結到這個標頭">¶</a></h3>
<blockquote>
<div><p>The instructions are enumerated in CPUID leaf 7, bit 0 of EBX. If
available /proc/cpuinfo shows 'fsgsbase' in the flag entry of the CPUs.</p>
<p>The availability of the instructions does not enable them
automatically. The kernel has to enable them explicitly in CR4. The
reason for this is that older kernels make assumptions about the values in
the GS register and enforce them when GS base is set via
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">arch_prctl()</span></code>. Allowing user space to write arbitrary values to GS base
would violate these assumptions and cause malfunction.</p>
<p>On kernels which do not enable FSGSBASE the execution of the FSGSBASE
instructions will fault with a #UD exception.</p>
<p>The kernel provides reliable information about the enabled state in the
ELF AUX vector. If the HWCAP2_FSGSBASE bit is set in the AUX vector, the
kernel has FSGSBASE instructions enabled and applications can use them.
The following code example shows how this detection works:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;sys/auxv.h&gt;
#include &lt;elf.h&gt;

/* Will be eventually in asm/hwcap.h */
#ifndef HWCAP2_FSGSBASE
#define HWCAP2_FSGSBASE        (1 &lt;&lt; 1)
#endif

....

unsigned val = getauxval(AT_HWCAP2);

if (val &amp; HWCAP2_FSGSBASE)
     printf(&quot;FSGSBASE enabled\n&quot;);
</pre></div>
</div>
</div></blockquote>
</section>
<section id="fsgsbase-instructions-compiler-support">
<h3><span class="section-number">30.7.4.2. </span>FSGSBASE instructions compiler support<a class="headerlink" href="#fsgsbase-instructions-compiler-support" title="連結到這個標頭">¶</a></h3>
<p>GCC version 4.6.4 and newer provide intrinsics for the FSGSBASE
instructions. Clang 5 supports them as well.</p>
<blockquote>
<div><table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">_readfsbase_u64()</span></code></p></td>
<td><p>Read the FS base register</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">_readgsbase_u64()</span></code></p></td>
<td><p>Read the GS base register</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">_writefsbase_u64()</span></code></p></td>
<td><p>Write the FS base register</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">_writegsbase_u64()</span></code></p></td>
<td><p>Write the GS base register</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>To utilize these intrinsics &lt;immintrin.h&gt; must be included in the source
code and the compiler option -mfsgsbase has to be added.</p>
</section>
</section>
<section id="compiler-support-for-fs-gs-based-addressing">
<h2><span class="section-number">30.7.5. </span>Compiler support for FS/GS based addressing<a class="headerlink" href="#compiler-support-for-fs-gs-based-addressing" title="連結到這個標頭">¶</a></h2>
<p>GCC version 6 and newer provide support for FS/GS based addressing via
Named Address Spaces. GCC implements the following address space
identifiers for x86:</p>
<blockquote>
<div><table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>__seg_fs</p></td>
<td><p>Variable is addressed relative to FS</p></td>
</tr>
<tr class="row-even"><td><p>__seg_gs</p></td>
<td><p>Variable is addressed relative to GS</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The preprocessor symbols __SEG_FS and __SEG_GS are defined when these
address spaces are supported. Code which implements fallback modes should
check whether these symbols are defined. Usage example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#ifdef __SEG_GS

long data0 = 0;
long data1 = 1;

long __seg_gs *ptr;

/* Check whether FSGSBASE is enabled by the kernel (HWCAP2_FSGSBASE) */
....

/* Set GS base to point to data0 */
_writegsbase_u64(&amp;data0);

/* Access offset 0 of GS */
ptr = 0;
printf(&quot;data0 = %ld\n&quot;, *ptr);

/* Set GS base to point to data1 */
_writegsbase_u64(&amp;data1);
/* ptr still addresses offset 0! */
printf(&quot;data1 = %ld\n&quot;, *ptr);
</pre></div>
</div>
<p>Clang does not provide the GCC address space identifiers, but it provides
address spaces via an attribute based mechanism in Clang 2.6 and newer
versions:</p>
<blockquote>
<div><table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>__attribute__((address_space(256))</p></td>
<td><p>Variable is addressed relative to GS</p></td>
</tr>
<tr class="row-even"><td><p>__attribute__((address_space(257))</p></td>
<td><p>Variable is addressed relative to FS</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</section>
<section id="fs-gs-based-addressing-with-inline-assembly">
<h2><span class="section-number">30.7.6. </span>FS/GS based addressing with inline assembly<a class="headerlink" href="#fs-gs-based-addressing-with-inline-assembly" title="連結到這個標頭">¶</a></h2>
<p>In case the compiler does not support address spaces, inline assembly can
be used for FS/GS based addressing mode:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mov %fs:offset, %reg
mov %gs:offset, %reg

mov %reg, %fs:offset
mov %reg, %gs:offset
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;The kernel development community.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../../../_sources/arch/x86/x86_64/fsgs.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>