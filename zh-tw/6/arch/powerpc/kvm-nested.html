<!DOCTYPE html>

<html lang="zh-TW" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Nested KVM on POWER &#8212; The Linux Kernel unknown version 說明文件</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=adfc0c0d" />
    <script src="../../_static/documentation_options.js?v=b446b479"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/translations.js?v=cbf116e0"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/linux-docs-l10n/arch/powerpc/kvm-nested.html" />
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜尋" href="../../search.html" />
    <link rel="next" title="Hypercall Op-codes (hcalls)" href="papr_hcalls.html" />
    <link rel="prev" title="Linux 2.6.x on MPC52xx family" href="mpc52xx.html" />

   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

<script type="text/javascript" src="../../ltd-provenance.js"></script>
<script type="text/javascript" src="../../ltd-current.js"></script>
<script type="text/javascript" src="../../../../ltd-config.js"></script>
<script type="text/javascript" src="../../../../ltd-flyout.js"></script>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.svg" alt="Logo of The Linux Kernel"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.19.0</p>







<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜尋</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="前往" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>


<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/submitting-patches.html">提交補釘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/code-of-conduct.html">行為守則</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maintainer/index.html">維護者手冊</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../process/index.html">All development-process docs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../core-api/index.html">核心 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../driver-api/index.html">Driver APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../subsystem-apis.html">子系統</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../doc-guide/index.html">撰寫文件</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/index.html">開發工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev-tools/testing-overview.html">測試指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../livepatch/index.html">即時補釘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../kbuild/index.html">建置系統</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../admin-guide/reporting-issues.html">回報議題</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/index.html">使用者空間工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userspace-api/index.html">使用者空間 API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../firmware-guide/index.html">韌體</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devicetree/index.html">韌體與裝置樹</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">CPU 架構</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../arc/index.html">ARC 架構</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arm/index.html">ARM 架構</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arm64/index.html">ARM64 架構</a></li>
<li class="toctree-l2"><a class="reference internal" href="../loongarch/index.html">LoongArch 架構</a></li>
<li class="toctree-l2"><a class="reference internal" href="../m68k/index.html">m68k 架構</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mips/index.html">MIPS-specific Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nios2/index.html">Nios II Specific Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../openrisc/index.html">OpenRISC 架構</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parisc/index.html">PA-RISC 架構</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">powerpc</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="associativity.html">NUMA resource associativity</a></li>
<li class="toctree-l3"><a class="reference internal" href="booting.html">DeviceTree Booting</a></li>
<li class="toctree-l3"><a class="reference internal" href="bootwrapper.html">The PowerPC boot wrapper</a></li>
<li class="toctree-l3"><a class="reference internal" href="cpu_families.html">CPU Families</a></li>
<li class="toctree-l3"><a class="reference internal" href="cpu_features.html">CPU Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="dawr-power9.html">DAWR issues on POWER9</a></li>
<li class="toctree-l3"><a class="reference internal" href="dexcr.html">DEXCR (Dynamic Execution Control Register)</a></li>
<li class="toctree-l3"><a class="reference internal" href="dscr.html">DSCR (Data Stream Control Register)</a></li>
<li class="toctree-l3"><a class="reference internal" href="eeh-pci-error-recovery.html">PCI Bus EEH Error Recovery</a></li>
<li class="toctree-l3"><a class="reference internal" href="elf_hwcaps.html">POWERPC ELF HWCAPs</a></li>
<li class="toctree-l3"><a class="reference internal" href="elfnote.html">ELF Note PowerPC Namespace</a></li>
<li class="toctree-l3"><a class="reference internal" href="firmware-assisted-dump.html">Firmware-Assisted Dump</a></li>
<li class="toctree-l3"><a class="reference internal" href="htm.html">HTM (Hardware Trace Macro)</a></li>
<li class="toctree-l3"><a class="reference internal" href="hvcs.html">HVCS IBM &quot;Hypervisor Virtual Console Server&quot; Installation Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="imc.html">IMC (In-Memory Collection Counters)</a></li>
<li class="toctree-l3"><a class="reference internal" href="isa-versions.html">CPU to ISA Version Mapping</a></li>
<li class="toctree-l3"><a class="reference internal" href="kaslr-booke32.html">KASLR for Freescale BookE32</a></li>
<li class="toctree-l3"><a class="reference internal" href="mpc52xx.html">Linux 2.6.x on MPC52xx family</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Nested KVM on POWER</a></li>
<li class="toctree-l3"><a class="reference internal" href="papr_hcalls.html">Hypercall Op-codes (hcalls)</a></li>
<li class="toctree-l3"><a class="reference internal" href="pci_iov_resource_on_powernv.html">PCI Express I/O Virtualization Resource on Powerenv</a></li>
<li class="toctree-l3"><a class="reference internal" href="pmu-ebb.html">PMU Event Based Branches</a></li>
<li class="toctree-l3"><a class="reference internal" href="ptrace.html">Ptrace</a></li>
<li class="toctree-l3"><a class="reference internal" href="qe_firmware.html">Freescale QUICC Engine Firmware Uploading</a></li>
<li class="toctree-l3"><a class="reference internal" href="syscall64-abi.html">Power Architecture 64-bit Linux system call ABI</a></li>
<li class="toctree-l3"><a class="reference internal" href="transactional_memory.html">Transactional Memory support</a></li>
<li class="toctree-l3"><a class="reference internal" href="ultravisor.html">Protected Execution Facility</a></li>
<li class="toctree-l3"><a class="reference internal" href="vas-api.html">Virtual Accelerator Switchboard (VAS) userspace API</a></li>
<li class="toctree-l3"><a class="reference internal" href="vcpudispatch_stats.html">VCPU Dispatch Statistics</a></li>
<li class="toctree-l3"><a class="reference internal" href="vmemmap_dedup.html">Device DAX</a></li>
<li class="toctree-l3"><a class="reference internal" href="vpa-dtl.html">DTL (Dispatch Trace Log)</a></li>
<li class="toctree-l3"><a class="reference internal" href="features.html">Feature status on powerpc architecture</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../riscv/index.html">RISC-V 架構</a></li>
<li class="toctree-l2"><a class="reference internal" href="../s390/index.html">s390 架構</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sh/index.html">SuperH Interfaces Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sparc/index.html">Sparc 架構</a></li>
<li class="toctree-l2"><a class="reference internal" href="../x86/index.html">x86-specific Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../xtensa/index.html">Xtensa 架構</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../staging/index.html">未排序的文件</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>本頁</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/arch/powerpc/kvm-nested.rst.txt"
            rel="nofollow">顯示原始碼</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="nested-kvm-on-power">
<h1>Nested KVM on POWER<a class="headerlink" href="#nested-kvm-on-power" title="連結到這個標頭">¶</a></h1>
<section id="introduction">
<h2>介紹<a class="headerlink" href="#introduction" title="連結到這個標頭">¶</a></h2>
<p>This document explains how a guest operating system can act as a
hypervisor and run nested guests through the use of hypercalls, if the
hypervisor has implemented them. The terms L0, L1, and L2 are used to
refer to different software entities. L0 is the hypervisor mode entity
that would normally be called the &quot;host&quot; or &quot;hypervisor&quot;. L1 is a
guest virtual machine that is directly run under L0 and is initiated
and controlled by L0. L2 is a guest virtual machine that is initiated
and controlled by L1 acting as a hypervisor.</p>
</section>
<section id="existing-api">
<h2>Existing API<a class="headerlink" href="#existing-api" title="連結到這個標頭">¶</a></h2>
<p>Linux/KVM has had support for Nesting as an L0 or L1 since 2018</p>
<p>The L0 code was added:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>commit 8e3f5fc1045dc49fd175b978c5457f5f51e7a2ce
Author: Paul Mackerras &lt;paulus@ozlabs.org&gt;
Date:   Mon Oct 8 16:31:03 2018 +1100
KVM: PPC: Book3S HV: Framework and hcall stubs for nested virtualization
</pre></div>
</div>
<p>The L1 code was added:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>commit 360cae313702cdd0b90f82c261a8302fecef030a
Author: Paul Mackerras &lt;paulus@ozlabs.org&gt;
Date:   Mon Oct 8 16:31:04 2018 +1100
KVM: PPC: Book3S HV: Nested guest entry via hypercall
</pre></div>
</div>
<p>This API works primarily using a single hcall <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">h_enter_nested()</span></code>. This
call made by the L1 to tell the L0 to start an L2 vCPU with the given
state. The L0 then starts this L2 and runs until an L2 exit condition
is reached. Once the L2 exits, the state of the L2 is given back to
the L1 by the L0. The full L2 vCPU state is always transferred from
and to L1 when the L2 is run. The L0 doesn't keep any state on the L2
vCPU (except in the short sequence in the L0 on L1 -&gt; L2 entry and L2
-&gt; L1 exit).</p>
<p>The only state kept by the L0 is the partition table. The L1 registers
it's partition table using the <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">h_set_partition_table()</span></code> hcall. All
other state held by the L0 about the L2s is cached state (such as
shadow page tables).</p>
<p>The L1 may run any L2 or vCPU without first informing the L0. It
simply starts the vCPU using <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">h_enter_nested()</span></code>. The creation of L2s and
vCPUs is done implicitly whenever <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">h_enter_nested()</span></code> is called.</p>
<p>In this document, we call this existing API the v1 API.</p>
</section>
<section id="new-papr-api">
<h2>New PAPR API<a class="headerlink" href="#new-papr-api" title="連結到這個標頭">¶</a></h2>
<p>The new PAPR API changes from the v1 API such that the creating L2 and
associated vCPUs is explicit. In this document, we call this the v2
API.</p>
<p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">h_enter_nested()</span></code> is replaced with <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">H_GUEST_VCPU_RUN()</span></code>.  Before this can
be called the L1 must explicitly create the L2 using <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">h_guest_create()</span></code>
and any associated <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">vCPUs()</span></code> created with <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">h_guest_create_vCPU()</span></code>. Getting
and setting vCPU state can also be performed using h_guest_{g|s}et
hcall.</p>
<p>The basic execution flow is for an L1 to create an L2, run it, and
delete it is:</p>
<ul class="simple">
<li><p>L1 and L0 negotiate capabilities with H_GUEST_{G,S}<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">ET_CAPABILITIES()</span></code>
(normally at L1 boot time).</p></li>
<li><p>L1 requests the L0 create an L2 with <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">H_GUEST_CREATE()</span></code> and receives a token</p></li>
<li><p>L1 requests the L0 create an L2 vCPU with <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">H_GUEST_CREATE_VCPU()</span></code></p></li>
<li><p>L1 and L0 communicate the vCPU state using the H_GUEST_{G,S}<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">ET()</span></code> hcall</p></li>
<li><p>L1 requests the L0 runs the vCPU running <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">H_GUEST_VCPU_RUN()</span></code> hcall</p></li>
<li><p>L1 deletes L2 with <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">H_GUEST_DELETE()</span></code></p></li>
</ul>
<p>More details of the individual hcalls follows:</p>
</section>
<section id="hcall-details">
<h2>HCALL Details<a class="headerlink" href="#hcall-details" title="連結到這個標頭">¶</a></h2>
<p>This documentation is provided to give an overall understating of the
API. It doesn't aim to provide all the details required to implement
an L1 or L0. Latest version of PAPR can be referred to for more details.</p>
<p>All these HCALLs are made by the L1 to the L0.</p>
<section id="h-guest-get-capabilities">
<h3>H_GUEST_GET_CAPABILITIES()<a class="headerlink" href="#h-guest-get-capabilities" title="連結到這個標頭">¶</a></h3>
<p>This is called to get the capabilities of the L0 nested
hypervisor. This includes capabilities such the CPU versions (eg
POWER9, POWER10) that are supported as L2s:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>H_GUEST_GET_CAPABILITIES(uint64 flags)

Parameters:
  Input:
    flags: Reserved
  Output:
    R3: Return code
    R4: Hypervisor Supported Capabilities bitmap 1
</pre></div>
</div>
</section>
<section id="h-guest-set-capabilities">
<h3>H_GUEST_SET_CAPABILITIES()<a class="headerlink" href="#h-guest-set-capabilities" title="連結到這個標頭">¶</a></h3>
<p>This is called to inform the L0 of the capabilities of the L1
hypervisor. The set of flags passed here are the same as
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">H_GUEST_GET_CAPABILITIES()</span></code></p>
<p>Typically, GET will be called first and then SET will be called with a
subset of the flags returned from GET. This process allows the L0 and
L1 to negotiate an agreed set of capabilities:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>H_GUEST_SET_CAPABILITIES(uint64 flags,
                         uint64 capabilitiesBitmap1)
Parameters:
  Input:
    flags: Reserved
    capabilitiesBitmap1: Only capabilities advertised through
                         H_GUEST_GET_CAPABILITIES
  Output:
    R3: Return code
    R4: If R3 = H_P2: The number of invalid bitmaps
    R5: If R3 = H_P2: The index of first invalid bitmap
</pre></div>
</div>
</section>
<section id="h-guest-create">
<h3>H_GUEST_CREATE()<a class="headerlink" href="#h-guest-create" title="連結到這個標頭">¶</a></h3>
<p>This is called to create an L2. A unique ID of the L2 created
(similar to an LPID) is returned, which can be used on subsequent HCALLs to
identify the L2:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>H_GUEST_CREATE(uint64 flags,
               uint64 continueToken);
Parameters:
  Input:
    flags: Reserved
    continueToken: Initial call set to -1. Subsequent calls,
                   after H_Busy or H_LongBusyOrder has been
                   returned, value that was returned in R4.
  Output:
    R3: Return code. Notable:
      H_Not_Enough_Resources: Unable to create Guest VCPU due to not
      enough Hypervisor memory. See H_GUEST_CREATE_GET_STATE(flags =
      takeOwnershipOfVcpuState)
    R4: If R3 = H_Busy or_H_LongBusyOrder -&gt; continueToken
</pre></div>
</div>
</section>
<section id="h-guest-create-vcpu">
<h3>H_GUEST_CREATE_VCPU()<a class="headerlink" href="#h-guest-create-vcpu" title="連結到這個標頭">¶</a></h3>
<p>This is called to create a vCPU associated with an L2. The L2 id
(returned from <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">H_GUEST_CREATE()</span></code>) should be passed it. Also passed in
is a unique (for this L2) vCPUid. This vCPUid is allocated by the
L1:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>H_GUEST_CREATE_VCPU(uint64 flags,
                    uint64 guestId,
                    uint64 vcpuId);
Parameters:
  Input:
    flags: Reserved
    guestId: ID obtained from H_GUEST_CREATE
    vcpuId: ID of the vCPU to be created. This must be within the
            range of 0 to 2047
  Output:
    R3: Return code. Notable:
      H_Not_Enough_Resources: Unable to create Guest VCPU due to not
      enough Hypervisor memory. See H_GUEST_CREATE_GET_STATE(flags =
      takeOwnershipOfVcpuState)
</pre></div>
</div>
</section>
<section id="h-guest-get-state">
<h3>H_GUEST_GET_STATE()<a class="headerlink" href="#h-guest-get-state" title="連結到這個標頭">¶</a></h3>
<p>This is called to get state associated with an L2 (Guest-wide or vCPU specific).
This info is passed via the Guest State Buffer (GSB), a standard format as
explained later in this doc, necessary details below:</p>
<p>This can get either L2 wide or vcpu specific information. Examples of
L2 wide is the timebase offset or process scoped page table
info. Examples of vCPU specific are GPRs or VSRs. A bit in the flags
parameter specifies if this call is L2 wide or vCPU specific and the
IDs in the GSB must match this.</p>
<p>The L1 provides a pointer to the GSB as a parameter to this call. Also
provided is the L2 and vCPU IDs associated with the state to set.</p>
<p>The L1 writes only the IDs and sizes in the GSB.  L0 writes the
associated values for each ID in the GSB:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>H_GUEST_GET_STATE(uint64 flags,
                         uint64 guestId,
                         uint64 vcpuId,
                         uint64 dataBuffer,
                         uint64 dataBufferSizeInBytes);
Parameters:
  Input:
    flags:
       Bit 0: getGuestWideState: Request state of the Guest instead
         of an individual VCPU.
       Bit 1: getHostWideState: Request stats of the Host. This causes
         the guestId and vcpuId parameters to be ignored and attempting
         to get the VCPU/Guest state will cause an error.
       Bits 2-63: Reserved
    guestId: ID obtained from H_GUEST_CREATE
    vcpuId: ID of the vCPU pass to H_GUEST_CREATE_VCPU
    dataBuffer: A L1 real address of the GSB.
      If takeOwnershipOfVcpuState, size must be at least the size
      returned by ID=0x0001
    dataBufferSizeInBytes: Size of dataBuffer
  Output:
    R3: Return code
    R4: If R3 = H_Invalid_Element_Id: The array index of the bad
          element ID.
        If R3 = H_Invalid_Element_Size: The array index of the bad
           element size.
        If R3 = H_Invalid_Element_Value: The array index of the bad
           element value.
</pre></div>
</div>
</section>
<section id="h-guest-set-state">
<h3>H_GUEST_SET_STATE()<a class="headerlink" href="#h-guest-set-state" title="連結到這個標頭">¶</a></h3>
<p>This is called to set L2 wide or vCPU specific L2 state. This info is
passed via the Guest State Buffer (GSB), necessary details below:</p>
<p>This can set either L2 wide or vcpu specific information. Examples of
L2 wide is the timebase offset or process scoped page table
info. Examples of vCPU specific are GPRs or VSRs. A bit in the flags
parameter specifies if this call is L2 wide or vCPU specific and the
IDs in the GSB must match this.</p>
<p>The L1 provides a pointer to the GSB as a parameter to this call. Also
provided is the L2 and vCPU IDs associated with the state to set.</p>
<p>The L1 writes all values in the GSB and the L0 only reads the GSB for
this call:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>H_GUEST_SET_STATE(uint64 flags,
                  uint64 guestId,
                  uint64 vcpuId,
                  uint64 dataBuffer,
                  uint64 dataBufferSizeInBytes);
Parameters:
  Input:
    flags:
       Bit 0: getGuestWideState: Request state of the Guest instead
         of an individual VCPU.
       Bit 1: returnOwnershipOfVcpuState Return Guest VCPU state. See
         GET_STATE takeOwnershipOfVcpuState
       Bits 2-63: Reserved
    guestId: ID obtained from H_GUEST_CREATE
    vcpuId: ID of the vCPU pass to H_GUEST_CREATE_VCPU
    dataBuffer: A L1 real address of the GSB.
      If takeOwnershipOfVcpuState, size must be at least the size
      returned by ID=0x0001
    dataBufferSizeInBytes: Size of dataBuffer
  Output:
    R3: Return code
    R4: If R3 = H_Invalid_Element_Id: The array index of the bad
          element ID.
        If R3 = H_Invalid_Element_Size: The array index of the bad
           element size.
        If R3 = H_Invalid_Element_Value: The array index of the bad
           element value.
</pre></div>
</div>
</section>
<section id="h-guest-run-vcpu">
<h3>H_GUEST_RUN_VCPU()<a class="headerlink" href="#h-guest-run-vcpu" title="連結到這個標頭">¶</a></h3>
<p>This is called to run an L2 vCPU. The L2 and vCPU IDs are passed in as
parameters. The vCPU runs with the state set previously using
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">H_GUEST_SET_STATE()</span></code>. When the L2 exits, the L1 will resume from this
hcall.</p>
<p>This hcall also has associated input and output GSBs. Unlike
H_GUEST_{S,G}<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">ET_STATE()</span></code>, these GSB pointers are not passed in as
parameters to the hcall (This was done in the interest of
performance). The locations of these GSBs must be preregistered using
the <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">H_GUEST_SET_STATE()</span></code> call with ID 0x0c00 and 0x0c01 (see table
below).</p>
<p>The input GSB may contain only VCPU specific elements to be set. This
GSB may also contain zero elements (ie 0 in the first 4 bytes of the
GSB) if nothing needs to be set.</p>
<p>On exit from the hcall, the output buffer is filled with elements
determined by the L0. The reason for the exit is contained in GPR4 (ie
NIP is put in GPR4).  The elements returned depend on the exit
type. For example, if the exit reason is the L2 doing a hcall (GPR4 =
0xc00), then GPR3-12 are provided in the output GSB as this is the
state likely needed to service the hcall. If additional state is
needed, <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">H_GUEST_GET_STATE()</span></code> may be called by the L1.</p>
<p>To synthesize interrupts in the L2, when calling <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">H_GUEST_RUN_VCPU()</span></code>
the L1 may set a flag (as a hcall parameter) and the L0 will
synthesize the interrupt in the L2. Alternatively, the L1 may
synthesize the interrupt itself using <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">H_GUEST_SET_STATE()</span></code> or the
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">H_GUEST_RUN_VCPU()</span></code> input GSB to set the state appropriately:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>H_GUEST_RUN_VCPU(uint64 flags,
                 uint64 guestId,
                 uint64 vcpuId,
                 uint64 dataBuffer,
                 uint64 dataBufferSizeInBytes);
Parameters:
  Input:
    flags:
       Bit 0: generateExternalInterrupt: Generate an external interrupt
       Bit 1: generatePrivilegedDoorbell: Generate a Privileged Doorbell
       Bit 2: sendToSystemReset”: Generate a System Reset Interrupt
       Bits 3-63: Reserved
    guestId: ID obtained from H_GUEST_CREATE
    vcpuId: ID of the vCPU pass to H_GUEST_CREATE_VCPU
  Output:
    R3: Return code
    R4: If R3 = H_Success: The reason L1 VCPU exited (ie. NIA)
          0x000: The VCPU stopped running for an unspecified reason. An
            example of this is the Hypervisor stopping a VCPU running
            due to an outstanding interrupt for the Host Partition.
          0x980: HDEC
          0xC00: HCALL
          0xE00: HDSI
          0xE20: HISI
          0xE40: HEA
          0xF80: HV Fac Unavail
        If R3 = H_Invalid_Element_Id, H_Invalid_Element_Size, or
          H_Invalid_Element_Value: R4 is offset of the invalid element
          in the input buffer.
</pre></div>
</div>
</section>
<section id="h-guest-delete">
<h3>H_GUEST_DELETE()<a class="headerlink" href="#h-guest-delete" title="連結到這個標頭">¶</a></h3>
<p>This is called to delete an L2. All associated vCPUs are also
deleted. No specific vCPU delete call is provided.</p>
<p>A flag may be provided to delete all guests. This is used to reset the
L0 in the case of kdump/kexec:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>H_GUEST_DELETE(uint64 flags,
               uint64 guestId)
Parameters:
  Input:
    flags:
       Bit 0: deleteAllGuests: deletes all guests
       Bits 1-63: Reserved
    guestId: ID obtained from H_GUEST_CREATE
  Output:
    R3: Return code
</pre></div>
</div>
</section>
</section>
<section id="guest-state-buffer">
<h2>Guest State Buffer<a class="headerlink" href="#guest-state-buffer" title="連結到這個標頭">¶</a></h2>
<p>The Guest State Buffer (GSB) is the main method of communicating state
about the L2 between the L1 and L0 via H_GUEST_{G,S}<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">ET()</span></code> and
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">H_GUEST_VCPU_RUN()</span></code> calls.</p>
<p>State may be associated with a whole L2 (eg timebase offset) or a
specific L2 vCPU (eg. GPR state). Only L2 VCPU state maybe be set by
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">H_GUEST_VCPU_RUN()</span></code>.</p>
<p>All data in the GSB is big endian (as is standard in PAPR)</p>
<p>The Guest state buffer has a header which gives the number of
elements, followed by the GSB elements themselves.</p>
<p>GSB header:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Offset
Bytes</p></th>
<th class="head"><p>Size
Bytes</p></th>
<th class="head"><p>Purpose</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>4</p></td>
<td><p>Number of elements</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td></td>
<td><p>Guest state buffer elements</p></td>
</tr>
</tbody>
</table>
<p>GSB element:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Offset
Bytes</p></th>
<th class="head"><p>Size
Bytes</p></th>
<th class="head"><p>Purpose</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>2</p></td>
<td><p>ID</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>2</p></td>
<td><p>Size of Value</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>As above</p></td>
<td><p>Value</p></td>
</tr>
</tbody>
</table>
<p>The ID in the GSB element specifies what is to be set. This includes
archtected state like GPRs, VSRs, SPRs, plus also some meta data about
the partition like the timebase offset and partition scoped page
table information.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>ID</p></th>
<th class="head"><p>Size
Bytes</p></th>
<th class="head"><p>RW</p></th>
<th class="head"><p>(H)ost
(G)uest
(T)hread
Scope</p></th>
<th class="head"><p>Details</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0000</p></td>
<td></td>
<td><p>RW</p></td>
<td><p>TG</p></td>
<td><p>NOP element</p></td>
</tr>
<tr class="row-odd"><td><p>0x0001</p></td>
<td><p>0x08</p></td>
<td><p>R</p></td>
<td><p>G</p></td>
<td><p>Size of L0 vCPU state. See:
H_GUEST_GET_STATE:
flags = takeOwnershipOfVcpuState</p></td>
</tr>
<tr class="row-even"><td><p>0x0002</p></td>
<td><p>0x08</p></td>
<td><p>R</p></td>
<td><p>G</p></td>
<td><p>Size Run vCPU out buffer</p></td>
</tr>
<tr class="row-odd"><td><p>0x0003</p></td>
<td><p>0x04</p></td>
<td><p>RW</p></td>
<td><p>G</p></td>
<td><p>Logical PVR</p></td>
</tr>
<tr class="row-even"><td><p>0x0004</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>G</p></td>
<td><p>TB Offset (L1 relative)</p></td>
</tr>
<tr class="row-odd"><td><p>0x0005</p></td>
<td><p>0x18</p></td>
<td><p>RW</p></td>
<td><p>G</p></td>
<td><p>Partition scoped page tbl info:</p>
<ul class="simple">
<li><p>0x00 Addr part scope table</p></li>
<li><p>0x08 Num addr bits</p></li>
<li><p>0x10 Size root dir</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>0x0006</p></td>
<td><p>0x10</p></td>
<td><p>RW</p></td>
<td><p>G</p></td>
<td><p>Process Table Information:</p>
<ul class="simple">
<li><p>0x0 Addr proc scope table</p></li>
<li><p>0x8 Table size.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>0x0007-
0x07FF</p></td>
<td></td>
<td></td>
<td></td>
<td><p>Reserved</p></td>
</tr>
<tr class="row-even"><td><p>0x0800</p></td>
<td><p>0x08</p></td>
<td><p>R</p></td>
<td><p>H</p></td>
<td><p>Current usage in bytes of the
L0's Guest Management Space
for an L1-Lpar.</p></td>
</tr>
<tr class="row-odd"><td><p>0x0801</p></td>
<td><p>0x08</p></td>
<td><p>R</p></td>
<td><p>H</p></td>
<td><p>Max bytes available in the
L0's Guest Management Space for
an L1-Lpar</p></td>
</tr>
<tr class="row-even"><td><p>0x0802</p></td>
<td><p>0x08</p></td>
<td><p>R</p></td>
<td><p>H</p></td>
<td><p>Current usage in bytes of the
L0's Guest Page Table Management
Space for an L1-Lpar</p></td>
</tr>
<tr class="row-odd"><td><p>0x0803</p></td>
<td><p>0x08</p></td>
<td><p>R</p></td>
<td><p>H</p></td>
<td><p>Max bytes available in the L0's
Guest Page Table Management
Space for an L1-Lpar</p></td>
</tr>
<tr class="row-even"><td><p>0x0804</p></td>
<td><p>0x08</p></td>
<td><p>R</p></td>
<td><p>H</p></td>
<td><p>Cumulative Reclaimed bytes from
L0 Guest's Page Table Management
Space due to overcommit</p></td>
</tr>
<tr class="row-odd"><td><p>0x0805-
0x0BFF</p></td>
<td></td>
<td></td>
<td></td>
<td><p>Reserved</p></td>
</tr>
<tr class="row-even"><td><p>0x0C00</p></td>
<td><p>0x10</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>Run vCPU Input Buffer:</p>
<ul class="simple">
<li><p>0x0 Addr of buffer</p></li>
<li><p>0x8 Buffer Size.</p></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>0x0C01</p></td>
<td><p>0x10</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>Run vCPU Output Buffer:</p>
<ul class="simple">
<li><p>0x0 Addr of buffer</p></li>
<li><p>0x8 Buffer Size.</p></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>0x0C02</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>vCPU VPA Address</p></td>
</tr>
<tr class="row-odd"><td><p>0x0C03-
0x0FFF</p></td>
<td></td>
<td></td>
<td></td>
<td><p>Reserved</p></td>
</tr>
<tr class="row-even"><td><p>0x1000-
0x101F</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>GPR 0-31</p></td>
</tr>
<tr class="row-odd"><td><p>0x1020</p></td>
<td><p>0x08</p></td>
<td><p>T</p></td>
<td><p>T</p></td>
<td><p>HDEC expiry TB</p></td>
</tr>
<tr class="row-even"><td><p>0x1021</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>NIA</p></td>
</tr>
<tr class="row-odd"><td><p>0x1022</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>MSR</p></td>
</tr>
<tr class="row-even"><td><p>0x1023</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>LR</p></td>
</tr>
<tr class="row-odd"><td><p>0x1024</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>XER</p></td>
</tr>
<tr class="row-even"><td><p>0x1025</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>CTR</p></td>
</tr>
<tr class="row-odd"><td><p>0x1026</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>CFAR</p></td>
</tr>
<tr class="row-even"><td><p>0x1027</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>SRR0</p></td>
</tr>
<tr class="row-odd"><td><p>0x1028</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>SRR1</p></td>
</tr>
<tr class="row-even"><td><p>0x1029</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>DAR</p></td>
</tr>
<tr class="row-odd"><td><p>0x102A</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>DEC expiry TB</p></td>
</tr>
<tr class="row-even"><td><p>0x102B</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>VTB</p></td>
</tr>
<tr class="row-odd"><td><p>0x102C</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>LPCR</p></td>
</tr>
<tr class="row-even"><td><p>0x102D</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>HFSCR</p></td>
</tr>
<tr class="row-odd"><td><p>0x102E</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>FSCR</p></td>
</tr>
<tr class="row-even"><td><p>0x102F</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>FPSCR</p></td>
</tr>
<tr class="row-odd"><td><p>0x1030</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>DAWR0</p></td>
</tr>
<tr class="row-even"><td><p>0x1031</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>DAWR1</p></td>
</tr>
<tr class="row-odd"><td><p>0x1032</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>CIABR</p></td>
</tr>
<tr class="row-even"><td><p>0x1033</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>PURR</p></td>
</tr>
<tr class="row-odd"><td><p>0x1034</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>SPURR</p></td>
</tr>
<tr class="row-even"><td><p>0x1035</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>IC</p></td>
</tr>
<tr class="row-odd"><td><p>0x1036-
0x1039</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>SPRG 0-3</p></td>
</tr>
<tr class="row-even"><td><p>0x103A</p></td>
<td><p>0x08</p></td>
<td><p>W</p></td>
<td><p>T</p></td>
<td><p>PPR</p></td>
</tr>
<tr class="row-odd"><td><p>0x103B
0x103E</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>MMCR 0-3</p></td>
</tr>
<tr class="row-even"><td><p>0x103F</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>MMCRA</p></td>
</tr>
<tr class="row-odd"><td><p>0x1040</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>SIER</p></td>
</tr>
<tr class="row-even"><td><p>0x1041</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>SIER 2</p></td>
</tr>
<tr class="row-odd"><td><p>0x1042</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>SIER 3</p></td>
</tr>
<tr class="row-even"><td><p>0x1043</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>BESCR</p></td>
</tr>
<tr class="row-odd"><td><p>0x1044</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>EBBHR</p></td>
</tr>
<tr class="row-even"><td><p>0x1045</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>EBBRR</p></td>
</tr>
<tr class="row-odd"><td><p>0x1046</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>AMR</p></td>
</tr>
<tr class="row-even"><td><p>0x1047</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>IAMR</p></td>
</tr>
<tr class="row-odd"><td><p>0x1048</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>AMOR</p></td>
</tr>
<tr class="row-even"><td><p>0x1049</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>UAMOR</p></td>
</tr>
<tr class="row-odd"><td><p>0x104A</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>SDAR</p></td>
</tr>
<tr class="row-even"><td><p>0x104B</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>SIAR</p></td>
</tr>
<tr class="row-odd"><td><p>0x104C</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>DSCR</p></td>
</tr>
<tr class="row-even"><td><p>0x104D</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>TAR</p></td>
</tr>
<tr class="row-odd"><td><p>0x104E</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>DEXCR</p></td>
</tr>
<tr class="row-even"><td><p>0x104F</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>HDEXCR</p></td>
</tr>
<tr class="row-odd"><td><p>0x1050</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>HASHKEYR</p></td>
</tr>
<tr class="row-even"><td><p>0x1051</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>HASHPKEYR</p></td>
</tr>
<tr class="row-odd"><td><p>0x1052</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>CTRL</p></td>
</tr>
<tr class="row-even"><td><p>0x1053</p></td>
<td><p>0x08</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>DPDES</p></td>
</tr>
<tr class="row-odd"><td><p>0x1054-
0x1FFF</p></td>
<td></td>
<td></td>
<td></td>
<td><p>Reserved</p></td>
</tr>
<tr class="row-even"><td><p>0x2000</p></td>
<td><p>0x04</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>CR</p></td>
</tr>
<tr class="row-odd"><td><p>0x2001</p></td>
<td><p>0x04</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>PIDR</p></td>
</tr>
<tr class="row-even"><td><p>0x2002</p></td>
<td><p>0x04</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>DSISR</p></td>
</tr>
<tr class="row-odd"><td><p>0x2003</p></td>
<td><p>0x04</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>VSCR</p></td>
</tr>
<tr class="row-even"><td><p>0x2004</p></td>
<td><p>0x04</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>VRSAVE</p></td>
</tr>
<tr class="row-odd"><td><p>0x2005</p></td>
<td><p>0x04</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>DAWRX0</p></td>
</tr>
<tr class="row-even"><td><p>0x2006</p></td>
<td><p>0x04</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>DAWRX1</p></td>
</tr>
<tr class="row-odd"><td><p>0x2007-
0x200c</p></td>
<td><p>0x04</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>PMC 1-6</p></td>
</tr>
<tr class="row-even"><td><p>0x200D</p></td>
<td><p>0x04</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>WORT</p></td>
</tr>
<tr class="row-odd"><td><p>0x200E</p></td>
<td><p>0x04</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>PSPB</p></td>
</tr>
<tr class="row-even"><td><p>0x200F-
0x2FFF</p></td>
<td></td>
<td></td>
<td></td>
<td><p>Reserved</p></td>
</tr>
<tr class="row-odd"><td><p>0x3000-
0x303F</p></td>
<td><p>0x10</p></td>
<td><p>RW</p></td>
<td><p>T</p></td>
<td><p>VSR 0-63</p></td>
</tr>
<tr class="row-even"><td><p>0x3040-
0xEFFF</p></td>
<td></td>
<td></td>
<td></td>
<td><p>Reserved</p></td>
</tr>
<tr class="row-odd"><td><p>0xF000</p></td>
<td><p>0x08</p></td>
<td><p>R</p></td>
<td><p>T</p></td>
<td><p>HDAR</p></td>
</tr>
<tr class="row-even"><td><p>0xF001</p></td>
<td><p>0x04</p></td>
<td><p>R</p></td>
<td><p>T</p></td>
<td><p>HDSISR</p></td>
</tr>
<tr class="row-odd"><td><p>0xF002</p></td>
<td><p>0x04</p></td>
<td><p>R</p></td>
<td><p>T</p></td>
<td><p>HEIR</p></td>
</tr>
<tr class="row-even"><td><p>0xF003</p></td>
<td><p>0x08</p></td>
<td><p>R</p></td>
<td><p>T</p></td>
<td><p>ASDR</p></td>
</tr>
</tbody>
</table>
</section>
<section id="miscellaneous-info">
<h2>Miscellaneous info<a class="headerlink" href="#miscellaneous-info" title="連結到這個標頭">¶</a></h2>
<section id="state-not-in-ptregs-hvregs">
<h3>State not in ptregs/hvregs<a class="headerlink" href="#state-not-in-ptregs-hvregs" title="連結到這個標頭">¶</a></h3>
<p>In the v1 API, some state is not in the ptregs/hvstate. This includes
the vector register and some SPRs. For the L1 to set this state for
the L2, the L1 loads up these hardware registers before the
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">h_enter_nested()</span></code> call and the L0 ensures they end up as the L2 state
(by not touching them).</p>
<p>The v2 API removes this and explicitly sets this state via the GSB.</p>
</section>
<section id="l1-implementation-details-caching-state">
<h3>L1 Implementation details: Caching state<a class="headerlink" href="#l1-implementation-details-caching-state" title="連結到這個標頭">¶</a></h3>
<p>In the v1 API, all state is sent from the L1 to the L0 and vice versa
on every <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">h_enter_nested()</span></code> hcall. If the L0 is not currently running
any L2s, the L0 has no state information about them. The only
exception to this is the location of the partition table, registered
via <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">h_set_partition_table()</span></code>.</p>
<p>The v2 API changes this so that the L0 retains the L2 state even when
it's vCPUs are no longer running. This means that the L1 only needs to
communicate with the L0 about L2 state when it needs to modify the L2
state, or when it's value is out of date. This provides an opportunity
for performance optimisation.</p>
<p>When a vCPU exits from a <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">H_GUEST_RUN_VCPU()</span></code> call, the L1 internally
marks all L2 state as invalid. This means that if the L1 wants to know
the L2 state (say via a <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">kvm_get_one_reg()</span></code> call), it needs call
<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">H_GUEST_GET_STATE()</span></code> to get that state. Once it's read, it's marked as
valid in L1 until the L2 is run again.</p>
<p>Also, when an L1 modifies L2 vcpu state, it doesn't need to write it
to the L0 until that L2 vcpu runs again. Hence when the L1 updates
state (say via a <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">kvm_set_one_reg()</span></code> call), it writes to an internal L1
copy and only flushes this copy to the L0 when the L2 runs again via
the <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">H_GUEST_VCPU_RUN()</span></code> input buffer.</p>
<p>This lazy updating of state by the L1 avoids unnecessary
H_GUEST_{G|S}<code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">ET_STATE()</span></code> calls.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;The kernel development community.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../../_sources/arch/powerpc/kvm-nested.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>