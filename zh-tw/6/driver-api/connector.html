<!DOCTYPE html>

<html lang="zh-TW" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Kernel Connector &#8212; The Linux Kernel unknown version 說明文件</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=adfc0c0d" />
    <script src="../_static/documentation_options.js?v=b446b479"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=cbf116e0"></script>
    <link rel="canonical" href="https://projects.localizethedocs.org/linux-docs-l10n/driver-api/connector.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜尋" href="../search.html" />
    <link rel="next" title="Bus-Independent Device Accesses" href="device-io.html" />
    <link rel="prev" title="initramfs buffer format" href="early-userspace/buffer-format.html" />

   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

<script type="text/javascript" src="../ltd-provenance.js"></script>
<script type="text/javascript" src="../ltd-current.js"></script>
<script type="text/javascript" src="../../../ltd-config.js"></script>
<script type="text/javascript" src="../../../ltd-flyout.js"></script>

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.svg" alt="Logo of The Linux Kernel"/>
            </a></p>
<h1 class="logo"><a href="../index.html">The Linux Kernel</a></h1>



<p class="blurb">6.19.0</p>







<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜尋</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="前往" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>


<p>
<h3 class="kernel-toc-contents">Contents</h3>
<input type="checkbox" class="kernel-toc-toggle" id = "kernel-toc-toggle" checked>
<label class="kernel-toc-title" for="kernel-toc-toggle"></label>

<div class="kerneltoc" id="kerneltoc">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/development-process.html">Development process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/submitting-patches.html">提交補釘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/code-of-conduct.html">行為守則</a></li>
<li class="toctree-l1"><a class="reference internal" href="../maintainer/index.html">維護者手冊</a></li>
<li class="toctree-l1"><a class="reference internal" href="../process/index.html">All development-process docs</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../core-api/index.html">核心 API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Driver APIs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#general-information-for-driver-authors">General information for driver authors</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#useful-support-libraries">Useful support libraries</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="early-userspace/index.html">Early Userspace</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Kernel Connector</a></li>
<li class="toctree-l3"><a class="reference internal" href="device-io.html">Bus-Independent Device Accesses</a></li>
<li class="toctree-l3"><a class="reference internal" href="devfreq.html">Device Frequency Scaling</a></li>
<li class="toctree-l3"><a class="reference internal" href="dma-buf.html">Buffer Sharing and Synchronization (dma-buf)</a></li>
<li class="toctree-l3"><a class="reference internal" href="component.html">Component Helper for Aggregate Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="io-mapping.html">The io_mapping functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="io_ordering.html">Ordering I/O writes to memory-mapped addresses</a></li>
<li class="toctree-l3"><a class="reference internal" href="uio-howto.html">The Userspace I/O HOWTO</a></li>
<li class="toctree-l3"><a class="reference internal" href="vfio-mediated-device.html">VFIO Mediated devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="vfio.html">VFIO - &quot;Virtual Function I/O&quot; </a></li>
<li class="toctree-l3"><a class="reference internal" href="vfio-pci-device-specific-driver-acceptance.html">Acceptance criteria for vfio-pci device specific driver variants</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#bus-level-documentation">Bus-level documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#subsystem-specific-apis">Subsystem-specific APIs</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../subsystem-apis.html">子系統</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../subsystem-apis.html#core-subsystems">Core subsystems</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../core-api/index.html">核心 API 文件</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">Driver implementer's API guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mm/index.html">記憶體管理文件</a></li>
<li class="toctree-l3"><a class="reference internal" href="../power/index.html">電源管理</a></li>
<li class="toctree-l3"><a class="reference internal" href="../scheduler/index.html">Scheduler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../timers/index.html">計時器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#human-interfaces">Human interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#networking-interfaces">Networking interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#storage-interfaces">Storage interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../subsystem-apis.html#other-subsystems">其他子系統</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../locking/index.html">Locking</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../process/license-rules.html">Licensing rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doc-guide/index.html">撰寫文件</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/index.html">開發工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev-tools/testing-overview.html">測試指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kernel-hacking/index.html">Hacking guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trace/index.html">Tracing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault-injection/index.html">Fault injection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../livepatch/index.html">即時補釘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kbuild/index.html">建置系統</a></li>
<li class="toctree-l1"><a class="reference internal" href="../admin-guide/reporting-issues.html">回報議題</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">使用者空間工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../userspace-api/index.html">使用者空間 API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../firmware-guide/index.html">韌體</a></li>
<li class="toctree-l1"><a class="reference internal" href="../devicetree/index.html">韌體與裝置樹</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../arch/index.html">CPU 架構</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../staging/index.html">未排序的文件</a></li>
</ul>

</div>

<script type="text/javascript"> <!--
  var sbar = document.getElementsByClassName("sphinxsidebar")[0];
  let currents = document.getElementsByClassName("current")
  if (currents.length) {
    sbar.scrollTop = currents[currents.length - 1].offsetTop;
  }
  --> </script>
  <div role="note" aria-label="source link">
    <h3>本頁</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/driver-api/connector.rst.txt"
            rel="nofollow">顯示原始碼</a></li>
    </ul>
   </div>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="kernel-connector">
<h1>Kernel Connector<a class="headerlink" href="#kernel-connector" title="連結到這個標頭">¶</a></h1>
<p>Kernel connector - new netlink based userspace &lt;-&gt; kernel space easy
to use communication module.</p>
<p>The Connector driver makes it easy to connect various agents using a
netlink based network.  One must register a callback and an identifier.
When the driver receives a special netlink message with the appropriate
identifier, the appropriate callback will be called.</p>
<p>From the userspace point of view it's quite straightforward:</p>
<blockquote>
<div><ul class="simple">
<li><p>socket();</p></li>
<li><p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">bind()</span></code>;</p></li>
<li><p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">send()</span></code>;</p></li>
<li><p><code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">recv()</span></code>;</p></li>
</ul>
</div></blockquote>
<p>But if kernelspace wants to use the full power of such connections, the
driver writer must create special sockets, must know about <a class="reference internal" href="../networking/kapi.html#c.sk_buff" title="sk_buff"><code class="xref c c-struct docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sk_buff</span></code></a>
handling, etc...  The Connector driver allows any kernelspace agents to use
netlink based networking for inter-process communication in a significantly
easier way:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>int cn_add_callback(const struct cb_id *id, char *name, void (*callback) (struct cn_msg *, struct netlink_skb_parms *));
void cn_netlink_send_mult(struct cn_msg *msg, u16 len, u32 portid, u32 __group, int gfp_mask);
void cn_netlink_send(struct cn_msg *msg, u32 portid, u32 __group, int gfp_mask);

struct cb_id
{
      __u32                   idx;
      __u32                   val;
};
</pre></div>
</div>
<p>idx and val are unique identifiers which must be registered in the
connector.h header for in-kernel usage.  <cite>void (*callback) (void *)</cite> is a
callback function which will be called when a message with above idx.val
is received by the connector core.  The argument for that function must
be dereferenced to <cite><code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cn_msg</span></code> *</cite>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>struct cn_msg
{
      struct cb_id            id;

      __u32                   seq;
      __u32                   ack;

      __u16                   len;    /* Length of the following data */
      __u16                   flags;
      __u8                    data[0];
};
</pre></div>
</div>
<section id="connector-interfaces">
<h2>Connector interfaces<a class="headerlink" href="#connector-interfaces" title="連結到這個標頭">¶</a></h2>
<blockquote>
<div><dl class="c function">
<dt class="sig sig-object c" id="c.cn_add_callback">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cn_add_callback</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cb_id</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">id</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">callback</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cn_msg</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">netlink_skb_parms</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cn_add_callback" title="連結到這個定義">¶</a><br /></dt>
<dd><p>Registers new callback with connector core.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cb_id</span> <span class="pre">*id</span></code></dt><dd><p>unique connector's user identifier.
It must be registered in connector.h for legal
in-kernel users.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*name</span></code></dt><dd><p>connector's callback symbolic name.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*callback)(struct</span> <span class="pre">cn_msg</span> <span class="pre">*,</span> <span class="pre">struct</span> <span class="pre">netlink_skb_parms</span> <span class="pre">*)</span></code></dt><dd><p>connector's callback.
parameters are <code class="docutils literal notranslate"><span class="pre">cn_msg</span></code> and the sender's credentials</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cn_del_callback">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cn_del_callback</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cb_id</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">id</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cn_del_callback" title="連結到這個定義">¶</a><br /></dt>
<dd><p>Unregisters new callback with connector core.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">cb_id</span> <span class="pre">*id</span></code></dt><dd><p>unique connector's user identifier.</p>
</dd>
</dl>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cn_netlink_send_mult">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cn_netlink_send_mult</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cn_msg</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">msg</span></span>, <span class="n"><span class="pre">u16</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">portid</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">group</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span>, <span class="n"><span class="pre">netlink_filter_fn</span></span><span class="w"> </span><span class="n"><span class="pre">filter</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">filter_data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cn_netlink_send_mult" title="連結到這個定義">¶</a><br /></dt>
<dd><p>Sends message to the specified groups.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cn_msg</span> <span class="pre">*msg</span></code></dt><dd><p>message header(with attached data).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u16</span> <span class="pre">len</span></code></dt><dd><p>Number of <strong>msg</strong> to be sent.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">portid</span></code></dt><dd><p>destination port.
If non-zero the message will be sent to the given port,
which should be set to the original sender.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">group</span></code></dt><dd><p>destination group.
If <strong>portid</strong> and <strong>group</strong> is zero, then appropriate group will
be searched through all registered connector users, and
message will be delivered to the group which was created
for user with the same ID as in <strong>msg</strong>.
If <strong>group</strong> is not zero, then message will be delivered
to the specified group.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>GFP mask.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">netlink_filter_fn</span> <span class="pre">filter</span></code></dt><dd><p>Filter function to be used at netlink layer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*filter_data</span></code></dt><dd><p>Filter data to be supplied to the filter function</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It can be safely called from softirq context, but may silently
fail under strong memory pressure.</p>
<p>If there are no listeners for given group <code class="docutils literal notranslate"><span class="pre">-ESRCH</span></code> can be returned.</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.cn_netlink_send">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">cn_netlink_send</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="n"><span class="pre">cn_msg</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">msg</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">portid</span></span>, <span class="n"><span class="pre">u32</span></span><span class="w"> </span><span class="n"><span class="pre">group</span></span>, <span class="n"><span class="pre">gfp_t</span></span><span class="w"> </span><span class="n"><span class="pre">gfp_mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.cn_netlink_send" title="連結到這個定義">¶</a><br /></dt>
<dd><p>Sends message to the specified groups.</p>
</dd></dl>

<div class="kernelindent docutils container">
<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">cn_msg</span> <span class="pre">*msg</span></code></dt><dd><p>message header(with attached data).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">portid</span></code></dt><dd><p>destination port.
If non-zero the message will be sent to the given port,
which should be set to the original sender.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">u32</span> <span class="pre">group</span></code></dt><dd><p>destination group.
If <strong>portid</strong> and <strong>group</strong> is zero, then appropriate group will
be searched through all registered connector users, and
message will be delivered to the group which was created
for user with the same ID as in <strong>msg</strong>.
If <strong>group</strong> is not zero, then message will be delivered
to the specified group.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">gfp_t</span> <span class="pre">gfp_mask</span></code></dt><dd><p>GFP mask.</p>
</dd>
</dl>
<p><strong>Description</strong></p>
<p>It can be safely called from softirq context, but may silently
fail under strong memory pressure.</p>
<p>If there are no listeners for given group <code class="docutils literal notranslate"><span class="pre">-ESRCH</span></code> can be returned.</p>
</div>
<dl class="simple">
<dt>Note:</dt><dd><p>When registering new callback user, connector core assigns
netlink group to the user which is equal to its id.idx.</p>
</dd>
</dl>
</div></blockquote>
</section>
<section id="protocol-description">
<h2>Protocol description<a class="headerlink" href="#protocol-description" title="連結到這個標頭">¶</a></h2>
<p>The current framework offers a transport layer with fixed headers.  The
recommended protocol which uses such a header is as following:</p>
<p>msg-&gt;seq and msg-&gt;ack are used to determine message genealogy.  When
someone sends a message, they use a locally unique sequence and random
acknowledge number.  The sequence number may be copied into
nlmsghdr-&gt;nlmsg_seq too.</p>
<p>The sequence number is incremented with each message sent.</p>
<p>If you expect a reply to the message, then the sequence number in the
received message MUST be the same as in the original message, and the
acknowledge number MUST be the same + 1.</p>
<p>If we receive a message and its sequence number is not equal to one we
are expecting, then it is a new message.  If we receive a message and
its sequence number is the same as one we are expecting, but its
acknowledge is not equal to the sequence number in the original
message + 1, then it is a new message.</p>
<p>Obviously, the protocol header contains the above id.</p>
<p>The connector allows event notification in the following form: kernel
driver or userspace process can ask connector to notify it when
selected ids will be turned on or off (registered or unregistered its
callback).  It is done by sending a special command to the connector
driver (it also registers itself with id={-1, -1}).</p>
<p>As example of this usage can be found in the cn_test.c module which
uses the connector to request notification and to send messages.</p>
</section>
<section id="reliability">
<h2>Reliability<a class="headerlink" href="#reliability" title="連結到這個標頭">¶</a></h2>
<p>Netlink itself is not a reliable protocol.  That means that messages can
be lost due to memory pressure or process' receiving queue overflowed,
so caller is warned that it must be prepared.  That is why the <code class="xref c c-struct broken_xref docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">cn_msg</span></code> [main connector's message header] contains u32 seq and u32 ack
fields.</p>
</section>
<section id="userspace-usage">
<h2>Userspace usage<a class="headerlink" href="#userspace-usage" title="連結到這個標頭">¶</a></h2>
<p>2.6.14 has a new netlink socket implementation, which by default does not
allow people to send data to netlink groups other than 1.
So, if you wish to use a netlink socket (for example using connector)
with a different group number, the userspace application must subscribe to
that group first.  It can be achieved by the following pseudocode:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR);

l_local.nl_family = AF_NETLINK;
l_local.nl_groups = 12345;
l_local.nl_pid = 0;

if (bind(s, (struct sockaddr *)&amp;l_local, sizeof(struct sockaddr_nl)) == -1) {
      perror(&quot;bind&quot;);
      close(s);
      return -1;
}

{
      int on = l_local.nl_groups;
      setsockopt(s, 270, 1, &amp;on, sizeof(on));
}
</pre></div>
</div>
<p>Where 270 above is SOL_NETLINK, and 1 is a NETLINK_ADD_MEMBERSHIP socket
option.  To drop a multicast subscription, one should call the above socket
option with the NETLINK_DROP_MEMBERSHIP parameter which is defined as 0.</p>
<p>2.6.14 netlink code only allows to select a group which is less or equal to
the maximum group number, which is used at <code class="xref c c-func broken_xref docutils literal notranslate"><span class="pre">netlink_kernel_create()</span></code> time.
In case of connector it is CN_NETLINK_USERS + 0xf, so if you want to use
group number 12345, you must increment CN_NETLINK_USERS to that number.
Additional 0xf numbers are allocated to be used by non-in-kernel users.</p>
<p>Due to this limitation, group 0xffffffff does not work now, so one can
not use add/remove connector's group notifications, but as far as I know,
only cn_test.c test module used it.</p>
<p>Some work in netlink area is still being done, so things can be changed in
2.6.15 timeframe, if it will happen, documentation will be updated for that
kernel.</p>
</section>
<section id="code-samples">
<h2>Code samples<a class="headerlink" href="#code-samples" title="連結到這個標頭">¶</a></h2>
<p>Sample code for a connector test module and user space can be found
in samples/connector/. To build this code, enable CONFIG_CONNECTOR
and CONFIG_SAMPLES.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;The kernel development community.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/driver-api/connector.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>