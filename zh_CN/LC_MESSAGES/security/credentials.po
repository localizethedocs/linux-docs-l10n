# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../security/credentials.rst:3
msgid "Credentials in Linux"
msgstr ""

#: ../../../security/credentials.rst:5
msgid "By: David Howells <dhowells@redhat.com>"
msgstr ""

#: ../../../security/credentials.rst:10
msgid "Overview"
msgstr ""

#: ../../../security/credentials.rst:12
msgid ""
"There are several parts to the security check performed by Linux when one "
"object acts upon another:"
msgstr ""

#: ../../../security/credentials.rst:15
msgid "Objects."
msgstr ""

#: ../../../security/credentials.rst:17
msgid ""
"Objects are things in the system that may be acted upon directly by "
"userspace programs.  Linux has a variety of actionable objects, including:"
msgstr ""

#: ../../../security/credentials.rst:20
msgid "Tasks"
msgstr ""

#: ../../../security/credentials.rst:21
msgid "Files/inodes"
msgstr ""

#: ../../../security/credentials.rst:22
msgid "Sockets"
msgstr ""

#: ../../../security/credentials.rst:23
msgid "Message queues"
msgstr ""

#: ../../../security/credentials.rst:24
msgid "Shared memory segments"
msgstr ""

#: ../../../security/credentials.rst:25
msgid "Semaphores"
msgstr ""

#: ../../../security/credentials.rst:26
msgid "Keys"
msgstr ""

#: ../../../security/credentials.rst:28
msgid ""
"As a part of the description of all these objects there is a set of "
"credentials.  What's in the set depends on the type of object."
msgstr ""

#: ../../../security/credentials.rst:31
msgid "Object ownership."
msgstr ""

#: ../../../security/credentials.rst:33
msgid ""
"Amongst the credentials of most objects, there will be a subset that "
"indicates the ownership of that object.  This is used for resource "
"accounting and limitation (disk quotas and task rlimits for example)."
msgstr ""

#: ../../../security/credentials.rst:37
msgid ""
"In a standard UNIX filesystem, for instance, this will be defined by the UID "
"marked on the inode."
msgstr ""

#: ../../../security/credentials.rst:40
msgid "The objective context."
msgstr ""

#: ../../../security/credentials.rst:42
msgid ""
"Also amongst the credentials of those objects, there will be a subset that "
"indicates the 'objective context' of that object.  This may or may not be "
"the same set as in (2) - in standard UNIX files, for instance, this is the "
"defined by the UID and the GID marked on the inode."
msgstr ""

#: ../../../security/credentials.rst:47
msgid ""
"The objective context is used as part of the security calculation that is "
"carried out when an object is acted upon."
msgstr ""

#: ../../../security/credentials.rst:50
msgid "Subjects."
msgstr ""

#: ../../../security/credentials.rst:52
msgid "A subject is an object that is acting upon another object."
msgstr ""

#: ../../../security/credentials.rst:54
msgid ""
"Most of the objects in the system are inactive: they don't act on other "
"objects within the system.  Processes/tasks are the obvious exception: they "
"do stuff; they access and manipulate things."
msgstr ""

#: ../../../security/credentials.rst:58
msgid ""
"Objects other than tasks may under some circumstances also be subjects. For "
"instance an open file may send SIGIO to a task using the UID and EUID given "
"to it by a task that called ``fcntl(F_SETOWN)`` upon it.  In this case, the "
"file struct will have a subjective context too."
msgstr ""

#: ../../../security/credentials.rst:63
msgid "The subjective context."
msgstr ""

#: ../../../security/credentials.rst:65
msgid ""
"A subject has an additional interpretation of its credentials.  A subset of "
"its credentials forms the 'subjective context'.  The subjective context is "
"used as part of the security calculation that is carried out when a subject "
"acts."
msgstr ""

#: ../../../security/credentials.rst:70
msgid ""
"A Linux task, for example, has the FSUID, FSGID and the supplementary group "
"list for when it is acting upon a file - which are quite separate from the "
"real UID and GID that normally form the objective context of the task."
msgstr ""

#: ../../../security/credentials.rst:75
msgid "Actions."
msgstr ""

#: ../../../security/credentials.rst:77
msgid ""
"Linux has a number of actions available that a subject may perform upon an "
"object.  The set of actions available depends on the nature of the subject "
"and the object."
msgstr ""

#: ../../../security/credentials.rst:81
msgid ""
"Actions include reading, writing, creating and deleting files; forking or "
"signalling and tracing tasks."
msgstr ""

#: ../../../security/credentials.rst:84
msgid "Rules, access control lists and security calculations."
msgstr ""

#: ../../../security/credentials.rst:86
msgid ""
"When a subject acts upon an object, a security calculation is made.  This "
"involves taking the subjective context, the objective context and the "
"action, and searching one or more sets of rules to see whether the subject "
"is granted or denied permission to act in the desired manner on the object, "
"given those contexts."
msgstr ""

#: ../../../security/credentials.rst:92
msgid "There are two main sources of rules:"
msgstr ""

#: ../../../security/credentials.rst:94
msgid "Discretionary access control (DAC):"
msgstr ""

#: ../../../security/credentials.rst:96
msgid ""
"Sometimes the object will include sets of rules as part of its description.  "
"This is an 'Access Control List' or 'ACL'.  A Linux file may supply more "
"than one ACL."
msgstr ""

#: ../../../security/credentials.rst:100
msgid ""
"A traditional UNIX file, for example, includes a permissions mask that is an "
"abbreviated ACL with three fixed classes of subject ('user', 'group' and "
"'other'), each of which may be granted certain privileges ('read', 'write' "
"and 'execute' - whatever those map to for the object in question).  UNIX "
"file permissions do not allow the arbitrary specification of subjects, "
"however, and so are of limited use."
msgstr ""

#: ../../../security/credentials.rst:107
msgid ""
"A Linux file might also sport a POSIX ACL.  This is a list of rules that "
"grants various permissions to arbitrary subjects."
msgstr ""

#: ../../../security/credentials.rst:110
msgid "Mandatory access control (MAC):"
msgstr ""

#: ../../../security/credentials.rst:112
msgid ""
"The system as a whole may have one or more sets of rules that get applied to "
"all subjects and objects, regardless of their source. SELinux and Smack are "
"examples of this."
msgstr ""

#: ../../../security/credentials.rst:116
msgid ""
"In the case of SELinux and Smack, each object is given a label as part of "
"its credentials.  When an action is requested, they take the subject label, "
"the object label and the action and look for a rule that says that this "
"action is either granted or denied."
msgstr ""

#: ../../../security/credentials.rst:123
msgid "Types of Credentials"
msgstr ""

#: ../../../security/credentials.rst:125
msgid "The Linux kernel supports the following types of credentials:"
msgstr ""

#: ../../../security/credentials.rst:127
msgid "Traditional UNIX credentials."
msgstr ""

#: ../../../security/credentials.rst:129
msgid "Real User ID"
msgstr ""

#: ../../../security/credentials.rst:130
msgid "Real Group ID"
msgstr ""

#: ../../../security/credentials.rst:132
msgid ""
"The UID and GID are carried by most, if not all, Linux objects, even if in "
"some cases it has to be invented (FAT or CIFS files for example, which are "
"derived from Windows).  These (mostly) define the objective context of that "
"object, with tasks being slightly different in some cases."
msgstr ""

#: ../../../security/credentials.rst:137
msgid "Effective, Saved and FS User ID"
msgstr ""

#: ../../../security/credentials.rst:138
msgid "Effective, Saved and FS Group ID"
msgstr ""

#: ../../../security/credentials.rst:139
msgid "Supplementary groups"
msgstr ""

#: ../../../security/credentials.rst:141
msgid ""
"These are additional credentials used by tasks only.  Usually, an EUID/EGID/"
"GROUPS will be used as the subjective context, and real UID/GID will be used "
"as the objective.  For tasks, it should be noted that this is not always "
"true."
msgstr ""

#: ../../../security/credentials.rst:146
msgid "Capabilities."
msgstr ""

#: ../../../security/credentials.rst:148
msgid "Set of permitted capabilities"
msgstr ""

#: ../../../security/credentials.rst:149
msgid "Set of inheritable capabilities"
msgstr ""

#: ../../../security/credentials.rst:150
msgid "Set of effective capabilities"
msgstr ""

#: ../../../security/credentials.rst:151
msgid "Capability bounding set"
msgstr ""

#: ../../../security/credentials.rst:153
msgid ""
"These are only carried by tasks.  They indicate superior capabilities "
"granted piecemeal to a task that an ordinary task wouldn't otherwise have. "
"These are manipulated implicitly by changes to the traditional UNIX "
"credentials, but can also be manipulated directly by the ``capset()`` system "
"call."
msgstr ""

#: ../../../security/credentials.rst:159
msgid ""
"The permitted capabilities are those caps that the process might grant "
"itself to its effective or permitted sets through ``capset()``.  This "
"inheritable set might also be so constrained."
msgstr ""

#: ../../../security/credentials.rst:163
msgid ""
"The effective capabilities are the ones that a task is actually allowed to "
"make use of itself."
msgstr ""

#: ../../../security/credentials.rst:166
msgid ""
"The inheritable capabilities are the ones that may get passed across "
"``execve()``."
msgstr ""

#: ../../../security/credentials.rst:169
msgid ""
"The bounding set limits the capabilities that may be inherited across "
"``execve()``, especially when a binary is executed that will execute as UID "
"0."
msgstr ""

#: ../../../security/credentials.rst:173
msgid "Secure management flags (securebits)."
msgstr ""

#: ../../../security/credentials.rst:175
msgid ""
"These are only carried by tasks.  These govern the way the above credentials "
"are manipulated and inherited over certain operations such as execve().  "
"They aren't used directly as objective or subjective credentials."
msgstr ""

#: ../../../security/credentials.rst:180
msgid "Keys and keyrings."
msgstr ""

#: ../../../security/credentials.rst:182
msgid ""
"These are only carried by tasks.  They carry and cache security tokens that "
"don't fit into the other standard UNIX credentials.  They are for making "
"such things as network filesystem keys available to the file accesses "
"performed by processes, without the necessity of ordinary programs having to "
"know about security details involved."
msgstr ""

#: ../../../security/credentials.rst:188
msgid ""
"Keyrings are a special type of key.  They carry sets of other keys and can "
"be searched for the desired key.  Each process may subscribe to a number of "
"keyrings:"
msgstr ""

#: ../../../security/credentials.rst:192
msgid "Per-thread keying Per-process keyring Per-session keyring"
msgstr ""

#: ../../../security/credentials.rst:196
msgid ""
"When a process accesses a key, if not already present, it will normally be "
"cached on one of these keyrings for future accesses to find."
msgstr ""

#: ../../../security/credentials.rst:199
msgid ""
"For more information on using keys, see ``Documentation/security/keys/*``."
msgstr ""

#: ../../../security/credentials.rst:201
msgid "LSM"
msgstr ""

#: ../../../security/credentials.rst:203
msgid ""
"The Linux Security Module allows extra controls to be placed over the "
"operations that a task may do.  Currently Linux supports several LSM options."
msgstr ""

#: ../../../security/credentials.rst:207
msgid ""
"Some work by labelling the objects in a system and then applying sets of "
"rules (policies) that say what operations a task with one label may do to an "
"object with another label."
msgstr ""

#: ../../../security/credentials.rst:211
msgid "AF_KEY"
msgstr ""

#: ../../../security/credentials.rst:213
msgid ""
"This is a socket-based approach to credential management for networking "
"stacks [RFC 2367].  It isn't discussed by this document as it doesn't "
"interact directly with task and file credentials; rather it keeps system "
"level credentials."
msgstr ""

#: ../../../security/credentials.rst:219
msgid ""
"When a file is opened, part of the opening task's subjective context is "
"recorded in the file struct created.  This allows operations using that file "
"struct to use those credentials instead of the subjective context of the "
"task that issued the operation.  An example of this would be a file opened "
"on a network filesystem where the credentials of the opened file should be "
"presented to the server, regardless of who is actually doing a read or a "
"write upon it."
msgstr ""

#: ../../../security/credentials.rst:228
msgid "File Markings"
msgstr ""

#: ../../../security/credentials.rst:230
msgid ""
"Files on disk or obtained over the network may have annotations that form "
"the objective security context of that file.  Depending on the type of "
"filesystem, this may include one or more of the following:"
msgstr ""

#: ../../../security/credentials.rst:234
msgid "UNIX UID, GID, mode;"
msgstr ""

#: ../../../security/credentials.rst:235
msgid "Windows user ID;"
msgstr ""

#: ../../../security/credentials.rst:236
msgid "Access control list;"
msgstr ""

#: ../../../security/credentials.rst:237
msgid "LSM security label;"
msgstr ""

#: ../../../security/credentials.rst:238
msgid "UNIX exec privilege escalation bits (SUID/SGID);"
msgstr ""

#: ../../../security/credentials.rst:239
msgid "File capabilities exec privilege escalation bits."
msgstr ""

#: ../../../security/credentials.rst:241
msgid ""
"These are compared to the task's subjective security context, and certain "
"operations allowed or disallowed as a result.  In the case of execve(), the "
"privilege escalation bits come into play, and may allow the resulting "
"process extra privileges, based on the annotations on the executable file."
msgstr ""

#: ../../../security/credentials.rst:248
msgid "Task Credentials"
msgstr ""

#: ../../../security/credentials.rst:250
msgid ""
"In Linux, all of a task's credentials are held in (uid, gid) or through "
"(groups, keys, LSM security) a refcounted structure of type 'struct cred'. "
"Each task points to its credentials by a pointer called 'cred' in its "
"task_struct."
msgstr ""

#: ../../../security/credentials.rst:255
msgid ""
"Once a set of credentials has been prepared and committed, it may not be "
"changed, barring the following exceptions:"
msgstr ""

#: ../../../security/credentials.rst:258
msgid "its reference count may be changed;"
msgstr ""

#: ../../../security/credentials.rst:260
msgid ""
"the reference count on the group_info struct it points to may be changed;"
msgstr ""

#: ../../../security/credentials.rst:262
msgid "the reference count on the security data it points to may be changed;"
msgstr ""

#: ../../../security/credentials.rst:264
msgid "the reference count on any keyrings it points to may be changed;"
msgstr ""

#: ../../../security/credentials.rst:266
msgid ""
"any keyrings it points to may be revoked, expired or have their security "
"attributes changed; and"
msgstr ""

#: ../../../security/credentials.rst:269
msgid ""
"the contents of any keyrings to which it points may be changed (the whole "
"point of keyrings being a shared set of credentials, modifiable by anyone "
"with appropriate access)."
msgstr ""

#: ../../../security/credentials.rst:273
msgid ""
"To alter anything in the cred struct, the copy-and-replace principle must be "
"adhered to.  First take a copy, then alter the copy and then use RCU to "
"change the task pointer to make it point to the new copy.  There are "
"wrappers to aid with this (see below)."
msgstr ""

#: ../../../security/credentials.rst:278
msgid ""
"A task may only alter its _own_ credentials; it is no longer permitted for a "
"task to alter another's credentials.  This means the ``capset()`` system "
"call is no longer permitted to take any PID other than the one of the "
"current process. Also ``keyctl_instantiate()`` and ``keyctl_negate()`` "
"functions no longer permit attachment to process-specific keyrings in the "
"requesting process as the instantiating process may need to create them."
msgstr ""

#: ../../../security/credentials.rst:287
msgid "Immutable Credentials"
msgstr ""

#: ../../../security/credentials.rst:289
msgid ""
"Once a set of credentials has been made public (by calling "
"``commit_creds()`` for example), it must be considered immutable, barring "
"two exceptions:"
msgstr ""

#: ../../../security/credentials.rst:292
msgid "The reference count may be altered."
msgstr ""

#: ../../../security/credentials.rst:294
msgid ""
"While the keyring subscriptions of a set of credentials may not be changed, "
"the keyrings subscribed to may have their contents altered."
msgstr ""

#: ../../../security/credentials.rst:297
msgid ""
"To catch accidental credential alteration at compile time, struct "
"task_struct has _const_ pointers to its credential sets, as does struct "
"file.  Furthermore, certain functions such as ``get_cred()`` and "
"``put_cred()`` operate on const pointers, thus rendering casts unnecessary, "
"but require to temporarily ditch the const qualification to be able to alter "
"the reference count."
msgstr ""

#: ../../../security/credentials.rst:305
msgid "Accessing Task Credentials"
msgstr ""

#: ../../../security/credentials.rst:307
msgid ""
"A task being able to alter only its own credentials permits the current "
"process to read or replace its own credentials without the need for any form "
"of locking -- which simplifies things greatly.  It can just call::"
msgstr ""

#: ../../../security/credentials.rst:313
msgid ""
"to get a pointer to its credentials structure, and it doesn't have to "
"release it afterwards."
msgstr ""

#: ../../../security/credentials.rst:316
msgid ""
"There are convenience wrappers for retrieving specific aspects of a task's "
"credentials (the value is simply returned in each case)::"
msgstr ""

#: ../../../security/credentials.rst:328
msgid ""
"There are also convenience wrappers for retrieving specific associated pairs "
"of a task's credentials::"
msgstr ""

#: ../../../security/credentials.rst:335
msgid ""
"which return these pairs of values through their arguments after retrieving "
"them from the current task's credentials."
msgstr ""

#: ../../../security/credentials.rst:339
msgid ""
"In addition, there is a function for obtaining a reference on the current "
"process's current set of credentials::"
msgstr ""

#: ../../../security/credentials.rst:344
msgid ""
"and functions for getting references to one of the credentials that don't "
"actually live in struct cred::"
msgstr ""

#: ../../../security/credentials.rst:350
msgid ""
"which get references to the current process's user accounting structure and "
"supplementary groups list respectively."
msgstr ""

#: ../../../security/credentials.rst:353
msgid ""
"Once a reference has been obtained, it must be released with ``put_cred()``, "
"``free_uid()`` or ``put_group_info()`` as appropriate."
msgstr ""

#: ../../../security/credentials.rst:358
msgid "Accessing Another Task's Credentials"
msgstr ""

#: ../../../security/credentials.rst:360
msgid ""
"While a task may access its own credentials without the need for locking, "
"the same is not true of a task wanting to access another task's "
"credentials.  It must use the RCU read lock and ``rcu_dereference()``."
msgstr ""

#: ../../../security/credentials.rst:364
msgid "The ``rcu_dereference()`` is wrapped by::"
msgstr ""

#: ../../../security/credentials.rst:368
msgid ""
"This should be used inside the RCU read lock, as in the following example::"
msgstr ""

#: ../../../security/credentials.rst:383
msgid ""
"Should it be necessary to hold another task's credentials for a long period "
"of time, and possibly to sleep while doing so, then the caller should get a "
"reference on them using::"
msgstr ""

#: ../../../security/credentials.rst:389
msgid ""
"This does all the RCU magic inside of it.  The caller must call put_cred() "
"on the credentials so obtained when they're finished with."
msgstr ""

#: ../../../security/credentials.rst:393
msgid ""
"The result of ``__task_cred()`` should not be passed directly to "
"``get_cred()`` as this may race with ``commit_cred()``."
msgstr ""

#: ../../../security/credentials.rst:396
msgid ""
"There are a couple of convenience functions to access bits of another task's "
"credentials, hiding the RCU magic from the caller::"
msgstr ""

#: ../../../security/credentials.rst:402
msgid "If the caller is holding the RCU read lock at the time anyway, then::"
msgstr ""

#: ../../../security/credentials.rst:407
msgid ""
"should be used instead.  Similarly, if multiple aspects of a task's "
"credentials need to be accessed, RCU read lock should be used, "
"``__task_cred()`` called, the result stored in a temporary pointer and then "
"the credential aspects called from that before dropping the lock.  This "
"prevents the potentially expensive RCU magic from being invoked multiple "
"times."
msgstr ""

#: ../../../security/credentials.rst:413
msgid ""
"Should some other single aspect of another task's credentials need to be "
"accessed, then this can be used::"
msgstr ""

#: ../../../security/credentials.rst:418
msgid ""
"where 'member' is a non-pointer member of the cred struct.  For instance::"
msgstr ""

#: ../../../security/credentials.rst:422
msgid ""
"will retrieve 'struct cred::suid' from the task, doing the appropriate RCU "
"magic.  This may not be used for pointer members as what they point to may "
"disappear the moment the RCU read lock is dropped."
msgstr ""

#: ../../../security/credentials.rst:428
msgid "Altering Credentials"
msgstr ""

#: ../../../security/credentials.rst:430
msgid ""
"As previously mentioned, a task may only alter its own credentials, and may "
"not alter those of another task.  This means that it doesn't need to use any "
"locking to alter its own credentials."
msgstr ""

#: ../../../security/credentials.rst:434
msgid ""
"To alter the current process's credentials, a function should first prepare "
"a new set of credentials by calling::"
msgstr ""

#: ../../../security/credentials.rst:439
msgid ""
"this locks current->cred_replace_mutex and then allocates and constructs a "
"duplicate of the current process's credentials, returning with the mutex "
"still held if successful.  It returns NULL if not successful (out of memory)."
msgstr ""

#: ../../../security/credentials.rst:443
msgid ""
"The mutex prevents ``ptrace()`` from altering the ptrace state of a process "
"while security checks on credentials construction and changing is taking "
"place as the ptrace state may alter the outcome, particularly in the case of "
"``execve()``."
msgstr ""

#: ../../../security/credentials.rst:448
msgid ""
"The new credentials set should be altered appropriately, and any security "
"checks and hooks done.  Both the current and the proposed sets of "
"credentials are available for this purpose as current_cred() will return the "
"current set still at this point."
msgstr ""

#: ../../../security/credentials.rst:453
msgid ""
"When replacing the group list, the new list must be sorted before it is "
"added to the credential, as a binary search is used to test for membership.  "
"In practice, this means groups_sort() should be called before set_groups() "
"or set_current_groups(). groups_sort() must not be called on a ``struct "
"group_list`` which is shared as it may permute elements as part of the "
"sorting process even if the array is already sorted."
msgstr ""

#: ../../../security/credentials.rst:461
msgid ""
"When the credential set is ready, it should be committed to the current "
"process by calling::"
msgstr ""

#: ../../../security/credentials.rst:466
msgid ""
"This will alter various aspects of the credentials and the process, giving "
"the LSM a chance to do likewise, then it will use ``rcu_assign_pointer()`` "
"to actually commit the new credentials to ``current->cred``, it will release "
"``current->cred_replace_mutex`` to allow ``ptrace()`` to take place, and it "
"will notify the scheduler and others of the changes."
msgstr ""

#: ../../../security/credentials.rst:472
msgid ""
"This function is guaranteed to return 0, so that it can be tail-called at "
"the end of such functions as ``sys_setresuid()``."
msgstr ""

#: ../../../security/credentials.rst:475
msgid ""
"Note that this function consumes the caller's reference to the new "
"credentials. The caller should _not_ call ``put_cred()`` on the new "
"credentials afterwards."
msgstr ""

#: ../../../security/credentials.rst:478
msgid ""
"Furthermore, once this function has been called on a new set of credentials, "
"those credentials may _not_ be changed further."
msgstr ""

#: ../../../security/credentials.rst:482
msgid ""
"Should the security checks fail or some other error occur after "
"``prepare_creds()`` has been called, then the following function should be "
"invoked::"
msgstr ""

#: ../../../security/credentials.rst:488
msgid ""
"This releases the lock on ``current->cred_replace_mutex`` that "
"``prepare_creds()`` got and then releases the new credentials."
msgstr ""

#: ../../../security/credentials.rst:492
msgid ""
"A typical credentials alteration function would look something like this::"
msgstr ""

#: ../../../security/credentials.rst:515
msgid "Managing Credentials"
msgstr ""

#: ../../../security/credentials.rst:517
msgid "There are some functions to help manage credentials:"
msgstr ""

#: ../../../security/credentials.rst:519
msgid "``void put_cred(const struct cred *cred);``"
msgstr ""

#: ../../../security/credentials.rst:521
msgid ""
"This releases a reference to the given set of credentials.  If the reference "
"count reaches zero, the credentials will be scheduled for destruction by the "
"RCU system."
msgstr ""

#: ../../../security/credentials.rst:525
msgid "``const struct cred *get_cred(const struct cred *cred);``"
msgstr ""

#: ../../../security/credentials.rst:527
msgid ""
"This gets a reference on a live set of credentials, returning a pointer to "
"that set of credentials."
msgstr ""

#: ../../../security/credentials.rst:532
msgid "Open File Credentials"
msgstr ""

#: ../../../security/credentials.rst:534
msgid ""
"When a new file is opened, a reference is obtained on the opening task's "
"credentials and this is attached to the file struct as ``f_cred`` in place "
"of ``f_uid`` and ``f_gid``.  Code that used to access ``file->f_uid`` and "
"``file->f_gid`` should now access ``file->f_cred->fsuid`` and ``file->f_cred-"
">fsgid``."
msgstr ""

#: ../../../security/credentials.rst:540
msgid ""
"It is safe to access ``f_cred`` without the use of RCU or locking because "
"the pointer will not change over the lifetime of the file struct, and nor "
"will the contents of the cred struct pointed to, barring the exceptions "
"listed above (see the Task Credentials section)."
msgstr ""

#: ../../../security/credentials.rst:545
msgid ""
"To avoid \"confused deputy\" privilege escalation attacks, access control "
"checks during subsequent operations on an opened file should use these "
"credentials instead of \"current\"'s credentials, as the file may have been "
"passed to a more privileged process."
msgstr ""

#: ../../../security/credentials.rst:551
msgid "Overriding the VFS's Use of Credentials"
msgstr ""

#: ../../../security/credentials.rst:553
msgid ""
"Under some circumstances it is desirable to override the credentials used by "
"the VFS, and that can be done by calling into such as ``vfs_mkdir()`` with a "
"different set of credentials.  This is done in the following places:"
msgstr ""

#: ../../../security/credentials.rst:557
msgid "``sys_faccessat()``."
msgstr ""

#: ../../../security/credentials.rst:558
msgid "``vfs_coredump()``."
msgstr ""

#: ../../../security/credentials.rst:559
msgid "nfs4recover.c."
msgstr ""
