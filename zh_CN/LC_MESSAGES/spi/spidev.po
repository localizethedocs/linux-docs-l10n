# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../spi/spidev.rst:3
msgid "SPI userspace API"
msgstr ""

#: ../../../spi/spidev.rst:5
msgid ""
"SPI devices have a limited userspace API, supporting basic half-duplex "
"read() and write() access to SPI slave devices.  Using ioctl() requests, "
"full duplex transfers and device I/O configuration are also available."
msgstr ""

#: ../../../spi/spidev.rst:17
msgid "Some reasons you might want to use this programming interface include:"
msgstr ""

#: ../../../spi/spidev.rst:19
msgid ""
"Prototyping in an environment that's not crash-prone; stray pointers in "
"userspace won't normally bring down any Linux system."
msgstr ""

#: ../../../spi/spidev.rst:22
msgid ""
"Developing simple protocols used to talk to microcontrollers acting as SPI "
"slaves, which you may need to change quite often."
msgstr ""

#: ../../../spi/spidev.rst:25
msgid ""
"Of course there are drivers that can never be written in userspace, because "
"they need to access kernel interfaces (such as IRQ handlers or other layers "
"of the driver stack) that are not accessible to userspace."
msgstr ""

#: ../../../spi/spidev.rst:31
msgid "DEVICE CREATION, DRIVER BINDING"
msgstr ""

#: ../../../spi/spidev.rst:33
msgid ""
"The spidev driver contains lists of SPI devices that are supported for the "
"different hardware topology representations."
msgstr ""

#: ../../../spi/spidev.rst:36
msgid "The following are the SPI device tables supported by the spidev driver:"
msgstr ""

#: ../../../spi/spidev.rst:38
msgid ""
"struct spi_device_id spidev_spi_ids[]: list of devices that can be bound "
"when these are defined using a struct spi_board_info with a .modalias field "
"matching one of the entries in the table."
msgstr ""

#: ../../../spi/spidev.rst:42
msgid ""
"struct of_device_id spidev_dt_ids[]: list of devices that can be bound when "
"these are defined using a Device Tree node that has a compatible string "
"matching one of the entries in the table."
msgstr ""

#: ../../../spi/spidev.rst:46
msgid ""
"struct acpi_device_id spidev_acpi_ids[]: list of devices that can be bound "
"when these are defined using a ACPI device object with a _HID matching one "
"of the entries in the table."
msgstr ""

#: ../../../spi/spidev.rst:50
msgid ""
"You are encouraged to add an entry for your SPI device name to relevant "
"tables, if these don't already have an entry for the device. To do that, "
"post a patch for spidev to the linux-spi@vger.kernel.org mailing list."
msgstr ""

#: ../../../spi/spidev.rst:54
msgid ""
"It used to be supported to define an SPI device using the \"spidev\" name. "
"For example, as .modalias = \"spidev\" or compatible = \"spidev\".  But this "
"is no longer supported by the Linux kernel and instead a real SPI device "
"name as listed in one of the tables must be used."
msgstr ""

#: ../../../spi/spidev.rst:59
msgid ""
"Not having a real SPI device name will lead to an error being printed and "
"the spidev driver failing to probe."
msgstr ""

#: ../../../spi/spidev.rst:62
msgid ""
"Sysfs also supports userspace driven binding/unbinding of drivers to devices "
"that do not bind automatically using one of the tables above. To make the "
"spidev driver bind to such a device, use the following::"
msgstr ""

#: ../../../spi/spidev.rst:69
msgid ""
"When the spidev driver is bound to a SPI device, the sysfs node for the "
"device will include a child device node with a \"dev\" attribute that will "
"be understood by udev or mdev (udev replacement from BusyBox; it's less "
"featureful, but often enough)."
msgstr ""

#: ../../../spi/spidev.rst:74
msgid "For a SPI device with chipselect C on bus B, you should see:"
msgstr ""

#: ../../../spi/spidev.rst:76
msgid "/dev/spidevB.C ..."
msgstr ""

#: ../../../spi/spidev.rst:77
msgid ""
"character special device, major number 153 with a dynamically chosen minor "
"device number.  This is the node that userspace programs will open, created "
"by \"udev\" or \"mdev\"."
msgstr ""

#: ../../../spi/spidev.rst:81
msgid "/sys/devices/.../spiB.C ..."
msgstr ""

#: ../../../spi/spidev.rst:82
msgid ""
"as usual, the SPI device node will be a child of its SPI master controller."
msgstr ""

#: ../../../spi/spidev.rst:85
msgid "/sys/class/spidev/spidevB.C ..."
msgstr ""

#: ../../../spi/spidev.rst:86
msgid ""
"created when the \"spidev\" driver binds to that device.  (Directory or "
"symlink, based on whether or not you enabled the \"deprecated sysfs files\" "
"Kconfig option.)"
msgstr ""

#: ../../../spi/spidev.rst:90
msgid ""
"Do not try to manage the /dev character device special file nodes by hand. "
"That's error prone, and you'd need to pay careful attention to system "
"security issues; udev/mdev should already be configured securely."
msgstr ""

#: ../../../spi/spidev.rst:94
msgid ""
"If you unbind the \"spidev\" driver from that device, those two \"spidev\" "
"nodes (in sysfs and in /dev) should automatically be removed (respectively "
"by the kernel and by udev/mdev).  You can unbind by removing the \"spidev\" "
"driver module, which will affect all devices using this driver.  You can "
"also unbind by having kernel code remove the SPI device, probably by "
"removing the driver for its SPI controller (so its spi_master vanishes)."
msgstr ""

#: ../../../spi/spidev.rst:101
msgid ""
"Since this is a standard Linux device driver -- even though it just happens "
"to expose a low level API to userspace -- it can be associated with any "
"number of devices at a time.  Just provide one spi_board_info record for "
"each such SPI device, and you'll get a /dev device node for each device."
msgstr ""

#: ../../../spi/spidev.rst:108
msgid "BASIC CHARACTER DEVICE API"
msgstr ""

#: ../../../spi/spidev.rst:109
msgid ""
"Normal open() and close() operations on /dev/spidevB.D files work as you "
"would expect."
msgstr ""

#: ../../../spi/spidev.rst:112
msgid ""
"Standard read() and write() operations are obviously only half-duplex, and "
"the chipselect is deactivated between those operations.  Full-duplex access, "
"and composite operation without chipselect de-activation, is available using "
"the SPI_IOC_MESSAGE(N) request."
msgstr ""

#: ../../../spi/spidev.rst:117
msgid ""
"Several ioctl() requests let your driver read or override the device's "
"current settings for data transfer parameters:"
msgstr ""

#: ../../../spi/spidev.rst:120
msgid "SPI_IOC_RD_MODE, SPI_IOC_WR_MODE ..."
msgstr ""

#: ../../../spi/spidev.rst:121
msgid ""
"pass a pointer to a byte which will return (RD) or assign (WR) the SPI "
"transfer mode.  Use the constants SPI_MODE_0..SPI_MODE_3; or if you prefer "
"you can combine SPI_CPOL (clock polarity, idle high iff this is set) or "
"SPI_CPHA (clock phase, sample on trailing edge iff this is set) flags. Note "
"that this request is limited to SPI mode flags that fit in a single byte."
msgstr ""

#: ../../../spi/spidev.rst:129
msgid "SPI_IOC_RD_MODE32, SPI_IOC_WR_MODE32 ..."
msgstr ""

#: ../../../spi/spidev.rst:130
msgid ""
"pass a pointer to a uin32_t which will return (RD) or assign (WR) the full "
"SPI transfer mode, not limited to the bits that fit in one byte."
msgstr ""

#: ../../../spi/spidev.rst:134
msgid "SPI_IOC_RD_LSB_FIRST, SPI_IOC_WR_LSB_FIRST ..."
msgstr ""

#: ../../../spi/spidev.rst:135
msgid ""
"pass a pointer to a byte which will return (RD) or assign (WR) the bit "
"justification used to transfer SPI words.  Zero indicates MSB-first; other "
"values indicate the less common LSB-first encoding.  In both cases the "
"specified value is right-justified in each word, so that unused (TX) or "
"undefined (RX) bits are in the MSBs."
msgstr ""

#: ../../../spi/spidev.rst:142
msgid "SPI_IOC_RD_BITS_PER_WORD, SPI_IOC_WR_BITS_PER_WORD ..."
msgstr ""

#: ../../../spi/spidev.rst:143
msgid ""
"pass a pointer to a byte which will return (RD) or assign (WR) the number of "
"bits in each SPI transfer word.  The value zero signifies eight bits."
msgstr ""

#: ../../../spi/spidev.rst:147
msgid "SPI_IOC_RD_MAX_SPEED_HZ, SPI_IOC_WR_MAX_SPEED_HZ ..."
msgstr ""

#: ../../../spi/spidev.rst:148
msgid ""
"pass a pointer to a u32 which will return (RD) or assign (WR) the maximum "
"SPI transfer speed, in Hz.  The controller can't necessarily assign that "
"specific clock speed."
msgstr ""

#: ../../../spi/spidev.rst:153
msgid "NOTES:"
msgstr ""

#: ../../../spi/spidev.rst:155
msgid ""
"At this time there is no async I/O support; everything is purely synchronous."
msgstr ""

#: ../../../spi/spidev.rst:158
msgid ""
"There's currently no way to report the actual bit rate used to shift data to/"
"from a given device."
msgstr ""

#: ../../../spi/spidev.rst:161
msgid ""
"From userspace, you can't currently change the chip select polarity; that "
"could corrupt transfers to other devices sharing the SPI bus. Each SPI "
"device is deselected when it's not in active use, allowing other drivers to "
"talk to other devices."
msgstr ""

#: ../../../spi/spidev.rst:166
msgid ""
"There's a limit on the number of bytes each I/O request can transfer to the "
"SPI device.  It defaults to one page, but that can be changed using a module "
"parameter."
msgstr ""

#: ../../../spi/spidev.rst:170
msgid ""
"Because SPI has no low-level transfer acknowledgement, you usually won't see "
"any I/O errors when talking to a non-existent device."
msgstr ""

#: ../../../spi/spidev.rst:175
msgid "FULL DUPLEX CHARACTER DEVICE API"
msgstr ""

#: ../../../spi/spidev.rst:177
msgid ""
"See the spidev_fdx.c sample program for one example showing the use of the "
"full duplex programming interface.  (Although it doesn't perform a full "
"duplex transfer.)  The model is the same as that used in the kernel "
"spi_sync() request; the individual transfers offer the same capabilities as "
"are available to kernel drivers (except that it's not asynchronous)."
msgstr ""

#: ../../../spi/spidev.rst:183
msgid ""
"The example shows one half-duplex RPC-style request and response message. "
"These requests commonly require that the chip not be deselected between the "
"request and response.  Several such requests could be chained into a single "
"kernel request, even allowing the chip to be deselected after each "
"response.  (Other protocol options include changing the word size and "
"bitrate for each transfer segment.)"
msgstr ""

#: ../../../spi/spidev.rst:190
msgid ""
"To make a full duplex request, provide both rx_buf and tx_buf for the same "
"transfer.  It's even OK if those are the same buffer."
msgstr ""
