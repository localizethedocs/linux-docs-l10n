# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-06 15:47+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/i3c/protocol.rst:5
msgid "I3C protocol"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:8
msgid "Disclaimer"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:10
msgid ""
"This chapter will focus on aspects that matter to software developers. For "
"everything hardware related (like how things are transmitted on the bus, how "
"collisions are prevented, ...) please have a look at the I3C specification."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:14
msgid ""
"This document is just a brief introduction to the I3C protocol and the "
"concepts it brings to the table. If you need more information, please refer "
"to the MIPI I3C specification (can be downloaded here https://resources.mipi."
"org/mipi-i3c-v1-download)."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:20
msgid "Introduction"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:22
msgid ""
"The I3C (pronounced 'eye-three-see') is a MIPI standardized protocol "
"designed to overcome I2C limitations (limited speed, external signals needed "
"for interrupts, no automatic detection of the devices connected to the "
"bus, ...) while remaining power-efficient."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:28
msgid "I3C Bus"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:30
msgid ""
"An I3C bus is made of several I3C devices and possibly some I2C devices as "
"well, but let's focus on I3C devices for now."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:33
msgid "An I3C device on the I3C bus can have one of the following roles:"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:35
msgid ""
"Master: the device is driving the bus. It's the one in charge of initiating "
"transactions or deciding who is allowed to talk on the bus (slave generated "
"events are possible in I3C, see below)."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:38
msgid ""
"Slave: the device acts as a slave, and is not able to send frames to another "
"slave on the bus. The device can still send events to the master on its own "
"initiative if the master allowed it."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:42
msgid ""
"I3C is a multi-master protocol, so there might be several masters on a bus, "
"though only one device can act as a master at a given time. In order to gain "
"bus ownership, a master has to follow a specific procedure."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:46
msgid ""
"Each device on the I3C bus has to be assigned a dynamic address to be able "
"to communicate. Until this is done, the device should only respond to a "
"limited set of commands. If it has a static address (also called legacy I2C "
"address), the device can reply to I2C transfers."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:51
msgid ""
"In addition to these per-device addresses, the protocol defines a broadcast "
"address in order to address all devices on the bus."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:54
msgid ""
"Once a dynamic address has been assigned to a device, this address will be "
"used for any direct communication with the device. Note that even after "
"being assigned a dynamic address, the device should still process broadcast "
"messages."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:59
msgid "I3C Device discovery"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:61
msgid ""
"The I3C protocol defines a mechanism to automatically discover devices "
"present on the bus, their capabilities and the functionalities they provide. "
"In this regard I3C is closer to a discoverable bus like USB than it is to "
"I2C or SPI."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:65
msgid ""
"The discovery mechanism is called DAA (Dynamic Address Assignment), because "
"it not only discovers devices but also assigns them a dynamic address."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:68
msgid "During DAA, each I3C device reports 3 important things:"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:70
msgid ""
"BCR: Bus Characteristic Register. This 8-bit register describes the device "
"bus related capabilities"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:72
msgid ""
"DCR: Device Characteristic Register. This 8-bit register describes the "
"functionalities provided by the device"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:74
msgid ""
"Provisioned ID: A 48-bit unique identifier. On a given bus there should be "
"no Provisioned ID collision, otherwise the discovery mechanism may fail."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:78
msgid "I3C slave events"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:80
msgid ""
"The I3C protocol allows slaves to generate events on their own, and thus "
"allows them to take temporary control of the bus."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:83
msgid ""
"This mechanism is called IBI for In Band Interrupts, and as stated in the "
"name, it allows devices to generate interrupts without requiring an external "
"signal."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:86
msgid ""
"During DAA, each device on the bus has been assigned an address, and this "
"address will serve as a priority identifier to determine who wins if 2 "
"different devices are generating an interrupt at the same moment on the bus "
"(the lower the dynamic address the higher the priority)."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:91
msgid ""
"Masters are allowed to inhibit interrupts if they want to. This inhibition "
"request can be broadcast (applies to all devices) or sent to a specific "
"device."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:96
msgid "I3C Hot-Join"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:98
msgid ""
"The Hot-Join mechanism is similar to USB hotplug. This mechanism allows "
"slaves to join the bus after it has been initialized by the master."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:101
msgid "This covers the following use cases:"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:103
msgid "the device is not powered when the bus is probed"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:104
msgid "the device is hotplugged on the bus through an extension board"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:106
msgid ""
"This mechanism is relying on slave events to inform the master that a new "
"device joined the bus and is waiting for a dynamic address."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:109
msgid ""
"The master is then free to address the request as it wishes: ignore it or "
"assign a dynamic address to the slave."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:113
msgid "I3C transfer types"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:115
msgid ""
"If you omit SMBus (which is just a standardization on how to access "
"registers exposed by I2C devices), I2C has only one transfer type."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:118
msgid ""
"I3C defines 3 different classes of transfer in addition to I2C transfers "
"which are here for backward compatibility with I2C devices."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:122
msgid "I3C CCC commands"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:124
msgid ""
"CCC (Common Command Code) commands are meant to be used for anything that is "
"related to bus management and all features that are common to a set of "
"devices."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:127
msgid ""
"CCC commands contain an 8-bit CCC ID describing the command that is "
"executed. The MSB of this ID specifies whether this is a broadcast command "
"(bit7 = 0) or a unicast one (bit7 = 1)."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:131
msgid ""
"The command ID can be followed by a payload. Depending on the command, this "
"payload is either sent by the master sending the command (write CCC "
"command), or sent by the slave receiving the command (read CCC command). Of "
"course, read accesses only apply to unicast commands. Note that, when "
"sending a CCC command to a specific device, the device address is passed in "
"the first byte of the payload."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:138
msgid ""
"The payload length is not explicitly passed on the bus, and should be "
"extracted from the CCC ID."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:141
msgid ""
"Note that vendors can use a dedicated range of CCC IDs for their own "
"commands (0x61-0x7f and 0xe0-0xef)."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:145
msgid "I3C Private SDR transfers"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:147
msgid ""
"Private SDR (Single Data Rate) transfers should be used for anything that is "
"device specific and does not require high transfer speed."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:150
msgid ""
"It is the equivalent of I2C transfers but in the I3C world. Each transfer is "
"passed the device address (dynamic address assigned during DAA), a payload "
"and a direction."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:154
msgid ""
"The only difference with I2C is that the transfer is much faster (typical "
"clock frequency is 12.5MHz)."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:158
msgid "I3C HDR commands"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:160
msgid ""
"HDR commands should be used for anything that is device specific and "
"requires high transfer speed."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:163
msgid ""
"The first thing attached to an HDR command is the HDR mode. There are "
"currently 3 different modes defined by the I3C specification (refer to the "
"specification for more details):"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:167
msgid "HDR-DDR: Double Data Rate mode"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:168
msgid "HDR-TSP: Ternary Symbol Pure. Only usable on buses with no I2C devices"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:169
msgid "HDR-TSL: Ternary Symbol Legacy. Usable on buses with I2C devices"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:171
msgid ""
"When sending an HDR command, the whole bus has to enter HDR mode, which is "
"done using a broadcast CCC command. Once the bus has entered a specific HDR "
"mode, the master sends the HDR command. An HDR command is made of:"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:176
msgid "one 16-bits command word in big endian"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:177
msgid "N 16-bits data words in big endian"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:179
msgid ""
"Those words may be wrapped with specific preambles/post-ambles which depend "
"on the chosen HDR mode and are detailed here (see the specification for more "
"details)."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:183
msgid "The 16-bits command word is made of:"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:185
msgid "bit[15]: direction bit, read is 1, write is 0"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:186
msgid ""
"bit[14:8]: command code. Identifies the command being executed, the amount "
"of data words and their meaning"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:188
msgid "bit[7:1]: I3C address of the device this command is addressed to"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:189
msgid "bit[0]: reserved/parity-bit"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:192
msgid "Backward compatibility with I2C devices"
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:194
msgid ""
"The I3C protocol has been designed to be backward compatible with I2C "
"devices. This backward compatibility allows one to connect a mix of I2C and "
"I3C devices on the same bus, though, in order to be really efficient, I2C "
"devices should be equipped with 50 ns spike filters."
msgstr ""

#: ../../../driver-api/i3c/protocol.rst:199
msgid ""
"I2C devices can't be discovered like I3C ones and have to be statically "
"declared. In order to let the master know what these devices are capable of "
"(both in terms of bus related limitations and functionalities), the software "
"has to provide some information, which is done through the LVR (Legacy I2C "
"Virtual Register)."
msgstr ""
