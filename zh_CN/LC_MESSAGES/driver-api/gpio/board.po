# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-14 08:59+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/gpio/board.rst:3
msgid "GPIO Mappings"
msgstr ""

#: ../../../driver-api/gpio/board.rst:5
msgid ""
"This document explains how GPIOs can be assigned to given devices and "
"functions."
msgstr ""

#: ../../../driver-api/gpio/board.rst:7
msgid ""
"All platforms can enable the GPIO library, but if the platform strictly "
"requires GPIO functionality to be present, it needs to select GPIOLIB from "
"its Kconfig. Then, how GPIOs are mapped depends on what the platform uses to "
"describe its hardware layout. Currently, mappings can be defined through "
"device tree, ACPI, and platform data."
msgstr ""

#: ../../../driver-api/gpio/board.rst:14
msgid "Device Tree"
msgstr ""

#: ../../../driver-api/gpio/board.rst:15
msgid ""
"GPIOs can easily be mapped to devices and functions in the device tree. The "
"exact way to do it depends on the GPIO controller providing the GPIOs, see "
"the device tree bindings for your controller."
msgstr ""

#: ../../../driver-api/gpio/board.rst:19
msgid ""
"GPIOs mappings are defined in the consumer device's node, in a property "
"named <function>-gpios, where <function> is the function the driver will "
"request through gpiod_get(). For example::"
msgstr ""

#: ../../../driver-api/gpio/board.rst:33
msgid ""
"Properties named <function>-gpio are also considered valid and old bindings "
"use it but are only supported for compatibility reasons and should not be "
"used for newer bindings since it has been deprecated."
msgstr ""

#: ../../../driver-api/gpio/board.rst:37
msgid ""
"This property will make GPIOs 15, 16 and 17 available to the driver under "
"the \"led\" function, and GPIO 1 as the \"power\" GPIO::"
msgstr ""

#: ../../../driver-api/gpio/board.rst:48
msgid ""
"The led GPIOs will be active high, while the power GPIO will be active low "
"(i.e. gpiod_is_active_low(power) will be true)."
msgstr ""

#: ../../../driver-api/gpio/board.rst:51
msgid ""
"The second parameter of the gpiod_get() functions, the con_id string, has to "
"be the <function>-prefix of the GPIO suffixes (\"gpios\" or \"gpio\", "
"automatically looked up by the gpiod functions internally) used in the "
"device tree. With above \"led-gpios\" example, use the prefix without the \"-"
"\" as con_id parameter: \"led\"."
msgstr ""

#: ../../../driver-api/gpio/board.rst:56
msgid ""
"Internally, the GPIO subsystem prefixes the GPIO suffix (\"gpios\" or "
"\"gpio\") with the string passed in con_id to get the resulting string "
"(``snprintf(... \"%s-%s\", con_id, gpio_suffixes[]``)."
msgstr ""

#: ../../../driver-api/gpio/board.rst:61
msgid "ACPI"
msgstr ""

#: ../../../driver-api/gpio/board.rst:62
msgid ""
"ACPI also supports function names for GPIOs in a similar fashion to DT. The "
"above DT example can be converted to an equivalent ACPI description with the "
"help of _DSD (Device Specific Data), introduced in ACPI 5.1::"
msgstr ""

#: ../../../driver-api/gpio/board.rst:94
msgid ""
"For more information about the ACPI GPIO bindings see Documentation/firmware-"
"guide/acpi/gpio-properties.rst."
msgstr ""

#: ../../../driver-api/gpio/board.rst:98
msgid "Software Nodes"
msgstr ""

#: ../../../driver-api/gpio/board.rst:100
msgid ""
"Software nodes allow board-specific code to construct an in-memory, device-"
"tree-like structure using struct software_node and struct property_entry. "
"This structure can then be associated with a platform device, allowing "
"drivers to use the standard device properties API to query configuration, "
"just as they would on an ACPI or device tree system."
msgstr ""

#: ../../../driver-api/gpio/board.rst:106
msgid ""
"Software-node-backed GPIOs are described using the ``PROPERTY_ENTRY_GPIO()`` "
"macro, which ties a software node representing the GPIO controller with "
"consumer device. It allows consumers to use regular gpiolib APIs, such as "
"gpiod_get(), gpiod_get_optional()."
msgstr ""

#: ../../../driver-api/gpio/board.rst:111
msgid ""
"The software node representing a GPIO controller need not be attached to the "
"GPIO controller device. The only requirement is that the node must be "
"registered and its name must match the GPIO controller's label."
msgstr ""

#: ../../../driver-api/gpio/board.rst:115
msgid ""
"For example, here is how to describe a single GPIO-connected LED. This is an "
"alternative to using platform_data on legacy systems."
msgstr ""

#: ../../../driver-api/gpio/board.rst:159
msgid ""
"For a complete guide on converting board files to use software nodes, see "
"Documentation/driver-api/gpio/legacy-boards.rst."
msgstr ""

#: ../../../driver-api/gpio/board.rst:163
msgid "Platform Data"
msgstr ""

#: ../../../driver-api/gpio/board.rst:164
msgid ""
"Finally, GPIOs can be bound to devices and functions using platform data. "
"Board files that desire to do so need to include the following header::"
msgstr ""

#: ../../../driver-api/gpio/board.rst:169
msgid ""
"GPIOs are mapped by the means of tables of lookups, containing instances of "
"the gpiod_lookup structure. Two macros are defined to help declaring such "
"mappings::"
msgstr ""

#: ../../../driver-api/gpio/board.rst:175
msgid "where"
msgstr ""

#: ../../../driver-api/gpio/board.rst:177
msgid ""
"key is either the label of the gpiod_chip instance providing the GPIO, or "
"the GPIO line name"
msgstr ""

#: ../../../driver-api/gpio/board.rst:179
msgid ""
"chip_hwnum is the hardware number of the GPIO within the chip, or U16_MAX to "
"indicate that key is a GPIO line name"
msgstr ""

#: ../../../driver-api/gpio/board.rst:181
msgid ""
"con_id is the name of the GPIO function from the device point of view. It"
msgstr ""

#: ../../../driver-api/gpio/board.rst:182
msgid "can be NULL, in which case it will match any function."
msgstr ""

#: ../../../driver-api/gpio/board.rst:183
msgid "idx is the index of the GPIO within the function."
msgstr ""

#: ../../../driver-api/gpio/board.rst:184
msgid "flags is defined to specify the following properties:"
msgstr ""

#: ../../../driver-api/gpio/board.rst:185
msgid "GPIO_ACTIVE_HIGH      - GPIO line is active high"
msgstr ""

#: ../../../driver-api/gpio/board.rst:186
msgid "GPIO_ACTIVE_LOW       - GPIO line is active low"
msgstr ""

#: ../../../driver-api/gpio/board.rst:187
msgid "GPIO_OPEN_DRAIN       - GPIO line is set up as open drain"
msgstr ""

#: ../../../driver-api/gpio/board.rst:188
msgid "GPIO_OPEN_SOURCE      - GPIO line is set up as open source"
msgstr ""

#: ../../../driver-api/gpio/board.rst:189
msgid "GPIO_PERSISTENT       - GPIO line is persistent during"
msgstr ""

#: ../../../driver-api/gpio/board.rst:190
msgid "suspend/resume and maintains its value"
msgstr ""

#: ../../../driver-api/gpio/board.rst:191
msgid "GPIO_TRANSITORY       - GPIO line is transitory and may loose its"
msgstr ""

#: ../../../driver-api/gpio/board.rst:192
msgid "electrical state during suspend/resume"
msgstr ""

#: ../../../driver-api/gpio/board.rst:194
msgid ""
"In the future, these flags might be extended to support more properties."
msgstr ""

#: ../../../driver-api/gpio/board.rst:196
msgid "Note that:"
msgstr ""

#: ../../../driver-api/gpio/board.rst:197
msgid ""
"GPIO line names are not guaranteed to be globally unique, so the first match "
"found will be used."
msgstr ""

#: ../../../driver-api/gpio/board.rst:199
msgid "GPIO_LOOKUP() is just a shortcut to GPIO_LOOKUP_IDX() where idx = 0."
msgstr ""

#: ../../../driver-api/gpio/board.rst:201
msgid ""
"A lookup table can then be defined as follows, with an empty entry defining "
"its end. The 'dev_id' field of the table is the identifier of the device "
"that will make use of these GPIOs. It can be NULL, in which case it will be "
"matched for calls to gpiod_get() with a NULL device."
msgstr ""

#: ../../../driver-api/gpio/board.rst:219
msgid "And the table can be added by the board code as follows::"
msgstr ""

#: ../../../driver-api/gpio/board.rst:223
msgid ""
"The driver controlling \"foo.0\" will then be able to obtain its GPIOs as "
"follows::"
msgstr ""

#: ../../../driver-api/gpio/board.rst:233
msgid ""
"Since the \"led\" GPIOs are mapped as active-high, this example will switch "
"their signals to 1, i.e. enabling the LEDs. And for the \"power\" GPIO, "
"which is mapped as active-low, its actual signal will be 0 after this code. "
"Contrary to the legacy integer GPIO interface, the active-low property is "
"handled during mapping and is thus transparent to GPIO consumers."
msgstr ""

#: ../../../driver-api/gpio/board.rst:239
msgid ""
"A set of functions such as gpiod_set_value() is available to work with the "
"new descriptor-oriented interface."
msgstr ""

#: ../../../driver-api/gpio/board.rst:242
msgid ""
"Boards using platform data can also hog GPIO lines by defining GPIO hog "
"tables."
msgstr ""

#: ../../../driver-api/gpio/board.rst:251
msgid "And the table can be added to the board code as follows::"
msgstr ""

#: ../../../driver-api/gpio/board.rst:255
msgid ""
"The line will be hogged as soon as the gpiochip is created or - in case the "
"chip was created earlier - when the hog table is registered."
msgstr ""

#: ../../../driver-api/gpio/board.rst:259
msgid "Arrays of pins"
msgstr ""

#: ../../../driver-api/gpio/board.rst:260
msgid ""
"In addition to requesting pins belonging to a function one by one, a device "
"may also request an array of pins assigned to the function.  The way those "
"pins are mapped to the device determines if the array qualifies for fast "
"bitmap processing.  If yes, a bitmap is passed over get/set array functions "
"directly between a caller and a respective .get/set_multiple() callback of a "
"GPIO chip."
msgstr ""

#: ../../../driver-api/gpio/board.rst:266
msgid ""
"In order to qualify for fast bitmap processing, the array must meet the "
"following requirements:"
msgstr ""

#: ../../../driver-api/gpio/board.rst:269
msgid "pin hardware number of array member 0 must also be 0,"
msgstr ""

#: ../../../driver-api/gpio/board.rst:270
msgid ""
"pin hardware numbers of consecutive array members which belong to the same "
"chip as member 0 does must also match their array indexes."
msgstr ""

#: ../../../driver-api/gpio/board.rst:273
msgid ""
"Otherwise fast bitmap processing path is not used in order to avoid "
"consecutive pins which belong to the same chip but are not in hardware order "
"being processed separately."
msgstr ""

#: ../../../driver-api/gpio/board.rst:277
msgid ""
"If the array applies for fast bitmap processing path, pins which belong to "
"different chips than member 0 does, as well as those with indexes different "
"from their hardware pin numbers, are excluded from the fast path, both input "
"and output.  Moreover, open drain and open source pins are excluded from "
"fast bitmap output processing."
msgstr ""
