# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/dmaengine/pxa_dma.rst:3
msgid "PXA/MMP - DMA Slave controller"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:6
msgid "Constraints"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:8
msgid ""
"a) Transfers hot queuing A driver submitting a transfer and issuing it "
"should be granted the transfer is queued even on a running DMA channel. This "
"implies that the queuing doesn't wait for the previous transfer end, and "
"that the descriptor chaining is not only done in the irq/tasklet code "
"triggered by the end of the transfer. A transfer which is submitted and "
"issued on a phy doesn't wait for a phy to stop and restart, but is submitted "
"on a \"running channel\". The other drivers, especially mmp_pdma waited for "
"the phy to stop before relaunching a new transfer."
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:19
msgid ""
"b) All transfers having asked for confirmation should be signaled Any issued "
"transfer with DMA_PREP_INTERRUPT should trigger a callback call. This "
"implies that even if an irq/tasklet is triggered by end of tx1, but at the "
"time of irq/dma tx2 is already finished, tx1->complete() and tx2->complete() "
"should be called."
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:25
msgid ""
"c) Channel running state A driver should be able to query if a channel is "
"running or not. For the multimedia case, such as video capture, if a "
"transfer is submitted and then a check of the DMA channel reports a "
"\"stopped channel\", the transfer should not be issued until the next "
"\"start of frame interrupt\", hence the need to know if a channel is in "
"running or stopped state."
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:32
msgid ""
"d) Bandwidth guarantee The PXA architecture has 4 levels of DMAs "
"priorities : high, normal, low. The high priorities get twice as much "
"bandwidth as the normal, which get twice as much as the low priorities. A "
"driver should be able to request a priority, especially the real-time ones "
"such as pxa_camera with (big) throughputs."
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:40
msgid "Design"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:41
msgid ""
"a) Virtual channels Same concept as in sa11x0 driver, ie. a driver was "
"assigned a \"virtual channel\" linked to the requestor line, and the "
"physical DMA channel is assigned on the fly when the transfer is issued."
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:46
msgid "Transfer anatomy for a scatter-gather transfer"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:54
msgid ""
"This structure is pointed by dma->sg_cpu. The descriptors are used as "
"follows :"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:57
msgid ""
"desc-sg[i]: i-th descriptor, transferring the i-th sg element to the video "
"buffer scatter gather"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:60
msgid ""
"status updater Transfers a single u32 to a well known dma coherent memory to "
"leave a trace that this transfer is done. The \"well known\" is unique per "
"physical channel, meaning that a read of this value will tell which is the "
"last finished transfer at that point in time."
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:66
msgid "finisher: has ddadr=DADDR_STOP, dcmd=ENDIRQEN"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:68
msgid "linker: has ddadr= desc-sg[0] of next transfer, dcmd=0"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:70
msgid "c) Transfers hot-chaining Suppose the running chain is:"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:82
msgid "After a call to dmaengine_submit(b3), the chain will look like:"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:94
msgid ""
"If while new_link was created the DMA channel stopped, it is _not_ "
"restarted. Hot-chaining doesn't break the assumption that "
"dma_async_issue_pending() is to be used to ensure the transfer is actually "
"started."
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:98
msgid "One exception to this rule :"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:100
msgid "if Buffer1 and Buffer2 had all their addresses 8 bytes aligned"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:102
msgid "and if Buffer3 has at least one address not 4 bytes aligned"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:104
msgid ""
"then hot-chaining cannot happen, as the channel must be stopped, the \"align "
"bit\" must be set, and the channel restarted As a consequence, such a "
"transfer tx_submit() will be queued on the submitted queue, and this "
"specific case if the DMA is already running in aligned mode."
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:109
msgid ""
"d) Transfers completion updater Each time a transfer is completed on a "
"channel, an interrupt might be generated or not, up to the client's request. "
"But in each case, the last descriptor of a transfer, the \"status updater\", "
"will write the latest transfer being completed into the physical channel's "
"completion mark."
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:115
msgid ""
"This will speed up residue calculation, for large transfers such as video "
"buffers which hold around 6k descriptors or more. This also allows without "
"any lock to find out what is the latest completed transfer in a running DMA "
"chain."
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:120
msgid ""
"e) Transfers completion, irq and tasklet When a transfer flagged as "
"\"DMA_PREP_INTERRUPT\" is finished, the dma irq is raised. Upon this "
"interrupt, a tasklet is scheduled for the physical channel."
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:125
msgid "The tasklet is responsible for :"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:127
msgid "reading the physical channel last updater mark"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:129
msgid ""
"calling all the transfer callbacks of finished transfers, based on that "
"mark, and each transfer flags."
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:132
msgid ""
"If a transfer is completed while this handling is done, a dma irq will be "
"raised, and the tasklet will be scheduled once again, having a new updater "
"mark."
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:136
msgid ""
"f) Residue Residue granularity will be descriptor based. The issued but not "
"completed transfers will be scanned for all of their descriptors against the "
"currently running descriptor."
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:141
msgid ""
"g) Most complicated case of driver's tx queues The most tricky situation is "
"when :"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:144
msgid "there are not \"acked\" transfers (tx0)"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:146
msgid "a driver submitted an aligned tx1, not chained"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:148
msgid "a driver submitted an aligned tx2 => tx2 is cold chained to tx1"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:150
msgid "a driver issued tx1+tx2 => channel is running in aligned mode"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:152
msgid "a driver submitted an aligned tx3 => tx3 is hot-chained"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:154
msgid ""
"a driver submitted an unaligned tx4 => tx4 is put in submitted queue, not "
"chained"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:157
msgid "a driver issued tx4 => tx4 is put in issued queue, not chained"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:159
msgid ""
"a driver submitted an aligned tx5 => tx5 is put in submitted queue, not "
"chained"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:162
msgid ""
"a driver submitted an aligned tx6 => tx6 is put in submitted queue, cold "
"chained to tx5"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:165
msgid "This translates into (after tx4 is issued) :"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:167
msgid "issued queue"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:183
msgid "completed queue : empty"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:185
msgid "allocated queue : tx0"
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:187
msgid ""
"It should be noted that after tx3 is completed, the channel is stopped, and "
"restarted in \"unaligned mode\" to handle tx4."
msgstr ""

#: ../../../driver-api/dmaengine/pxa_dma.rst:190
msgid "Author: Robert Jarzmik <robert.jarzmik@free.fr>"
msgstr ""
