# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/usb/callbacks.rst:2
msgid "USB core callbacks"
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:5
msgid "What callbacks will usbcore do?"
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:7
msgid ""
"Usbcore will call into a driver through callbacks defined in the driver "
"structure and through the completion handler of URBs a driver submits. Only "
"the former are in the scope of this document. These two kinds of callbacks "
"are completely independent of each other. Information on the completion "
"callback can be found in :ref:`usb-urb`."
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:13
msgid "The callbacks defined in the driver structure are:"
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:15
msgid "Hotplugging callbacks:"
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:17
msgid "@probe:"
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:18
msgid ""
"Called to see if the driver is willing to manage a particular interface on a "
"device."
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:21
msgid "@disconnect:"
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:22
msgid ""
"Called when the interface is no longer accessible, usually because its "
"device has been (or is being) disconnected or the driver module is being "
"unloaded."
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:26
msgid "Odd backdoor through usbfs:"
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:28
msgid "@ioctl:"
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:29
msgid ""
"Used for drivers that want to talk to userspace through the \"usbfs\" "
"filesystem.  This lets devices provide ways to expose information to user "
"space regardless of where they do (or don't) show up otherwise in the "
"filesystem."
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:34
msgid "Power management (PM) callbacks:"
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:36
msgid "@suspend:"
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:37
msgid "Called when the device is going to be suspended."
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:39
msgid "@resume:"
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:40
msgid "Called when the device is being resumed."
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:42
msgid "@reset_resume:"
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:43
msgid ""
"Called when the suspended device has been reset instead of being resumed."
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:46
msgid "Device level operations:"
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:48
msgid "@pre_reset:"
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:49
msgid "Called when the device is about to be reset."
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:51
msgid "@post_reset:"
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:52
msgid "Called after the device has been reset"
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:54
msgid ""
"The ioctl interface (2) should be used only if you have a very good reason. "
"Sysfs is preferred these days. The PM callbacks are covered separately in :"
"ref:`usb-power-management`."
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:59
msgid "Calling conventions"
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:61
msgid ""
"All callbacks are mutually exclusive. There's no need for locking against "
"other USB callbacks. All callbacks are called from a task context. You may "
"sleep. However, it is important that all sleeps have a small fixed upper "
"limit in time. In particular you must not call out to user space and await "
"results."
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:68
msgid "Hotplugging callbacks"
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:70
msgid ""
"These callbacks are intended to associate and disassociate a driver with an "
"interface. A driver's bond to an interface is exclusive."
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:74
msgid "The probe() callback"
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:81
msgid ""
"Accept or decline an interface. If you accept the device return 0, otherwise "
"-ENODEV or -ENXIO. Other error codes should be used only if a genuine error "
"occurred during initialisation which prevented a driver from accepting a "
"device that would else have been accepted. You are strongly encouraged to "
"use usbcore's facility, usb_set_intfdata(), to associate a data structure "
"with an interface, so that you know which internal state and identity you "
"associate with a particular interface. The device will not be suspended and "
"you may do IO to the interface you are called for and endpoint 0 of the "
"device. Device initialisation that doesn't take too long is a good idea here."
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:93
msgid "The disconnect() callback"
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:99
msgid ""
"This callback is a signal to break any connection with an interface. You are "
"not allowed any IO to a device after returning from this callback. You also "
"may not do any other operation that may interfere with another driver bound "
"to the interface, eg. a power management operation. Outstanding operations "
"on the device must be completed or aborted before this callback may return."
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:106
msgid ""
"If you are called due to a physical disconnection, all your URBs will be "
"killed by usbcore. Note that in this case disconnect will be called some "
"time after the physical disconnection. Thus your driver must be prepared to "
"deal with failing IO even prior to the callback."
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:112
msgid "Device level callbacks"
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:115
msgid "pre_reset"
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:121
msgid ""
"A driver or user space is triggering a reset on the device which contains "
"the interface passed as an argument. Cease IO, wait for all outstanding URBs "
"to complete, and save any device state you need to restore.  No more URBs "
"may be submitted until the post_reset method is called."
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:127
#: ../../../driver-api/usb/callbacks.rst:140
msgid ""
"If you need to allocate memory here, use GFP_NOIO or GFP_ATOMIC, if you are "
"in atomic context."
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:131
msgid "post_reset"
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:137
msgid ""
"The reset has completed.  Restore any saved device state and begin using the "
"device again."
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:144
msgid "Call sequences"
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:146
msgid ""
"No callbacks other than probe will be invoked for an interface that isn't "
"bound to your driver."
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:149
msgid ""
"Probe will never be called for an interface bound to a driver. Hence "
"following a successful probe, disconnect will be called before there is "
"another probe for the same interface."
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:153
msgid ""
"Once your driver is bound to an interface, disconnect can be called at any "
"time except in between pre_reset and post_reset. pre_reset is always "
"followed by post_reset, even if the reset failed or the device has been "
"unplugged."
msgstr ""

#: ../../../driver-api/usb/callbacks.rst:158
msgid ""
"suspend is always followed by one of: resume, reset_resume, or disconnect."
msgstr ""
