# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/pwm.rst:3
msgid "Pulse Width Modulation (PWM) interface"
msgstr ""

#: ../../../driver-api/pwm.rst:5
msgid "This provides an overview about the Linux PWM interface"
msgstr ""

#: ../../../driver-api/pwm.rst:7
msgid ""
"PWMs are commonly used for controlling LEDs, fans or vibrators in cell "
"phones. PWMs with a fixed purpose have no need implementing the Linux PWM "
"API (although they could). However, PWMs are often found as discrete devices "
"on SoCs which have no fixed purpose. It's up to the board designer to "
"connect them to LEDs or fans. To provide this kind of flexibility the "
"generic PWM API exists."
msgstr ""

#: ../../../driver-api/pwm.rst:15
msgid "Identifying PWMs"
msgstr ""

#: ../../../driver-api/pwm.rst:17
msgid "Users of the legacy PWM API use unique IDs to refer to PWM devices."
msgstr ""

#: ../../../driver-api/pwm.rst:19
msgid ""
"Instead of referring to a PWM device via its unique ID, board setup code "
"should instead register a static mapping that can be used to match PWM "
"consumers to providers, as given in the following example::"
msgstr ""

#: ../../../driver-api/pwm.rst:36
msgid "Using PWMs"
msgstr ""

#: ../../../driver-api/pwm.rst:38
msgid ""
"Consumers use the pwm_get() function and pass to it the consumer device or a "
"consumer name. pwm_put() is used to free the PWM device. Managed variants of "
"the getter, devm_pwm_get() and devm_fwnode_pwm_get(), also exist."
msgstr ""

#: ../../../driver-api/pwm.rst:42
msgid "After being requested, a PWM has to be configured using::"
msgstr ""

#: ../../../driver-api/pwm.rst:46
msgid ""
"This API controls both the PWM period/duty_cycle config and the enable/"
"disable state."
msgstr ""

#: ../../../driver-api/pwm.rst:49
msgid ""
"PWM devices can be used from atomic context, if the PWM does not sleep. You "
"can check if this the case with::"
msgstr ""

#: ../../../driver-api/pwm.rst:54
msgid "If false, the PWM can also be configured from atomic context with::"
msgstr ""

#: ../../../driver-api/pwm.rst:58
msgid ""
"As a consumer, don't rely on the output's state for a disabled PWM. If it's "
"easily possible, drivers are supposed to emit the inactive state, but some "
"drivers cannot. If you rely on getting the inactive state, use ."
"duty_cycle=0, .enabled=true."
msgstr ""

#: ../../../driver-api/pwm.rst:63
msgid ""
"There is also a usage_power setting: If set, the PWM driver is only required "
"to maintain the power output but has more freedom regarding signal form. If "
"supported by the driver, the signal can be optimized, for example to improve "
"EMI by phase shifting the individual channels of a chip."
msgstr ""

#: ../../../driver-api/pwm.rst:68
msgid ""
"The pwm_config(), pwm_enable() and pwm_disable() functions are just wrappers "
"around pwm_apply_might_sleep() and should not be used if the user wants to "
"change several parameter at once. For example, if you see pwm_config() and "
"pwm_{enable,disable}() calls in the same function, this probably means you "
"should switch to pwm_apply_might_sleep()."
msgstr ""

#: ../../../driver-api/pwm.rst:74
msgid ""
"The PWM user API also allows one to query the PWM state that was passed to "
"the last invocation of pwm_apply_might_sleep() using pwm_get_state(). Note "
"this is different to what the driver has actually implemented if the request "
"cannot be satisfied exactly with the hardware in use. There is currently no "
"way for consumers to get the actually implemented settings."
msgstr ""

#: ../../../driver-api/pwm.rst:80
msgid ""
"In addition to the PWM state, the PWM API also exposes PWM arguments, which "
"are the reference PWM config one should use on this PWM. PWM arguments are "
"usually platform-specific and allows the PWM user to only care about "
"dutycycle relatively to the full period (like, duty = 50% of the period). "
"struct pwm_args contains 2 fields (period and polarity) and should be used "
"to set the initial PWM config (usually done in the probe function of the PWM "
"user). PWM arguments are retrieved with pwm_get_args()."
msgstr ""

#: ../../../driver-api/pwm.rst:88
msgid ""
"All consumers should really be reconfiguring the PWM upon resume as "
"appropriate. This is the only way to ensure that everything is resumed in "
"the proper order."
msgstr ""

#: ../../../driver-api/pwm.rst:93
msgid "Using PWMs with the sysfs interface"
msgstr ""

#: ../../../driver-api/pwm.rst:95
msgid ""
"If CONFIG_SYSFS is enabled in your kernel configuration a simple sysfs "
"interface is provided to use the PWMs from userspace. It is exposed at /sys/"
"class/pwm/. Each probed PWM controller/chip will be exported as pwmchipN, "
"where N is the base of the PWM chip. Inside the directory you will find:"
msgstr ""

#: ../../../driver-api/pwm.rst:101
msgid "npwm"
msgstr ""

#: ../../../driver-api/pwm.rst:102
msgid "The number of PWM channels this chip supports (read-only)."
msgstr ""

#: ../../../driver-api/pwm.rst:104
msgid "export"
msgstr ""

#: ../../../driver-api/pwm.rst:105
msgid "Exports a PWM channel for use with sysfs (write-only)."
msgstr ""

#: ../../../driver-api/pwm.rst:107
msgid "unexport"
msgstr ""

#: ../../../driver-api/pwm.rst:108
msgid "Unexports a PWM channel from sysfs (write-only)."
msgstr ""

#: ../../../driver-api/pwm.rst:110
msgid "The PWM channels are numbered using a per-chip index from 0 to npwm-1."
msgstr ""

#: ../../../driver-api/pwm.rst:112
msgid ""
"When a PWM channel is exported a pwmX directory will be created in the "
"pwmchipN directory it is associated with, where X is the number of the "
"channel that was exported. The following properties will then be available:"
msgstr ""

#: ../../../driver-api/pwm.rst:116
msgid "period"
msgstr ""

#: ../../../driver-api/pwm.rst:117
msgid ""
"The total period of the PWM signal (read/write). Value is in nanoseconds and "
"is the sum of the active and inactive time of the PWM."
msgstr ""

#: ../../../driver-api/pwm.rst:121
msgid "duty_cycle"
msgstr ""

#: ../../../driver-api/pwm.rst:122
msgid ""
"The active time of the PWM signal (read/write). Value is in nanoseconds and "
"must be less than or equal to the period."
msgstr ""

#: ../../../driver-api/pwm.rst:125
msgid "polarity"
msgstr ""

#: ../../../driver-api/pwm.rst:126
msgid ""
"Changes the polarity of the PWM signal (read/write). Writes to this property "
"only work if the PWM chip supports changing the polarity. Value is the "
"string \"normal\" or \"inversed\"."
msgstr ""

#: ../../../driver-api/pwm.rst:131
msgid "enable"
msgstr ""

#: ../../../driver-api/pwm.rst:132
msgid "Enable/disable the PWM signal (read/write)."
msgstr ""

#: ../../../driver-api/pwm.rst:134
msgid "0 - disabled"
msgstr ""

#: ../../../driver-api/pwm.rst:135
msgid "1 - enabled"
msgstr ""

#: ../../../driver-api/pwm.rst:138
msgid "Implementing a PWM driver"
msgstr ""

#: ../../../driver-api/pwm.rst:140
msgid ""
"Currently there are two ways to implement pwm drivers. Traditionally there "
"only has been the barebone API meaning that each driver has to implement the "
"pwm_*() functions itself. This means that it's impossible to have multiple "
"PWM drivers in the system. For this reason it's mandatory for new drivers to "
"use the generic PWM framework."
msgstr ""

#: ../../../driver-api/pwm.rst:146
msgid ""
"A new PWM controller/chip can be allocated using pwmchip_alloc(), then "
"registered using pwmchip_add() and removed again with pwmchip_remove(). To "
"undo pwmchip_alloc() use pwmchip_put(). pwmchip_add() takes a filled in "
"struct pwm_chip as argument which provides a description of the PWM chip, "
"the number of PWM devices provided by the chip and the chip-specific "
"implementation of the supported PWM operations to the framework."
msgstr ""

#: ../../../driver-api/pwm.rst:153
msgid ""
"When implementing polarity support in a PWM driver, make sure to respect the "
"signal conventions in the PWM framework. By definition, normal polarity "
"characterizes a signal starts high for the duration of the duty cycle and "
"goes low for the remainder of the period. Conversely, a signal with inversed "
"polarity starts low for the duration of the duty cycle and goes high for the "
"remainder of the period."
msgstr ""

#: ../../../driver-api/pwm.rst:160
msgid ""
"Drivers are encouraged to implement ->apply() instead of the legacy -"
">enable(), ->disable() and ->config() methods. Doing that should provide "
"atomicity in the PWM config workflow, which is required when the PWM "
"controls a critical device (like a regulator)."
msgstr ""

#: ../../../driver-api/pwm.rst:165
msgid ""
"The implementation of ->get_state() (a method used to retrieve initial PWM "
"state) is also encouraged for the same reason: letting the PWM user know "
"about the current PWM state would allow him to avoid glitches."
msgstr ""

#: ../../../driver-api/pwm.rst:169
msgid ""
"Drivers should not implement any power management. In other words, consumers "
"should implement it as described in the \"Using PWMs\" section."
msgstr ""

#: ../../../driver-api/pwm.rst:173
msgid "Locking"
msgstr ""

#: ../../../driver-api/pwm.rst:175
msgid ""
"The PWM core list manipulations are protected by a mutex, so pwm_get() and "
"pwm_put() may not be called from an atomic context. Most functions in the "
"PWM consumer API might sleep and so must not be called from atomic context. "
"The notable exception is pwm_apply_atomic() which has the same semantics as "
"pwm_apply_might_sleep() but can be called from atomic context. (The price "
"for that is that it doesn't work for all PWM devices, use pwm_might_sleep() "
"to check if a given PWM supports atomic operation."
msgstr ""

#: ../../../driver-api/pwm.rst:183
msgid ""
"Locking in the PWM core ensures that callbacks related to a single chip are "
"serialized."
msgstr ""

#: ../../../driver-api/pwm.rst:187
msgid "Helpers"
msgstr ""

#: ../../../driver-api/pwm.rst:189
msgid ""
"Currently a PWM can only be configured with period_ns and duty_ns. For "
"several use cases freq_hz and duty_percent might be better. Instead of "
"calculating this in your driver please consider adding appropriate helpers "
"to the framework."
msgstr ""
