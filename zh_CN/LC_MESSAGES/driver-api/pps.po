# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/pps.rst:5
msgid "PPS - Pulse Per Second"
msgstr ""

#: ../../../driver-api/pps.rst:7
msgid "Copyright (C) 2007 Rodolfo Giometti <giometti@enneenne.com>"
msgstr ""

#: ../../../driver-api/pps.rst:9
msgid ""
"This program is free software; you can redistribute it and/or modify it "
"under the terms of the GNU General Public License as published by the Free "
"Software Foundation; either version 2 of the License, or (at your option) "
"any later version."
msgstr ""

#: ../../../driver-api/pps.rst:14
msgid ""
"This program is distributed in the hope that it will be useful, but WITHOUT "
"ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or "
"FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for "
"more details."
msgstr ""

#: ../../../driver-api/pps.rst:22
msgid "Overview"
msgstr ""

#: ../../../driver-api/pps.rst:24
msgid ""
"LinuxPPS provides a programming interface (API) to define in the system "
"several PPS sources."
msgstr ""

#: ../../../driver-api/pps.rst:27
msgid ""
"PPS means \"pulse per second\" and a PPS source is just a device which "
"provides a high precision signal each second so that an application can use "
"it to adjust system clock time."
msgstr ""

#: ../../../driver-api/pps.rst:31
msgid ""
"A PPS source can be connected to a serial port (usually to the Data Carrier "
"Detect pin) or to a parallel port (ACK-pin) or to a special CPU's GPIOs "
"(this is the common case in embedded systems) but in each case when a new "
"pulse arrives the system must apply to it a timestamp and record it for "
"userland."
msgstr ""

#: ../../../driver-api/pps.rst:37
msgid ""
"Common use is the combination of the NTPD as userland program, with a GPS "
"receiver as PPS source, to obtain a wallclock-time with sub-millisecond "
"synchronisation to UTC."
msgstr ""

#: ../../../driver-api/pps.rst:43
msgid "RFC considerations"
msgstr ""

#: ../../../driver-api/pps.rst:45
msgid ""
"While implementing a PPS API as RFC 2783 defines and using an embedded CPU "
"GPIO-Pin as physical link to the signal, I encountered a deeper problem:"
msgstr ""

#: ../../../driver-api/pps.rst:49
msgid ""
"At startup it needs a file descriptor as argument for the function "
"time_pps_create()."
msgstr ""

#: ../../../driver-api/pps.rst:52
msgid ""
"This implies that the source has a /dev/... entry. This assumption is OK for "
"the serial and parallel port, where you can do something useful besides(!) "
"the gathering of timestamps as it is the central task for a PPS API. But "
"this assumption does not work for a single purpose GPIO line. In this case "
"even basic file-related functionality (like read() and write()) makes no "
"sense at all and should not be a precondition for the use of a PPS API."
msgstr ""

#: ../../../driver-api/pps.rst:60
msgid ""
"The problem can be simply solved if you consider that a PPS source is not "
"always connected with a GPS data source."
msgstr ""

#: ../../../driver-api/pps.rst:63
msgid ""
"So your programs should check if the GPS data source (the serial port for "
"instance) is a PPS source too, and if not they should provide the "
"possibility to open another device as PPS source."
msgstr ""

#: ../../../driver-api/pps.rst:67
msgid ""
"In LinuxPPS the PPS sources are simply char devices usually mapped into "
"files /dev/pps0, /dev/pps1, etc."
msgstr ""

#: ../../../driver-api/pps.rst:72
msgid "PPS with USB to serial devices"
msgstr ""

#: ../../../driver-api/pps.rst:74
msgid ""
"It is possible to grab the PPS from an USB to serial device. However, you "
"should take into account the latencies and jitter introduced by the USB "
"stack. Users have reported clock instability around +-1ms when synchronized "
"with PPS through USB. With USB 2.0, jitter may decrease down to the order of "
"125 microseconds."
msgstr ""

#: ../../../driver-api/pps.rst:80
msgid ""
"This may be suitable for time server synchronization with NTP because of its "
"undersampling and algorithms."
msgstr ""

#: ../../../driver-api/pps.rst:83
msgid ""
"If your device doesn't report PPS, you can check that the feature is "
"supported by its driver. Most of the time, you only need to add a call to "
"usb_serial_handle_dcd_change after checking the DCD status (see ch341 and "
"pl2303 examples)."
msgstr ""

#: ../../../driver-api/pps.rst:90
msgid "Coding example"
msgstr ""

#: ../../../driver-api/pps.rst:92
msgid ""
"To register a PPS source into the kernel you should define a struct "
"pps_source_info as follows::"
msgstr ""

#: ../../../driver-api/pps.rst:105
msgid ""
"and then calling the function pps_register_source() in your initialization "
"routine as follows::"
msgstr ""

#: ../../../driver-api/pps.rst:111
msgid "The pps_register_source() prototype is::"
msgstr ""

#: ../../../driver-api/pps.rst:115
msgid ""
"where \"info\" is a pointer to a structure that describes a particular PPS "
"source, \"default_params\" tells the system what the initial default "
"parameters for the device should be (it is obvious that these parameters "
"must be a subset of ones defined in the struct pps_source_info which "
"describe the capabilities of the driver)."
msgstr ""

#: ../../../driver-api/pps.rst:121
msgid ""
"Once you have registered a new PPS source into the system you can signal an "
"assert event (for example in the interrupt handler routine) just using::"
msgstr ""

#: ../../../driver-api/pps.rst:127
msgid "where \"ts\" is the event's timestamp."
msgstr ""

#: ../../../driver-api/pps.rst:129
msgid ""
"The same function may also run the defined echo function (pps_ktimer_echo(), "
"passing to it the \"ptr\" pointer) if the user asked for that... etc.."
msgstr ""

#: ../../../driver-api/pps.rst:133
msgid "Please see the file drivers/pps/clients/pps-ktimer.c for example code."
msgstr ""

#: ../../../driver-api/pps.rst:137
msgid "SYSFS support"
msgstr ""

#: ../../../driver-api/pps.rst:139 ../../../driver-api/pps.rst:230
msgid ""
"If the SYSFS filesystem is enabled in the kernel it provides a new class::"
msgstr ""

#: ../../../driver-api/pps.rst:144
msgid ""
"Every directory is the ID of a PPS sources defined in the system and inside "
"you find several files::"
msgstr ""

#: ../../../driver-api/pps.rst:152
msgid ""
"Inside each \"assert\" and \"clear\" file you can find the timestamp and a "
"sequence number::"
msgstr ""

#: ../../../driver-api/pps.rst:158
msgid ""
"Where before the \"#\" is the timestamp in seconds; after it is the sequence "
"number. Other files are:"
msgstr ""

#: ../../../driver-api/pps.rst:161
msgid "echo: reports if the PPS source has an echo function or not;"
msgstr ""

#: ../../../driver-api/pps.rst:163
msgid "mode: reports available PPS functioning modes;"
msgstr ""

#: ../../../driver-api/pps.rst:165
msgid "name: reports the PPS source's name;"
msgstr ""

#: ../../../driver-api/pps.rst:167
msgid ""
"path: reports the PPS source's device path, that is the device the PPS "
"source is connected to (if it exists)."
msgstr ""

#: ../../../driver-api/pps.rst:172
msgid "Testing the PPS support"
msgstr ""

#: ../../../driver-api/pps.rst:174
msgid ""
"In order to test the PPS support even without specific hardware you can use "
"the pps-ktimer driver (see the client subsection in the PPS configuration "
"menu) and the userland tools available in your distribution's pps-tools "
"package, http://linuxpps.org , or https://github.com/redlab-i/pps-tools."
msgstr ""

#: ../../../driver-api/pps.rst:179
msgid ""
"Once you have enabled the compilation of pps-ktimer just modprobe it (if not "
"statically compiled)::"
msgstr ""

#: ../../../driver-api/pps.rst:184
msgid "and the run ppstest as follow::"
msgstr ""

#: ../../../driver-api/pps.rst:194
msgid ""
"Please note that to compile userland programs, you need the file timepps.h. "
"This is available in the pps-tools repository mentioned above."
msgstr ""

#: ../../../driver-api/pps.rst:199
msgid "Generators"
msgstr ""

#: ../../../driver-api/pps.rst:201
msgid ""
"Sometimes one needs to be able not only to catch PPS signals but to produce "
"them also. For example, running a distributed simulation, which requires "
"computers' clock to be synchronized very tightly."
msgstr ""

#: ../../../driver-api/pps.rst:205
msgid ""
"To do so the class pps-gen has been added. PPS generators can be registered "
"in the kernel by defining a struct pps_gen_source_info as follows::"
msgstr ""

#: ../../../driver-api/pps.rst:215
msgid ""
"Where the use_system_clock states if the generator uses the system clock to "
"generate its pulses, or they are from a peripheral device clock. Method "
"get_time() is used to query the time stored into the generator clock, while "
"the method enable() is used to enable or disable the PPS pulse generation."
msgstr ""

#: ../../../driver-api/pps.rst:221
msgid ""
"Then calling the function pps_gen_register_source() in your initialization "
"routine as follows creates a new generator in the system::"
msgstr ""

#: ../../../driver-api/pps.rst:228
msgid "Generators SYSFS support"
msgstr ""

#: ../../../driver-api/pps.rst:235
msgid ""
"Every directory is the ID of a PPS generator defined in the system and "
"inside of it you find several files::"
msgstr ""

#: ../../../driver-api/pps.rst:241
msgid "To enable the PPS signal generation you can use the command below::"
msgstr ""

#: ../../../driver-api/pps.rst:246
msgid "Parallel port generator"
msgstr ""

#: ../../../driver-api/pps.rst:248
msgid ""
"One way to do this is to invent some complicated hardware solutions but it "
"may be neither necessary nor affordable. The cheap way is to load a PPS "
"generator on one of the computers (master) and PPS clients on others "
"(slaves), and use very simple cables to deliver signals using parallel "
"ports, for example."
msgstr ""

#: ../../../driver-api/pps.rst:254
msgid "Parallel port cable pinout::"
msgstr ""

#: ../../../driver-api/pps.rst:276
msgid ""
"Please note that parallel port interrupt occurs only on high->low "
"transition, so it is used for PPS assert edge. PPS clear edge can be "
"determined only using polling in the interrupt handler which actually can be "
"done way more precisely because interrupt handling delays can be quite big "
"and random. So current parport PPS generator implementation (pps_gen_parport "
"module) is geared towards using the clear edge for time synchronization."
msgstr ""

#: ../../../driver-api/pps.rst:283
msgid ""
"Clear edge polling is done with disabled interrupts so it's better to select "
"delay between assert and clear edge as small as possible to reduce system "
"latencies. But if it is too small slave won't be able to capture clear edge "
"transition. The default of 30us should be good enough in most situations. "
"The delay can be selected using 'delay' pps_gen_parport module parameter."
msgstr ""

#: ../../../driver-api/pps.rst:291
msgid "Intel Timed I/O PPS signal generator"
msgstr ""

#: ../../../driver-api/pps.rst:293
msgid ""
"Intel Timed I/O is a high precision device, present on 2019 and newer Intel "
"CPUs, that can generate PPS signals."
msgstr ""

#: ../../../driver-api/pps.rst:296
msgid ""
"Timed I/O and system time are both driven by same hardware clock. The signal "
"is generated with a precision of ~20 nanoseconds. The generated PPS signal "
"is used to synchronize an external device with system clock. For example, it "
"can be used to share your clock with a device that receives PPS signal, "
"generated by Timed I/O device. There are dedicated Timed I/O pins to deliver "
"the PPS signal to an external device."
msgstr ""

#: ../../../driver-api/pps.rst:303
msgid "Usage of Intel Timed I/O as PPS generator:"
msgstr ""

#: ../../../driver-api/pps.rst:305
msgid "Start generating PPS signal::"
msgstr ""

#: ../../../driver-api/pps.rst:309
msgid "Stop generating PPS signal::"
msgstr ""
