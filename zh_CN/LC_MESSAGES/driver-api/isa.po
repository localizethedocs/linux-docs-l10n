# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../driver-api/isa.rst:3
msgid "ISA Drivers"
msgstr ""

#: ../../../driver-api/isa.rst:5
msgid ""
"The following text is adapted from the commit message of the initial commit "
"of the ISA bus driver authored by Rene Herman."
msgstr ""

#: ../../../driver-api/isa.rst:8
msgid ""
"During the recent \"isa drivers using platform devices\" discussion it was "
"pointed out that (ALSA) ISA drivers ran into the problem of not having the "
"option to fail driver load (device registration rather) upon not finding "
"their hardware due to a probe() error not being passed up through the driver "
"model. In the course of that, I suggested a separate ISA bus might be best; "
"Russell King agreed and suggested this bus could use the .match() method for "
"the actual device discovery."
msgstr ""

#: ../../../driver-api/isa.rst:16
msgid ""
"The attached does this. For this old non (generically) discoverable ISA "
"hardware only the driver itself can do discovery so as a difference with the "
"platform_bus, this isa_bus also distributes match() up to the driver."
msgstr ""

#: ../../../driver-api/isa.rst:21
msgid ""
"As another difference: these devices only exist in the driver model due to "
"the driver creating them because it might want to drive them, meaning that "
"all device creation has been made internal as well."
msgstr ""

#: ../../../driver-api/isa.rst:25
msgid ""
"The usage model this provides is nice, and has been acked from the ALSA side "
"by Takashi Iwai and Jaroslav Kysela. The ALSA driver module_init's now (for "
"oldisa-only drivers) become::"
msgstr ""

#: ../../../driver-api/isa.rst:39
msgid ""
"Quite like the other bus models therefore. This removes a lot of duplicated "
"init code from the ALSA ISA drivers."
msgstr ""

#: ../../../driver-api/isa.rst:42
msgid ""
"The passed in isa_driver struct is the regular driver struct embedding a "
"struct device_driver, the normal probe/remove/shutdown/suspend/resume "
"callbacks, and as indicated that .match callback."
msgstr ""

#: ../../../driver-api/isa.rst:46
msgid ""
"The \"SNDRV_CARDS\" you see being passed in is a \"unsigned int ndev\" "
"parameter, indicating how many devices to create and call our methods with."
msgstr ""

#: ../../../driver-api/isa.rst:50
msgid ""
"The platform_driver callbacks are called with a platform_device param; the "
"isa_driver callbacks are being called with a ``struct device *dev, unsigned "
"int id`` pair directly -- with the device creation completely internal to "
"the bus it's much cleaner to not leak isa_dev's by passing them in at all. "
"The id is the only thing we ever want other then the struct device anyways, "
"and it makes for nicer code in the callbacks as well."
msgstr ""

#: ../../../driver-api/isa.rst:58
msgid ""
"With this additional .match() callback ISA drivers have all options. If ALSA "
"would want to keep the old non-load behaviour, it could stick all of the "
"old .probe in .match, which would only keep them registered after everything "
"was found to be present and accounted for. If it wanted the behaviour of "
"always loading as it inadvertently did for a bit after the changeover to "
"platform devices, it could just not provide a .match() and do everything in ."
"probe() as before."
msgstr ""

#: ../../../driver-api/isa.rst:66
msgid ""
"If it, as Takashi Iwai already suggested earlier as a way of following the "
"model from saner buses more closely, wants to load when a later bind could "
"conceivably succeed, it could use .match() for the prerequisites (such as "
"checking the user wants the card enabled and that port/irq/dma values have "
"been passed in) and .probe() for everything else. This is the nicest model."
msgstr ""

#: ../../../driver-api/isa.rst:73
msgid "To the code..."
msgstr ""

#: ../../../driver-api/isa.rst:75
msgid "This exports only two functions; isa_{,un}register_driver()."
msgstr ""

#: ../../../driver-api/isa.rst:77
msgid ""
"isa_register_driver() register's the struct device_driver, and then loops "
"over the passed in ndev creating devices and registering them. This causes "
"the bus match method to be called for them, which is::"
msgstr ""

#: ../../../driver-api/isa.rst:94
msgid ""
"The first thing this does is check if this device is in fact one of this "
"driver's devices by seeing if the device's platform_data pointer is set to "
"this driver. Platform devices compare strings, but we don't need to do that "
"with everything being internal, so isa_register_driver() abuses dev-"
">platform_data as a isa_driver pointer which we can then check here. I "
"believe platform_data is available for this, but if rather not, moving the "
"isa_driver pointer to the private struct isa_dev is ofcourse fine as well."
msgstr ""

#: ../../../driver-api/isa.rst:103
msgid ""
"Then, if the driver did not provide a .match, it matches. If it did, the "
"driver match() method is called to determine a match."
msgstr ""

#: ../../../driver-api/isa.rst:106
msgid ""
"If it did **not** match, dev->platform_data is reset to indicate this to "
"isa_register_driver which can then unregister the device again."
msgstr ""

#: ../../../driver-api/isa.rst:109
msgid ""
"If during all this, there's any error, or no devices matched at all "
"everything is backed out again and the error, or -ENODEV, is returned."
msgstr ""

#: ../../../driver-api/isa.rst:112
msgid ""
"isa_unregister_driver() just unregisters the matched devices and the driver "
"itself."
msgstr ""

#: ../../../driver-api/isa.rst:115
msgid ""
"module_isa_driver is a helper macro for ISA drivers which do not do anything "
"special in module init/exit. This eliminates a lot of boilerplate code. Each "
"module may only use this macro once, and calling it replaces module_init and "
"module_exit."
msgstr ""

#: ../../../driver-api/isa.rst:120
msgid ""
"max_num_isa_dev is a macro to determine the maximum possible number of ISA "
"devices which may be registered in the I/O port address space given the "
"address extent of the ISA devices."
msgstr ""
