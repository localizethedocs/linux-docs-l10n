# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/unaligned-memory-access.rst:3
msgid "Unaligned Memory Accesses"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:0
msgid "Author"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:5
msgid "Daniel Drake <dsd@gentoo.org>,"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:6
msgid "Johannes Berg <johannes@sipsolutions.net>"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:0
msgid "With help from"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:8
msgid ""
"Alan Cox, Avuton Olrich, Heikki Orsila, Jan Engelhardt, Kyle McMartin, Kyle "
"Moffett, Randy Dunlap, Robert Hancock, Uli Kunitz, Vadim Lobanov"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:13
msgid ""
"Linux runs on a wide variety of architectures which have varying behaviour "
"when it comes to memory access. This document presents some details about "
"unaligned accesses, why you need to write code that doesn't cause them, and "
"how to write such code!"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:20
msgid "The definition of an unaligned access"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:22
msgid ""
"Unaligned memory accesses occur when you try to read N bytes of data "
"starting from an address that is not evenly divisible by N (i.e. addr % N != "
"0). For example, reading 4 bytes of data from address 0x10004 is fine, but "
"reading 4 bytes of data from address 0x10005 would be an unaligned memory "
"access."
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:28
msgid ""
"The above may seem a little vague, as memory access can happen in different "
"ways. The context here is at the machine code level: certain instructions "
"read or write a number of bytes to or from memory (e.g. movb, movw, movl in "
"x86 assembly). As will become clear, it is relatively easy to spot C "
"statements which will compile to multiple-byte memory access instructions, "
"namely when dealing with types such as u16, u32 and u64."
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:37
msgid "Natural alignment"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:39
msgid ""
"The rule mentioned above forms what we refer to as natural alignment: When "
"accessing N bytes of memory, the base memory address must be evenly "
"divisible by N, i.e. addr % N == 0."
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:43
msgid ""
"When writing code, assume the target architecture has natural alignment "
"requirements."
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:46
msgid ""
"In reality, only a few architectures require natural alignment on all sizes "
"of memory access. However, we must consider ALL supported architectures; "
"writing code that satisfies natural alignment requirements is the easiest "
"way to achieve full portability."
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:53
msgid "Why unaligned access is bad"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:55
msgid ""
"The effects of performing an unaligned memory access vary from architecture "
"to architecture. It would be easy to write a whole document on the "
"differences here; a summary of the common scenarios is presented below:"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:59
msgid ""
"Some architectures are able to perform unaligned memory accesses "
"transparently, but there is usually a significant performance cost."
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:61
msgid ""
"Some architectures raise processor exceptions when unaligned accesses "
"happen. The exception handler is able to correct the unaligned access, at "
"significant cost to performance."
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:64
msgid ""
"Some architectures raise processor exceptions when unaligned accesses "
"happen, but the exceptions do not contain enough information for the "
"unaligned access to be corrected."
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:67
msgid ""
"Some architectures are not capable of unaligned memory access, but will "
"silently perform a different memory access to the one that was requested, "
"resulting in a subtle code bug that is hard to detect!"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:71
msgid ""
"It should be obvious from the above that if your code causes unaligned "
"memory accesses to happen, your code will not work correctly on certain "
"platforms and will cause performance problems on others."
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:77
msgid "Code that does not cause unaligned access"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:79
msgid ""
"At first, the concepts above may seem a little hard to relate to actual "
"coding practice. After all, you don't have a great deal of control over "
"memory addresses of certain variables, etc."
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:83
msgid ""
"Fortunately things are not too complex, as in most cases, the compiler "
"ensures that things will work for you. For example, take the following "
"structure::"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:93
msgid ""
"Let us assume that an instance of the above structure resides in memory "
"starting at address 0x10000. With a basic level of understanding, it would "
"not be unreasonable to expect that accessing field2 would cause an unaligned "
"access. You'd be expecting field2 to be located at offset 2 bytes into the "
"structure, i.e. address 0x10002, but that address is not evenly divisible by "
"4 (remember, we're reading a 4 byte value here)."
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:100
msgid ""
"Fortunately, the compiler understands the alignment constraints, so in the "
"above case it would insert 2 bytes of padding in between field1 and field2. "
"Therefore, for standard structure types you can always rely on the compiler "
"to pad structures so that accesses to fields are suitably aligned (assuming "
"you do not cast the field to a type of different length)."
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:106
msgid ""
"Similarly, you can also rely on the compiler to align variables and function "
"parameters to a naturally aligned scheme, based on the size of the type of "
"the variable."
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:110
msgid ""
"At this point, it should be clear that accessing a single byte (u8 or char) "
"will never cause an unaligned access, because all memory addresses are "
"evenly divisible by one."
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:114
msgid ""
"On a related topic, with the above considerations in mind you may observe "
"that you could reorder the fields in the structure in order to place fields "
"where padding would otherwise be inserted, and hence reduce the overall "
"resident memory size of structure instances. The optimal layout of the above "
"example is::"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:126
msgid ""
"For a natural alignment scheme, the compiler would only have to add a single "
"byte of padding at the end of the structure. This padding is added in order "
"to satisfy alignment constraints for arrays of these structures."
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:130
msgid ""
"Another point worth mentioning is the use of __attribute__((packed)) on a "
"structure type. This GCC-specific attribute tells the compiler never to "
"insert any padding within structures, useful when you want to use a C struct "
"to represent some data that comes in a fixed arrangement 'off the wire'."
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:135
msgid ""
"You might be inclined to believe that usage of this attribute can easily "
"lead to unaligned accesses when accessing fields that do not satisfy "
"architectural alignment requirements. However, again, the compiler is aware "
"of the alignment constraints and will generate extra instructions to perform "
"the memory access in a way that does not cause unaligned access. Of course, "
"the extra instructions obviously cause a loss in performance compared to the "
"non-packed case, so the packed attribute should only be used when avoiding "
"structure padding is of importance."
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:146
msgid "Code that causes unaligned access"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:148
msgid ""
"With the above in mind, let's move onto a real life example of a function "
"that can cause an unaligned memory access. The following function taken from "
"include/linux/etherdevice.h is an optimized routine to compare two ethernet "
"MAC addresses for equality::"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:167
msgid ""
"In the above function, when the hardware has efficient unaligned access "
"capability, there is no issue with this code.  But when the hardware isn't "
"able to access memory on arbitrary boundaries, the reference to a[0] causes "
"2 bytes (16 bits) to be read from memory starting at address addr1."
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:172
msgid ""
"Think about what would happen if addr1 was an odd address such as 0x10003. "
"(Hint: it'd be an unaligned access.)"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:175
msgid ""
"Despite the potential unaligned access problems with the above function, it "
"is included in the kernel anyway but is understood to only work normally on "
"16-bit-aligned addresses. It is up to the caller to ensure this alignment or "
"not use this function at all. This alignment-unsafe function is still useful "
"as it is a decent optimization for the cases when you can ensure alignment, "
"which is true almost all of the time in ethernet networking context."
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:183
msgid ""
"Here is another example of some code that could cause unaligned accesses::"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:192
msgid ""
"This code will cause unaligned accesses every time the data parameter points "
"to an address that is not evenly divisible by 4."
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:195
msgid ""
"In summary, the 2 main scenarios where you may run into unaligned access "
"problems involve:"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:198
msgid "Casting variables to types of different lengths"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:199
msgid "Pointer arithmetic followed by access to at least 2 bytes of data"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:203
msgid "Avoiding unaligned accesses"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:205
msgid ""
"The easiest way to avoid unaligned access is to use the get_unaligned() and "
"put_unaligned() macros provided by the <linux/unaligned.h> header file."
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:208
msgid ""
"Going back to an earlier example of code that potentially causes unaligned "
"access::"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:218
msgid "To avoid the unaligned memory access, you would rewrite it as follows::"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:228
msgid ""
"The get_unaligned() macro works similarly. Assuming 'data' is a pointer to "
"memory and you wish to avoid unaligned access, its usage is as follows::"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:233
msgid ""
"These macros work for memory accesses of any length (not just 32 bits as in "
"the examples above). Be aware that when compared to standard access of "
"aligned memory, using these macros to access unaligned memory can be costly "
"in terms of performance."
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:238
msgid ""
"If use of such macros is not convenient, another option is to use memcpy(), "
"where the source or destination (or both) are of type u8* or unsigned char*. "
"Due to the byte-wise nature of this operation, unaligned accesses are "
"avoided."
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:244
msgid "Alignment vs. Networking"
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:246
msgid ""
"On architectures that require aligned loads, networking requires that the IP "
"header is aligned on a four-byte boundary to optimise the IP stack. For "
"regular ethernet hardware, the constant NET_IP_ALIGN is used. On most "
"architectures this constant has the value 2 because the normal ethernet "
"header is 14 bytes long, so in order to get proper alignment one needs to "
"DMA to an address which can be expressed as 4*n + 2. One notable exception "
"here is powerpc which defines NET_IP_ALIGN to 0 because DMA to unaligned "
"addresses can be very expensive and dwarf the cost of unaligned loads."
msgstr ""

#: ../../../core-api/unaligned-memory-access.rst:255
msgid ""
"For some ethernet hardware that cannot DMA to unaligned addresses like 4*n+2 "
"or non-ethernet hardware, this can be a problem, and it is then required to "
"copy the incoming frame into an aligned buffer. Because this is unnecessary "
"on architectures that can do unaligned accesses, the code can be made "
"dependent on CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS like so::"
msgstr ""
