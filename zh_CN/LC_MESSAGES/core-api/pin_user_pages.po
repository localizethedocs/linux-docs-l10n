# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/pin_user_pages.rst:5
msgid "pin_user_pages() and related calls"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:10
msgid "Overview"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:12
msgid "This document describes the following functions::"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:19
msgid "Basic description of FOLL_PIN"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:21
msgid ""
"FOLL_PIN and FOLL_LONGTERM are flags that can be passed to the "
"get_user_pages*() (\"gup\") family of functions. FOLL_PIN has significant "
"interactions and interdependencies with FOLL_LONGTERM, so both are covered "
"here."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:25
msgid ""
"FOLL_PIN is internal to gup, meaning that it should not appear at the gup "
"call sites. This allows the associated wrapper functions  (pin_user_pages*() "
"and others) to set the correct combination of these flags, and to check for "
"problems as well."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:30
msgid ""
"FOLL_LONGTERM, on the other hand, *is* allowed to be set at the gup call "
"sites. This is in order to avoid creating a large number of wrapper "
"functions to cover all combinations of get*(), pin*(), FOLL_LONGTERM, and "
"more. Also, the pin_user_pages*() APIs are clearly distinct from the "
"get_user_pages*() APIs, so that's a natural dividing line, and a good point "
"to make separate wrapper calls. In other words, use pin_user_pages*() for "
"DMA-pinned pages, and get_user_pages*() for other cases. There are five "
"cases described later on in this document, to further clarify that concept."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:39
msgid ""
"FOLL_PIN and FOLL_GET are mutually exclusive for a given gup call. However, "
"multiple threads and call sites are free to pin the same struct pages, via "
"both FOLL_PIN and FOLL_GET. It's just the call site that needs to choose one "
"or the other, not the struct page(s)."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:44
msgid ""
"The FOLL_PIN implementation is nearly the same as FOLL_GET, except that "
"FOLL_PIN uses a different reference counting technique."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:47
msgid ""
"FOLL_PIN is a prerequisite to FOLL_LONGTERM. Another way of saying that is, "
"FOLL_LONGTERM is a specific case, more restrictive case of FOLL_PIN."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:51
msgid "Which flags are set by each wrapper"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:53
msgid ""
"For these pin_user_pages*() functions, FOLL_PIN is OR'd in with whatever gup "
"flags the caller provides. The caller is required to pass in a non-null "
"struct pages* array, and the function then pins pages by incrementing each "
"by a special value: GUP_PIN_COUNTING_BIAS."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:58
msgid ""
"For large folios, the GUP_PIN_COUNTING_BIAS scheme is not used. Instead, the "
"extra space available in the struct folio is used to store the pincount "
"directly."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:62
msgid ""
"This approach for large folios avoids the counting upper limit problems that "
"are discussed below. Those limitations would have been aggravated severely "
"by huge pages, because each tail page adds a refcount to the head page. And "
"in fact, testing revealed that, without a separate pincount field, refcount "
"overflows were seen in some huge page stress tests."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:68
msgid ""
"This also means that huge pages and large folios do not suffer from the "
"false positives problem that is mentioned below.::"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:77
msgid ""
"For these get_user_pages*() functions, FOLL_GET might not even be specified. "
"Behavior is a little more complex than above. If FOLL_GET was *not* "
"specified, but the caller passed in a non-null struct pages* array, then the "
"function sets FOLL_GET for you, and proceeds to pin pages by incrementing "
"the refcount of each page by +1.::"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:90
msgid "Tracking dma-pinned pages"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:92
msgid ""
"Some of the key design constraints, and solutions, for tracking dma-pinned "
"pages:"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:95
msgid ""
"An actual reference count, per struct page, is required. This is because "
"multiple processes may pin and unpin a page."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:98
msgid ""
"False positives (reporting that a page is dma-pinned, when in fact it is "
"not) are acceptable, but false negatives are not."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:101
msgid ""
"struct page may not be increased in size for this, and all fields are "
"already used."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:104
msgid ""
"Given the above, we can overload the page->_refcount field by using, sort "
"of, the upper bits in that field for a dma-pinned count. \"Sort of\", means "
"that, rather than dividing page->_refcount into bit fields, we simple add a "
"medium- large value (GUP_PIN_COUNTING_BIAS, initially chosen to be 1024: 10 "
"bits) to page->_refcount. This provides fuzzy behavior: if a page has "
"get_page() called on it 1024 times, then it will appear to have a single dma-"
"pinned count. And again, that's acceptable."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:112
msgid ""
"This also leads to limitations: there are only 31-10==21 bits available for "
"a counter that increments 10 bits at a time."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:115
msgid ""
"Because of that limitation, special handling is applied to the zero pages "
"when using FOLL_PIN.  We only pretend to pin a zero page - we don't alter "
"its refcount or pincount at all (it is permanent, so there's no need).  The "
"unpinning functions also don't do anything to a zero page.  This is "
"transparent to the caller."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:121
msgid ""
"Callers must specifically request \"dma-pinned tracking of pages\". In other "
"words, just calling get_user_pages() will not suffice; a new set of "
"functions, pin_user_page() and related, must be used."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:126
msgid "FOLL_PIN, FOLL_GET, FOLL_LONGTERM: when to use which flags"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:128
msgid ""
"Thanks to Jan Kara, Vlastimil Babka and several other -mm people, for "
"describing these categories:"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:132
msgid "CASE 1: Direct IO (DIO)"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:133
msgid ""
"There are GUP references to pages that are serving as DIO buffers. These "
"buffers are needed for a relatively short time (so they are not \"long "
"term\"). No special synchronization with folio_mkclean() or munmap() is "
"provided. Therefore, flags to set at the call site are: ::"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:140
msgid ""
"...but rather than setting FOLL_PIN directly, call sites should use one of "
"the pin_user_pages*() routines that set FOLL_PIN."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:144
msgid "CASE 2: RDMA"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:145
msgid ""
"There are GUP references to pages that are serving as DMA buffers. These "
"buffers are needed for a long time (\"long term\"). No special "
"synchronization with folio_mkclean() or munmap() is provided. Therefore, "
"flags to set at the call site are: ::"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:152
msgid ""
"NOTE: Some pages, such as DAX pages, cannot be pinned with longterm pins. "
"That's because DAX pages do not have a separate page cache, and so "
"\"pinning\" implies locking down file system blocks, which is not (yet) "
"supported in that way."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:159
msgid ""
"CASE 3: MMU notifier registration, with or without page faulting hardware"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:160
msgid ""
"Device drivers can pin pages via get_user_pages*(), and register for mmu "
"notifier callbacks for the memory range. Then, upon receiving a notifier "
"\"invalidate range\" callback , stop the device from using the range, and "
"unpin the pages. There may be other possible schemes, such as for example "
"explicitly synchronizing against pending IO, that accomplish approximately "
"the same thing."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:166
msgid ""
"Or, if the hardware supports replayable page faults, then the device driver "
"can avoid pinning entirely (this is ideal), as follows: register for mmu "
"notifier callbacks as above, but instead of stopping the device and "
"unpinning in the callback, simply remove the range from the device's page "
"tables."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:171
msgid ""
"Either way, as long as the driver unpins the pages upon mmu notifier "
"callback, then there is proper synchronization with both filesystem and mm "
"(folio_mkclean(), munmap(), etc). Therefore, neither flag needs to be set."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:176
msgid "CASE 4: Pinning for struct page manipulation only"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:177
msgid ""
"If only struct page data (as opposed to the actual memory contents that a "
"page is tracking) is affected, then normal GUP calls are sufficient, and "
"neither flag needs to be set."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:182
msgid "CASE 5: Pinning in order to write to the data within the page"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:183
msgid ""
"Even though neither DMA nor Direct IO is involved, just a simple case of "
"\"pin, write to a page's data, unpin\" can cause a problem. Case 5 may be "
"considered a superset of Case 1, plus Case 2, plus anything that invokes "
"that pattern. In other words, if the code is neither Case 1 nor Case 2, it "
"may still require FOLL_PIN, for patterns like this:"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:189
msgid "Correct (uses FOLL_PIN calls):"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:190
msgid "pin_user_pages() write to the data within the pages unpin_user_pages()"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:194
msgid "INCORRECT (uses FOLL_GET calls):"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:195
msgid "get_user_pages() write to the data within the pages put_page()"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:200
msgid "folio_maybe_dma_pinned(): the whole point of pinning"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:202
msgid ""
"The whole point of marking folios as \"DMA-pinned\" or \"gup-pinned\" is to "
"be able to query, \"is this folio DMA-pinned?\" That allows code such as "
"folio_mkclean() (and file system writeback code in general) to make informed "
"decisions about what to do when a folio cannot be unmapped due to such pins."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:207
msgid ""
"What to do in those cases is the subject of a years-long series of "
"discussions and debates (see the References at the end of this document). "
"It's a TODO item here: fill in the details once that's worked out. "
"Meanwhile, it's safe to say that having this available: ::"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:214
msgid "...is a prerequisite to solving the long-running gup+DMA problem."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:217
msgid "Another way of thinking about FOLL_GET, FOLL_PIN, and FOLL_LONGTERM"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:219
msgid ""
"Another way of thinking about these flags is as a progression of "
"restrictions: FOLL_GET is for struct page manipulation, without affecting "
"the data that the struct page refers to. FOLL_PIN is a *replacement* for "
"FOLL_GET, and is for short term pins on pages whose data *will* get "
"accessed. As such, FOLL_PIN is a \"more severe\" form of pinning. And "
"finally, FOLL_LONGTERM is an even more restrictive case that has FOLL_PIN as "
"a prerequisite: this is for pages that will be pinned longterm, and whose "
"data will be accessed."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:228
msgid "Unit testing"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:229
msgid "This file::"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:233
msgid ""
"has the following new calls to exercise the new pin*() wrapper functions:"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:235
msgid "PIN_FAST_BENCHMARK (./gup_test -a)"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:236
msgid "PIN_BASIC_TEST (./gup_test -b)"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:238
msgid ""
"You can monitor how many total dma-pinned pages have been acquired and "
"released since the system was booted, via two new /proc/vmstat entries: ::"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:244
msgid ""
"Under normal conditions, these two values will be equal unless there are any "
"long-term [R]DMA pins in place, or during pin/unpin transitions."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:247
msgid ""
"nr_foll_pin_acquired: This is the number of logical pins that have been "
"acquired since the system was powered on. For huge pages, the head page is "
"pinned once for each page (head page and each tail page) within the huge "
"page. This follows the same sort of behavior that get_user_pages() uses for "
"huge pages: the head page is refcounted once for each tail or head page in "
"the huge page, when get_user_pages() is applied to a huge page."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:254
msgid ""
"nr_foll_pin_released: The number of logical pins that have been released "
"since the system was powered on. Note that pages are released (unpinned) on "
"a PAGE_SIZE granularity, even if the original pin was applied to a huge "
"page. Becaused of the pin count behavior described above in "
"\"nr_foll_pin_acquired\", the accounting balances out, so that after doing "
"this::"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:264
msgid "...the following is expected::"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:268
msgid ""
"(...unless it was already out of balance due to a long-term RDMA pin being "
"in place.)"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:272
msgid "Other diagnostics"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:274
msgid ""
"dump_page() has been enhanced slightly to handle these new counting fields, "
"and to better report on large folios in general.  Specifically, for large "
"folios, the exact pincount is reported."
msgstr ""

#: ../../../core-api/pin_user_pages.rst:279
msgid "References"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:281
msgid ""
"`Some slow progress on get_user_pages() (Apr 2, 2019) <https://lwn.net/"
"Articles/784574/>`_"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:282
msgid ""
"`DMA and get_user_pages() (LPC: Dec 12, 2018) <https://lwn.net/"
"Articles/774411/>`_"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:283
msgid ""
"`The trouble with get_user_pages() (Apr 30, 2018) <https://lwn.net/"
"Articles/753027/>`_"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:284
msgid ""
"`LWN kernel index: get_user_pages() <https://lwn.net/Kernel/Index/"
"#Memory_management-get_user_pages>`_"
msgstr ""

#: ../../../core-api/pin_user_pages.rst:286
msgid "John Hubbard, October, 2019"
msgstr ""
