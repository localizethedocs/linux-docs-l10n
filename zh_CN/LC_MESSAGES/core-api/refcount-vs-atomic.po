# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../core-api/refcount-vs-atomic.rst:3
msgid "refcount_t API compared to atomic_t"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:8
msgid "Introduction"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:10
msgid ""
"The goal of refcount_t API is to provide a minimal API for implementing an "
"object's reference counters. While a generic architecture-independent "
"implementation from lib/refcount.c uses atomic operations underneath, there "
"are a number of differences between some of the ``refcount_*()`` and "
"``atomic_*()`` functions with regards to the memory ordering guarantees. "
"This document outlines the differences and provides respective examples in "
"order to help maintainers validate their code against the change in these "
"memory ordering guarantees."
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:19
msgid ""
"The terms used through this document try to follow the formal LKMM defined "
"in tools/memory-model/Documentation/explanation.txt."
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:22
msgid ""
"memory-barriers.txt and atomic_t.txt provide more background to the memory "
"ordering in general and for atomic operations specifically."
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:26
msgid "Relevant types of memory ordering"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:28
msgid ""
"The following section only covers some of the memory ordering types that are "
"relevant for the atomics and reference counters and used through this "
"document. For a much broader picture please consult memory-barriers.txt "
"document."
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:33
msgid ""
"In the absence of any memory ordering guarantees (i.e. fully unordered) "
"atomics & refcounters only provide atomicity and program order (po) relation "
"(on the same CPU). It guarantees that each ``atomic_*()`` and "
"``refcount_*()`` operation is atomic and instructions are executed in "
"program order on a single CPU. This is implemented using READ_ONCE()/"
"WRITE_ONCE() and compare-and-swap primitives."
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:41
msgid ""
"A strong (full) memory ordering guarantees that all prior loads and stores "
"(all po-earlier instructions) on the same CPU are completed before any po-"
"later instruction is executed on the same CPU. It also guarantees that all "
"po-earlier stores on the same CPU and all propagated stores from other CPUs "
"must propagate to all other CPUs before any po-later instruction is executed "
"on the original CPU (A-cumulative property). This is implemented using "
"smp_mb()."
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:49
msgid ""
"A RELEASE memory ordering guarantees that all prior loads and stores (all po-"
"earlier instructions) on the same CPU are completed before the operation. It "
"also guarantees that all po-earlier stores on the same CPU and all "
"propagated stores from other CPUs must propagate to all other CPUs before "
"the release operation (A-cumulative property). This is implemented using "
"smp_store_release()."
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:57
msgid ""
"An ACQUIRE memory ordering guarantees that all post loads and stores (all po-"
"later instructions) on the same CPU are completed after the acquire "
"operation. It also guarantees that all po-later stores on the same CPU must "
"propagate to all other CPUs after the acquire operation executes. This is "
"implemented using smp_acquire__after_ctrl_dep()."
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:64
msgid ""
"A control dependency (on success) for refcounters guarantees that if a "
"reference for an object was successfully obtained (reference counter "
"increment or addition happened, function returned true), then further stores "
"are ordered against this operation. Control dependency on stores are not "
"implemented using any explicit barriers, but rely on CPU not to speculate on "
"stores. This is only a single CPU relation and provides no guarantees for "
"other CPUs."
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:74
msgid "Comparison of functions"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:77
msgid "case 1) - non-\"Read/Modify/Write\" (RMW) ops"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:79
#: ../../../core-api/refcount-vs-atomic.rst:92
#: ../../../core-api/refcount-vs-atomic.rst:104
#: ../../../core-api/refcount-vs-atomic.rst:116
#: ../../../core-api/refcount-vs-atomic.rst:128
#: ../../../core-api/refcount-vs-atomic.rst:144
#: ../../../core-api/refcount-vs-atomic.rst:157
#: ../../../core-api/refcount-vs-atomic.rst:170
#: ../../../core-api/refcount-vs-atomic.rst:185
msgid "Function changes:"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:81
msgid "atomic_set() --> refcount_set()"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:82
msgid "atomic_read() --> refcount_read()"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:84
#: ../../../core-api/refcount-vs-atomic.rst:96
#: ../../../core-api/refcount-vs-atomic.rst:109
#: ../../../core-api/refcount-vs-atomic.rst:120
msgid "Memory ordering guarantee changes:"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:86
#: ../../../core-api/refcount-vs-atomic.rst:111
msgid "none (both fully unordered)"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:90
msgid "case 2) - non-\"Read/Modify/Write\" (RMW) ops with release ordering"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:94
msgid "atomic_set_release() --> refcount_set_release()"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:98
msgid "none (both provide RELEASE ordering)"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:102
msgid "case 3) - increment-based ops that return no value"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:106
msgid "atomic_inc() --> refcount_inc()"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:107
msgid "atomic_add() --> refcount_add()"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:114
msgid "case 4) - decrement-based RMW ops that return no value"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:118
msgid "atomic_dec() --> refcount_dec()"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:122
msgid "fully unordered --> RELEASE ordering"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:126
msgid "case 5) - increment-based RMW ops that return a value"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:130
msgid "atomic_inc_not_zero() --> refcount_inc_not_zero()"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:131
msgid "no atomic counterpart --> refcount_add_not_zero()"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:133
#: ../../../core-api/refcount-vs-atomic.rst:149
#: ../../../core-api/refcount-vs-atomic.rst:162
#: ../../../core-api/refcount-vs-atomic.rst:175
#: ../../../core-api/refcount-vs-atomic.rst:190
msgid "Memory ordering guarantees changes:"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:135
msgid "fully ordered --> control dependency on success for stores"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:137
msgid ""
"We really assume here that necessary ordering is provided as a result of "
"obtaining pointer to the object!"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:142
msgid ""
"case 6) - increment-based RMW ops with acquire ordering that return a value"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:146
msgid "atomic_inc_not_zero() --> refcount_inc_not_zero_acquire()"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:147
msgid "no atomic counterpart --> refcount_add_not_zero_acquire()"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:151
msgid "fully ordered --> ACQUIRE ordering on success"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:155
msgid "case 7) - generic dec/sub decrement-based RMW ops that return a value"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:159
msgid "atomic_dec_and_test() --> refcount_dec_and_test()"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:160
msgid "atomic_sub_and_test() --> refcount_sub_and_test()"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:164
msgid "fully ordered --> RELEASE ordering + ACQUIRE ordering on success"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:168
msgid "case 8) other decrement-based RMW ops that return a value"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:172
msgid "no atomic counterpart --> refcount_dec_if_one()"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:173
msgid "``atomic_add_unless(&var, -1, 1)`` --> ``refcount_dec_not_one(&var)``"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:177
msgid "fully ordered --> RELEASE ordering + control dependency"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:179
msgid "atomic_add_unless() only provides full order on success."
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:183
msgid "case 9) - lock-based RMW"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:187
msgid "atomic_dec_and_lock() --> refcount_dec_and_lock()"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:188
msgid "atomic_dec_and_mutex_lock() --> refcount_dec_and_mutex_lock()"
msgstr ""

#: ../../../core-api/refcount-vs-atomic.rst:192
msgid ""
"fully ordered --> RELEASE ordering + control dependency + hold spin_lock() "
"on success"
msgstr ""
