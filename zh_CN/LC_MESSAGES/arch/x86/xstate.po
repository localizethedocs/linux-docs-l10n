# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/x86/xstate.rst:2
msgid "Using XSTATE features in user space applications"
msgstr ""

#: ../../../arch/x86/xstate.rst:4
msgid ""
"The x86 architecture supports floating-point extensions which are enumerated "
"via CPUID. Applications consult CPUID and use XGETBV to evaluate which "
"features have been enabled by the kernel XCR0."
msgstr ""

#: ../../../arch/x86/xstate.rst:8
msgid ""
"Up to AVX-512 and PKRU states, these features are automatically enabled by "
"the kernel if available. Features like AMX TILE_DATA (XSTATE component 18) "
"are enabled by XCR0 as well, but the first use of related instruction is "
"trapped by the kernel because by default the required large XSTATE buffers "
"are not allocated automatically."
msgstr ""

#: ../../../arch/x86/xstate.rst:15
msgid "The purpose for dynamic features"
msgstr ""

#: ../../../arch/x86/xstate.rst:17
msgid ""
"Legacy userspace libraries often have hard-coded, static sizes for alternate "
"signal stacks, often using MINSIGSTKSZ which is typically 2KB. That stack "
"must be able to store at *least* the signal frame that the kernel sets up "
"before jumping into the signal handler. That signal frame must include an "
"XSAVE buffer defined by the CPU."
msgstr ""

#: ../../../arch/x86/xstate.rst:23
msgid ""
"However, that means that the size of signal stacks is dynamic, not static, "
"because different CPUs have differently-sized XSAVE buffers. A compiled-in "
"size of 2KB with existing applications is too small for new CPU features "
"like AMX. Instead of universally requiring larger stack, with the dynamic "
"enabling, the kernel can enforce userspace applications to have properly-"
"sized altstacks."
msgstr ""

#: ../../../arch/x86/xstate.rst:31
msgid "Using dynamically enabled XSTATE features in user space applications"
msgstr ""

#: ../../../arch/x86/xstate.rst:33
msgid ""
"The kernel provides an arch_prctl(2) based mechanism for applications to "
"request the usage of such features. The arch_prctl(2) options related to "
"this are:"
msgstr ""

#: ../../../arch/x86/xstate.rst:39
msgid "arch_prctl(ARCH_GET_XCOMP_SUPP, &features);"
msgstr ""

#: ../../../arch/x86/xstate.rst:41
msgid ""
"ARCH_GET_XCOMP_SUPP stores the supported features in userspace storage of "
"type uint64_t. The second argument is a pointer to that storage."
msgstr ""

#: ../../../arch/x86/xstate.rst:46
msgid "arch_prctl(ARCH_GET_XCOMP_PERM, &features);"
msgstr ""

#: ../../../arch/x86/xstate.rst:48
msgid ""
"ARCH_GET_XCOMP_PERM stores the features for which the userspace process has "
"permission in userspace storage of type uint64_t. The second argument is a "
"pointer to that storage."
msgstr ""

#: ../../../arch/x86/xstate.rst:54
msgid "arch_prctl(ARCH_REQ_XCOMP_PERM, feature_nr);"
msgstr ""

#: ../../../arch/x86/xstate.rst:56
msgid ""
"ARCH_REQ_XCOMP_PERM allows to request permission for a dynamically enabled "
"feature or a feature set. A feature set can be mapped to a facility, e.g. "
"AMX, and can require one or more XSTATE components to be enabled."
msgstr ""

#: ../../../arch/x86/xstate.rst:60
msgid ""
"The feature argument is the number of the highest XSTATE component which is "
"required for a facility to work."
msgstr ""

#: ../../../arch/x86/xstate.rst:63
msgid ""
"When requesting permission for a feature, the kernel checks the "
"availability. The kernel ensures that sigaltstacks in the process's tasks "
"are large enough to accommodate the resulting large signal frame. It "
"enforces this both during ARCH_REQ_XCOMP_SUPP and during any subsequent "
"sigaltstack(2) calls. If an installed sigaltstack is smaller than the "
"resulting sigframe size, ARCH_REQ_XCOMP_SUPP results in -ENOSUPP. Also, "
"sigaltstack(2) results in -ENOMEM if the requested altstack is too small for "
"the permitted features."
msgstr ""

#: ../../../arch/x86/xstate.rst:72
msgid ""
"Permission, when granted, is valid per process. Permissions are inherited on "
"fork(2) and cleared on exec(3)."
msgstr ""

#: ../../../arch/x86/xstate.rst:75
msgid ""
"The first use of an instruction related to a dynamically enabled feature is "
"trapped by the kernel. The trap handler checks whether the process has "
"permission to use the feature. If the process has no permission then the "
"kernel sends SIGILL to the application. If the process has permission then "
"the handler allocates a larger xstate buffer for the task so the large state "
"can be context switched. In the unlikely cases that the allocation fails, "
"the kernel sends SIGSEGV."
msgstr ""

#: ../../../arch/x86/xstate.rst:84
msgid "AMX TILE_DATA enabling example"
msgstr ""

#: ../../../arch/x86/xstate.rst:86
msgid ""
"Below is the example of how userspace applications enable TILE_DATA "
"dynamically:"
msgstr ""

#: ../../../arch/x86/xstate.rst:89
msgid "The application first needs to query the kernel for AMX support::"
msgstr ""

#: ../../../arch/x86/xstate.rst:122
msgid ""
"After that, determining support for AMX, an application must explicitly ask "
"permission to use it::"
msgstr ""

#: ../../../arch/x86/xstate.rst:136
msgid "Note this example does not include the sigaltstack preparation."
msgstr ""

#: ../../../arch/x86/xstate.rst:139
msgid "Dynamic features in signal frames"
msgstr ""

#: ../../../arch/x86/xstate.rst:141
msgid ""
"Dynamically enabled features are not written to the signal frame upon signal "
"entry if the feature is in its initial configuration.  This differs from non-"
"dynamic features which are always written regardless of their "
"configuration.  Signal handlers can examine the XSAVE buffer's XSTATE_BV "
"field to determine if a features was written."
msgstr ""

#: ../../../arch/x86/xstate.rst:148
msgid "Dynamic features for virtual machines"
msgstr ""

#: ../../../arch/x86/xstate.rst:150
msgid ""
"The permission for the guest state component needs to be managed separately "
"from the host, as they are exclusive to each other. A coupled of options are "
"extended to control the guest permission:"
msgstr ""

#: ../../../arch/x86/xstate.rst:156
msgid "arch_prctl(ARCH_GET_XCOMP_GUEST_PERM, &features);"
msgstr ""

#: ../../../arch/x86/xstate.rst:158
msgid ""
"ARCH_GET_XCOMP_GUEST_PERM is a variant of ARCH_GET_XCOMP_PERM. So it "
"provides the same semantics and functionality but for the guest components."
msgstr ""

#: ../../../arch/x86/xstate.rst:164
msgid "arch_prctl(ARCH_REQ_XCOMP_GUEST_PERM, feature_nr);"
msgstr ""

#: ../../../arch/x86/xstate.rst:166
msgid ""
"ARCH_REQ_XCOMP_GUEST_PERM is a variant of ARCH_REQ_XCOMP_PERM. It has the "
"same semantics for the guest permission. While providing a similar "
"functionality, this comes with a constraint. Permission is frozen when the "
"first VCPU is created. Any attempt to change permission after that point is "
"going to be rejected. So, the permission has to be requested before the "
"first VCPU creation."
msgstr ""

#: ../../../arch/x86/xstate.rst:173
msgid ""
"Note that some VMMs may have already established a set of supported state "
"components. These options are not presumed to support any particular VMM."
msgstr ""
