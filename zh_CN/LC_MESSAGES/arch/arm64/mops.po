# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/arm64/mops.rst:5
msgid "Memory copy/set instructions (MOPS)"
msgstr ""

#: ../../../arch/arm64/mops.rst:7
msgid ""
"A MOPS memory copy/set operation consists of three consecutive CPY* or SET* "
"instructions: a prologue, main and epilogue (for example: CPYP, CPYM, CPYE)."
msgstr ""

#: ../../../arch/arm64/mops.rst:10
msgid ""
"A main or epilogue instruction can take a MOPS exception for various "
"reasons, for example when a task is migrated to a CPU with a different MOPS "
"implementation, or when the instruction's alignment and size requirements "
"are not met. The software exception handler is then expected to reset the "
"registers and restart execution from the prologue instruction. Normally this "
"is handled by the kernel."
msgstr ""

#: ../../../arch/arm64/mops.rst:17
msgid ""
"For more details refer to \"D1.3.5.7 Memory Copy and Memory Set exceptions\" "
"in the Arm Architecture Reference Manual DDI 0487K.a (Arm ARM)."
msgstr ""

#: ../../../arch/arm64/mops.rst:23
msgid "Hypervisor requirements"
msgstr ""

#: ../../../arch/arm64/mops.rst:25
msgid ""
"A hypervisor running a Linux guest must handle all MOPS exceptions from the "
"guest kernel, as Linux may not be able to handle the exception at all times. "
"For example, a MOPS exception can be taken when the hypervisor migrates a "
"vCPU to another physical CPU with a different MOPS implementation."
msgstr ""

#: ../../../arch/arm64/mops.rst:30
msgid "To do this, the hypervisor must:"
msgstr ""

#: ../../../arch/arm64/mops.rst:32
msgid ""
"Set HCRX_EL2.MCE2 to 1 so that the exception is taken to the hypervisor."
msgstr ""

#: ../../../arch/arm64/mops.rst:34
msgid ""
"Have an exception handler that implements the algorithm from the Arm ARM "
"rules CNTMJ and MWFQH."
msgstr ""

#: ../../../arch/arm64/mops.rst:37
msgid ""
"Set the guest's PSTATE.SS to 0 in the exception handler, to handle a "
"potential step of the current instruction."
msgstr ""

#: ../../../arch/arm64/mops.rst:40
msgid ""
"Note: Clearing PSTATE.SS is needed so that a single step exception is taken "
"on the next instruction (the prologue instruction). Otherwise prologue would "
"get silently stepped over and the single step exception taken on the main "
"instruction. Note that if the guest instruction is not being stepped then "
"clearing PSTATE.SS has no effect."
msgstr ""
