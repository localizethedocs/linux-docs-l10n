# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/powerpc/transactional_memory.rst:3
msgid "Transactional Memory support"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:5
msgid ""
"POWER kernel support for this feature is currently limited to supporting its "
"use by user programs.  It is not currently used by the kernel itself."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:8
msgid ""
"This file aims to sum up how it is supported by Linux and what behaviour you "
"can expect from your user programs."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:13
msgid "Basic overview"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:15
msgid ""
"Hardware Transactional Memory is supported on POWER8 processors, and is a "
"feature that enables a different form of atomic memory access.  Several new "
"instructions are presented to delimit transactions; transactions are "
"guaranteed to either complete atomically or roll back and undo any partial "
"changes."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:21
msgid "A simple transaction looks like this::"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:46
msgid ""
"The 'tbegin' instruction denotes the start point, and 'tend' the end point. "
"Between these points the processor is in 'Transactional' state; any memory "
"references will complete in one go if there are no conflicts with other "
"transactional or non-transactional accesses within the system.  In this "
"example, the transaction completes as though it were normal straight-line "
"code IF no other processor has touched SAVINGS_ACCT(r3) or CURRENT_ACCT(r3); "
"an atomic move of money from the current account to the savings account has "
"been performed.  Even though the normal ld/std instructions are used (note "
"no lwarx/stwcx), either *both* SAVINGS_ACCT(r3) and CURRENT_ACCT(r3) will be "
"updated, or neither will be updated."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:57
msgid ""
"If, in the meantime, there is a conflict with the locations accessed by the "
"transaction, the transaction will be aborted by the CPU.  Register and "
"memory state will roll back to that at the 'tbegin', and control will "
"continue from 'tbegin+4'.  The branch to abort_handler will be taken this "
"second time; the abort handler can check the cause of the failure, and retry."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:63
msgid ""
"Checkpointed registers include all GPRs, FPRs, VRs/VSRs, LR, CCR/CR, CTR, "
"FPCSR and a few other status/flag regs; see the ISA for details."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:67
msgid "Causes of transaction aborts"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:69
msgid "Conflicts with cache lines used by other processors"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:70
#: ../../../arch/powerpc/transactional_memory.rst:98
msgid "Signals"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:71
msgid "Context switches"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:72
msgid ""
"See the ISA for full documentation of everything that will abort "
"transactions."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:76
msgid "Syscalls"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:78
msgid ""
"Syscalls made from within an active transaction will not be performed and "
"the transaction will be doomed by the kernel with the failure code "
"TM_CAUSE_SYSCALL | TM_CAUSE_PERSISTENT."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:82
msgid ""
"Syscalls made from within a suspended transaction are performed as normal "
"and the transaction is not explicitly doomed by the kernel.  However, what "
"the kernel does to perform the syscall may result in the transaction being "
"doomed by the hardware.  The syscall is performed in suspended mode so any "
"side effects will be persistent, independent of transaction success or "
"failure.  No guarantees are provided by the kernel about which syscalls will "
"affect transaction success."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:90
msgid ""
"Care must be taken when relying on syscalls to abort during active "
"transactions if the calls are made via a library.  Libraries may cache "
"values (which may give the appearance of success) or perform operations that "
"cause transaction failure before entering the kernel (which may produce "
"different failure codes). Examples are glibc's getpid() and lazy symbol "
"resolution."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:100
msgid ""
"Delivery of signals (both sync and async) during transactions provides a "
"second thread state (ucontext/mcontext) to represent the second "
"transactional register state.  Signal delivery 'treclaim's to capture both "
"register states, so signals abort transactions.  The usual ucontext_t passed "
"to the signal handler represents the checkpointed/original register state; "
"the signal appears to have arisen at 'tbegin+4'."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:107
msgid ""
"If the sighandler ucontext has uc_link set, a second ucontext has been "
"delivered.  For future compatibility the MSR.TS field should be checked to "
"determine the transactional state -- if so, the second ucontext in uc-"
">uc_link represents the active transactional registers at the point of the "
"signal."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:112
msgid ""
"For 64-bit processes, uc->uc_mcontext.regs->msr is a full 64-bit MSR and its "
"TS field shows the transactional mode."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:115
msgid ""
"For 32-bit processes, the mcontext's MSR register is only 32 bits; the top "
"32 bits are stored in the MSR of the second ucontext, i.e. in uc->uc_link-"
">uc_mcontext.regs->msr.  The top word contains the transactional state TS."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:120
msgid ""
"However, basic signal handlers don't need to be aware of transactions and "
"simply returning from the handler will deal with things correctly:"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:123
msgid ""
"Transaction-aware signal handlers can read the transactional register state "
"from the second ucontext.  This will be necessary for crash handlers to "
"determine, for example, the address of the instruction causing the SIGSEGV."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:127
msgid "Example signal handler::"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:152
msgid ""
"When in an active transaction that takes a signal, we need to be careful "
"with the stack.  It's possible that the stack has moved back up after the "
"tbegin. The obvious case here is when the tbegin is called inside a function "
"that returns before a tend.  In this case, the stack is part of the "
"checkpointed transactional memory state.  If we write over this non "
"transactionally or in suspend, we are in trouble because if we get a tm "
"abort, the program counter and stack pointer will be back at the tbegin but "
"our in memory stack won't be valid anymore."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:161
msgid ""
"To avoid this, when taking a signal in an active transaction, we need to use "
"the stack pointer from the checkpointed state, rather than the speculated "
"state.  This ensures that the signal context (written tm suspended) will be "
"written below the stack required for the rollback.  The transaction is "
"aborted because of the treclaim, so any memory written between the tbegin "
"and the signal will be rolled back anyway."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:168
msgid ""
"For signals taken in non-TM or suspended mode, we use the normal/non-"
"checkpointed stack pointer."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:171
msgid ""
"Any transaction initiated inside a sighandler and suspended on return from "
"the sighandler to the kernel will get reclaimed and discarded."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:175
msgid "Failure cause codes used by kernel"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:177
msgid ""
"These are defined in <asm/reg.h>, and distinguish different reasons why the "
"kernel aborted a transaction:"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:181
msgid "TM_CAUSE_RESCHED"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:181
msgid "Thread was rescheduled."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:182
msgid "TM_CAUSE_TLBI"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:182
msgid "Software TLB invalid."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:183
msgid "TM_CAUSE_FAC_UNAV"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:183
msgid "FP/VEC/VSX unavailable trap."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:184
msgid "TM_CAUSE_SYSCALL"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:184
msgid "Syscall from active transaction."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:185
msgid "TM_CAUSE_SIGNAL"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:185
msgid "Signal delivered."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:186
msgid "TM_CAUSE_MISC"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:186
msgid "Currently unused."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:187
msgid "TM_CAUSE_ALIGNMENT"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:187
msgid "Alignment fault."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:188
msgid "TM_CAUSE_EMULATE"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:188
msgid "Emulation that touched memory."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:191
msgid ""
"These can be checked by the user program's abort handler as TEXASR[0:7].  If "
"bit 7 is set, it indicates that the error is considered persistent.  For "
"example a TM_CAUSE_ALIGNMENT will be persistent while a TM_CAUSE_RESCHED "
"will not."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:196
msgid "GDB"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:198
msgid ""
"GDB and ptrace are not currently TM-aware.  If one stops during a "
"transaction, it looks like the transaction has just started (the "
"checkpointed state is presented).  The transaction cannot then be continued "
"and will take the failure handler route.  Furthermore, the transactional 2nd "
"register state will be inaccessible.  GDB can currently be used on programs "
"using TM, but not sensibly in parts within transactions."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:206
msgid "POWER9"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:208
msgid ""
"TM on POWER9 has issues with storing the complete register state. This is "
"described in this commit::"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:216
msgid ""
"To account for this different POWER9 chips have TM enabled in different ways."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:219
msgid ""
"On POWER9N DD2.01 and below, TM is disabled. ie HWCAP2[PPC_FEATURE2_HTM] is "
"not set."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:222
msgid ""
"On POWER9N DD2.1 TM is configured by firmware to always abort a transaction "
"when tm suspend occurs. So tsuspend will cause a transaction to be aborted "
"and rolled back. Kernel exceptions will also cause the transaction to be "
"aborted and rolled back and the exception will not occur. If userspace "
"constructs a sigcontext that enables TM suspend, the sigcontext will be "
"rejected by the kernel. This mode is advertised to users with "
"HWCAP2[PPC_FEATURE2_HTM_NO_SUSPEND] set. HWCAP2[PPC_FEATURE2_HTM] is not set "
"in this mode."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:231
msgid ""
"On POWER9N DD2.2 and above, KVM and POWERVM emulate TM for guests (as "
"described in commit 4bb3c7a0208f), hence TM is enabled for guests ie. "
"HWCAP2[PPC_FEATURE2_HTM] is set for guest userspace. Guests that makes heavy "
"use of TM suspend (tsuspend or kernel suspend) will result in traps into the "
"hypervisor and hence will suffer a performance degradation. Host userspace "
"has TM disabled ie. HWCAP2[PPC_FEATURE2_HTM] is not set. (although we make "
"enable it at some point in the future if we bring the emulation into host "
"userspace context switching)."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:241
msgid ""
"POWER9C DD1.2 and above are only available with POWERVM and hence Linux only "
"runs as a guest. On these systems TM is emulated like on POWER9N DD2.2."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:245
msgid ""
"Guest migration from POWER8 to POWER9 will work with POWER9N DD2.2 and "
"POWER9C DD1.2. Since earlier POWER9 processors don't support TM emulation, "
"migration from POWER8 to POWER9 is not supported there."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:250
msgid "Kernel implementation"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:253
msgid "h/rfid mtmsrd quirk"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:255
msgid ""
"As defined in the ISA, rfid has a quirk which is useful in early exception "
"handling. When in a userspace transaction and we enter the kernel via some "
"exception, MSR will end up as TM=0 and TS=01 (ie. TM off but TM suspended). "
"Regularly the kernel will want change bits in the MSR and will perform an "
"rfid to do this. In this case rfid can have SRR0 TM = 0 and TS = 00 (ie. TM "
"off and non transaction) and the resulting MSR will retain TM = 0 and TS=01 "
"from before (ie. stay in suspend). This is a quirk in the architecture as "
"this would normally be a transition from TS=01 to TS=00 (ie. suspend -> non "
"transactional) which is an illegal transition."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:266
msgid ""
"This quirk is described the architecture in the definition of rfid with "
"these lines:"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:269
msgid "if (MSR 29:31 ¬ = 0b010 | SRR1 29:31 ¬ = 0b000) then"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:270
msgid "MSR 29:31 <- SRR1 29:31"
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:272
msgid "hrfid and mtmsrd have the same quirk."
msgstr ""

#: ../../../arch/powerpc/transactional_memory.rst:274
msgid "The Linux kernel uses this quirk in its early exception handling."
msgstr ""
