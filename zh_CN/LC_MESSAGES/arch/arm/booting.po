# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../arch/arm/booting.rst:3
msgid "Booting ARM Linux"
msgstr ""

#: ../../../arch/arm/booting.rst:5
msgid "Author: Russell King"
msgstr ""

#: ../../../arch/arm/booting.rst:7
msgid "Date  : 18 May 2002"
msgstr ""

#: ../../../arch/arm/booting.rst:9
msgid "The following documentation is relevant to 2.4.18-rmk6 and beyond."
msgstr ""

#: ../../../arch/arm/booting.rst:11
msgid ""
"In order to boot ARM Linux, you require a boot loader, which is a small "
"program that runs before the main kernel.  The boot loader is expected to "
"initialise various devices, and eventually call the Linux kernel, passing "
"information to the kernel."
msgstr ""

#: ../../../arch/arm/booting.rst:16
msgid ""
"Essentially, the boot loader should provide (as a minimum) the following:"
msgstr ""

#: ../../../arch/arm/booting.rst:19
msgid "Setup and initialise the RAM."
msgstr ""

#: ../../../arch/arm/booting.rst:20
msgid "Initialise one serial port."
msgstr ""

#: ../../../arch/arm/booting.rst:21
msgid "Detect the machine type."
msgstr ""

#: ../../../arch/arm/booting.rst:22
msgid "Setup the kernel tagged list."
msgstr ""

#: ../../../arch/arm/booting.rst:23
msgid "Load initramfs."
msgstr ""

#: ../../../arch/arm/booting.rst:24
msgid "Call the kernel image."
msgstr ""

#: ../../../arch/arm/booting.rst:28
msgid "1. Setup and initialise RAM"
msgstr ""

#: ../../../arch/arm/booting.rst:30 ../../../arch/arm/booting.rst:46
#: ../../../arch/arm/booting.rst:66 ../../../arch/arm/booting.rst:85
#: ../../../arch/arm/booting.rst:147 ../../../arch/arm/booting.rst:164
msgid "Existing boot loaders:"
msgstr ""

#: ../../../arch/arm/booting.rst:31 ../../../arch/arm/booting.rst:33
#: ../../../arch/arm/booting.rst:88 ../../../arch/arm/booting.rst:165
#: ../../../arch/arm/booting.rst:167
msgid "MANDATORY"
msgstr ""

#: ../../../arch/arm/booting.rst:32 ../../../arch/arm/booting.rst:48
#: ../../../arch/arm/booting.rst:68 ../../../arch/arm/booting.rst:87
#: ../../../arch/arm/booting.rst:149 ../../../arch/arm/booting.rst:166
msgid "New boot loaders:"
msgstr ""

#: ../../../arch/arm/booting.rst:35
msgid ""
"The boot loader is expected to find and initialise all RAM that the kernel "
"will use for volatile data storage in the system.  It performs this in a "
"machine dependent manner.  (It may use internal algorithms to automatically "
"locate and size all RAM, or it may use knowledge of the RAM in the machine, "
"or any other method the boot loader designer sees fit.)"
msgstr ""

#: ../../../arch/arm/booting.rst:44
msgid "2. Initialise one serial port"
msgstr ""

#: ../../../arch/arm/booting.rst:47 ../../../arch/arm/booting.rst:49
msgid "OPTIONAL, RECOMMENDED"
msgstr ""

#: ../../../arch/arm/booting.rst:51
msgid ""
"The boot loader should initialise and enable one serial port on the target.  "
"This allows the kernel serial driver to automatically detect which serial "
"port it should use for the kernel console (generally used for debugging "
"purposes, or communication with the target.)"
msgstr ""

#: ../../../arch/arm/booting.rst:56
msgid ""
"As an alternative, the boot loader can pass the relevant 'console=' option "
"to the kernel via the tagged lists specifying the port, and serial format "
"options as described in"
msgstr ""

#: ../../../arch/arm/booting.rst:60
msgid "Documentation/admin-guide/kernel-parameters.rst."
msgstr ""

#: ../../../arch/arm/booting.rst:64
msgid "3. Detect the machine type"
msgstr ""

#: ../../../arch/arm/booting.rst:67 ../../../arch/arm/booting.rst:148
#: ../../../arch/arm/booting.rst:150
msgid "OPTIONAL"
msgstr ""

#: ../../../arch/arm/booting.rst:69
msgid "MANDATORY except for DT-only platforms"
msgstr ""

#: ../../../arch/arm/booting.rst:71
msgid ""
"The boot loader should detect the machine type its running on by some "
"method.  Whether this is a hard coded value or some algorithm that looks at "
"the connected hardware is beyond the scope of this document. The boot loader "
"must ultimately be able to provide a MACH_TYPE_xxx value to the kernel. (see "
"linux/arch/arm/tools/mach-types).  This should be passed to the kernel in "
"register r1."
msgstr ""

#: ../../../arch/arm/booting.rst:78
msgid ""
"For DT-only platforms, the machine type will be determined by device tree.  "
"set the machine type to all ones (~0).  This is not strictly necessary, but "
"assures that it will not match any existing types."
msgstr ""

#: ../../../arch/arm/booting.rst:83
msgid "4. Setup boot data"
msgstr ""

#: ../../../arch/arm/booting.rst:86
msgid "OPTIONAL, HIGHLY RECOMMENDED"
msgstr ""

#: ../../../arch/arm/booting.rst:90
msgid ""
"The boot loader must provide either a tagged list or a dtb image for passing "
"configuration data to the kernel.  The physical address of the boot data is "
"passed to the kernel in register r2."
msgstr ""

#: ../../../arch/arm/booting.rst:95
msgid "4a. Setup the kernel tagged list"
msgstr ""

#: ../../../arch/arm/booting.rst:97
msgid ""
"The boot loader must create and initialise the kernel tagged list. A valid "
"tagged list starts with ATAG_CORE and ends with ATAG_NONE. The ATAG_CORE tag "
"may or may not be empty.  An empty ATAG_CORE tag has the size field set to "
"'2' (0x00000002).  The ATAG_NONE must set the size field to zero."
msgstr ""

#: ../../../arch/arm/booting.rst:103
msgid ""
"Any number of tags can be placed in the list.  It is undefined whether a "
"repeated tag appends to the information carried by the previous tag, or "
"whether it replaces the information in its entirety; some tags behave as the "
"former, others the latter."
msgstr ""

#: ../../../arch/arm/booting.rst:108
msgid ""
"The boot loader must pass at a minimum the size and location of the system "
"memory, and root filesystem location.  Therefore, the minimum tagged list "
"should look::"
msgstr ""

#: ../../../arch/arm/booting.rst:120
msgid "The tagged list should be stored in system RAM."
msgstr ""

#: ../../../arch/arm/booting.rst:122
msgid ""
"The tagged list must be placed in a region of memory where neither the "
"kernel decompressor nor initrd 'bootp' program will overwrite it.  The "
"recommended placement is in the first 16KiB of RAM."
msgstr ""

#: ../../../arch/arm/booting.rst:127
msgid "4b. Setup the device tree"
msgstr ""

#: ../../../arch/arm/booting.rst:129
msgid ""
"The boot loader must load a device tree image (dtb) into system ram at a "
"64bit aligned address and initialize it with the boot data.  The dtb format "
"is documented at https://www.devicetree.org/specifications/. The kernel will "
"look for the dtb magic value of 0xd00dfeed at the dtb physical address to "
"determine if a dtb has been passed instead of a tagged list."
msgstr ""

#: ../../../arch/arm/booting.rst:136
msgid ""
"The boot loader must pass at a minimum the size and location of the system "
"memory, and the root filesystem location.  The dtb must be placed in a "
"region of memory where the kernel decompressor will not overwrite it, while "
"remaining within the region which will be covered by the kernel's low-memory "
"mapping."
msgstr ""

#: ../../../arch/arm/booting.rst:142
msgid "A safe location is just above the 128MiB boundary from start of RAM."
msgstr ""

#: ../../../arch/arm/booting.rst:145
msgid "5. Load initramfs."
msgstr ""

#: ../../../arch/arm/booting.rst:152
msgid ""
"If an initramfs is in use then, as with the dtb, it must be placed in a "
"region of memory where the kernel decompressor will not overwrite it while "
"also with the region which will be covered by the kernel's low-memory "
"mapping."
msgstr ""

#: ../../../arch/arm/booting.rst:157
msgid ""
"A safe location is just above the device tree blob which itself will be "
"loaded just above the 128MiB boundary from the start of RAM as recommended "
"above."
msgstr ""

#: ../../../arch/arm/booting.rst:162
msgid "6. Calling the kernel image"
msgstr ""

#: ../../../arch/arm/booting.rst:169
msgid ""
"There are two options for calling the kernel zImage.  If the zImage is "
"stored in flash, and is linked correctly to be run from flash, then it is "
"legal for the boot loader to call the zImage in flash directly."
msgstr ""

#: ../../../arch/arm/booting.rst:174
msgid ""
"The zImage may also be placed in system RAM and called there.  The kernel "
"should be placed in the first 128MiB of RAM.  It is recommended that it is "
"loaded above 32MiB in order to avoid the need to relocate prior to "
"decompression, which will make the boot process slightly faster."
msgstr ""

#: ../../../arch/arm/booting.rst:180
msgid ""
"When booting a raw (non-zImage) kernel the constraints are tighter. In this "
"case the kernel must be loaded at an offset into system equal to TEXT_OFFSET "
"- PAGE_OFFSET."
msgstr ""

#: ../../../arch/arm/booting.rst:184
msgid "In any case, the following conditions must be met:"
msgstr ""

#: ../../../arch/arm/booting.rst:186
msgid ""
"Quiesce all DMA capable devices so that memory does not get corrupted by "
"bogus network packets or disk data. This will save you many hours of debug."
msgstr ""

#: ../../../arch/arm/booting.rst:190
msgid "CPU register settings"
msgstr ""

#: ../../../arch/arm/booting.rst:192
msgid "r0 = 0,"
msgstr ""

#: ../../../arch/arm/booting.rst:193
msgid "r1 = machine type number discovered in (3) above."
msgstr ""

#: ../../../arch/arm/booting.rst:194
msgid ""
"r2 = physical address of tagged list in system RAM, or physical address of "
"device tree block (dtb) in system RAM"
msgstr ""

#: ../../../arch/arm/booting.rst:197
msgid "CPU mode"
msgstr ""

#: ../../../arch/arm/booting.rst:199
msgid "All forms of interrupts must be disabled (IRQs and FIQs)"
msgstr ""

#: ../../../arch/arm/booting.rst:201
msgid ""
"For CPUs which do not include the ARM virtualization extensions, the CPU "
"must be in SVC mode.  (A special exception exists for Angel)"
msgstr ""

#: ../../../arch/arm/booting.rst:204
msgid ""
"CPUs which include support for the virtualization extensions can be entered "
"in HYP mode in order to enable the kernel to make full use of these "
"extensions.  This is the recommended boot method for such CPUs, unless the "
"virtualisations are already in use by a pre-installed hypervisor."
msgstr ""

#: ../../../arch/arm/booting.rst:210
msgid ""
"If the kernel is not entered in HYP mode for any reason, it must be entered "
"in SVC mode."
msgstr ""

#: ../../../arch/arm/booting.rst:213
msgid "Caches, MMUs"
msgstr ""

#: ../../../arch/arm/booting.rst:215
msgid "The MMU must be off."
msgstr ""

#: ../../../arch/arm/booting.rst:217
msgid "Instruction cache may be on or off."
msgstr ""

#: ../../../arch/arm/booting.rst:219
msgid "Data cache must be off."
msgstr ""

#: ../../../arch/arm/booting.rst:221
msgid ""
"If the kernel is entered in HYP mode, the above requirements apply to the "
"HYP mode configuration in addition to the ordinary PL1 (privileged kernel "
"modes) configuration.  In addition, all traps into the hypervisor must be "
"disabled, and PL1 access must be granted for all peripherals and CPU "
"resources for which this is architecturally possible.  Except for entering "
"in HYP mode, the system configuration should be such that a kernel which "
"does not include support for the virtualization extensions can boot "
"correctly without extra help."
msgstr ""

#: ../../../arch/arm/booting.rst:230
msgid ""
"The boot loader is expected to call the kernel image by jumping directly to "
"the first instruction of the kernel image."
msgstr ""

#: ../../../arch/arm/booting.rst:233
msgid ""
"On CPUs supporting the ARM instruction set, the entry must be made in ARM "
"state, even for a Thumb-2 kernel."
msgstr ""

#: ../../../arch/arm/booting.rst:236
msgid ""
"On CPUs supporting only the Thumb instruction set such as Cortex-M class "
"CPUs, the entry must be made in Thumb state."
msgstr ""
