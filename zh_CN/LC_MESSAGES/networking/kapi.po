# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-20 11:24+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/kapi.rst:3
msgid "Linux Networking and Network Devices APIs"
msgstr ""

#: ../../../networking/kapi.rst:6
msgid "Linux Networking"
msgstr ""

#: ../../../networking/kapi.rst:9
msgid "Networking Base Types"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:49
msgid "Socket types"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1669
#: ../../../networking/kapi:11: include/linux/net.h:53 include/linux/net.h:91
#: ../../../networking/kapi:125: include/linux/phy.h:74 include/linux/phy.h:472
#: include/linux/phy.h:809
msgid "**Constants**"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:55
msgid "``SOCK_STREAM``"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:56
msgid "stream (connection) socket"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:58
msgid "``SOCK_DGRAM``"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:59
msgid "datagram (conn.less) socket"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:61
msgid "``SOCK_RAW``"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:62
msgid "raw socket"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:64
msgid "``SOCK_RDM``"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:65
msgid "reliably-delivered message"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:67
msgid "``SOCK_SEQPACKET``"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:68
msgid "sequential packet socket"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:70
msgid "``SOCK_DCCP``"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:71
msgid "Datagram Congestion Control Protocol socket"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:73
msgid "``SOCK_PACKET``"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:74
msgid ""
"linux specific way of getting packets at the dev level. For writing rarp and "
"other similar things on the user level."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:87
#: include/linux/etherdevice.h:109 include/linux/etherdevice.h:173
#: include/linux/etherdevice.h:197 include/linux/etherdevice.h:215
#: include/linux/etherdevice.h:233 include/linux/etherdevice.h:247
#: include/linux/etherdevice.h:258 include/linux/etherdevice.h:270
#: include/linux/etherdevice.h:287 include/linux/etherdevice.h:299
#: include/linux/etherdevice.h:321 include/linux/etherdevice.h:333
#: include/linux/etherdevice.h:348 include/linux/etherdevice.h:372
#: include/linux/etherdevice.h:401 include/linux/etherdevice.h:420
#: include/linux/etherdevice.h:533 include/linux/etherdevice.h:561
#: include/linux/etherdevice.h:599 include/linux/etherdevice.h:619
#: include/linux/etherdevice.h:651 ../../../networking/kapi:104:
#: include/linux/netdevice.h:522 include/linux/netdevice.h:547
#: include/linux/netdevice.h:567 include/linux/netdevice.h:580
#: include/linux/netdevice.h:606 include/linux/netdevice.h:624
#: include/linux/netdevice.h:1772 include/linux/netdevice.h:1855
#: include/linux/netdevice.h:2741 include/linux/netdevice.h:2808
#: include/linux/netdevice.h:2866 include/linux/netdevice.h:2883
#: include/linux/netdevice.h:2904 include/linux/netdevice.h:3584
#: include/linux/netdevice.h:3607 include/linux/netdevice.h:3641
#: include/linux/netdevice.h:3660 include/linux/netdevice.h:3689
#: include/linux/netdevice.h:3716 include/linux/netdevice.h:3730
#: include/linux/netdevice.h:3745 include/linux/netdevice.h:3805
#: include/linux/netdevice.h:3829 include/linux/netdevice.h:3862
#: include/linux/netdevice.h:3895 include/linux/netdevice.h:3908
#: include/linux/netdevice.h:3927 include/linux/netdevice.h:3946
#: include/linux/netdevice.h:3960 include/linux/netdevice.h:3973
#: include/linux/netdevice.h:3988 include/linux/netdevice.h:4001
#: include/linux/netdevice.h:4022 include/linux/netdevice.h:4121
#: include/linux/netdevice.h:4421 include/linux/netdevice.h:4433
#: include/linux/netdevice.h:4472 include/linux/netdevice.h:4482
#: include/linux/netdevice.h:4501 include/linux/netdevice.h:4519
#: include/linux/netdevice.h:4531 include/linux/netdevice.h:4543
#: include/linux/netdevice.h:4559 include/linux/netdevice.h:4571
#: include/linux/netdevice.h:4583 include/linux/netdevice.h:4597
#: include/linux/netdevice.h:4763 include/linux/netdevice.h:4948
#: include/linux/netdevice.h:4965 include/linux/netdevice.h:4992
#: include/linux/netdevice.h:5009 ../../../networking/kapi:107:
#: include/net/net_shaper.h:118 ../../../networking/kapi:113:
#: drivers/net/phy/phy.c:139 drivers/net/phy/phy.c:181
#: drivers/net/phy/phy.c:201 drivers/net/phy/phy.c:240
#: drivers/net/phy/phy.c:306 drivers/net/phy/phy.c:453
#: drivers/net/phy/phy.c:1040 drivers/net/phy/phy.c:1061
#: drivers/net/phy/phy.c:1088 drivers/net/phy/phy.c:1120
#: drivers/net/phy/phy.c:1221 drivers/net/phy/phy.c:1268
#: drivers/net/phy/phy.c:1302 drivers/net/phy/phy.c:1354
#: drivers/net/phy/phy.c:1446 drivers/net/phy/phy.c:1475
#: drivers/net/phy/phy.c:1677 drivers/net/phy/phy.c:1711
#: drivers/net/phy/phy.c:1727 drivers/net/phy/phy.c:1812
#: drivers/net/phy/phy.c:1833 drivers/net/phy/phy.c:1854
#: drivers/net/phy/phy.c:1883 drivers/net/phy/phy.c:1906
#: drivers/net/phy/phy.c:1965 ../../../networking/kapi:116:
#: drivers/net/phy/phy.c:166 drivers/net/phy/phy.c:222
#: drivers/net/phy/phy.c:252 drivers/net/phy/phy.c:471
#: drivers/net/phy/phy.c:609 drivers/net/phy/phy.c:630
#: drivers/net/phy/phy.c:651 drivers/net/phy/phy.c:683
#: drivers/net/phy/phy.c:712 drivers/net/phy/phy.c:812
#: drivers/net/phy/phy.c:997 drivers/net/phy/phy.c:1318
#: drivers/net/phy/phy.c:1380 drivers/net/phy/phy.c:1429
#: drivers/net/phy/phy.c:1489 drivers/net/phy/phy.c:1931
#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:175
#: drivers/net/phy/phy-core.c:264 drivers/net/phy/phy-core.c:285
#: drivers/net/phy/phy-core.c:413 drivers/net/phy/phy-core.c:435
#: drivers/net/phy/phy-core.c:457 drivers/net/phy/phy-core.c:480
#: drivers/net/phy/phy-core.c:571 drivers/net/phy/phy-core.c:690
#: drivers/net/phy/phy-core.c:706 drivers/net/phy/phy-core.c:736
#: drivers/net/phy/phy-core.c:775 drivers/net/phy/phy-core.c:796
#: drivers/net/phy/phy-core.c:818 drivers/net/phy/phy-core.c:841
#: ../../../networking/kapi:11: include/linux/net.h:77
#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:263
#: drivers/net/phy/phy-c45.c:315 drivers/net/phy/phy-c45.c:336
#: drivers/net/phy/phy-c45.c:357 drivers/net/phy/phy-c45.c:390
#: drivers/net/phy/phy-c45.c:415 drivers/net/phy/phy-c45.c:517
#: drivers/net/phy/phy-c45.c:956 drivers/net/phy/phy-c45.c:994
#: drivers/net/phy/phy-c45.c:1067 drivers/net/phy/phy-c45.c:1162
#: drivers/net/phy/phy-c45.c:1201 drivers/net/phy/phy-c45.c:1247
#: drivers/net/phy/phy-c45.c:1282 drivers/net/phy/phy-c45.c:1336
#: drivers/net/phy/phy-c45.c:1450 drivers/net/phy/phy-c45.c:1473
#: drivers/net/phy/phy-c45.c:1505 drivers/net/phy/phy-c45.c:1530
#: ../../../networking/kapi:125: include/linux/phy.h:3 include/linux/phy.h:193
#: include/linux/phy.h:206 include/linux/phy.h:298 include/linux/phy.h:431
#: include/linux/phy.h:580 include/linux/phy.h:793 include/linux/phy.h:820
#: include/linux/phy.h:852 include/linux/phy.h:873 include/linux/phy.h:1278
#: include/linux/phy.h:1295 include/linux/phy.h:1334 include/linux/phy.h:1418
#: include/linux/phy.h:1446 include/linux/phy.h:1461 include/linux/phy.h:1553
#: include/linux/phy.h:1566 include/linux/phy.h:1604 include/linux/phy.h:1620
#: include/linux/phy.h:1751 include/linux/phy.h:1787 include/linux/phy.h:2140
#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:557
#: drivers/net/phy/phy_device.c:1095 drivers/net/phy/phy_device.c:1184
#: drivers/net/phy/phy_device.c:1206 drivers/net/phy/phy_device.c:1287
#: drivers/net/phy/phy_device.c:1510 drivers/net/phy/phy_device.c:1532
#: drivers/net/phy/phy_device.c:1552 drivers/net/phy/phy_device.c:1569
#: drivers/net/phy/phy_device.c:1618 drivers/net/phy/phy_device.c:1791
#: drivers/net/phy/phy_device.c:1827 drivers/net/phy/phy_device.c:1963
#: drivers/net/phy/phy_device.c:2075 drivers/net/phy/phy_device.c:2189
#: drivers/net/phy/phy_device.c:2219 drivers/net/phy/phy_device.c:2275
#: drivers/net/phy/phy_device.c:2323 drivers/net/phy/phy_device.c:2339
#: drivers/net/phy/phy_device.c:2439 drivers/net/phy/phy_device.c:2469
#: drivers/net/phy/phy_device.c:2521 drivers/net/phy/phy_device.c:2584
#: drivers/net/phy/phy_device.c:2636 drivers/net/phy/phy_device.c:2752
#: drivers/net/phy/phy_device.c:2775 drivers/net/phy/phy_device.c:2792
#: drivers/net/phy/phy_device.c:2808 drivers/net/phy/phy_device.c:2836
#: drivers/net/phy/phy_device.c:2853 drivers/net/phy/phy_device.c:2867
#: drivers/net/phy/phy_device.c:2882 drivers/net/phy/phy_device.c:2905
#: drivers/net/phy/phy_device.c:2928 drivers/net/phy/phy_device.c:2956
#: drivers/net/phy/phy_device.c:2993 drivers/net/phy/phy_device.c:3320
#: drivers/net/phy/phy_device.c:3344 drivers/net/phy/phy_device.c:3368
#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:271
#: drivers/net/phy/phy_device.c:935 drivers/net/phy/phy_device.c:1033
#: drivers/net/phy/phy_device.c:1239 drivers/net/phy/phy_device.c:1345
#: drivers/net/phy/phy_device.c:1990 drivers/net/phy/phy_device.c:2041
#: drivers/net/phy/phy_device.c:3392 ../../../networking/kapi:134:
#: drivers/net/phy/mdio_bus.c:373 drivers/net/phy/mdio_bus.c:391
#: drivers/net/phy/mdio_bus.c:439 drivers/net/phy/mdio_bus.c:471
#: drivers/net/phy/mdio_bus.c:504 drivers/net/phy/mdio_bus.c:535
#: drivers/net/phy/mdio_bus.c:568 drivers/net/phy/mdio_bus.c:633
#: drivers/net/phy/mdio_bus.c:704 drivers/net/phy/mdio_bus.c:731
#: drivers/net/phy/mdio_bus.c:806 ../../../networking/kapi:137:
#: drivers/net/phy/mdio_bus.c:138 drivers/net/phy/mdio_bus.c:603
#: drivers/net/phy/mdio_bus.c:942 ../../../networking/kapi:147:
#: include/linux/phylink.h:194 include/linux/phylink.h:222
#: include/linux/phylink.h:234 include/linux/phylink.h:251
#: include/linux/phylink.h:276 include/linux/phylink.h:351
#: include/linux/phylink.h:368 include/linux/phylink.h:393
#: include/linux/phylink.h:421 include/linux/phylink.h:432
#: include/linux/phylink.h:461 include/linux/phylink.h:525
#: include/linux/phylink.h:541 include/linux/phylink.h:568
#: include/linux/phylink.h:589 include/linux/phylink.h:623
#: include/linux/phylink.h:636 include/linux/phylink.h:652
#: include/linux/phylink.h:660 include/linux/phylink.h:668
#: include/linux/phylink.h:758 include/linux/phylink.h:783
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:151
#: drivers/net/phy/phylink.c:227 drivers/net/phy/phylink.c:362
#: drivers/net/phy/phylink.c:384 drivers/net/phy/phylink.c:402
#: drivers/net/phy/phylink.c:427 drivers/net/phy/phylink.c:489
#: drivers/net/phy/phylink.c:1067 drivers/net/phy/phylink.c:1779
#: drivers/net/phy/phylink.c:1823 drivers/net/phy/phylink.c:1924
#: drivers/net/phy/phylink.c:1944 drivers/net/phy/phylink.c:2211
#: drivers/net/phy/phylink.c:2249 drivers/net/phy/phylink.c:2268
#: drivers/net/phy/phylink.c:2328 drivers/net/phy/phylink.c:2369
#: drivers/net/phy/phylink.c:2383 drivers/net/phy/phylink.c:2411
#: drivers/net/phy/phylink.c:2477 drivers/net/phy/phylink.c:2511
#: drivers/net/phy/phylink.c:2540 drivers/net/phy/phylink.c:2570
#: drivers/net/phy/phylink.c:2615 drivers/net/phy/phylink.c:2640
#: drivers/net/phy/phylink.c:2681 drivers/net/phy/phylink.c:2702
#: drivers/net/phy/phylink.c:2810 drivers/net/phy/phylink.c:3053
#: drivers/net/phy/phylink.c:3181 drivers/net/phy/phylink.c:3420
#: drivers/net/phy/phylink.c:3498 drivers/net/phy/phylink.c:3522
#: drivers/net/phy/phylink.c:3969 drivers/net/phy/phylink.c:4012
#: drivers/net/phy/phylink.c:4049 drivers/net/phy/phylink.c:4112
#: drivers/net/phy/phylink.c:4144 drivers/net/phy/phylink.c:4185
#: drivers/net/phy/phylink.c:4226 ../../../networking/kapi:158:
#: include/linux/sfp.h:227 ../../../networking/kapi:161:
#: drivers/net/phy/sfp-bus.c:337 drivers/net/phy/sfp-bus.c:431
#: drivers/net/phy/sfp-bus.c:483 drivers/net/phy/sfp-bus.c:500
#: drivers/net/phy/sfp-bus.c:518 drivers/net/phy/sfp-bus.c:536
#: drivers/net/phy/sfp-bus.c:553 drivers/net/phy/sfp-bus.c:577
#: drivers/net/phy/sfp-bus.c:596 drivers/net/phy/sfp-bus.c:643
#: drivers/net/phy/sfp-bus.c:691 drivers/net/phy/sfp-bus.c:712
#: ../../../networking/kapi:17: include/linux/skbuff.h:432
#: include/linux/skbuff.h:455 include/linux/skbuff.h:1178
#: include/linux/skbuff.h:1212 include/linux/skbuff.h:1227
#: include/linux/skbuff.h:1378 include/linux/skbuff.h:1428
#: include/linux/skbuff.h:1468 include/linux/skbuff.h:1922
#: include/linux/skbuff.h:1933 include/linux/skbuff.h:1947
#: include/linux/skbuff.h:1960 include/linux/skbuff.h:1973
#: include/linux/skbuff.h:1991 include/linux/skbuff.h:2008
#: include/linux/skbuff.h:2025 include/linux/skbuff.h:2065
#: include/linux/skbuff.h:2094 include/linux/skbuff.h:2107
#: include/linux/skbuff.h:2120 include/linux/skbuff.h:2155
#: include/linux/skbuff.h:2184 include/linux/skbuff.h:2206
#: include/linux/skbuff.h:2218 include/linux/skbuff.h:2236
#: include/linux/skbuff.h:2259 include/linux/skbuff.h:2270
#: include/linux/skbuff.h:2282 include/linux/skbuff.h:2368
#: include/linux/skbuff.h:2399 include/linux/skbuff.h:2418
#: include/linux/skbuff.h:2445 include/linux/skbuff.h:2462
#: include/linux/skbuff.h:2495 include/linux/skbuff.h:2512
#: include/linux/skbuff.h:2603 include/linux/skbuff.h:2652
#: include/linux/skbuff.h:2672 include/linux/skbuff.h:2884
#: include/linux/skbuff.h:2895 include/linux/skbuff.h:2906
#: include/linux/skbuff.h:2922 include/linux/skbuff.h:2937
#: include/linux/skbuff.h:3087 include/linux/skbuff.h:3341
#: include/linux/skbuff.h:3369 include/linux/skbuff.h:3389
#: include/linux/skbuff.h:3415 include/linux/skbuff.h:3450
#: include/linux/skbuff.h:3473 include/linux/skbuff.h:3547
#: include/linux/skbuff.h:3578 include/linux/skbuff.h:3598
#: include/linux/skbuff.h:3773 include/linux/skbuff.h:3828
#: include/linux/skbuff.h:3863 include/linux/skbuff.h:3880
#: include/linux/skbuff.h:3895 include/linux/skbuff.h:3914
#: include/linux/skbuff.h:3939 include/linux/skbuff.h:3981
#: include/linux/skbuff.h:4006 include/linux/skbuff.h:4033
#: include/linux/skbuff.h:4063 include/linux/skbuff.h:4079
#: include/linux/skbuff.h:4098 include/linux/skbuff.h:4315
#: include/linux/skbuff.h:4368 include/linux/skbuff.h:4595
#: include/linux/skbuff.h:4608 include/linux/skbuff.h:4629
#: include/linux/skbuff.h:4660 include/linux/skbuff.h:5217
#: include/linux/skbuff.h:5237 ../../../networking/kapi:20:
#: include/net/sock.h:149 include/net/sock.h:635 include/net/sock.h:1699
#: include/net/sock.h:1729 include/net/sock.h:2345 include/net/sock.h:2381
#: include/net/sock.h:2577 include/net/sock.h:2928 ../../../networking/kapi:23:
#: net/socket.c:3 net/socket.c:468 net/socket.c:527 net/socket.c:544
#: net/socket.c:684 net/socket.c:750 net/socket.c:781 net/socket.c:1093
#: net/socket.c:1113 net/socket.c:1388 net/socket.c:1528 net/socket.c:1657
#: net/socket.c:1675 net/socket.c:3244 net/socket.c:3277 net/socket.c:3583
#: net/socket.c:3602 net/socket.c:3617 net/socket.c:3659 net/socket.c:3682
#: net/socket.c:3697 net/socket.c:3712 net/socket.c:3725
#: ../../../networking/kapi:26: net/core/skbuff.c:306 net/core/skbuff.c:544
#: net/core/skbuff.c:634 net/core/skbuff.c:711 net/core/skbuff.c:788
#: net/core/skbuff.c:1159 net/core/skbuff.c:1196 net/core/skbuff.c:1371
#: net/core/skbuff.c:1388 net/core/skbuff.c:1604 net/core/skbuff.c:1921
#: net/core/skbuff.c:2022 net/core/skbuff.c:2099 net/core/skbuff.c:2151
#: net/core/skbuff.c:2214 net/core/skbuff.c:2383 net/core/skbuff.c:2436
#: net/core/skbuff.c:2501 net/core/skbuff.c:2550 net/core/skbuff.c:2572
#: net/core/skbuff.c:2593 net/core/skbuff.c:2612 net/core/skbuff.c:2629
#: net/core/skbuff.c:2652 net/core/skbuff.c:2777 net/core/skbuff.c:2933
#: net/core/skbuff.c:3365 net/core/skbuff.c:3786 net/core/skbuff.c:3888
#: net/core/skbuff.c:3909 net/core/skbuff.c:3930 net/core/skbuff.c:4005
#: net/core/skbuff.c:4026 net/core/skbuff.c:4047 net/core/skbuff.c:4068
#: net/core/skbuff.c:4320 net/core/skbuff.c:4341 net/core/skbuff.c:4451
#: net/core/skbuff.c:4468 net/core/skbuff.c:4517 net/core/skbuff.c:4565
#: net/core/skbuff.c:4691 net/core/skbuff.c:5217 net/core/skbuff.c:5269
#: net/core/skbuff.c:5453 net/core/skbuff.c:5703 net/core/skbuff.c:6003
#: net/core/skbuff.c:6167 net/core/skbuff.c:6403 net/core/skbuff.c:6431
#: net/core/skbuff.c:6489 net/core/skbuff.c:6542 net/core/skbuff.c:6585
#: net/core/skbuff.c:6617 net/core/skbuff.c:6653 net/core/skbuff.c:6936
#: net/core/skbuff.c:7034 net/core/skbuff.c:7058 net/core/skbuff.c:7243
#: ../../../networking/kapi:29: net/core/sock.c:167 net/core/sock.c:184
#: net/core/sock.c:199 net/core/sock.c:298 net/core/sock.c:2458
#: net/core/sock.c:3219 net/core/sock.c:3361 ../../../networking/kapi:32:
#: net/core/datagram.c:218 net/core/datagram.c:359 net/core/datagram.c:547
#: net/core/datagram.c:779 net/core/datagram.c:881 net/core/datagram.c:928
#: ../../../networking/kapi:35: net/core/stream.c:58
#: ../../../networking/kapi:41: net/core/filter.c:127 net/core/filter.c:1382
#: net/core/filter.c:1428 net/core/filter.c:1549 ../../../networking/kapi:50:
#: net/core/gen_stats.c:49 net/core/gen_stats.c:103 net/core/gen_stats.c:253
#: net/core/gen_stats.c:280 net/core/gen_stats.c:301 net/core/gen_stats.c:379
#: net/core/gen_stats.c:418 net/core/gen_stats.c:453
#: ../../../networking/kapi:53: net/core/gen_estimator.c:123
#: net/core/gen_estimator.c:204 net/core/gen_estimator.c:230
#: net/core/gen_estimator.c:250 ../../../networking/kapi:59:
#: net/sunrpc/xdr.c:46 net/sunrpc/xdr.c:76 net/sunrpc/xdr.c:145
#: net/sunrpc/xdr.c:411 net/sunrpc/xdr.c:987 net/sunrpc/xdr.c:1067
#: net/sunrpc/xdr.c:1104 net/sunrpc/xdr.c:1147 net/sunrpc/xdr.c:1231
#: net/sunrpc/xdr.c:1262 net/sunrpc/xdr.c:1494 net/sunrpc/xdr.c:1561
#: net/sunrpc/xdr.c:1590 net/sunrpc/xdr.c:1620 net/sunrpc/xdr.c:1655
#: net/sunrpc/xdr.c:1716 net/sunrpc/xdr.c:1764 net/sunrpc/xdr.c:1816
#: net/sunrpc/xdr.c:2226 net/sunrpc/xdr.c:2259 net/sunrpc/xdr.c:2287
#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:81
#: net/sunrpc/svc_xprt.c:155 net/sunrpc/svc_xprt.c:218
#: net/sunrpc/svc_xprt.c:298 net/sunrpc/svc_xprt.c:341
#: net/sunrpc/svc_xprt.c:516 net/sunrpc/svc_xprt.c:580
#: net/sunrpc/svc_xprt.c:839 net/sunrpc/svc_xprt.c:1120
#: net/sunrpc/svc_xprt.c:1281 net/sunrpc/svc_xprt.c:1316
#: net/sunrpc/svc_xprt.c:1373 ../../../networking/kapi:65: net/sunrpc/xprt.c:94
#: net/sunrpc/xprt.c:260 net/sunrpc/xprt.c:417 net/sunrpc/xprt.c:434
#: net/sunrpc/xprt.c:496 net/sunrpc/xprt.c:516 net/sunrpc/xprt.c:552
#: net/sunrpc/xprt.c:605 net/sunrpc/xprt.c:631 net/sunrpc/xprt.c:1064
#: net/sunrpc/xprt.c:1095 net/sunrpc/xprt.c:1108 net/sunrpc/xprt.c:1193
#: net/sunrpc/xprt.c:1215 net/sunrpc/xprt.c:1256 net/sunrpc/xprt.c:1274
#: ../../../networking/kapi:68: net/sunrpc/sched.c:725 net/sunrpc/sched.c:757
#: ../../../networking/kapi:74: net/sunrpc/stats.c:198
#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:129
#: net/sunrpc/rpc_pipe.c:626 net/sunrpc/rpc_pipe.c:688
#: ../../../networking/kapi:80: net/sunrpc/rpcb_clnt.c:666
#: ../../../networking/kapi:83: net/sunrpc/clnt.c:514 net/sunrpc/clnt.c:671
#: net/sunrpc/clnt.c:693 net/sunrpc/clnt.c:716 net/sunrpc/clnt.c:839
#: net/sunrpc/clnt.c:899 net/sunrpc/clnt.c:1051 net/sunrpc/clnt.c:1383
#: net/sunrpc/clnt.c:1408 net/sunrpc/clnt.c:1540 net/sunrpc/clnt.c:1609
#: net/sunrpc/clnt.c:3043 net/sunrpc/clnt.c:3080 ../../../networking/kapi:92:
#: net/core/dev.c:3 net/core/dev.c:596 net/core/dev.c:622 net/core/dev.c:658
#: net/core/dev.c:685 net/core/dev.c:703 net/core/dev.c:853 net/core/dev.c:874
#: net/core/dev.c:910 net/core/dev.c:933 net/core/dev.c:957 net/core/dev.c:996
#: net/core/dev.c:1206 net/core/dev.c:1233 net/core/dev.c:1301
#: net/core/dev.c:1418 net/core/dev.c:1566 net/core/dev.c:1594
#: net/core/dev.c:1612 net/core/dev.c:1937 net/core/dev.c:1992
#: net/core/dev.c:2068 net/core/dev.c:2096 net/core/dev.c:2275
#: net/core/dev.c:2442 net/core/dev.c:2513 net/core/dev.c:3217
#: net/core/dev.c:3249 net/core/dev.c:3292 net/core/dev.c:3311
#: net/core/dev.c:3451 net/core/dev.c:3466 net/core/dev.c:4654
#: net/core/dev.c:5097 net/core/dev.c:5600 net/core/dev.c:5621
#: net/core/dev.c:5746 net/core/dev.c:5764 net/core/dev.c:5794
#: net/core/dev.c:6088 net/core/dev.c:6320 net/core/dev.c:6348
#: net/core/dev.c:6585 net/core/dev.c:6602 net/core/dev.c:6634
#: net/core/dev.c:7135 net/core/dev.c:7155 net/core/dev.c:7502
#: net/core/dev.c:7537 net/core/dev.c:7858 net/core/dev.c:7881
#: net/core/dev.c:7902 net/core/dev.c:7917 net/core/dev.c:7982
#: net/core/dev.c:8153 net/core/dev.c:8181 net/core/dev.c:8208
#: net/core/dev.c:8498 net/core/dev.c:8517 net/core/dev.c:8794
#: net/core/dev.c:8821 net/core/dev.c:8879 net/core/dev.c:8993
#: net/core/dev.c:9252 net/core/dev.c:9284 net/core/dev.c:9398
#: net/core/dev.c:9572 net/core/dev.c:9970 net/core/dev.c:10958
#: net/core/dev.c:10973 net/core/dev.c:10991 net/core/dev.c:11178
#: net/core/dev.c:11393 net/core/dev.c:11713 net/core/dev.c:11774
#: net/core/dev.c:11808 net/core/dev.c:11850 net/core/dev.c:11873
#: net/core/dev.c:12031 net/core/dev.c:12143 net/core/dev.c:12355
#: net/core/dev.c:12627 ../../../networking/kapi:95: net/ethernet/eth.c:75
#: net/ethernet/eth.c:122 net/ethernet/eth.c:151 net/ethernet/eth.c:215
#: net/ethernet/eth.c:247 net/ethernet/eth.c:305 net/ethernet/eth.c:343
#: net/ethernet/eth.c:371 net/ethernet/eth.c:511 net/ethernet/eth.c:581
#: net/ethernet/eth.c:628 ../../../networking/kapi:98:
#: net/sched/sch_generic.c:580 net/sched/sch_generic.c:599
#: net/sched/sch_generic.c:616
msgid "**Description**"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:58
msgid ""
"When adding some new socket type please grep ARCH_HAS_SOCKET_TYPE include/"
"asm-* /socket.h, at least MIPS overrides this enum for binary compat reasons."
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:87
msgid "Shutdown types"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:93
msgid "``SHUT_RD``"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:94
msgid "shutdown receptions"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:96
msgid "``SHUT_WR``"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:97
msgid "shutdown transmissions"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:99
msgid "``SHUT_RDWR``"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:100
msgid "shutdown receptions/transmissions"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:107
msgid "general BSD socket"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:353
#: include/linux/netdevice.h:1775 ../../../networking/kapi:107:
#: include/net/net_shaper.h:37 include/net/net_shaper.h:64
#: ../../../networking/kapi:11: include/linux/net.h:111
#: ../../../networking/kapi:125: include/linux/phy.h:339
#: include/linux/phy.h:356 include/linux/phy.h:523 include/linux/phy.h:538
#: include/linux/phy.h:788 include/linux/phy.h:827 include/linux/phy.h:869
#: include/linux/phy.h:894 include/linux/phy.h:911
#: ../../../networking/kapi:147: include/linux/phylink.h:108
#: include/linux/phylink.h:141 include/linux/phylink.h:185
#: include/linux/phylink.h:452 include/linux/phylink.h:478
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:42
#: ../../../networking/kapi:155: drivers/net/phy/sfp-bus.c:18
#: ../../../networking/kapi:158: include/linux/sfp.h:225
#: include/linux/sfp.h:529 include/linux/sfp.h:551 ../../../networking/kapi:17:
#: include/linux/skbuff.h:451 include/linux/skbuff.h:780
#: include/linux/skbuff.h:4922 ../../../networking/kapi:20:
#: include/net/sock.h:110 include/net/sock.h:242 ../../../networking/kapi:47:
#: include/uapi/linux/gen_stats.h:26 include/uapi/linux/gen_stats.h:36
#: include/uapi/linux/gen_stats.h:46 include/uapi/linux/gen_stats.h:56
#: include/uapi/linux/gen_stats.h:72
msgid "**Definition**::"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:363
#: include/linux/netdevice.h:2067 ../../../networking/kapi:107:
#: include/net/net_shaper.h:50 include/net/net_shaper.h:73
#: ../../../networking/kapi:11: include/linux/net.h:123
#: ../../../networking/kapi:125: include/linux/phy.h:349
#: include/linux/phy.h:391 include/linux/phy.h:531 include/linux/phy.h:626
#: include/linux/phy.h:797 include/linux/phy.h:839 include/linux/phy.h:875
#: include/linux/phy.h:903 include/linux/phy.h:972
#: ../../../networking/kapi:147: include/linux/phylink.h:122
#: include/linux/phylink.h:160 include/linux/phylink.h:199
#: include/linux/phylink.h:462 include/linux/phylink.h:496
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:47
#: ../../../networking/kapi:155: drivers/net/phy/sfp-bus.c:23
#: ../../../networking/kapi:158: include/linux/sfp.h:232
#: include/linux/sfp.h:538 include/linux/sfp.h:566 ../../../networking/kapi:17:
#: include/linux/skbuff.h:460 include/linux/skbuff.h:938
#: include/linux/skbuff.h:4931 ../../../networking/kapi:20:
#: include/net/sock.h:170 include/net/sock.h:411 ../../../networking/kapi:47:
#: include/uapi/linux/gen_stats.h:33 include/uapi/linux/gen_stats.h:43
#: include/uapi/linux/gen_stats.h:53 include/uapi/linux/gen_stats.h:66
#: include/uapi/linux/gen_stats.h:79
msgid "**Members**"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1795
#: ../../../networking/kapi:11: include/linux/net.h:108
#: ../../../networking/kapi:125: include/linux/phy.h:390
#: include/linux/phy.h:560
msgid "``state``"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:109
msgid "socket state (``SS_CONNECTED``, etc)"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1859
#: ../../../networking/kapi:11: include/linux/net.h:109
#: ../../../networking/kapi:147: include/linux/phylink.h:139
msgid "``type``"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:110
#: ../../../networking/kapi:20: include/net/sock.h:295
msgid "socket type (``SOCK_STREAM``, etc)"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1847
#: ../../../networking/kapi:11: include/linux/net.h:110
#: ../../../networking/kapi:125: include/linux/phy.h:917
msgid "``flags``"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:111
msgid "socket flags (``SOCK_NOSPACE``, etc)"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:112
msgid "``file``"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:113
msgid "File back pointer for gc"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:113
#: ../../../networking/kapi:17: include/linux/skbuff.h:785
msgid "``sk``"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:114
msgid "internal networking protocol agnostic socket representation"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:111
#: ../../../networking/kapi:147: include/linux/phylink.h:451
msgid "``ops``"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:112
msgid "protocol specific socket operations"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:114
msgid "``wq``"
msgstr ""

#: ../../../networking/kapi:11: include/linux/net.h:115
msgid "wait queue for several uses"
msgstr ""

#: ../../../networking/kapi.rst:15
msgid "Socket Buffer Functions"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:368
msgid "Returns the size of a skb fragment"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:85
#: include/linux/etherdevice.h:108 include/linux/etherdevice.h:127
#: include/linux/etherdevice.h:161 include/linux/etherdevice.h:172
#: include/linux/etherdevice.h:187 include/linux/etherdevice.h:198
#: include/linux/etherdevice.h:216 include/linux/etherdevice.h:234
#: include/linux/etherdevice.h:248 include/linux/etherdevice.h:259
#: include/linux/etherdevice.h:270 include/linux/etherdevice.h:288
#: include/linux/etherdevice.h:299 include/linux/etherdevice.h:321
#: include/linux/etherdevice.h:333 include/linux/etherdevice.h:348
#: include/linux/etherdevice.h:372 include/linux/etherdevice.h:401
#: include/linux/etherdevice.h:419 include/linux/etherdevice.h:462
#: include/linux/etherdevice.h:479 include/linux/etherdevice.h:494
#: include/linux/etherdevice.h:507 include/linux/etherdevice.h:519
#: include/linux/etherdevice.h:533 include/linux/etherdevice.h:561
#: include/linux/etherdevice.h:598 include/linux/etherdevice.h:619
#: include/linux/etherdevice.h:652 ../../../networking/kapi:104:
#: include/linux/netdevice.h:523 include/linux/netdevice.h:548
#: include/linux/netdevice.h:568 include/linux/netdevice.h:580
#: include/linux/netdevice.h:607 include/linux/netdevice.h:624
#: include/linux/netdevice.h:2742 include/linux/netdevice.h:2807
#: include/linux/netdevice.h:2849 include/linux/netdevice.h:2865
#: include/linux/netdevice.h:2884 include/linux/netdevice.h:2905
#: include/linux/netdevice.h:3585 include/linux/netdevice.h:3608
#: include/linux/netdevice.h:3642 include/linux/netdevice.h:3661
#: include/linux/netdevice.h:3689 include/linux/netdevice.h:3717
#: include/linux/netdevice.h:3731 include/linux/netdevice.h:3745
#: include/linux/netdevice.h:3805 include/linux/netdevice.h:3828
#: include/linux/netdevice.h:3861 include/linux/netdevice.h:3885
#: include/linux/netdevice.h:3896 include/linux/netdevice.h:3908
#: include/linux/netdevice.h:3928 include/linux/netdevice.h:3946
#: include/linux/netdevice.h:3960 include/linux/netdevice.h:3973
#: include/linux/netdevice.h:3988 include/linux/netdevice.h:4001
#: include/linux/netdevice.h:4021 include/linux/netdevice.h:4037
#: include/linux/netdevice.h:4057 include/linux/netdevice.h:4079
#: include/linux/netdevice.h:4122 include/linux/netdevice.h:4422
#: include/linux/netdevice.h:4434 include/linux/netdevice.h:4473
#: include/linux/netdevice.h:4483 include/linux/netdevice.h:4502
#: include/linux/netdevice.h:4520 include/linux/netdevice.h:4532
#: include/linux/netdevice.h:4544 include/linux/netdevice.h:4560
#: include/linux/netdevice.h:4572 include/linux/netdevice.h:4584
#: include/linux/netdevice.h:4598 include/linux/netdevice.h:4764
#: include/linux/netdevice.h:4947 include/linux/netdevice.h:4965
#: include/linux/netdevice.h:4991 include/linux/netdevice.h:5009
#: ../../../networking/kapi:113: drivers/net/phy/phy.c:120
#: drivers/net/phy/phy.c:139 drivers/net/phy/phy.c:182
#: drivers/net/phy/phy.c:202 drivers/net/phy/phy.c:238
#: drivers/net/phy/phy.c:305 drivers/net/phy/phy.c:436
#: drivers/net/phy/phy.c:451 drivers/net/phy/phy.c:520
#: drivers/net/phy/phy.c:542 drivers/net/phy/phy.c:561
#: drivers/net/phy/phy.c:587 drivers/net/phy/phy.c:843
#: drivers/net/phy/phy.c:912 drivers/net/phy/phy.c:1040
#: drivers/net/phy/phy.c:1061 drivers/net/phy/phy.c:1089
#: drivers/net/phy/phy.c:1121 drivers/net/phy/phy.c:1221
#: drivers/net/phy/phy.c:1269 drivers/net/phy/phy.c:1303
#: drivers/net/phy/phy.c:1355 drivers/net/phy/phy.c:1447
#: drivers/net/phy/phy.c:1476 drivers/net/phy/phy.c:1634
#: drivers/net/phy/phy.c:1678 drivers/net/phy/phy.c:1712
#: drivers/net/phy/phy.c:1726 drivers/net/phy/phy.c:1813
#: drivers/net/phy/phy.c:1833 drivers/net/phy/phy.c:1854
#: drivers/net/phy/phy.c:1884 drivers/net/phy/phy.c:1906
#: drivers/net/phy/phy.c:1965 drivers/net/phy/phy.c:1997
#: drivers/net/phy/phy.c:2019 drivers/net/phy/phy.c:2061
#: ../../../networking/kapi:116: drivers/net/phy/phy.c:166
#: drivers/net/phy/phy.c:221 drivers/net/phy/phy.c:253
#: drivers/net/phy/phy.c:470 drivers/net/phy/phy.c:487
#: drivers/net/phy/phy.c:507 drivers/net/phy/phy.c:608
#: drivers/net/phy/phy.c:630 drivers/net/phy/phy.c:651
#: drivers/net/phy/phy.c:682 drivers/net/phy/phy.c:711
#: drivers/net/phy/phy.c:812 drivers/net/phy/phy.c:998
#: drivers/net/phy/phy.c:1319 drivers/net/phy/phy.c:1370
#: drivers/net/phy/phy.c:1380 drivers/net/phy/phy.c:1421
#: drivers/net/phy/phy.c:1430 drivers/net/phy/phy.c:1490
#: drivers/net/phy/phy.c:1616 drivers/net/phy/phy.c:1930
#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:18
#: drivers/net/phy/phy-core.c:71 drivers/net/phy/phy-core.c:88
#: drivers/net/phy/phy-core.c:109 drivers/net/phy/phy-core.c:174
#: drivers/net/phy/phy-core.c:264 drivers/net/phy/phy-core.c:286
#: drivers/net/phy/phy-core.c:411 drivers/net/phy/phy-core.c:433
#: drivers/net/phy/phy-core.c:454 drivers/net/phy/phy-core.c:477
#: drivers/net/phy/phy-core.c:499 drivers/net/phy/phy-core.c:524
#: drivers/net/phy/phy-core.c:545 drivers/net/phy/phy-core.c:568
#: drivers/net/phy/phy-core.c:600 drivers/net/phy/phy-core.c:627
#: drivers/net/phy/phy-core.c:650 drivers/net/phy/phy-core.c:691
#: drivers/net/phy/phy-core.c:706 drivers/net/phy/phy-core.c:735
#: drivers/net/phy/phy-core.c:774 drivers/net/phy/phy-core.c:794
#: drivers/net/phy/phy-core.c:815 drivers/net/phy/phy-core.c:838
#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:53
#: drivers/net/phy/phy-c45.c:67 drivers/net/phy/phy-c45.c:81
#: drivers/net/phy/phy-c45.c:111 drivers/net/phy/phy-c45.c:264
#: drivers/net/phy/phy-c45.c:316 drivers/net/phy/phy-c45.c:337
#: drivers/net/phy/phy-c45.c:357 drivers/net/phy/phy-c45.c:391
#: drivers/net/phy/phy-c45.c:416 drivers/net/phy/phy-c45.c:518
#: drivers/net/phy/phy-c45.c:573 drivers/net/phy/phy-c45.c:601
#: drivers/net/phy/phy-c45.c:651 drivers/net/phy/phy-c45.c:898
#: drivers/net/phy/phy-c45.c:941 drivers/net/phy/phy-c45.c:957
#: drivers/net/phy/phy-c45.c:995 drivers/net/phy/phy-c45.c:1068
#: drivers/net/phy/phy-c45.c:1163 drivers/net/phy/phy-c45.c:1202
#: drivers/net/phy/phy-c45.c:1247 drivers/net/phy/phy-c45.c:1282
#: drivers/net/phy/phy-c45.c:1335 drivers/net/phy/phy-c45.c:1450
#: drivers/net/phy/phy-c45.c:1473 drivers/net/phy/phy-c45.c:1505
#: drivers/net/phy/phy-c45.c:1530 ../../../networking/kapi:125:
#: include/linux/phy.h:207 include/linux/phy.h:299 include/linux/phy.h:440
#: include/linux/phy.h:1294 include/linux/phy.h:1308 include/linux/phy.h:1321
#: include/linux/phy.h:1334 include/linux/phy.h:1354 include/linux/phy.h:1363
#: include/linux/phy.h:1374 include/linux/phy.h:1390 include/linux/phy.h:1418
#: include/linux/phy.h:1430 include/linux/phy.h:1445 include/linux/phy.h:1459
#: include/linux/phy.h:1484 include/linux/phy.h:1552 include/linux/phy.h:1565
#: include/linux/phy.h:1579 include/linux/phy.h:1590 include/linux/phy.h:1601
#: include/linux/phy.h:1617 include/linux/phy.h:1633 include/linux/phy.h:1647
#: include/linux/phy.h:1661 include/linux/phy.h:1673 include/linux/phy.h:1690
#: include/linux/phy.h:1699 include/linux/phy.h:1708 include/linux/phy.h:1718
#: include/linux/phy.h:1752 include/linux/phy.h:1767 include/linux/phy.h:1776
#: include/linux/phy.h:1787 include/linux/phy.h:1801 include/linux/phy.h:1811
#: include/linux/phy.h:2140 ../../../networking/kapi:128:
#: drivers/net/phy/phy_device.c:472 drivers/net/phy/phy_device.c:557
#: drivers/net/phy/phy_device.c:1093 drivers/net/phy/phy_device.c:1146
#: drivers/net/phy/phy_device.c:1185 drivers/net/phy/phy_device.c:1207
#: drivers/net/phy/phy_device.c:1221 drivers/net/phy/phy_device.c:1257
#: drivers/net/phy/phy_device.c:1285 drivers/net/phy/phy_device.c:1327
#: drivers/net/phy/phy_device.c:1510 drivers/net/phy/phy_device.c:1532
#: drivers/net/phy/phy_device.c:1552 drivers/net/phy/phy_device.c:1569
#: drivers/net/phy/phy_device.c:1586 drivers/net/phy/phy_device.c:1616
#: drivers/net/phy/phy_device.c:1790 drivers/net/phy/phy_device.c:1828
#: drivers/net/phy/phy_device.c:1964 drivers/net/phy/phy_device.c:2076
#: drivers/net/phy/phy_device.c:2177 drivers/net/phy/phy_device.c:2189
#: drivers/net/phy/phy_device.c:2219 drivers/net/phy/phy_device.c:2276
#: drivers/net/phy/phy_device.c:2324 drivers/net/phy/phy_device.c:2340
#: drivers/net/phy/phy_device.c:2440 drivers/net/phy/phy_device.c:2470
#: drivers/net/phy/phy_device.c:2521 drivers/net/phy/phy_device.c:2585
#: drivers/net/phy/phy_device.c:2637 drivers/net/phy/phy_device.c:2752
#: drivers/net/phy/phy_device.c:2776 drivers/net/phy/phy_device.c:2793
#: drivers/net/phy/phy_device.c:2809 drivers/net/phy/phy_device.c:2837
#: drivers/net/phy/phy_device.c:2854 drivers/net/phy/phy_device.c:2868
#: drivers/net/phy/phy_device.c:2880 drivers/net/phy/phy_device.c:2904
#: drivers/net/phy/phy_device.c:2928 drivers/net/phy/phy_device.c:2953
#: drivers/net/phy/phy_device.c:2991 drivers/net/phy/phy_device.c:3070
#: drivers/net/phy/phy_device.c:3094 drivers/net/phy/phy_device.c:3321
#: drivers/net/phy/phy_device.c:3344 drivers/net/phy/phy_device.c:3369
#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:272
#: drivers/net/phy/phy_device.c:427 drivers/net/phy/phy_device.c:934
#: drivers/net/phy/phy_device.c:1032 drivers/net/phy/phy_device.c:1239
#: drivers/net/phy/phy_device.c:1346 drivers/net/phy/phy_device.c:1990
#: drivers/net/phy/phy_device.c:2042 drivers/net/phy/phy_device.c:3393
#: drivers/net/phy/phy_device.c:3547 ../../../networking/kapi:134:
#: drivers/net/phy/mdio_bus.c:374 drivers/net/phy/mdio_bus.c:392
#: drivers/net/phy/mdio_bus.c:438 drivers/net/phy/mdio_bus.c:469
#: drivers/net/phy/mdio_bus.c:501 drivers/net/phy/mdio_bus.c:533
#: drivers/net/phy/mdio_bus.c:565 drivers/net/phy/mdio_bus.c:632
#: drivers/net/phy/mdio_bus.c:657 drivers/net/phy/mdio_bus.c:679
#: drivers/net/phy/mdio_bus.c:702 drivers/net/phy/mdio_bus.c:729
#: drivers/net/phy/mdio_bus.c:755 drivers/net/phy/mdio_bus.c:778
#: drivers/net/phy/mdio_bus.c:803 drivers/net/phy/mdio_bus.c:851
#: drivers/net/phy/mdio_bus.c:872 drivers/net/phy/mdio_bus.c:896
#: drivers/net/phy/mdio_bus.c:918 ../../../networking/kapi:137:
#: drivers/net/phy/mdio_bus.c:139 drivers/net/phy/mdio_bus.c:599
#: drivers/net/phy/mdio_bus.c:941 ../../../networking/kapi:147:
#: include/linux/phylink.h:222 include/linux/phylink.h:234
#: include/linux/phylink.h:250 include/linux/phylink.h:275
#: include/linux/phylink.h:350 include/linux/phylink.h:367
#: include/linux/phylink.h:387 include/linux/phylink.h:422
#: include/linux/phylink.h:431 include/linux/phylink.h:524
#: include/linux/phylink.h:541 include/linux/phylink.h:555
#: include/linux/phylink.h:561 include/linux/phylink.h:567
#: include/linux/phylink.h:586 include/linux/phylink.h:624
#: include/linux/phylink.h:633 include/linux/phylink.h:653
#: include/linux/phylink.h:661 include/linux/phylink.h:669
#: include/linux/phylink.h:759 include/linux/phylink.h:784
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:152
#: drivers/net/phy/phylink.c:228 drivers/net/phy/phylink.c:332
#: drivers/net/phy/phylink.c:362 drivers/net/phy/phylink.c:384
#: drivers/net/phy/phylink.c:402 drivers/net/phy/phylink.c:426
#: drivers/net/phy/phylink.c:488 drivers/net/phy/phylink.c:1065
#: drivers/net/phy/phylink.c:1779 drivers/net/phy/phylink.c:1820
#: drivers/net/phy/phylink.c:1925 drivers/net/phy/phylink.c:1945
#: drivers/net/phy/phylink.c:2211 drivers/net/phy/phylink.c:2248
#: drivers/net/phy/phylink.c:2267 drivers/net/phy/phylink.c:2328
#: drivers/net/phy/phylink.c:2369 drivers/net/phy/phylink.c:2383
#: drivers/net/phy/phylink.c:2412 drivers/net/phy/phylink.c:2478
#: drivers/net/phy/phylink.c:2512 drivers/net/phy/phylink.c:2541
#: drivers/net/phy/phylink.c:2570 drivers/net/phy/phylink.c:2616
#: drivers/net/phy/phylink.c:2641 drivers/net/phy/phylink.c:2681
#: drivers/net/phy/phylink.c:2702 drivers/net/phy/phylink.c:2810
#: drivers/net/phy/phylink.c:2884 drivers/net/phy/phylink.c:3054
#: drivers/net/phy/phylink.c:3079 drivers/net/phy/phylink.c:3095
#: drivers/net/phy/phylink.c:3181 drivers/net/phy/phylink.c:3204
#: drivers/net/phy/phylink.c:3230 drivers/net/phy/phylink.c:3419
#: drivers/net/phy/phylink.c:3497 drivers/net/phy/phylink.c:3522
#: drivers/net/phy/phylink.c:3969 drivers/net/phy/phylink.c:4012
#: drivers/net/phy/phylink.c:4047 drivers/net/phy/phylink.c:4111
#: drivers/net/phy/phylink.c:4143 drivers/net/phy/phylink.c:4183
#: drivers/net/phy/phylink.c:4227 ../../../networking/kapi:161:
#: drivers/net/phy/sfp-bus.c:337 drivers/net/phy/sfp-bus.c:432
#: drivers/net/phy/sfp-bus.c:483 drivers/net/phy/sfp-bus.c:499
#: drivers/net/phy/sfp-bus.c:517 drivers/net/phy/sfp-bus.c:537
#: drivers/net/phy/sfp-bus.c:554 drivers/net/phy/sfp-bus.c:577
#: drivers/net/phy/sfp-bus.c:597 drivers/net/phy/sfp-bus.c:642
#: drivers/net/phy/sfp-bus.c:692 drivers/net/phy/sfp-bus.c:713
#: ../../../networking/kapi:17: include/linux/skbuff.h:372
#: include/linux/skbuff.h:381 include/linux/skbuff.h:391
#: include/linux/skbuff.h:401 include/linux/skbuff.h:411
#: include/linux/skbuff.h:424 include/linux/skbuff.h:1140
#: include/linux/skbuff.h:1156 include/linux/skbuff.h:1179
#: include/linux/skbuff.h:1201 include/linux/skbuff.h:1212
#: include/linux/skbuff.h:1227 include/linux/skbuff.h:1245
#: include/linux/skbuff.h:1263 include/linux/skbuff.h:1285
#: include/linux/skbuff.h:1330 include/linux/skbuff.h:1378
#: include/linux/skbuff.h:1407 include/linux/skbuff.h:1428
#: include/linux/skbuff.h:1468 include/linux/skbuff.h:1923
#: include/linux/skbuff.h:1934 include/linux/skbuff.h:1947
#: include/linux/skbuff.h:1960 include/linux/skbuff.h:1973
#: include/linux/skbuff.h:1991 include/linux/skbuff.h:2009
#: include/linux/skbuff.h:2026 include/linux/skbuff.h:2066
#: include/linux/skbuff.h:2095 include/linux/skbuff.h:2108
#: include/linux/skbuff.h:2120 include/linux/skbuff.h:2155
#: include/linux/skbuff.h:2185 include/linux/skbuff.h:2207
#: include/linux/skbuff.h:2218 include/linux/skbuff.h:2237
#: include/linux/skbuff.h:2260 include/linux/skbuff.h:2271
#: include/linux/skbuff.h:2283 include/linux/skbuff.h:2354
#: include/linux/skbuff.h:2368 include/linux/skbuff.h:2385
#: include/linux/skbuff.h:2399 include/linux/skbuff.h:2417
#: include/linux/skbuff.h:2445 include/linux/skbuff.h:2462
#: include/linux/skbuff.h:2496 include/linux/skbuff.h:2513
#: include/linux/skbuff.h:2588 include/linux/skbuff.h:2600
#: include/linux/skbuff.h:2649 include/linux/skbuff.h:2669
#: include/linux/skbuff.h:2885 include/linux/skbuff.h:2896
#: include/linux/skbuff.h:2907 include/linux/skbuff.h:2922
#: include/linux/skbuff.h:2936 include/linux/skbuff.h:3088
#: include/linux/skbuff.h:3341 include/linux/skbuff.h:3370
#: include/linux/skbuff.h:3389 include/linux/skbuff.h:3415
#: include/linux/skbuff.h:3451 include/linux/skbuff.h:3473
#: include/linux/skbuff.h:3547 include/linux/skbuff.h:3579
#: include/linux/skbuff.h:3599 include/linux/skbuff.h:3615
#: include/linux/skbuff.h:3627 include/linux/skbuff.h:3636
#: include/linux/skbuff.h:3646 include/linux/skbuff.h:3656
#: include/linux/skbuff.h:3673 include/linux/skbuff.h:3688
#: include/linux/skbuff.h:3703 include/linux/skbuff.h:3719
#: include/linux/skbuff.h:3734 include/linux/skbuff.h:3756
#: include/linux/skbuff.h:3769 include/linux/skbuff.h:3828
#: include/linux/skbuff.h:3863 include/linux/skbuff.h:3880
#: include/linux/skbuff.h:3895 include/linux/skbuff.h:3913
#: include/linux/skbuff.h:3939 include/linux/skbuff.h:3982
#: include/linux/skbuff.h:3994 include/linux/skbuff.h:4007
#: include/linux/skbuff.h:4032 include/linux/skbuff.h:4062
#: include/linux/skbuff.h:4079 include/linux/skbuff.h:4098
#: include/linux/skbuff.h:4314 include/linux/skbuff.h:4368
#: include/linux/skbuff.h:4589 include/linux/skbuff.h:4608
#: include/linux/skbuff.h:4622 include/linux/skbuff.h:4641
#: include/linux/skbuff.h:4661 include/linux/skbuff.h:5218
#: include/linux/skbuff.h:5238 ../../../networking/kapi:20:
#: include/net/sock.h:621 include/net/sock.h:632 include/net/sock.h:657
#: include/net/sock.h:940 include/net/sock.h:1700 include/net/sock.h:1729
#: include/net/sock.h:2311 include/net/sock.h:2322 include/net/sock.h:2333
#: include/net/sock.h:2344 include/net/sock.h:2380 include/net/sock.h:2578
#: include/net/sock.h:2844 include/net/sock.h:2928 ../../../networking/kapi:23:
#: net/socket.c:467 net/socket.c:528 net/socket.c:544 net/socket.c:629
#: net/socket.c:685 net/socket.c:750 net/socket.c:778 net/socket.c:1092
#: net/socket.c:1109 net/socket.c:1386 net/socket.c:1524 net/socket.c:1655
#: net/socket.c:1672 net/socket.c:3245 net/socket.c:3278 net/socket.c:3582
#: net/socket.c:3602 net/socket.c:3616 net/socket.c:3657 net/socket.c:3682
#: net/socket.c:3697 net/socket.c:3712 net/socket.c:3726
#: ../../../networking/kapi:26: net/core/skbuff.c:160 net/core/skbuff.c:179
#: net/core/skbuff.c:306 net/core/skbuff.c:498 net/core/skbuff.c:544
#: net/core/skbuff.c:629 net/core/skbuff.c:710 net/core/skbuff.c:788
#: net/core/skbuff.c:1160 net/core/skbuff.c:1195 net/core/skbuff.c:1372
#: net/core/skbuff.c:1389 net/core/skbuff.c:1579 net/core/skbuff.c:1604
#: net/core/skbuff.c:1921 net/core/skbuff.c:2022 net/core/skbuff.c:2099
#: net/core/skbuff.c:2147 net/core/skbuff.c:2212 net/core/skbuff.c:2383
#: net/core/skbuff.c:2434 net/core/skbuff.c:2500 net/core/skbuff.c:2549
#: net/core/skbuff.c:2572 net/core/skbuff.c:2593 net/core/skbuff.c:2612
#: net/core/skbuff.c:2628 net/core/skbuff.c:2652 net/core/skbuff.c:2777
#: net/core/skbuff.c:2931 net/core/skbuff.c:3363 net/core/skbuff.c:3784
#: net/core/skbuff.c:3889 net/core/skbuff.c:3910 net/core/skbuff.c:3930
#: net/core/skbuff.c:4005 net/core/skbuff.c:4026 net/core/skbuff.c:4047
#: net/core/skbuff.c:4067 net/core/skbuff.c:4152 net/core/skbuff.c:4318
#: net/core/skbuff.c:4340 net/core/skbuff.c:4452 net/core/skbuff.c:4466
#: net/core/skbuff.c:4515 net/core/skbuff.c:4565 net/core/skbuff.c:4691
#: net/core/skbuff.c:5215 net/core/skbuff.c:5268 net/core/skbuff.c:5454
#: net/core/skbuff.c:5702 net/core/skbuff.c:5937 net/core/skbuff.c:6002
#: net/core/skbuff.c:6068 net/core/skbuff.c:6166 net/core/skbuff.c:6403
#: net/core/skbuff.c:6429 net/core/skbuff.c:6483 net/core/skbuff.c:6539
#: net/core/skbuff.c:6584 net/core/skbuff.c:6617 net/core/skbuff.c:6649
#: net/core/skbuff.c:6937 net/core/skbuff.c:7033 net/core/skbuff.c:7058
#: net/core/skbuff.c:7242 ../../../networking/kapi:29: net/core/sock.c:166
#: net/core/sock.c:184 net/core/sock.c:199 net/core/sock.c:299
#: net/core/sock.c:2287 net/core/sock.c:2458 net/core/sock.c:3095
#: net/core/sock.c:3218 net/core/sock.c:3360 net/core/sock.c:3401
#: ../../../networking/kapi:32: net/core/datagram.c:212 net/core/datagram.c:358
#: net/core/datagram.c:503 net/core/datagram.c:529 net/core/datagram.c:545
#: net/core/datagram.c:779 net/core/datagram.c:880 net/core/datagram.c:927
#: ../../../networking/kapi:35: net/core/stream.c:58 net/core/stream.c:122
#: ../../../networking/kapi:41: net/core/filter.c:125 net/core/filter.c:1382
#: net/core/filter.c:1426 net/core/filter.c:1549 ../../../networking/kapi:50:
#: net/core/gen_stats.c:44 net/core/gen_stats.c:100 net/core/gen_stats.c:247
#: net/core/gen_stats.c:274 net/core/gen_stats.c:301 net/core/gen_stats.c:377
#: net/core/gen_stats.c:417 net/core/gen_stats.c:454
#: ../../../networking/kapi:53: net/core/gen_estimator.c:117
#: net/core/gen_estimator.c:205 net/core/gen_estimator.c:224
#: net/core/gen_estimator.c:251 ../../../networking/kapi:59:
#: net/sunrpc/xdr.c:45 net/sunrpc/xdr.c:75 net/sunrpc/xdr.c:97
#: net/sunrpc/xdr.c:144 net/sunrpc/xdr.c:195 net/sunrpc/xdr.c:409
#: net/sunrpc/xdr.c:893 net/sunrpc/xdr.c:915 net/sunrpc/xdr.c:928
#: net/sunrpc/xdr.c:969 net/sunrpc/xdr.c:988 net/sunrpc/xdr.c:1067
#: net/sunrpc/xdr.c:1104 net/sunrpc/xdr.c:1147 net/sunrpc/xdr.c:1216
#: net/sunrpc/xdr.c:1231 net/sunrpc/xdr.c:1260 net/sunrpc/xdr.c:1401
#: net/sunrpc/xdr.c:1426 net/sunrpc/xdr.c:1445 net/sunrpc/xdr.c:1494
#: net/sunrpc/xdr.c:1561 net/sunrpc/xdr.c:1590 net/sunrpc/xdr.c:1620
#: net/sunrpc/xdr.c:1653 net/sunrpc/xdr.c:1715 net/sunrpc/xdr.c:1762
#: net/sunrpc/xdr.c:1793 net/sunrpc/xdr.c:1816 net/sunrpc/xdr.c:2224
#: net/sunrpc/xdr.c:2257 net/sunrpc/xdr.c:2285 ../../../networking/kapi:62:
#: net/sunrpc/svc_xprt.c:82 net/sunrpc/svc_xprt.c:108 net/sunrpc/svc_xprt.c:156
#: net/sunrpc/svc_xprt.c:219 net/sunrpc/svc_xprt.c:294
#: net/sunrpc/svc_xprt.c:336 net/sunrpc/svc_xprt.c:401
#: net/sunrpc/svc_xprt.c:473 net/sunrpc/svc_xprt.c:516
#: net/sunrpc/svc_xprt.c:581 net/sunrpc/svc_xprt.c:840
#: net/sunrpc/svc_xprt.c:1057 net/sunrpc/svc_xprt.c:1119
#: net/sunrpc/svc_xprt.c:1279 net/sunrpc/svc_xprt.c:1313
#: net/sunrpc/svc_xprt.c:1372 ../../../networking/kapi:65: net/sunrpc/xprt.c:95
#: net/sunrpc/xprt.c:131 net/sunrpc/xprt.c:230 net/sunrpc/xprt.c:261
#: net/sunrpc/xprt.c:417 net/sunrpc/xprt.c:434 net/sunrpc/xprt.c:496
#: net/sunrpc/xprt.c:517 net/sunrpc/xprt.c:551 net/sunrpc/xprt.c:591
#: net/sunrpc/xprt.c:606 net/sunrpc/xprt.c:632 net/sunrpc/xprt.c:756
#: net/sunrpc/xprt.c:788 net/sunrpc/xprt.c:963 net/sunrpc/xprt.c:979
#: net/sunrpc/xprt.c:1064 net/sunrpc/xprt.c:1096 net/sunrpc/xprt.c:1109
#: net/sunrpc/xprt.c:1194 net/sunrpc/xprt.c:1215 net/sunrpc/xprt.c:1257
#: net/sunrpc/xprt.c:1275 net/sunrpc/xprt.c:2163 net/sunrpc/xprt.c:2176
#: ../../../networking/kapi:68: net/sunrpc/sched.c:726 net/sunrpc/sched.c:757
#: ../../../networking/kapi:74: net/sunrpc/stats.c:124 net/sunrpc/stats.c:143
#: net/sunrpc/stats.c:154 net/sunrpc/stats.c:198 ../../../networking/kapi:77:
#: net/sunrpc/rpc_pipe.c:129 net/sunrpc/rpc_pipe.c:623
#: net/sunrpc/rpc_pipe.c:689 net/sunrpc/rpc_pipe.c:707
#: net/sunrpc/rpc_pipe.c:718 net/sunrpc/rpc_pipe.c:758
#: net/sunrpc/rpc_pipe.c:783 net/sunrpc/rpc_pipe.c:805
#: ../../../networking/kapi:80: net/sunrpc/rpcb_clnt.c:667
#: ../../../networking/kapi:83: net/sunrpc/clnt.c:515 net/sunrpc/clnt.c:671
#: net/sunrpc/clnt.c:692 net/sunrpc/clnt.c:715 net/sunrpc/clnt.c:838
#: net/sunrpc/clnt.c:897 net/sunrpc/clnt.c:1050 net/sunrpc/clnt.c:1225
#: net/sunrpc/clnt.c:1252 net/sunrpc/clnt.c:1285 net/sunrpc/clnt.c:1355
#: net/sunrpc/clnt.c:1382 net/sunrpc/clnt.c:1408 net/sunrpc/clnt.c:1539
#: net/sunrpc/clnt.c:1594 net/sunrpc/clnt.c:1610 net/sunrpc/clnt.c:1630
#: net/sunrpc/clnt.c:1660 net/sunrpc/clnt.c:2958 net/sunrpc/clnt.c:3030
#: net/sunrpc/clnt.c:3078 ../../../networking/kapi:92: net/core/dev.c:597
#: net/core/dev.c:623 net/core/dev.c:659 net/core/dev.c:686 net/core/dev.c:703
#: net/core/dev.c:853 net/core/dev.c:874 net/core/dev.c:908 net/core/dev.c:933
#: net/core/dev.c:957 net/core/dev.c:994 net/core/dev.c:1205
#: net/core/dev.c:1232 net/core/dev.c:1302 net/core/dev.c:1418
#: net/core/dev.c:1567 net/core/dev.c:1594 net/core/dev.c:1613
#: net/core/dev.c:1938 net/core/dev.c:1993 net/core/dev.c:2068
#: net/core/dev.c:2095 net/core/dev.c:2275 net/core/dev.c:2441
#: net/core/dev.c:2511 net/core/dev.c:3217 net/core/dev.c:3248
#: net/core/dev.c:3292 net/core/dev.c:3311 net/core/dev.c:3328
#: net/core/dev.c:3340 net/core/dev.c:3452 net/core/dev.c:3467
#: net/core/dev.c:4264 net/core/dev.c:4654 net/core/dev.c:5095
#: net/core/dev.c:5601 net/core/dev.c:5622 net/core/dev.c:5747
#: net/core/dev.c:5763 net/core/dev.c:5795 net/core/dev.c:6089
#: net/core/dev.c:6321 net/core/dev.c:6349 net/core/dev.c:6586
#: net/core/dev.c:6603 net/core/dev.c:6635 net/core/dev.c:7136
#: net/core/dev.c:7153 net/core/dev.c:7503 net/core/dev.c:7538
#: net/core/dev.c:7858 net/core/dev.c:7881 net/core/dev.c:7903
#: net/core/dev.c:7918 net/core/dev.c:7982 net/core/dev.c:8152
#: net/core/dev.c:8179 net/core/dev.c:8207 net/core/dev.c:8497
#: net/core/dev.c:8518 net/core/dev.c:8793 net/core/dev.c:8818
#: net/core/dev.c:8879 net/core/dev.c:8993 net/core/dev.c:9251
#: net/core/dev.c:9284 net/core/dev.c:9398 net/core/dev.c:9573
#: net/core/dev.c:9839 net/core/dev.c:9969 net/core/dev.c:10012
#: net/core/dev.c:10959 net/core/dev.c:10974 net/core/dev.c:10991
#: net/core/dev.c:11179 net/core/dev.c:11394 net/core/dev.c:11713
#: net/core/dev.c:11774 net/core/dev.c:11808 net/core/dev.c:11851
#: net/core/dev.c:11869 net/core/dev.c:12032 net/core/dev.c:12099
#: net/core/dev.c:12112 net/core/dev.c:12143 net/core/dev.c:12343
#: net/core/dev.c:12356 net/core/dev.c:12626 ../../../networking/kapi:95:
#: net/ethernet/eth.c:71 net/ethernet/eth.c:121 net/ethernet/eth.c:151
#: net/ethernet/eth.c:201 net/ethernet/eth.c:214 net/ethernet/eth.c:246
#: net/ethernet/eth.c:263 net/ethernet/eth.c:275 net/ethernet/eth.c:292
#: net/ethernet/eth.c:305 net/ethernet/eth.c:344 net/ethernet/eth.c:369
#: net/ethernet/eth.c:511 net/ethernet/eth.c:581 net/ethernet/eth.c:614
#: net/ethernet/eth.c:628 ../../../networking/kapi:98:
#: net/sched/sch_generic.c:581 net/sched/sch_generic.c:600
#: net/sched/sch_generic.c:617
msgid "**Parameters**"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:374
#: include/linux/skbuff.h:3629 include/linux/skbuff.h:3675
#: include/linux/skbuff.h:3690 include/linux/skbuff.h:3705
#: include/linux/skbuff.h:3721 include/linux/skbuff.h:3736
#: include/linux/skbuff.h:3768
msgid "``const skb_frag_t *frag``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:369
#: include/linux/skbuff.h:378 include/linux/skbuff.h:388
#: include/linux/skbuff.h:398 include/linux/skbuff.h:3633
#: include/linux/skbuff.h:3643
msgid "skb fragment"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:377
msgid "Sets the size of a skb fragment"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:383
#: include/linux/skbuff.h:393 include/linux/skbuff.h:403
#: include/linux/skbuff.h:3638 include/linux/skbuff.h:3648
msgid "``skb_frag_t *frag``"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:221
#: ../../../networking/kapi:17: include/linux/skbuff.h:380
#: include/linux/skbuff.h:1380 include/linux/skbuff.h:1430
#: ../../../networking/kapi:26: net/core/skbuff.c:631
#: ../../../networking/kapi:92: net/core/dev.c:3291
msgid "``unsigned int size``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:379
msgid "size of fragment"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:387
msgid "Increments the size of a skb fragment by **delta**"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:390
#: include/linux/skbuff.h:400 include/linux/skbuff.h:2587
#: include/linux/skbuff.h:3635 ../../../networking/kapi:26:
#: net/core/skbuff.c:2776
msgid "``int delta``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:389
#: include/linux/skbuff.h:3634
msgid "value to add"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:397
msgid "Decrements the size of a skb fragment by **delta**"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:399
msgid "value to subtract"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:407
msgid "Test if ``p`` is a high memory page"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:413
msgid "``struct page *p``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:408
msgid "fragment's page"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:422
msgid "``skb_frag_foreach_page (f, f_off, f_len, p, p_off, p_len, copied)``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:420
msgid "loop over pages in a fragment"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:426
msgid "``f``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:422
msgid "skb frag to operate on"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:424
msgid "``f_off``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:423
msgid "offset from start of f->netmem"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:425
msgid "``f_len``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:424
msgid "length from f_off to loop over"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:426
msgid "``p``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:425
msgid "(temp var) current page"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:427
msgid "``p_off``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:426
msgid ""
"(temp var) offset from start of current page, non-zero only on first page."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:429
msgid "``p_len``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:428
msgid ""
"(temp var) length in current page, < PAGE_SIZE only on first and last page."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:431
msgid "``copied``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:430
msgid "(temp var) length so far, excluding current p_len."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:431
msgid ""
"A fragment can hold a compound page, in which case per-page operations, "
"notably kmap_atomic, must be called for each regular page."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:447
#: include/linux/skbuff.h:4593
msgid "hardware time stamps"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1
#: ../../../networking/kapi:17: include/linux/skbuff.h:1
#: ../../../networking/kapi:20: include/net/sock.h:1
msgid "``{unnamed_union}``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2
#: ../../../networking/kapi:17: include/linux/skbuff.h:2
#: ../../../networking/kapi:20: include/net/sock.h:2
msgid "anonymous"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:448
msgid "``hwtstamp``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:449
msgid ""
"hardware time stamp transformed into duration since arbitrary point in time"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:450
msgid "``netdev_data``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:451
msgid ""
"address/cookie of network device driver used as reference to actual hardware "
"time stamp"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:452
msgid ""
"Software time stamps generated by ktime_get_real() are stored in skb->tstamp."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:455
msgid ""
"hwtstamps can only be compared against other hwtstamps from the same device."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:458
msgid ""
"This structure is attached to packets as part of the :c:type:"
"`skb_shared_info`. Use skb_hwtstamps() to get a pointer."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:776
msgid "socket buffer"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1
#: ../../../networking/kapi:20: include/net/sock.h:1
msgid "``{unnamed_struct}``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:777
msgid "``next``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:778
msgid "Next buffer in list"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:778
msgid "``prev``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:779
msgid "Previous buffer in list"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1981
#: ../../../networking/kapi:125: include/linux/phy.h:398
#: ../../../networking/kapi:147: include/linux/phylink.h:138
#: ../../../networking/kapi:17: include/linux/skbuff.h:786
msgid "``dev``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:787
msgid "Device we arrived on/are leaving by"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:787
msgid "``dev_scratch``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:788
msgid "(aka **dev**) alternate use of **dev** when **dev** would be ``NULL``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:782
msgid "``rbnode``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:783
msgid "RB tree node, alternative to next/prev for netem/tcp"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:892
#: ../../../networking/kapi:17: include/linux/skbuff.h:783
msgid "``list``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:784
#: include/linux/skbuff.h:1920 include/linux/skbuff.h:1931
#: include/linux/skbuff.h:1944 include/linux/skbuff.h:1957
#: include/linux/skbuff.h:1970 include/linux/skbuff.h:1988
msgid "queue head"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:784
msgid "``ll_node``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:785
msgid "anchor in an llist (eg socket defer_list)"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:786
msgid "Socket we are owned by"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:779
msgid "``tstamp``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:780
msgid "Time we arrived/left"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:780
msgid "``skb_mstamp_ns``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:781
msgid ""
"(aka **tstamp**) earliest departure time; start point for retransmit timer"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:788
msgid "``cb``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:789
msgid "Control buffer. Free for use by every layer. Put private vars here"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:789
msgid "``_skb_refdst``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:790
msgid "destination entry (with norefcount bit)"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:819
msgid "``destructor``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:820
msgid "Destruct function"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:820
msgid "``tcp_tsorted_anchor``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:821
msgid "list structure for TCP (tp->tsorted_sent_queue)"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:821
msgid "``_sk_redir``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:822
msgid "socket redirection information for skmsg"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:822
msgid "``_nfct``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:823
msgid "Associated connection, if any (with nfctinfo bits)"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:790
msgid "``len``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:791
msgid "Length of actual data"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:791
msgid "``data_len``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:792
msgid "Data length"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:792
msgid "``mac_len``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:793
msgid "Length of link layer header"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:793
msgid "``hdr_len``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:794
msgid "writable header length of cloned skb"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:826
msgid "``queue_mapping``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:827
msgid "Queue mapping for multiqueue devices"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:799
msgid "``cloned``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:800
msgid "Head may be cloned (check refcnt to be sure)"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:801
msgid "``nohdr``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:802
msgid "Payload reference only, must not modify header"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:803
msgid "``fclone``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:804
msgid "skbuff clone status"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:815
msgid "``peeked``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:816
msgid ""
"this packet has been seen already, so stats have been done for it, don't do "
"them again"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:827
msgid "``head_frag``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:828
msgid ""
"skb was allocated from page fragments, not allocated by kmalloc() or "
"vmalloc()."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:829
msgid "``pfmemalloc``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:830
msgid "skbuff was allocated from PFMEMALLOC reserves"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:830
msgid "``pp_recycle``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:831
msgid ""
"mark the packet for recycling instead of freeing (implies page_pool support "
"on driver)"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:832
msgid "``active_extensions``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:833
msgid "active extensions (skb_ext_id types)"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:802
msgid "``pkt_type``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:803
msgid "Packet class"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:798
msgid "``ignore_df``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:799
msgid "allow local fragmentation"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:851
msgid "``dst_pending_confirm``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:852
#: ../../../networking/kapi:20: include/net/sock.h:251
msgid "need to confirm neighbour"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:800
msgid "``ip_summed``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:801
msgid "Driver fed us an IP checksum"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:834
msgid "``ooo_okay``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:835
msgid "allow the mapping of a socket to a queue to be changed"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:854
msgid "``tstamp_type``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:855
msgid "When set, skb->tstamp has the delivery_time clock base of skb->tstamp."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:811
msgid "``tc_at_ingress``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:812
msgid "used within tc_classify to distinguish in/egress"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:810
msgid "``tc_skip_classify``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:811
msgid "do not classify packet. set by IFB device"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:807
msgid "``remcsum_offload``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:808
msgid "remote checksum offload is enabled"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:845
msgid "``csum_complete_sw``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:846
msgid "checksum was completed by software"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:846
msgid "``csum_level``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:847
msgid ""
"indicates the number of consecutive checksums found in the packet minus one "
"that have been verified as CHECKSUM_UNNECESSARY (max 3)"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:805
msgid "``inner_protocol_type``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:806
msgid "whether the inner protocol is ENCAP_TYPE_ETHER or ENCAP_TYPE_IPPROTO"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:835
msgid "``l4_hash``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:836
msgid "indicate hash is a canonical 4-tuple hash over transport ports."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:837
msgid "``sw_hash``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:838
msgid "indicates hash was computed in software stack"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:838
msgid "``wifi_acked_valid``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:839
msgid "wifi_acked was set"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:839
msgid "``wifi_acked``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:840
msgid "whether frame was acked on wifi or not"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:840
msgid "``no_fcs``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:841
msgid "Request NIC to treat last 4 bytes as Ethernet FCS"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:841
msgid "``encapsulation``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:842
msgid "indicates the inner headers in the skbuff are valid"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:842
msgid "``encap_hdr_csum``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:843
msgid "software checksum is needed"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:843
msgid "``csum_valid``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:844
msgid "checksum is already valid"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:833
msgid "``ndisc_nodetype``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:834
msgid "router type (from link layer)"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:804
msgid "``ipvs_property``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:805
msgid "skbuff is owned by ipvs"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:817
msgid "``nf_trace``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:818
msgid "netfilter packet trace flag"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:808
msgid "``offload_fwd_mark``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:809
msgid "Packet was L2-forwarded in hardware"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:809
msgid "``offload_l3_fwd_mark``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:810
msgid "Packet was L3-forwarded in hardware"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:812
msgid "``redirected``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:813
msgid "packet was redirected by packet classifier"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:813
msgid "``from_ingress``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:814
msgid "packet was redirected from the ingress path"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:814
msgid "``nf_skip_egress``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:815
msgid "packet shall skip nf egress - see netfilter_netdev.h"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:852
msgid "``decrypted``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:853
msgid "Decrypted SKB"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:853
msgid "``slow_gro``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:854
msgid "state present at GRO time, slower prepare step required"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:844
msgid "``csum_not_inet``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:845
msgid "use CRC32c to resolve CHECKSUM_PARTIAL"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:849
msgid "``unreadable``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:850
msgid "indicates that at least 1 of the fragments in this skb is unreadable."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:824
msgid "``tc_index``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:825
msgid "Traffic control index"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:858
msgid "``alloc_cpu``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:859
msgid "CPU which did the skb allocation."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:794
msgid "``csum``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:795
msgid "Checksum (must include start/offset pair)"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:795
msgid "``csum_start``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:796
msgid "Offset from skb->head where checksumming should start"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:796
msgid "``csum_offset``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:797
msgid "Offset from csum_start where checksum should be stored"
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:41
#: ../../../networking/kapi:17: include/linux/skbuff.h:797
msgid "``priority``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:798
msgid "Packet queueing priority"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:823
msgid "``skb_iif``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:824
msgid "ifindex of device we arrived on"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:351
#: ../../../networking/kapi:17: include/linux/skbuff.h:825
msgid "``hash``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:826
msgid "the packet hash"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:863
msgid "``vlan_all``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:864
msgid "vlan fields (proto & tci)"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:864
msgid "``vlan_proto``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:865
msgid "vlan encapsulation protocol"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:865
msgid "``vlan_tci``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:866
msgid "vlan tag control information"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:856
msgid "``napi_id``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:857
msgid "id of the NAPI struct this skb came from"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:857
msgid "``sender_cpu``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:858
msgid "(aka **napi_id**) source CPU in XPS"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:859
msgid "``secmark``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:860
msgid "security marking"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:860
msgid "``mark``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:861
msgid "Generic packet mark"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:861
msgid "``reserved_tailroom``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:862
msgid ""
"(aka **mark**) number of bytes of free space available at the tail of an "
"sk_buff"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:866
msgid "``inner_protocol``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:867
msgid "Protocol (encapsulation)"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:867
msgid "``inner_ipproto``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:868
msgid ""
"(aka **inner_protocol**) stores ipproto when skb->inner_protocol_type == "
"ENCAP_TYPE_IPPROTO;"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:869
msgid "``inner_transport_header``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:870
msgid "Inner transport layer header (encapsulation)"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:870
msgid "``inner_network_header``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:871
msgid "Network layer header (encapsulation)"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:871
msgid "``inner_mac_header``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:872
msgid "Link layer header (encapsulation)"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:818
msgid "``protocol``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:819
msgid "Packet protocol from driver"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:872
msgid "``transport_header``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:873
msgid "Transport layer header"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:873
msgid "``network_header``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:874
msgid "Network layer header"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:874
msgid "``mac_header``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:875
msgid "Link layer header"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:875
msgid "``kcov_handle``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:876
msgid "KCOV remote handle for remote coverage collection"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:876
msgid "``tail``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:877
msgid "Tail pointer"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:877
msgid "``end``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:878
msgid "End pointer"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:878
#: ../../../networking/kapi:20: include/net/sock.h:940
msgid "``head``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:879
msgid "Head of buffer"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:879
#: include/linux/skbuff.h:4922
msgid "``data``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:880
msgid "Data head pointer"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:880
msgid "``truesize``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:881
msgid "Buffer size"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:881
msgid "``users``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:882
msgid "User count - see {datagram,tcp}.c"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:882
msgid "``extensions``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:883
msgid "allocated extensions, valid if active_extensions is nonzero"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1136
msgid "Test if the skb was allocated from PFMEMALLOC reserves"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1142
#: include/linux/skbuff.h:1158 include/linux/skbuff.h:1247
#: include/linux/skbuff.h:1265 include/linux/skbuff.h:1406
#: include/linux/skbuff.h:1946 include/linux/skbuff.h:1959
#: include/linux/skbuff.h:1972 include/linux/skbuff.h:1990
#: include/linux/skbuff.h:2028 include/linux/skbuff.h:2068
#: include/linux/skbuff.h:2110 include/linux/skbuff.h:2887
#: include/linux/skbuff.h:2898 include/linux/skbuff.h:2909
#: include/linux/skbuff.h:3830 include/linux/skbuff.h:3996
#: include/linux/skbuff.h:4370 include/linux/skbuff.h:5220
#: include/linux/skbuff.h:5240 ../../../networking/kapi:26:
#: net/core/skbuff.c:2101 net/core/skbuff.c:2436 net/core/skbuff.c:2933
#: ../../../networking/kapi:29: net/core/sock.c:3218
#: ../../../networking/kapi:32: net/core/datagram.c:505 net/core/datagram.c:531
#: ../../../networking/kapi:95: net/ethernet/eth.c:203 net/ethernet/eth.c:265
msgid "``const struct sk_buff *skb``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1137
#: include/linux/skbuff.h:1153 include/linux/skbuff.h:1176
#: include/linux/skbuff.h:1198 include/linux/skbuff.h:1209
#: include/linux/skbuff.h:1224 include/linux/skbuff.h:1242
#: include/linux/skbuff.h:1260 include/linux/skbuff.h:1282
#: include/linux/skbuff.h:1405 include/linux/skbuff.h:1945
#: include/linux/skbuff.h:1958 ../../../networking/kapi:26:
#: net/core/skbuff.c:1157 net/core/skbuff.c:6482 net/core/skbuff.c:6537
#: net/core/skbuff.c:6582 net/core/skbuff.c:6615 net/core/skbuff.c:6934
#: net/core/skbuff.c:7030 net/core/skbuff.c:7055
msgid "buffer"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1152
msgid "returns skb dst_entry"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:84
#: include/linux/etherdevice.h:107 include/linux/etherdevice.h:126
#: include/linux/etherdevice.h:160 include/linux/etherdevice.h:171
#: include/linux/etherdevice.h:186 include/linux/etherdevice.h:202
#: include/linux/etherdevice.h:216 include/linux/etherdevice.h:461
#: ../../../networking/kapi:104: include/linux/netdevice.h:533
#: include/linux/netdevice.h:549 include/linux/netdevice.h:583
#: include/linux/netdevice.h:4038 include/linux/netdevice.h:4058
#: include/linux/netdevice.h:4081 ../../../networking/kapi:113:
#: drivers/net/phy/phy.c:142 drivers/net/phy/phy.c:1064
#: drivers/net/phy/phy.c:1729 drivers/net/phy/phy.c:1835
#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1431
#: drivers/net/phy/phy.c:1492 ../../../networking/kapi:119:
#: drivers/net/phy/phy-core.c:739 ../../../networking/kapi:125:
#: include/linux/phy.h:303 include/linux/phy.h:1308 include/linux/phy.h:1321
#: include/linux/phy.h:1363 include/linux/phy.h:1494 include/linux/phy.h:1754
#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:563
#: drivers/net/phy/phy_device.c:1512 drivers/net/phy/phy_device.c:2587
#: drivers/net/phy/phy_device.c:2639 drivers/net/phy/phy_device.c:3072
#: drivers/net/phy/phy_device.c:3095 ../../../networking/kapi:131:
#: drivers/net/phy/phy_device.c:282 ../../../networking/kapi:147:
#: include/linux/phylink.h:438 ../../../networking/kapi:150:
#: drivers/net/phy/phylink.c:230 drivers/net/phy/phylink.c:331
#: drivers/net/phy/phylink.c:403 drivers/net/phy/phylink.c:1781
#: drivers/net/phy/phylink.c:3430 drivers/net/phy/phylink.c:4149
#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:605
#: drivers/net/phy/sfp-bus.c:652 drivers/net/phy/sfp-bus.c:714
#: ../../../networking/kapi:17: include/linux/skbuff.h:1155
#: include/linux/skbuff.h:1185 include/linux/skbuff.h:1284
#: include/linux/skbuff.h:1407 include/linux/skbuff.h:3088
#: include/linux/skbuff.h:3600 include/linux/skbuff.h:3672
#: include/linux/skbuff.h:3687 include/linux/skbuff.h:3702
#: include/linux/skbuff.h:3718 include/linux/skbuff.h:3733
#: include/linux/skbuff.h:3993 ../../../networking/kapi:20:
#: include/net/sock.h:2310 include/net/sock.h:2321 include/net/sock.h:2332
#: include/net/sock.h:2343 include/net/sock.h:2585 ../../../networking/kapi:26:
#: net/core/skbuff.c:313 net/core/skbuff.c:4472 ../../../networking/kapi:32:
#: net/core/datagram.c:507 net/core/datagram.c:882 ../../../networking/kapi:65:
#: net/sunrpc/xprt.c:96 net/sunrpc/xprt.c:130 net/sunrpc/xprt.c:229
#: ../../../networking/kapi:92: net/core/dev.c:1238 net/core/dev.c:4664
#: net/core/dev.c:9840 net/core/dev.c:9971 net/core/dev.c:12098
msgid "**Return**"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1155
msgid "skb dst_entry, regardless of reference taken or not."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1175
msgid "return current dst_entry value and clear it"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:621
#: include/linux/etherdevice.h:654 ../../../networking/kapi:104:
#: include/linux/netdevice.h:3987 ../../../networking/kapi:17:
#: include/linux/skbuff.h:1181 include/linux/skbuff.h:1203
#: include/linux/skbuff.h:1214 include/linux/skbuff.h:1229
#: include/linux/skbuff.h:1287 include/linux/skbuff.h:1332
#: include/linux/skbuff.h:1470 include/linux/skbuff.h:2011
#: include/linux/skbuff.h:2097 include/linux/skbuff.h:2122
#: include/linux/skbuff.h:2157 include/linux/skbuff.h:2220
#: include/linux/skbuff.h:2590 include/linux/skbuff.h:2602
#: include/linux/skbuff.h:2651 include/linux/skbuff.h:2671
#: include/linux/skbuff.h:2924 include/linux/skbuff.h:2938
#: include/linux/skbuff.h:3090 include/linux/skbuff.h:3343
#: include/linux/skbuff.h:3372 include/linux/skbuff.h:3391
#: include/linux/skbuff.h:3614 include/linux/skbuff.h:3865
#: include/linux/skbuff.h:3882 include/linux/skbuff.h:3897
#: include/linux/skbuff.h:3915 include/linux/skbuff.h:3941
#: include/linux/skbuff.h:3984 include/linux/skbuff.h:4009
#: include/linux/skbuff.h:4034 include/linux/skbuff.h:4064
#: include/linux/skbuff.h:4081 include/linux/skbuff.h:4100
#: include/linux/skbuff.h:4316 include/linux/skbuff.h:4591
#: include/linux/skbuff.h:4624 include/linux/skbuff.h:4643
#: include/linux/skbuff.h:4663 ../../../networking/kapi:20:
#: include/net/sock.h:2927 ../../../networking/kapi:26: net/core/skbuff.c:500
#: net/core/skbuff.c:1162 net/core/skbuff.c:1194 net/core/skbuff.c:1374
#: net/core/skbuff.c:1391 net/core/skbuff.c:1923 net/core/skbuff.c:2024
#: net/core/skbuff.c:2149 net/core/skbuff.c:2214 net/core/skbuff.c:2385
#: net/core/skbuff.c:2502 net/core/skbuff.c:2551 net/core/skbuff.c:2574
#: net/core/skbuff.c:2595 net/core/skbuff.c:2614 net/core/skbuff.c:2630
#: net/core/skbuff.c:2654 net/core/skbuff.c:2779 net/core/skbuff.c:3365
#: net/core/skbuff.c:4049 net/core/skbuff.c:4154 net/core/skbuff.c:4320
#: net/core/skbuff.c:4517 net/core/skbuff.c:4567 net/core/skbuff.c:5217
#: net/core/skbuff.c:5270 net/core/skbuff.c:5456 net/core/skbuff.c:5704
#: net/core/skbuff.c:5939 net/core/skbuff.c:6004 net/core/skbuff.c:6168
#: net/core/skbuff.c:6405 net/core/skbuff.c:6431 net/core/skbuff.c:6485
#: net/core/skbuff.c:6541 net/core/skbuff.c:6586 net/core/skbuff.c:6619
#: net/core/skbuff.c:6939 net/core/skbuff.c:7035 net/core/skbuff.c:7060
#: net/core/skbuff.c:7244 ../../../networking/kapi:32: net/core/datagram.c:357
#: net/core/datagram.c:547 net/core/datagram.c:781 net/core/datagram.c:882
#: ../../../networking/kapi:41: net/core/filter.c:124
#: ../../../networking/kapi:50: net/core/gen_stats.c:46
#: net/core/gen_stats.c:102 ../../../networking/kapi:92: net/core/dev.c:702
#: net/core/dev.c:2441 net/core/dev.c:4264 net/core/dev.c:4656
#: net/core/dev.c:5603 net/core/dev.c:5624 net/core/dev.c:6091
#: net/core/dev.c:6323 net/core/dev.c:9250 ../../../networking/kapi:95:
#: net/ethernet/eth.c:73 net/ethernet/eth.c:153
msgid "``struct sk_buff *skb``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1177
msgid ""
"Resets skb dst_entry without adjusting its reference count. Useful in cases "
"where dst_entry needs to be temporarily reset and restored. Note that the "
"returned value cannot be used directly because it might contain "
"SKB_DST_NOREF bit."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1182
msgid ""
"When in doubt, prefer skb_dst_drop() over skb_dstref_steal() to correctly "
"handle dst_entry reference counting."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1186
msgid "original skb dst_entry."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1197
msgid "restore skb dst_entry removed via skb_dstref_steal()"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1200
msgid "``unsigned long refdst``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1199
msgid "dst entry from a call to skb_dstref_steal()"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1208
msgid "sets skb dst"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1211
#: include/linux/skbuff.h:1226
msgid "``struct dst_entry *dst``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1210
#: include/linux/skbuff.h:1225
msgid "dst entry"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1211
msgid ""
"Sets skb dst, assuming a reference was taken on dst and should be released "
"by skb_dst_drop()"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1223
msgid "sets skb dst, hopefully, without taking reference"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1226
msgid ""
"Sets skb dst, assuming a reference was not taken on dst. If dst entry is "
"cached, we do not take reference and dst_release will be avoided by "
"refdst_drop. If dst entry is not cached, we take reference, so that last "
"dst_release can destroy the dst immediately."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1241
msgid "Test if skb dst isn't refcounted"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1259
msgid "Returns the skb's NAPI id"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1281
msgid "decrement the skb's reference count"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1284
msgid "true if we can free the skb."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1326
msgid "free an sk_buff with 'NOT_SPECIFIED' reason"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1327
#: ../../../networking/kapi:26: net/core/skbuff.c:1193 net/core/skbuff.c:1386
msgid "buffer to free"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1374
#: ../../../networking/kapi:26: net/core/skbuff.c:625
msgid "allocate a network buffer"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1375
#: include/linux/skbuff.h:1425 ../../../networking/kapi:26:
#: net/core/skbuff.c:626
msgid "size to allocate"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1377
#: include/linux/skbuff.h:1427 ../../../networking/kapi:29:
#: net/core/sock.c:2287
msgid "``gfp_t priority``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1376
#: include/linux/skbuff.h:1426 ../../../networking/kapi:26:
#: net/core/skbuff.c:627 net/core/skbuff.c:6651
msgid "allocation mask"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1377
#: include/linux/skbuff.h:1427
msgid "This function is a convenient wrapper around __alloc_skb()."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1403
msgid "check if fclone is busy"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1409
#: ../../../networking/kapi:20: include/net/sock.h:623 include/net/sock.h:634
#: include/net/sock.h:659 include/net/sock.h:2313 include/net/sock.h:2324
#: include/net/sock.h:2335 ../../../networking/kapi:29: net/core/sock.c:168
#: net/core/sock.c:186 net/core/sock.c:201 net/core/sock.c:2460
msgid "``const struct sock *sk``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1404
#: ../../../networking/kapi:20: include/net/sock.h:618 include/net/sock.h:632
#: include/net/sock.h:657 include/net/sock.h:1697 include/net/sock.h:1726
#: include/net/sock.h:2308 include/net/sock.h:2319 include/net/sock.h:2330
#: include/net/sock.h:2575 ../../../networking/kapi:23: net/socket.c:464
#: net/socket.c:747 net/socket.c:775 net/socket.c:1089 net/socket.c:3579
#: net/socket.c:3599 net/socket.c:3654 net/socket.c:3679 net/socket.c:3694
#: net/socket.c:3709 net/socket.c:3723 ../../../networking/kapi:29:
#: net/core/sock.c:3357 net/core/sock.c:3398 ../../../networking/kapi:32:
#: net/core/datagram.c:209 net/core/datagram.c:355 net/core/datagram.c:925
msgid "socket"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1407
msgid ""
"true if skb is a fast clone, and its clone is not freed. Some drivers call "
"skb_orphan() in their ndo_start_xmit(), so we also check that didn't happen."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1424
msgid "allocate a network buffer from fclone cache"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1464
#: ../../../networking/kapi:26: net/core/skbuff.c:2496
msgid "zero pad the tail of an skb"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1465
#: include/linux/skbuff.h:3892 include/linux/skbuff.h:3910
#: include/linux/skbuff.h:3936 ../../../networking/kapi:26:
#: net/core/skbuff.c:2497
msgid "buffer to pad"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1467
#: ../../../networking/kapi:26: net/core/skbuff.c:2499
msgid "``int pad``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1466
#: ../../../networking/kapi:26: net/core/skbuff.c:2498
msgid "space to pad"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1467
#: ../../../networking/kapi:26: net/core/skbuff.c:2500
msgid ""
"Ensure that a buffer is followed by a padding area that is zero filled. Used "
"by network drivers which may DMA or transfer data beyond the buffer end onto "
"the wire."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1471
msgid "May return error in out of memory cases. The skb is freed on error."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1919
#: include/linux/skbuff.h:1930
msgid "check if a queue is empty"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1925
#: include/linux/skbuff.h:1936 include/linux/skbuff.h:1949
#: include/linux/skbuff.h:1962 include/linux/skbuff.h:1975
#: include/linux/skbuff.h:1993 include/linux/skbuff.h:2356
#: include/linux/skbuff.h:2387
msgid "``const struct sk_buff_head *list``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1921
msgid "Returns true if the queue is empty, false otherwise."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1932
msgid ""
"Returns true if the queue is empty, false otherwise. This variant can be "
"used in lockless contexts."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1943
msgid "check if skb is the last entry in the queue"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1946
msgid "Returns true if **skb** is the last buffer on the list."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1956
msgid "check if skb is the first entry in the queue"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1959
msgid "Returns true if **skb** is the first buffer on the list."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1969
msgid "return the next packet in the queue"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1971
#: include/linux/skbuff.h:1989
msgid "current buffer"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1972
msgid ""
"Return the next packet in **list** after **skb**.  It is only valid to call "
"this if skb_queue_is_last() evaluates to false."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1987
msgid "return the prev packet in the queue"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:1990
msgid ""
"Return the prev packet in **list** before **skb**.  It is only valid to call "
"this if skb_queue_is_first() evaluates to false."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2005
msgid "reference buffer"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2006
msgid "buffer to reference"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2007
msgid ""
"Makes another reference to a socket buffer and returns a pointer to the "
"buffer."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2022
msgid "is the buffer a clone"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2023
#: include/linux/skbuff.h:2063 include/linux/skbuff.h:2105
#: include/linux/skbuff.h:2117 include/linux/skbuff.h:2152
#: include/linux/skbuff.h:2882 include/linux/skbuff.h:2893
#: include/linux/skbuff.h:2904 include/linux/skbuff.h:3825
msgid "buffer to check"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2024
msgid ""
"Returns true if the buffer was generated with skb_clone() and is one of "
"multiple shared copies of the buffer. Cloned buffers are shared data so must "
"not be written to under normal circumstances."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2062
msgid "is the header a clone"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2064
msgid ""
"Returns true if modifying the header part of the buffer requires the data to "
"be copied."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2091
msgid "allow clones to use the headroom"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2092
msgid "buffer to operate on"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2093
msgid "See \"DOC: dataref and headerless skbs\"."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2104
msgid "is the buffer shared"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2106
msgid "Returns true if more than one person has a reference to this buffer."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2116
msgid "check if buffer is shared and if so clone it"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2119
#: include/linux/skbuff.h:2154
msgid "``gfp_t pri``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2118
#: include/linux/skbuff.h:2153 ../../../networking/kapi:29:
#: net/core/sock.c:3094
msgid "priority for memory allocation"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2119
msgid ""
"If the buffer is shared the buffer is cloned and the old copy drops a "
"reference. A new clone with a single reference is returned. If the buffer is "
"not shared the original buffer is returned. When being called from interrupt "
"status or with spinlocks held pri must be GFP_ATOMIC."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2125
msgid "NULL is returned on a memory allocation failure."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2151
msgid "make a copy of a shared buffer"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2154
msgid ""
"If the socket buffer is a clone then this function creates a new copy of the "
"data, drops a reference count on the old copy and returns the new copy with "
"the reference count at 1. If the buffer is not a clone the original buffer "
"is returned. When called with a spinlock held or from interrupt state "
"**pri** must be ``GFP_ATOMIC``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2160
msgid "``NULL`` is returned on a memory allocation failure."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2181
msgid "peek at the head of an :c:type:`sk_buff_head`"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2187
#: include/linux/skbuff.h:2209 include/linux/skbuff.h:2217
#: include/linux/skbuff.h:2239 include/linux/skbuff.h:2262
#: include/linux/skbuff.h:2273
msgid "``const struct sk_buff_head *list_``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2182
#: include/linux/skbuff.h:2204 include/linux/skbuff.h:2216
#: include/linux/skbuff.h:2234
msgid "list to peek at"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2183
#: include/linux/skbuff.h:2235
msgid ""
"Peek an :c:type:`sk_buff`. Unlike most other operations you _MUST_ be "
"careful with this one. A peek leaves the buffer on the list and someone else "
"may run off with it. You must hold the appropriate locks or have a private "
"queue to do this."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2188
msgid ""
"Returns ``NULL`` for an empty list or a pointer to the head element. The "
"reference count is not incremented and the reference is therefore volatile. "
"Use with caution."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2203
msgid "peek at the head of a non-empty :c:type:`sk_buff_head`"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2205
msgid "Like skb_peek(), but the caller knows that the list is not empty."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2214
msgid "peek skb following the given one from a queue"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2215
msgid "skb to start from"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2217
msgid ""
"Returns ``NULL`` when the end of the list is met or a pointer to the next "
"element. The reference count is not incremented and the reference is "
"therefore volatile. Use with caution."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2233
msgid "peek at the tail of an :c:type:`sk_buff_head`"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2240
msgid ""
"Returns ``NULL`` for an empty list or a pointer to the tail element. The "
"reference count is not incremented and the reference is therefore volatile. "
"Use with caution."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2256
#: include/linux/skbuff.h:2267
msgid "get queue length"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2257
#: include/linux/skbuff.h:2268
msgid "list to measure"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2258
msgid "Return the length of an :c:type:`sk_buff` queue."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2269
msgid ""
"Return the length of an :c:type:`sk_buff` queue. This variant can be used in "
"lockless contexts."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2279
msgid "initialize non-spinlock portions of sk_buff_head"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2285
#: include/linux/skbuff.h:2370 include/linux/skbuff.h:2401
#: include/linux/skbuff.h:2419 include/linux/skbuff.h:2447
#: include/linux/skbuff.h:2464 include/linux/skbuff.h:2498
#: include/linux/skbuff.h:2515 include/linux/skbuff.h:3417
#: ../../../networking/kapi:26: net/core/skbuff.c:3891 net/core/skbuff.c:3912
#: net/core/skbuff.c:3932 net/core/skbuff.c:4007 net/core/skbuff.c:4028
#: net/core/skbuff.c:4046 net/core/skbuff.c:4067
msgid "``struct sk_buff_head *list``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2280
msgid "queue to initialize"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2281
msgid ""
"This initializes only the list and queue length aspects of an sk_buff_head "
"object.  This allows to initialize the list aspects of an sk_buff_head "
"without reinitializing things like the spinlock.  It can also be used for on-"
"stack sk_buff_head objects where the spinlock is known to not be used."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2350
msgid "join two skb lists, this is designed for stacks"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2351
#: include/linux/skbuff.h:2365 include/linux/skbuff.h:2382
#: include/linux/skbuff.h:2396
msgid "the new list to add"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2353
#: include/linux/skbuff.h:2367 include/linux/skbuff.h:2384
#: include/linux/skbuff.h:2398
msgid "``struct sk_buff_head *head``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2352
#: include/linux/skbuff.h:2366 include/linux/skbuff.h:2383
#: include/linux/skbuff.h:2397
msgid "the place to add it in the first list"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2364
#: include/linux/skbuff.h:2395
msgid "join two skb lists and reinitialise the emptied list"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2367
msgid "The list at **list** is reinitialised"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2381
msgid "join two skb lists, each list being a queue"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2398
msgid "Each of the lists is a queue. The list at **list** is reinitialised"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2413
#: include/linux/skbuff.h:2441 ../../../networking/kapi:26:
#: net/core/skbuff.c:4001
msgid "queue a buffer at the list head"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2414
#: include/linux/skbuff.h:2442 include/linux/skbuff.h:2459
#: ../../../networking/kapi:26: net/core/skbuff.c:4002 net/core/skbuff.c:4023
#: net/core/skbuff.c:4045 net/core/skbuff.c:4066
msgid "list to use"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2416
msgid "``struct sk_buff *prev``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2415
msgid "place after this buffer"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2417
#: include/linux/skbuff.h:2444 include/linux/skbuff.h:2461
#: ../../../networking/kapi:26: net/core/skbuff.c:4004 net/core/skbuff.c:4025
#: net/core/skbuff.c:4066
msgid "``struct sk_buff *newsk``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2416
#: include/linux/skbuff.h:2443 include/linux/skbuff.h:2460
#: ../../../networking/kapi:26: net/core/skbuff.c:4003 net/core/skbuff.c:4024
msgid "buffer to queue"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2417
msgid ""
"Queue a buffer int the middle of a list. This function takes no locks and "
"you must therefore hold required locks before calling it."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2420
#: include/linux/skbuff.h:2447 include/linux/skbuff.h:2464
#: ../../../networking/kapi:26: net/core/skbuff.c:4008 net/core/skbuff.c:4029
msgid "A buffer cannot be placed on two lists at the same time."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2444
msgid ""
"Queue a buffer at the start of a list. This function takes no locks and you "
"must therefore hold required locks before calling it."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2458
#: ../../../networking/kapi:26: net/core/skbuff.c:4022
msgid "queue a buffer at the list tail"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2461
msgid ""
"Queue a buffer at the end of a list. This function takes no locks and you "
"must therefore hold required locks before calling it."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2492
#: ../../../networking/kapi:26: net/core/skbuff.c:3885
msgid "remove from the head of the queue"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2493
#: include/linux/skbuff.h:2510 ../../../networking/kapi:26:
#: net/core/skbuff.c:3886 net/core/skbuff.c:3907
msgid "list to dequeue from"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2494
msgid ""
"Remove the head of the list. This function does not take any locks so must "
"be used with appropriate locks held only. The head item is returned or "
"``NULL`` if the list is empty."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2509
#: ../../../networking/kapi:26: net/core/skbuff.c:3906
msgid "remove from the tail of the queue"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2511
msgid ""
"Remove the tail of the list. This function does not take any locks so must "
"be used with appropriate locks held only. The tail item is returned or "
"``NULL`` if the list is empty."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2584
msgid "adds a number to len fields of skb"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2585
msgid "buffer to add len to"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2586
msgid "number of bytes to add"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2596
msgid "initialise a fragment in an skb"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2597
#: include/linux/skbuff.h:2646 include/linux/skbuff.h:2666
msgid "buffer containing fragment to be initialised"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2599
#: include/linux/skbuff.h:2648 include/linux/skbuff.h:2668
msgid "``int i``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2598
msgid "fragment index to initialise"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2600
msgid "``netmem_ref netmem``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2599
msgid "the netmem to use for this fragment"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2601
#: include/linux/skbuff.h:2650 include/linux/skbuff.h:2670
msgid "``int off``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2600
#: include/linux/skbuff.h:2649 include/linux/skbuff.h:2669
msgid "the offset to the data with **page**"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2991
#: ../../../networking/kapi:17: include/linux/skbuff.h:2602
#: include/linux/skbuff.h:2651 include/linux/skbuff.h:2671
#: ../../../networking/kapi:29: net/core/sock.c:3359
msgid "``int size``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2601
#: include/linux/skbuff.h:2650 include/linux/skbuff.h:2670
msgid "the length of the data"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2602
msgid ""
"Initialises the **i**'th fragment of **skb** to point to :c:type:`size` "
"bytes at offset **off** within **page**."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2605
#: include/linux/skbuff.h:2655
msgid "Does not take any additional reference on the fragment."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2645
#: include/linux/skbuff.h:2665
msgid "initialise a paged fragment in an skb"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2647
#: include/linux/skbuff.h:2667
msgid "paged fragment index to initialise"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2649
#: include/linux/skbuff.h:2669
msgid "``struct page *page``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2648
#: include/linux/skbuff.h:2668
msgid "the page to use for this fragment"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2651
msgid ""
"As per __skb_fill_page_desc() -- initialises the **i**'th fragment of "
"**skb** to point to **size** bytes at offset **off** within **page**. In "
"addition updates **skb** such that **i** is the last fragment."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2671
msgid ""
"Variant of skb_fill_page_desc() which does not deal with pfmemalloc, if page "
"is not owned by us."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2881
msgid "bytes at buffer head"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2883
msgid ""
"Return the number of bytes of free space at the head of an :c:type:`sk_buff`."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2892
#: include/linux/skbuff.h:2903
msgid "bytes at buffer end"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2894
msgid "Return the number of bytes of free space at the tail of an sk_buff"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2905
msgid ""
"Return the number of bytes of free space at the tail of an sk_buff allocated "
"by sk_stream_alloc()"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2918
msgid "adjust headroom"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2919
#: include/linux/skbuff.h:2933 include/linux/skbuff.h:3085
#: include/linux/skbuff.h:3338 ../../../networking/kapi:26:
#: net/core/skbuff.c:2649 ../../../networking/kapi:95: net/ethernet/eth.c:68
msgid "buffer to alter"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2921
#: ../../../networking/kapi:26: net/core/skbuff.c:2549 net/core/skbuff.c:2932
#: net/core/skbuff.c:3364 net/core/skbuff.c:3784 net/core/skbuff.c:4467
#: net/core/skbuff.c:5216 ../../../networking/kapi:32: net/core/datagram.c:505
#: net/core/datagram.c:530 net/core/datagram.c:546 ../../../networking/kapi:50:
#: net/core/gen_stats.c:417
msgid "``int len``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2920
msgid "bytes to move"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2921
msgid ""
"Increase the headroom of an empty :c:type:`sk_buff` by reducing the tail "
"room. This is only allowed for an empty buffer."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2932
msgid "adjust reserved_tailroom"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2935
msgid "``unsigned int mtu``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2934
msgid "maximum amount of headlen permitted"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2936
msgid "``unsigned int needed_tailroom``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2935
msgid "minimum amount of reserved_tailroom"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:2936
msgid ""
"Set reserved_tailroom so that headlen can be as large as possible but not "
"larger than mtu and tailroom cannot be smaller than needed_tailroom. The "
"required headroom should already have been reserved before using this "
"function."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3084
msgid "conditionally reset transport header"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3086
msgid "Hardened version of skb_reset_transport_header()."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3089
msgid "true if the operation was a success."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3337
msgid "remove end from a paged unique (not cloned) buffer"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3340
#: include/linux/skbuff.h:3827 include/linux/skbuff.h:3894
#: include/linux/skbuff.h:3912 include/linux/skbuff.h:3938
#: include/linux/skbuff.h:4032 include/linux/skbuff.h:4062
#: include/linux/skbuff.h:4078 include/linux/skbuff.h:4097
#: ../../../networking/kapi:26: net/core/skbuff.c:709 net/core/skbuff.c:787
#: net/core/skbuff.c:2571 net/core/skbuff.c:2592 net/core/skbuff.c:2611
#: net/core/skbuff.c:2651 net/core/skbuff.c:4564 ../../../networking/kapi:59:
#: net/sunrpc/xdr.c:197 net/sunrpc/xdr.c:1261 net/sunrpc/xdr.c:1427
#: net/sunrpc/xdr.c:1560 net/sunrpc/xdr.c:1589 net/sunrpc/xdr.c:1619
#: net/sunrpc/xdr.c:1654 net/sunrpc/xdr.c:1815 ../../../networking/kapi:83:
#: net/sunrpc/clnt.c:1356 ../../../networking/kapi:95: net/ethernet/eth.c:74
msgid "``unsigned int len``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3339
#: include/linux/skbuff.h:4096 ../../../networking/kapi:26:
#: net/core/skbuff.c:2650
msgid "new length"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3340
msgid ""
"This is identical to pskb_trim except that the caller knows that the skb is "
"not cloned so we should never get an error due to out- of-memory."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3366
msgid "orphan a buffer"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3367
msgid "buffer to orphan"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3368
msgid ""
"If a buffer currently has an owner then we call the owner's destructor "
"function and make the **skb** unowned. The buffer continues to exist but is "
"no longer charged to its former owner."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3385
msgid "orphan the frags contained in a buffer"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3386
msgid "buffer to orphan frags from"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3388
#: include/linux/skbuff.h:3549 include/linux/skbuff.h:3581
#: ../../../networking/kapi:26: net/core/skbuff.c:628 net/core/skbuff.c:710
#: net/core/skbuff.c:1920 net/core/skbuff.c:2021 net/core/skbuff.c:2098
#: net/core/skbuff.c:2147 net/core/skbuff.c:2213 net/core/skbuff.c:2435
#: net/core/skbuff.c:6652
msgid "``gfp_t gfp_mask``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3387
msgid "allocation mask for replacement pages"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3388
msgid ""
"For each frag in the SKB which needs a destructor (i.e. has an owner) create "
"a copy of that frag and release the original page by calling the destructor."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3411
#: ../../../networking/kapi:26: net/core/skbuff.c:3926
msgid "empty a list"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3412
#: ../../../networking/kapi:26: net/core/skbuff.c:3927
msgid "list to empty"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3414
#: ../../../networking/kapi:26: net/core/skbuff.c:1195 net/core/skbuff.c:3929
msgid "``enum skb_drop_reason reason``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3413
#: ../../../networking/kapi:26: net/core/skbuff.c:3928
msgid "drop reason"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3414
msgid ""
"Delete all buffers on an :c:type:`sk_buff` list. Each buffer is removed from "
"the list and one reference dropped. This function does not take the list "
"lock and the caller must hold the relevant locks to use it."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3447
msgid "allocate a page fragment"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3453
msgid "``unsigned int fragsz``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3448
msgid "fragment size"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3449
msgid ""
"Allocates a frag from a page for receive buffer. Uses GFP_ATOMIC allocations."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3469
#: ../../../networking/kapi:26: net/core/skbuff.c:706
msgid "allocate an skbuff for rx on a specific device"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:272
#: include/linux/etherdevice.h:323 include/linux/etherdevice.h:600
#: ../../../networking/kapi:104: include/linux/netdevice.h:2809
#: include/linux/netdevice.h:2851 include/linux/netdevice.h:2867
#: include/linux/netdevice.h:3587 include/linux/netdevice.h:3610
#: include/linux/netdevice.h:3644 include/linux/netdevice.h:3807
#: include/linux/netdevice.h:3863 include/linux/netdevice.h:3910
#: include/linux/netdevice.h:3948 include/linux/netdevice.h:3962
#: include/linux/netdevice.h:4003 include/linux/netdevice.h:4424
#: include/linux/netdevice.h:4436 include/linux/netdevice.h:4475
#: include/linux/netdevice.h:4504 include/linux/netdevice.h:4522
#: include/linux/netdevice.h:4546 include/linux/netdevice.h:4562
#: include/linux/netdevice.h:4766 include/linux/netdevice.h:4949
#: include/linux/netdevice.h:4967 include/linux/netdevice.h:4993
#: include/linux/netdevice.h:5011 ../../../networking/kapi:113:
#: drivers/net/phy/phy.c:438 drivers/net/phy/phy.c:453
#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1259
#: drivers/net/phy/phy_device.c:1287 drivers/net/phy/phy_device.c:1618
#: drivers/net/phy/phy_device.c:1792 ../../../networking/kapi:17:
#: include/linux/skbuff.h:3475 ../../../networking/kapi:26:
#: net/core/skbuff.c:712 ../../../networking/kapi:92: net/core/dev.c:705
#: net/core/dev.c:1420 net/core/dev.c:1569 net/core/dev.c:1596
#: net/core/dev.c:1615 net/core/dev.c:2274 net/core/dev.c:2443
#: net/core/dev.c:3219 net/core/dev.c:3250 net/core/dev.c:3294
#: net/core/dev.c:3313 net/core/dev.c:3454 net/core/dev.c:3469
#: net/core/dev.c:5097 net/core/dev.c:5749 net/core/dev.c:5765
#: net/core/dev.c:5797 net/core/dev.c:7138 net/core/dev.c:7155
#: net/core/dev.c:7860 net/core/dev.c:7883 net/core/dev.c:7905
#: net/core/dev.c:7920 net/core/dev.c:7984 net/core/dev.c:8154
#: net/core/dev.c:8181 net/core/dev.c:8209 net/core/dev.c:8499
#: net/core/dev.c:8520 net/core/dev.c:8795 net/core/dev.c:8820
#: net/core/dev.c:8881 net/core/dev.c:8995 net/core/dev.c:9253
#: net/core/dev.c:9286 net/core/dev.c:9841 net/core/dev.c:9971
#: net/core/dev.c:10961 net/core/dev.c:10976 net/core/dev.c:10990
#: net/core/dev.c:11181 net/core/dev.c:11396 net/core/dev.c:11715
#: net/core/dev.c:11810 net/core/dev.c:11853 net/core/dev.c:12034
#: net/core/dev.c:12145 net/core/dev.c:12358 ../../../networking/kapi:95:
#: net/ethernet/eth.c:70 net/ethernet/eth.c:150 net/ethernet/eth.c:277
#: net/ethernet/eth.c:294 net/ethernet/eth.c:307 net/ethernet/eth.c:346
#: ../../../networking/kapi:98: net/sched/sch_generic.c:583
#: net/sched/sch_generic.c:602 net/sched/sch_generic.c:619
msgid "``struct net_device *dev``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3470
#: ../../../networking/kapi:26: net/core/skbuff.c:707
msgid "network device to receive on"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3472
#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1763 net/sunrpc/xdr.c:1793
msgid "``unsigned int length``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3471
#: ../../../networking/kapi:26: net/core/skbuff.c:708 net/core/skbuff.c:786
msgid "length to allocate"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3472
msgid ""
"Allocate a new :c:type:`sk_buff` and assign it a usage count of one. The "
"buffer has unspecified headroom built in. Users should allocate the headroom "
"they think they need without accounting for the built in space. The built in "
"space is used for optimisations."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3477
msgid ""
"``NULL`` is returned if there is no free memory. Although this function "
"allocates memory it can be called from an interrupt."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3543
msgid "allocate page for network Rx"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3544
#: include/linux/skbuff.h:3576
msgid "allocation priority. Set __GFP_NOMEMALLOC if not for network Rx"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3546
msgid "``unsigned int order``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3545
msgid "size of the allocation"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3546
#: include/linux/skbuff.h:3577
msgid "Allocate a new page."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3548
#: include/linux/skbuff.h:3579 ../../../networking/kapi:26:
#: net/core/skbuff.c:715 net/core/skbuff.c:792
msgid "``NULL`` is returned if there is no free memory."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3575
msgid "allocate a page for network Rx"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3595
msgid "check whether a page can be reused for network Rx"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3601
#: include/linux/skbuff.h:3617
msgid "``const struct page *page``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3596
msgid "the page to test"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3597
msgid ""
"A page shouldn't be considered for reusing/recycling if it was allocated "
"under memory pressure or at a distant memory node."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3601
msgid ""
"false if this page should be returned to page allocator, true otherwise."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3611
msgid "Propagate pfmemalloc if skb is allocated after RX page"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3612
msgid "The page that was allocated from skb_alloc_page"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3613
msgid "The skb that may need pfmemalloc set"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3623
msgid "Returns the offset of a skb fragment"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3624
#: include/linux/skbuff.h:3685
msgid "the paged fragment"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3632
msgid "Increments the offset of a skb fragment by **delta**"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3642
msgid "Sets the offset of a skb fragment"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3645
#: ../../../networking/kapi:59: net/sunrpc/xdr.c:194 net/sunrpc/xdr.c:1761
#: net/sunrpc/xdr.c:1792
msgid "``unsigned int offset``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3644
msgid "offset of fragment"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3652
msgid "Sets the offset of a skb fragment from another fragment"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3658
#: include/linux/skbuff.h:3758
msgid "``skb_frag_t *fragto``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3653
msgid "skb fragment where offset is set"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3655
#: include/linux/skbuff.h:3755
msgid "``const skb_frag_t *fragfrom``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3654
msgid "skb fragment offset is copied from"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3669
msgid "retrieve the net_iov referred to by fragment"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3670
#: include/linux/skbuff.h:3700
msgid "the fragment"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3672
msgid ""
"the :c:type:`struct net_iov <net_iov>` associated with **frag**. Returns "
"NULL if this frag has no associated net_iov."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3684
msgid "retrieve the page referred to by a paged fragment"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3687
msgid ""
"the :c:type:`struct page <page>` associated with **frag**. Returns NULL if "
"this frag has no associated page."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3699
msgid "retrieve the netmem referred to by a fragment"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3702
msgid "the :c:type:`netmem_ref` associated with **frag**."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3715
#: include/linux/skbuff.h:3730
msgid "gets the address of the data contained in a paged fragment"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3716
#: include/linux/skbuff.h:3731
msgid "the paged fragment buffer"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3718
msgid ""
"the address of the data within **frag**. The page must already be mapped."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3733
msgid ""
"the address of the data within **frag**. Checks that the page is mapped and "
"returns ``NULL`` otherwise."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3752
msgid "sets the page in a fragment from another fragment"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3753
msgid "skb fragment where page is set"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3754
msgid "skb fragment page is copied from"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3765
msgid "maps a paged fragment via the DMA API"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:3069
#: drivers/net/phy/phy_device.c:3093 ../../../networking/kapi:131:
#: drivers/net/phy/phy_device.c:3395 ../../../networking/kapi:137:
#: drivers/net/phy/mdio_bus.c:943 ../../../networking/kapi:17:
#: include/linux/skbuff.h:3771 ../../../networking/kapi:95:
#: net/ethernet/eth.c:513 net/ethernet/eth.c:616 net/ethernet/eth.c:630
msgid "``struct device *dev``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3766
msgid "the device to map the fragment to"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3767
msgid "the paged fragment to map"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3769
msgid "``size_t offset``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3768
msgid "the offset within the fragment (starting at the fragment's own offset)"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3771
#: ../../../networking/kapi:23: net/socket.c:780 net/socket.c:1111
msgid "``size_t size``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3770
msgid "the number of bytes to map"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3772
msgid "``enum dma_data_direction dir``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3771
msgid "the direction of the mapping (``PCI_DMA_*``)"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3772
msgid "Maps the page associated with **frag** to **device**."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3824
msgid "is the header of a clone writable"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3826
msgid "length up to which to write"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3827
msgid ""
"Returns true if modifying the header part of the cloned buffer does not "
"requires the data to be copied."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3859
msgid "copy header of skb when it is required"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3860
#: include/linux/skbuff.h:3877
msgid "buffer to cow"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3862
#: include/linux/skbuff.h:3879 ../../../networking/kapi:26:
#: net/core/skbuff.c:2382
msgid "``unsigned int headroom``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3861
#: include/linux/skbuff.h:3878 ../../../networking/kapi:26:
#: net/core/skbuff.c:2381
msgid "needed headroom"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3862
msgid ""
"If the skb passed lacks sufficient headroom or its data part is shared, data "
"is reallocated. If reallocation fails, an error is returned and original skb "
"is not changed."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3866
msgid ""
"The result is skb with writable area skb->head...skb->tail and at least "
"**headroom** of space at head."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3876
msgid "skb_cow but only making the head writable"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3879
msgid ""
"This function is identical to skb_cow except that we replace the skb_cloned "
"check by skb_header_cloned.  It should be used when you only need to push on "
"some header and do not need to modify the data."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3891
msgid "pad an skbuff up to a minimal size"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3893
#: include/linux/skbuff.h:3911 include/linux/skbuff.h:3937
msgid "minimal length"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3894
#: include/linux/skbuff.h:3938
msgid ""
"Pads up a buffer to ensure the trailing bytes exist and are blanked. If the "
"buffer already contains sufficient data it is untouched. Otherwise it is "
"extended. Returns zero on success. The skb is freed on error."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3909
#: include/linux/skbuff.h:3935
msgid "increase size and pad an skbuff up to a minimal size"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3913
#: ../../../networking/kapi:26: net/core/skbuff.c:2500
msgid "``bool free_on_error``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3912
#: ../../../networking/kapi:26: net/core/skbuff.c:2499
msgid "free buffer on error"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3913
msgid ""
"Pads up a buffer to ensure the trailing bytes exist and are blanked. If the "
"buffer already contains sufficient data it is untouched. Otherwise it is "
"extended. Returns zero on success. The skb is freed on error if "
"**free_on_error** is true."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3978
msgid "convert paged skb to linear one"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3979
msgid "buffer to linarize"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3980
#: include/linux/skbuff.h:4005
msgid ""
"If there is no free memory -ENOMEM is returned, otherwise zero is returned "
"and the old skb data released."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3990
msgid "can any frag be overwritten"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3991
msgid "buffer to test"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:3993
msgid ""
"true if the skb has at least one frag that might be modified by an external "
"entity (as in vmsplice()/sendfile())"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4003
msgid "make sure skb is linear and writable"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4004
#: ../../../networking/kapi:92: net/core/dev.c:6086 net/core/dev.c:6318
msgid "buffer to process"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4028
msgid "update checksum for received skb after pull"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4029
#: include/linux/skbuff.h:4059 include/linux/skbuff.h:4076
#: ../../../networking/kapi:26: net/core/skbuff.c:4562
msgid "buffer to update"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4031
#: include/linux/skbuff.h:4061
msgid "``const void *start``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4030
msgid "start of data before pull"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4031
#: include/linux/skbuff.h:4077 ../../../networking/kapi:26:
#: net/core/skbuff.c:4563
msgid "length of data pulled"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4032
msgid ""
"After doing a pull on a received packet, you need to call this to update the "
"CHECKSUM_COMPLETE checksum, or set ip_summed to CHECKSUM_NONE so that it can "
"be recomputed from scratch."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4058
msgid "update checksum for received skb after push"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4060
msgid "start of data after push"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4061
msgid "length of data pushed"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4062
msgid ""
"After doing a push on a received packet, you need to call this to update the "
"CHECKSUM_COMPLETE checksum."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4075
msgid "push skb and update receive checksum"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4078
msgid ""
"This function performs an skb_push on the packet and updates the "
"CHECKSUM_COMPLETE checksum.  It should be used on receive path processing "
"instead of skb_push unless you know that the checksum difference is zero (e."
"g., a valid IP header) or you are setting ip_summed to CHECKSUM_NONE."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4094
msgid "trim received skb and update checksum"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4095
msgid "buffer to trim"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4097
msgid ""
"This is exactly the same as pskb_trim except that it ensures the checksum of "
"received packets are still valid after the operation. It can change skb "
"pointers."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4310
msgid ""
"check if we need to linearize a given skb depending on the given device "
"features."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4312
msgid "socket buffer to check"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4314
#: ../../../networking/kapi:26: net/core/skbuff.c:4690
msgid "``netdev_features_t features``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4313
msgid "net device features"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4314
msgid ""
"Returns true if either: 1. skb has frag_list and the device doesn't support "
"FRAGLIST, or 2. skb is fragmented and the device does not support SG."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4364
msgid "get timestamp from a skb"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4365
msgid "skb to get stamp from"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4367
msgid "``struct __kernel_old_timeval *stamp``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4366
msgid "pointer to struct __kernel_old_timeval to store stamp in"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4367
msgid ""
"Timestamps are stored in the skb as offsets to a base timestamp. This "
"function converts the offset back to a struct timeval and stores it in stamp."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4585
msgid "deliver cloned skb with tx timestamps"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4592
msgid "clone of the original outgoing packet"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4594
#: include/linux/skbuff.h:4607
msgid "``struct skb_shared_hwtstamps *hwtstamps``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4586
msgid ""
"PHY drivers may accept clones of transmitted packets for timestamping via "
"their phy_driver.txtstamp method. These drivers must call this function to "
"return the skb back to the stack with a timestamp."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4604
msgid "queue clone of skb with send time stamps"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4610
msgid "``struct sk_buff *orig_skb``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4605
#: include/linux/skbuff.h:4639
msgid "the original outgoing packet"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4606
msgid "hardware time stamps, may be NULL if not available"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4607
msgid ""
"If the skb has a socket associated, then this function clones the skb (thus "
"sharing the actual data and optional structures), stores the optional "
"hardware time stamping information (if non NULL) or generates a software "
"time stamp (otherwise), then queues the clone to the error queue of the "
"socket.  Errors are silently ignored."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4618
msgid "Driver hook for transmit timestamping"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4627
msgid "A socket buffer."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4619
msgid ""
"Ethernet MAC Drivers should call this function in their hard_xmit() function "
"immediately before giving the sk_buff to the MAC hardware."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4622
msgid ""
"Specifically, one should make absolutely sure that this function is called "
"before TX completion of this packet can trigger.  Otherwise the packet could "
"potentially already be freed."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4637
msgid "deliver skb with wifi status"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4641
msgid "``bool acked``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4640
msgid "ack status"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4657
msgid "Calculate checksum of an entire packet"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4658
msgid "packet to process"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4659
msgid ""
"This function calculates the checksum over the entire packet plus the value "
"of skb->csum.  The latter can be used to supply the checksum of a pseudo "
"header as used by TCP/UDP.  It returns the checksum."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4664
msgid ""
"For protocols that contain complete checksums such as ICMP/TCP/UDP, this "
"function can be used to verify that checksum on received packets.  In that "
"case the function should return zero if the checksum is correct.  In "
"particular, this function will return zero if skb->ip_summed is "
"CHECKSUM_UNNECESSARY which indicates that the hardware has already verified "
"the correctness of the checksum."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4918
msgid "sk_buff extensions"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4919
msgid "``refcnt``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4920
msgid "1 on allocation, deallocated on 0"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4920
#: ../../../networking/kapi:20: include/net/sock.h:941
msgid "``offset``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4921
msgid "offset to add to **data** to obtain extension address"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4921
msgid "``chunks``"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4922
msgid "size currently allocated, stored in SKB_EXT_ALIGN_SHIFT units"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4923
msgid "start of extension data, variable sized"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1076
#: drivers/net/phy/phylink.c:1825 drivers/net/phy/phylink.c:1926
#: ../../../networking/kapi:17: include/linux/skbuff.h:4926
#: ../../../networking/kapi:20: include/net/sock.h:2846
#: ../../../networking/kapi:26: net/core/skbuff.c:178
#: ../../../networking/kapi:29: net/core/sock.c:3096
#: ../../../networking/kapi:32: net/core/datagram.c:931
#: ../../../networking/kapi:59: net/sunrpc/xdr.c:49 net/sunrpc/xdr.c:930
#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:220
#: ../../../networking/kapi:92: net/core/dev.c:12342
msgid "**Note**"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4924
msgid "offsets/lengths are stored in chunks of 8 bytes, this allows"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:4925
msgid "to use 'u8' types while allowing up to 2kb worth of extension data."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:5214
msgid "make sure skb ip_summed is CHECKSUM_NONE"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:5215
#: include/linux/skbuff.h:5235
msgid "skb to check"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:5216
msgid ""
"fresh skbs have their ip_summed set to CHECKSUM_NONE. Instead of forcing "
"ip_summed to CHECKSUM_NONE, we can use this helper, to document places where "
"we make this assertion."
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:5234
msgid "Determine if the skb->head is locked down"
msgstr ""

#: ../../../networking/kapi:17: include/linux/skbuff.h:5236
msgid ""
"The head on skbs build around a head frag can be removed if they are not "
"cloned.  This function returns true if the skb head is locked down due to "
"either being allocated via kmalloc, or by being a clone with multiple "
"references to the head."
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:106
msgid "minimal network layer representation of sockets"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:109
msgid "``skc_addrpair``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:110
msgid "8-byte-aligned __u64 union of **skc_daddr** & **skc_rcv_saddr**"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:107
msgid "``skc_daddr``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:108
msgid "Foreign IPv4 addr"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:108
msgid "``skc_rcv_saddr``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:109
msgid "Bound local IPv4 addr"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:110
msgid "``skc_hash``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:111
msgid "hash value used with various protocol lookup tables"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:111
msgid "``skc_u16hashes``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:112
msgid "two u16 hash values used by UDP lookup tables"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:114
msgid "``skc_portpair``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:115
msgid "__u32 union of **skc_dport** & **skc_num**"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:112
msgid "``skc_dport``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:113
msgid "placeholder for inet_dport/tw_dport"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:113
msgid "``skc_num``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:114
msgid "placeholder for inet_num/tw_num"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:115
msgid "``skc_family``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:116
#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:336
msgid "network address family"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:116
msgid "``skc_state``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:117
msgid "Connection state"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:117
msgid "``skc_reuse``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:118
msgid "``SO_REUSEADDR`` setting"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:118
msgid "``skc_reuseport``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:119
msgid "``SO_REUSEPORT`` setting"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:119
msgid "``skc_ipv6only``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:120
msgid "socket is IPV6 only"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:120
msgid "``skc_net_refcnt``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:121
msgid "socket is using net ref counting"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:121
msgid "``skc_bound_dev_if``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:122
msgid "bound device index if != 0"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:122
msgid "``skc_bind_node``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:123
msgid "bind hash linkage for various protocol lookup tables"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:123
msgid "``skc_portaddr_node``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:124
msgid "second hash linkage for UDP/UDP-Lite protocol"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:124
msgid "``skc_prot``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:125
msgid "protocol handlers inside a network family"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:125
msgid "``skc_net``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:126
msgid "reference to the network namespace of this socket"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:126
msgid "``skc_v6_daddr``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:127
msgid "IPV6 destination address"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:127
msgid "``skc_v6_rcv_saddr``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:128
msgid "IPV6 source address"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:128
msgid "``skc_cookie``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:129
msgid "socket's cookie value"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:133
msgid "``skc_flags``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:134
msgid ""
"place holder for sk_flags ``SO_LINGER`` (l_onoff), ``SO_BROADCAST``, "
"``SO_KEEPALIVE``, ``SO_OOBINLINE`` settings, ``SO_TIMESTAMPING`` settings"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:136
msgid "``skc_listener``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:137
msgid ""
"connection request listener socket (aka rsk_listener) [union with "
"**skc_flags**]"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:138
msgid "``skc_tw_dr``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:139
msgid ""
"(aka tw_dr) ptr to :c:type:`struct inet_timewait_death_row "
"<inet_timewait_death_row>` [union with **skc_flags**]"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:129
msgid "``skc_node``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:130
msgid "main hash linkage for various protocol lookup tables"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:130
msgid "``skc_nulls_node``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:131
msgid "main hash linkage for TCP/UDP/UDP-Lite protocol"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:131
msgid "``skc_tx_queue_mapping``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:132
msgid "tx queue number for this connection"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:132
msgid "``skc_rx_queue_mapping``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:133
msgid "rx queue number for this connection"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:140
msgid "``skc_incoming_cpu``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:141
msgid "record/match cpu processing incoming packets"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:141
msgid "``skc_rcv_wnd``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:142
msgid ""
"(aka rsk_rcv_wnd) TCP receive window size (possibly scaled) [union with "
"**skc_incoming_cpu**]"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:143
msgid "``skc_tw_rcv_nxt``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:144
msgid ""
"(aka tw_rcv_nxt) TCP window next expected seq number [union with "
"**skc_incoming_cpu**]"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:145
msgid "``skc_refcnt``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:146
msgid "reference count"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:146
msgid ""
"This is the minimal network layer representation of sockets, the header for "
"struct sock and struct inet_timewait_sock."
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:238
msgid "network layer representation of sockets"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:239
msgid "``__sk_common``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:240
msgid "shared layout with inet_timewait_sock"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:285
msgid "``sk_drops``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:286
msgid "raw/udp drops counter"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:320
msgid "``sk_peek_off``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:321
msgid "current peek_offset value"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:279
msgid "``sk_error_queue``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:280
msgid "rarely used"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:253
msgid "``sk_receive_queue``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:254
msgid "incoming packets"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:277
msgid "``sk_backlog``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:278
msgid "always used with the per-socket spinlock held"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:246
msgid "``sk_rx_dst``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:247
msgid "receive input route used by early demux"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:247
msgid "``sk_rx_dst_ifindex``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:248
msgid "ifindex for **sk_rx_dst**"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:248
msgid "``sk_rx_dst_cookie``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:249
msgid "cookie for **sk_rx_dst**"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:262
msgid "``sk_ll_usec``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:263
msgid "usecs to busypoll when there is no data"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:261
msgid "``sk_napi_id``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:262
msgid "id of the last napi context to receive data for sk"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:292
msgid "``sk_busy_poll_budget``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:293
msgid "napi processing budget when busypolling"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:291
msgid "``sk_prefer_busy_poll``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:292
msgid "prefer busypolling over softirq processing"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:241
msgid "``sk_userlocks``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:242
msgid "``SO_SNDBUF`` and ``SO_RCVBUF`` settings"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:244
msgid "``sk_rcvbuf``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:245
msgid "size of receive buffer in bytes"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:304
msgid "``sk_filter``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:305
msgid "socket filtering instructions"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:245
msgid "``sk_wq``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:246
msgid "sock wait queue and async head"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:330
msgid "``sk_data_ready``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:331
msgid "callback to indicate there is data to be processed"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:300
msgid "``sk_rcvtimeo``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:301
msgid "``SO_RCVTIMEO`` setting"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:299
msgid "``sk_rcvlowat``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:300
msgid "``SO_RCVLOWAT`` setting"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:282
msgid "``sk_err``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:283
msgid "last error"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:317
msgid "``sk_socket``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:318
msgid "Identd and reporting IO signals"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:326
msgid "``sk_memcg``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:327
msgid "this socket's memory cgroup association"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:251
msgid "``sk_policy``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:252
msgid "flow policy"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:252
msgid "``psp_assoc``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:253
msgid "PSP association, if socket is PSP-secured"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:242
msgid "``sk_lock``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:243
msgid "synchronizer"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:260
msgid "``sk_reserved_mem``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:261
msgid "space reserved and non-reclaimable for the socket"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:259
msgid "``sk_forward_alloc``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:260
msgid "space allocated forward"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:308
msgid "``sk_tsflags``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:309
msgid "SO_TIMESTAMPING flags"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:327
msgid "``sk_write_pending``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:328
msgid "a write to stream socket waits to start"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:257
msgid "``sk_omem_alloc``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:258
msgid "\"o\" is \"option\" or \"other\""
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:283
msgid "``sk_err_soft``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:284
msgid ""
"errors that don't cause failure but are the cause of a persistent failure "
"not just 'timed out'"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:258
msgid "``sk_wmem_queued``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:259
msgid "persistent queue size"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:254
msgid "``sk_wmem_alloc``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:255
msgid "transmit queue bytes committed"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:255
msgid "``sk_tsq_flags``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:256
msgid "TCP Small Queues flags"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:321
msgid "``sk_send_head``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:322
msgid "front of stuff to transmit"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:322
msgid "``tcp_rtx_queue``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:323
msgid "TCP re-transmit queue [union with **sk_send_head**]"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:256
msgid "``sk_write_queue``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:257
msgid "Packet sending queue"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:250
msgid "``sk_dst_pending_confirm``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:265
msgid "``sk_pacing_status``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:266
msgid "Pacing status (requested, handled by sch_fq)"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:319
msgid "``sk_frag``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:320
msgid "cached page frag"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:305
msgid "``sk_timer``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:306
msgid "sock cleanup timer"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:264
msgid "``sk_pacing_rate``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:265
msgid "Pacing rate (if supported by transport/packet scheduler)"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:316
msgid "``sk_zckey``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:317
msgid "counter to order MSG_ZEROCOPY notifications"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:315
msgid "``sk_tskey``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:316
msgid "counter to disambiguate concurrent tstamp requests"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:266
msgid "``sk_max_pacing_rate``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:267
msgid "Maximum pacing rate (``SO_MAX_PACING_RATE``)"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:301
msgid "``sk_sndtimeo``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:302
msgid "``SO_SNDTIMEO`` setting"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:293
msgid "``sk_priority``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:294
msgid "``SO_PRIORITY`` setting"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:324
msgid "``sk_mark``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:325
msgid "generic packet mark"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:289
msgid "``sk_uid``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:290
msgid "user id of owner"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:295
msgid "``sk_protocol``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:296
msgid "which protocol this socket belongs in this network family"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:294
msgid "``sk_type``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:249
msgid "``sk_dst_cache``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:250
msgid "destination cache"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:270
msgid "``sk_route_caps``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:271
msgid "route capabilities (e.g. ``NETIF_F_TSO``)"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:334
msgid "``sk_validate_xmit_skb``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:335
msgid "ptr to an optional validate function"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:272
msgid "``sk_gso_type``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:273
msgid "GSO type (e.g. ``SKB_GSO_TCPV4``)"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:274
msgid "``sk_gso_max_segs``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:275
msgid "Maximum number of GSO segments"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:273
msgid "``sk_gso_max_size``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:274
msgid "Maximum GSO segment size to build"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:263
msgid "``sk_allocation``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:264
msgid "allocation mode"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:302
msgid "``sk_txhash``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:303
msgid "computed flow hash for use on transmit"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:267
msgid "``sk_sndbuf``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:268
msgid "size of send buffer in bytes"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:275
msgid "``sk_pacing_shift``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:276
msgid "scaling factor for TCP Small Queues"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:310
msgid "``sk_use_task_frag``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:311
msgid ""
"allow sk_page_frag() to use current->task_frag. Sockets that can be used "
"under memory reclaim should set this to false."
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:271
msgid "``sk_gso_disabled``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:272
msgid "if set, NETIF_F_GSO_MASK is forbidden."
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:243
msgid "``sk_kern_sock``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:244
msgid "True if sock is using kernel lock classes"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:268
msgid "``sk_no_check_tx``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:269
msgid "``SO_NO_CHECK`` setting, set checksum in TX packets"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:269
msgid "``sk_no_check_rx``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:270
msgid "allow zero checksum in RX packets"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:240
msgid "``sk_shutdown``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:241
msgid "mask of ``SEND_SHUTDOWN`` and/or ``RCV_SHUTDOWN``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:276
msgid "``sk_lingertime``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:277
msgid "``SO_LINGER`` l_linger setting"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:280
msgid "``sk_prot_creator``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:281
msgid ""
"sk_prot of original sock creator (see ipv6_setsockopt, IPV6_ADDRFORM for "
"instance)"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:278
msgid "``sk_callback_lock``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:279
msgid "used with the callbacks in the end of this struct"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:287
msgid "``sk_ack_backlog``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:288
msgid "current listen backlog"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:288
msgid "``sk_max_ack_backlog``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:289
msgid "listen backlog set in listen()"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:290
msgid "``sk_ino``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:291
msgid "inode number (zero if orphaned)"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:296
msgid "``sk_peer_lock``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:297
msgid "lock protecting **sk_peer_pid** and **sk_peer_cred**"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:313
msgid "``sk_bind_phc``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:314
msgid "SO_TIMESTAMPING bind PHC index of PTP virtual clock for timestamping"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:297
msgid "``sk_peer_pid``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:298
msgid ":c:type:`struct pid <pid>` for this socket's peer"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:298
msgid "``sk_peer_cred``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:299
msgid "``SO_PEERCRED`` setting"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:306
msgid "``sk_stamp``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:307
msgid "time stamp of last packet received"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:307
msgid "``sk_stamp_seq``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:308
msgid "lock for accessing sk_stamp on 32 bit architectures only"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:328
msgid "``sk_disconnects``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:329
msgid "number of disconnect operations performed on this sock"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:303
msgid "``sk_txrehash``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:304
msgid "enable TX hash rethink"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:343
msgid "``sk_scm_recv_flags``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:344
msgid "all flags used by scm_recv()"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:344
msgid "``sk_scm_credentials``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:345
msgid "flagged by SO_PASSCRED to recv SCM_CREDENTIALS"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:345
msgid "``sk_scm_security``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:346
msgid "flagged by SO_PASSSEC to recv SCM_SECURITY"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:346
msgid "``sk_scm_pidfd``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:347
msgid "flagged by SO_PASSPIDFD to recv SCM_PIDFD"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:347
msgid "``sk_scm_rights``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:348
msgid "flagged by SO_PASSRIGHTS to recv SCM_RIGHTS"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:348
msgid "``sk_scm_unused``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:349
msgid "unused flags for scm_recv()"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:339
msgid "``sk_clockid``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:340
msgid "clockid used by time-based scheduling (SO_TXTIME)"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:340
msgid "``sk_txtime_deadline_mode``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:341
msgid "set deadline mode for SO_TXTIME"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:341
msgid "``sk_txtime_report_errors``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:342
msgid "set report errors mode for SO_TXTIME"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:342
msgid "``sk_txtime_unused``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:343
msgid "unused txtime flags"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:309
msgid "``sk_bpf_cb_flags``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:310
msgid "used in bpf_setsockopt()"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:318
msgid "``sk_user_data``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:319
msgid "RPC layer private data. Write-protected by **sk_callback_lock**."
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:323
msgid "``sk_security``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:324
msgid "used by security modules"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:325
msgid "``sk_cgrp_data``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:326
msgid "cgroup data for this cgroup"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:329
msgid "``sk_state_change``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:330
msgid "callback to indicate change in the state of the sock"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:331
msgid "``sk_write_space``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:332
msgid "callback to indicate there is bf sending space available"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:332
msgid "``sk_error_report``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:333
msgid "callback to indicate errors (e.g. ``MSG_ERRQUEUE``)"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:333
msgid "``sk_backlog_rcv``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:334
msgid "callback to process the backlog"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:335
msgid "``sk_destruct``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:336
msgid "called at sock freeing time, i.e. when all refcnt == 0"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:336
msgid "``sk_reuseport_cb``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:337
msgid "reuseport group container"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:337
msgid "``sk_bpf_storage``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:338
msgid "ptr to cache and control for bpf_sk_storage"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:286
msgid "``sk_drop_counters``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:287
msgid "optional pointer to numa_drop_counters"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:338
msgid "``sk_rcu``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:339
msgid "used during RCU grace period"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:349
msgid "``ns_tracker``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:350
msgid "tracker for netns reference"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:350
msgid "``sk_user_frags``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:351
msgid "xarray of pages the user is holding a reference on."
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:351
msgid "``sk_owner``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:352
msgid ""
"reference to the real owner of the socket that calls "
"sock_lock_init_class_and_name()."
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:617
msgid "Test if sk_user_data pointer must not be copied"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:628 include/net/sock.h:653
msgid ""
"return the pointer only if argument flags all has been set in sk_user_data. "
"Otherwise return NULL"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:634 include/net/sock.h:659
msgid "``uintptr_t flags``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:633 include/net/sock.h:658
msgid "flag bits"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:634
msgid "The caller must be holding sk->sk_callback_lock."
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:938
msgid "``sk_for_each_entry_offset_rcu (tpos, pos, head, offset)``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:936
msgid "iterate over a list at a given struct offset"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:942
msgid "``tpos``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:937
msgid "the type * to use as a loop cursor."
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:939
msgid "``pos``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:938
msgid "the :c:type:`struct hlist_node <hlist_node>` to use as a loop cursor."
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:939
msgid "the head for your list."
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:940
msgid "offset of hlist_node within the struct."
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:1500
msgid "``SOCK_CONNECT_BIND``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:1498
msgid ""
":c:type:`sock->sk_userlocks <sock>` flag for auto-bind at connect() time"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:1696
msgid "fast version of lock_sock"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:1702 include/net/sock.h:1731
#: include/net/sock.h:2580 include/net/sock.h:2846 include/net/sock.h:2930
#: ../../../networking/kapi:23: net/socket.c:3728 ../../../networking/kapi:26:
#: net/core/skbuff.c:1197 ../../../networking/kapi:29: net/core/sock.c:301
#: net/core/sock.c:3220 net/core/sock.c:3362 net/core/sock.c:3403
#: ../../../networking/kapi:32: net/core/datagram.c:214 net/core/datagram.c:360
#: ../../../networking/kapi:35: net/core/stream.c:60 net/core/stream.c:124
#: ../../../networking/kapi:41: net/core/filter.c:127 net/core/filter.c:1548
#: ../../../networking/kapi:92: net/core/dev.c:4263 net/core/dev.c:9283
msgid "``struct sock *sk``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:1698
msgid ""
"This version should be used for very small section, where process won't "
"block return false if fast path is taken:"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:1701
msgid "sk_lock.slock locked, owned = 0, BH disabled"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:1703
msgid "return true if slow path is taken:"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:1705
msgid "sk_lock.slock unlocked, owned = 1, BH enabled"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:1725
msgid "complement of lock_sock_fast"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:1728
msgid "``bool slow``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:1727
msgid "slow mode"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:1728
msgid ""
"fast unlock socket for user context. If slow mode is on, we call regular "
"release_sock()"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2307
msgid "returns write allocations"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2310
msgid "sk_wmem_alloc minus initial offset of one"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2318
msgid "returns read allocations"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2321
msgid "sk_rmem_alloc"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2329
msgid "check if allocations are outstanding"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2332
msgid "true if socket has write or read allocations"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2340
msgid "check if there are any waiting processes"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2346
msgid "``struct socket_wq *wq``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2341
msgid "struct socket_wq"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2343
msgid "true if socket_wq has waiting processes"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2344
msgid ""
"The purpose of the skwq_has_sleeper and sock_poll_wait is to wrap the memory "
"barrier call. They were added due to the race found within the tcp code."
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2347
msgid "Consider following tcp code paths::"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2363
msgid ""
"The race for tcp fires when the __add_wait_queue changes done by CPU1 stay "
"in its cache, and so does the tp->rcv_nxt update on CPU2 side.  The CPU1 "
"could then endup calling schedule and sleep forever if there are no more "
"data on the socket."
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2376
msgid "wrapper for the poll_wait call."
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2382
msgid "``struct file *filp``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2377
#: ../../../networking/kapi:23: net/socket.c:525
msgid "file"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2379
#: ../../../networking/kapi:23: net/socket.c:469 net/socket.c:687
#: net/socket.c:752 net/socket.c:780 net/socket.c:1094 net/socket.c:1111
#: net/socket.c:3584 net/socket.c:3604 net/socket.c:3618 net/socket.c:3659
#: net/socket.c:3684 net/socket.c:3699 net/socket.c:3714
#: ../../../networking/kapi:32: net/core/datagram.c:926
msgid "``struct socket *sock``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2378
msgid "socket to wait on"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2380
msgid "``poll_table *p``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2379
msgid "poll_table"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2380
msgid "See the comments in the wq_has_sleeper function."
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2574
msgid "return an appropriate page_frag"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2576
msgid ""
"Use the per task page_frag instead of the per socket one for optimization "
"when we know that we're in process context and own everything that's "
"associated with ``current``."
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2580
msgid ""
"Both direct reclaim and page faults can nest inside other socket operations "
"and end up recursing into sk_page_frag() while it's already in use: "
"explicitly avoid task page_frag when users disable sk_use_task_frag."
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2586
msgid ""
"a per task page_frag if context allows that, otherwise a per socket one."
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2840
msgid "checks whether the outgoing packet is to be time stamped"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2841
msgid "socket sending this packet"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2843
msgid "``const struct sockcm_cookie *sockc``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2842
msgid "pointer to socket cmsg cookie to get timestamping info"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2844
msgid "``__u8 *tx_flags``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2843
msgid "completed with instructions for time stamping"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2845
msgid "``__u32 *tskey``"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2844
msgid "filled in with next sk_tskey (not for TCP, which uses seqno)"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2846
msgid "callers should take care of initial ``*tx_flags`` value (usually 0)"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2924
msgid "Release a skb if it is no longer needed"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2925
msgid "socket to eat this skb from"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2926
msgid "socket buffer to eat"
msgstr ""

#: ../../../networking/kapi:20: include/net/sock.h:2927
msgid ""
"This routine must be called with interrupts disabled or with the socket "
"locked so that the sk_buff queue operation is ok."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:463
msgid "Bind a :c:type:`socket` to a :c:type:`file`"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:466 net/socket.c:1092
#: net/socket.c:1112 net/socket.c:3616 net/socket.c:3658
#: ../../../networking/kapi:26: net/core/skbuff.c:629
#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:296
#: net/sunrpc/svc_xprt.c:339 ../../../networking/kapi:83:
#: net/sunrpc/clnt.c:1252 net/sunrpc/clnt.c:1285
msgid "``int flags``"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:465
msgid "file status flags"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:467
msgid "``const char *dname``"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:466
msgid "protocol name"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:467
msgid ""
"Returns the :c:type:`file` bound with **sock**, implicitly storing it in "
"sock->file. If dname is ``NULL``, sets to \"\"."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:470
msgid "On failure **sock** is released, and an ERR pointer is returned."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:472
msgid "This function uses GFP_KERNEL internally."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:524
msgid "Return the :c:type:`socket` bounded to **file**."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:530 ../../../networking/kapi:32:
#: net/core/datagram.c:929
msgid "``struct file *file``"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:526
msgid "On failure returns ``NULL``."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:540
msgid "Go from a file number to its socket slot"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:546
msgid "``int fd``"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:541
msgid "file handle"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:543 ../../../networking/kapi:32:
#: net/core/datagram.c:215
msgid "``int *err``"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:542
msgid "pointer to an error code return"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:543
msgid ""
"The file handle passed in is locked and the socket it is bound to is "
"returned. If an error occurs the err pointer is overwritten with a negative "
"errno code and NULL is returned. The function checks for both invalid "
"handles and passing a handle which is not a socket."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:548
msgid "On a success the socket object pointer is returned."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:625
msgid "allocate a socket"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:442
#: ../../../networking/kapi:23: net/socket.c:631 ../../../networking/kapi:92:
#: net/core/dev.c:3342 net/core/dev.c:12114
msgid "``void``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1
#: ../../../networking/kapi:23: net/socket.c:1 ../../../networking/kapi:92:
#: net/core/dev.c:1
msgid "no arguments"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:626
msgid ""
"Allocate a new inode and socket object. The two are bound together and "
"initialised. The socket is then returned. If we are out of inodes NULL is "
"returned. This functions uses GFP_KERNEL internally."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:681
msgid "close a socket"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:682
msgid "socket to close"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:683
msgid ""
"The socket is released from the protocol stack if it has a release callback, "
"and the inode is then released if the socket is bound to an inode not a file."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:746
msgid "send a message through **sock**"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:749 net/socket.c:777
#: net/socket.c:1091 net/socket.c:1108 ../../../networking/kapi:32:
#: net/core/datagram.c:880
msgid "``struct msghdr *msg``"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:748
msgid "message to send"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:749
msgid ""
"Sends **msg** through **sock**, passing through LSM. Returns the number of "
"bytes sent, or an error code."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:774
msgid "send a message through **sock** (kernel-space)"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:776
msgid "message header"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:778 net/socket.c:1109
msgid "``struct kvec *vec``"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:777
msgid "kernel vec"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:779 net/socket.c:1110
msgid "``size_t num``"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:778
msgid "vec array length"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:779
msgid "total message data size"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:780
msgid ""
"Builds the message data with **vec** and sends it through **sock**. Returns "
"the number of bytes sent, or an error code."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1088
msgid "receive a message from **sock**"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1090
msgid "message to receive"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1091
msgid "message flags"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1092
msgid ""
"Receives **msg** from **sock**, passing through LSM. Returns the total "
"number of bytes received, or an error."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1105
msgid "Receive a message from a socket (kernel space)"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1106
msgid "The socket to receive the message from"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1107
msgid "Received message"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1108
msgid "Input s/g array for message data"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1109
msgid "Size of input s/g array"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1110
msgid "Number of bytes to read"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1111
msgid "Message flags (MSG_DONTWAIT, etc...)"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1112
msgid ""
"On return the msg structure contains the scatter/gather array passed in the "
"vec argument. The array is modified so that it consists of the unfilled "
"portion of the original array."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1116
msgid "The returned value is the total number of bytes received, or an error."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1382 net/socket.c:1520
#: net/socket.c:1651
msgid "creates a socket"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1388 net/socket.c:1523
#: net/socket.c:1657 net/socket.c:1671 net/socket.c:3280
#: ../../../networking/kapi:29: net/core/sock.c:2286
msgid "``int family``"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1383 net/socket.c:1522
#: net/socket.c:1652 net/socket.c:1670
msgid "protocol family (AF_INET, ...)"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1385 net/socket.c:1524
#: net/socket.c:1654 net/socket.c:1672 ../../../networking/kapi:50:
#: net/core/gen_stats.c:43 net/core/gen_stats.c:99
msgid "``int type``"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1384 net/socket.c:1523
#: net/socket.c:1653 net/socket.c:1671
msgid "communication type (SOCK_STREAM, ...)"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1386 net/socket.c:1525
#: net/socket.c:1655 net/socket.c:1673
msgid "``int protocol``"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1385 net/socket.c:1524
#: net/socket.c:1654 net/socket.c:1672
msgid "protocol (0, ...)"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1387 net/socket.c:1526
#: net/socket.c:1656 net/socket.c:1674
msgid "``struct socket **res``"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1386 net/socket.c:1525
#: net/socket.c:1655 net/socket.c:1673
msgid "new socket"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1387
msgid ""
"Creates a new socket and assigns it to **res**, passing through LSM. The new "
"socket initialization is not complete, see kernel_accept(). Returns 0 or an "
"error. On failure **res** is set to ``NULL``. This function internally uses "
"GFP_KERNEL."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1526 net/socket.c:1674
#: ../../../networking/kapi:29: net/core/sock.c:2289
#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:294
#: net/sunrpc/svc_xprt.c:336 net/sunrpc/svc_xprt.c:1118
#: net/sunrpc/svc_xprt.c:1279 net/sunrpc/svc_xprt.c:1313
#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:760
#: net/sunrpc/rpc_pipe.c:785 net/sunrpc/rpc_pipe.c:807
#: ../../../networking/kapi:92: net/core/dev.c:855 net/core/dev.c:876
#: net/core/dev.c:910 net/core/dev.c:935 net/core/dev.c:959 net/core/dev.c:996
#: net/core/dev.c:1207 net/core/dev.c:1234 net/core/dev.c:2070
#: net/core/dev.c:2097 net/core/dev.c:4266
msgid "``struct net *net``"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1521 net/socket.c:1669
msgid "net namespace"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1527 ../../../networking/kapi:29:
#: net/core/sock.c:2289
msgid "``int kern``"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1526
msgid "boolean for kernel space sockets"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1527
msgid ""
"Creates a new socket and assigns it to **res**, passing through LSM. Returns "
"0 or an error. On failure **res** is set to ``NULL``. **kern** must be set "
"to true if the socket resides in kernel space. This function internally uses "
"GFP_KERNEL."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1656 net/socket.c:1674
msgid ""
"A wrapper around __sock_create(). Returns 0 or an error. This function "
"internally uses GFP_KERNEL."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:1668
msgid "creates a socket (kernel space)"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3241
msgid "add a socket protocol handler"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3247
msgid "``const struct net_proto_family *ops``"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3242
msgid "description of protocol"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3243
msgid ""
"This function is called by a protocol handler that wants to advertise its "
"address family, and have it linked into the socket interface. The value ops-"
">family corresponds to the socket system call protocol family."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3274
msgid "remove a protocol handler"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3275
msgid "protocol family to remove"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3276
msgid ""
"This function is called by a protocol handler that wants to remove its "
"address family, and have it unlinked from the new socket creation."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3280
msgid ""
"If protocol handler is a module, then it can use module reference counts to "
"protect against new references. If protocol handler is not a module then it "
"needs to provide its own protection in the ops->create routine."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3578
msgid "bind an address to a socket (kernel space)"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3581 net/socket.c:3656
#: net/socket.c:3681 net/socket.c:3696
msgid "``struct sockaddr *addr``"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3580 net/socket.c:3655
msgid "address"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3582 net/socket.c:3657
msgid "``int addrlen``"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3581
msgid "length of address"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3582 net/socket.c:3601
#: net/socket.c:3711
msgid "Returns 0 or an error."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3598
msgid "move socket to listening state (kernel space)"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3601
msgid "``int backlog``"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3600
msgid "pending connections queue size"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3612
msgid "accept a connection (kernel space)"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3613
msgid "listening socket"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3615
msgid "``struct socket **newsock``"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3614
msgid "new connected socket"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3615
msgid "flags"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3616
msgid ""
"**flags** must be SOCK_CLOEXEC, SOCK_NONBLOCK or 0. If it fails, **newsock** "
"is guaranteed to be ``NULL``. Returns 0 or an error."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3653
msgid "connect a socket (kernel space)"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3656
msgid "address length"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3657
msgid "flags (O_NONBLOCK, ...)"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3658
msgid ""
"For datagram sockets, **addr** is the address to which datagrams are sent by "
"default, and the only address from which datagrams are received. For stream "
"sockets, attempts to connect to **addr**. Returns 0 or an error code."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3678
msgid "get the address which the socket is bound (kernel space)"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3680 net/socket.c:3695
msgid "address holder"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3681
msgid ""
"Fills the **addr** pointer with the address which the socket is bound. "
"Returns the length of the address in bytes or an error code."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3693
msgid "get the address which the socket is connected (kernel space)"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3696
msgid ""
"Fills the **addr** pointer with the address which the socket is connected. "
"Returns the length of the address in bytes or an error code."
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3708
msgid "shut down part of a full-duplex connection (kernel space)"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3711
msgid "``enum sock_shutdown_cmd how``"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3710
msgid "connection part"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3722
msgid "returns the IP overhead imposed by a socket"
msgstr ""

#: ../../../networking/kapi:23: net/socket.c:3724
msgid ""
"This routine returns the IP overhead imposed by a socket i.e. the length of "
"the underlying IP header, depending on whether this is an IPv4 or IPv6 "
"socket and the length from IP options turned on at the socket. Assumes that "
"the caller has a lock on the socket."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:156
msgid "register another drop reason subsystem"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:162 net/core/skbuff.c:181
msgid "``enum skb_drop_reason_subsys subsys``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:157
msgid "the subsystem to register, must not be the core"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:159
msgid "``const struct drop_reason_list *list``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:158
msgid ""
"the list of drop reasons within the subsystem, must point to a statically "
"initialized list"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:175
msgid "unregister a drop reason subsystem"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:176
msgid "the subsystem to remove, must not be the core"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:178
msgid "This will synchronize_rcu() to ensure no users when it returns."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:302
msgid "obtain a number of zeroed skb heads from the cache"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:308
msgid "``void **skbs``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:303
msgid "pointer to an at least **n**-sized array to fill with skb pointers"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:305
msgid "``u32 n``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:304
msgid "number of entries to provide"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:305
msgid ""
"Tries to obtain **n** :c:type:`sk_buff` entries from the NAPI percpu cache "
"and writes the pointers into the provided array **skbs**. If there are less "
"entries available, tries to replenish the cache and bulk-allocates the diff "
"from the MM layer if needed. The heads are being zeroed with either memset() "
"or ``__GFP_ZERO``, so they are ready for {,__}build_skb_around() and don't "
"have any data buffers attached. Must be called *only* from the BH context."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:314
msgid ""
"number of successfully allocated skbs (**n** if no actual allocation needed "
"or kmem_cache_alloc_bulk() didn't fail)."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:494
msgid "build a network buffer around provided skb"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:495
msgid "sk_buff provide by caller, must be memset cleared"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:497 net/core/skbuff.c:546
#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:807
#: ../../../networking/kapi:83: net/sunrpc/clnt.c:838 net/sunrpc/clnt.c:1287
#: net/sunrpc/clnt.c:3041 net/sunrpc/clnt.c:3079
msgid "``void *data``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:496 net/core/skbuff.c:541
msgid "data buffer provided by caller"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:498 net/core/skbuff.c:543
msgid "``unsigned int frag_size``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:497 net/core/skbuff.c:542
msgid "size of data"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:540
msgid "build a network buffer"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:543
msgid ""
"Version of __napi_build_skb() that takes care of skb->head_frag and skb-"
">pfmemalloc when the data is a page or page fragment."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:546
msgid ""
"Returns a new :c:type:`sk_buff` on success, ``NULL`` on allocation failure."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:628
msgid ""
"If SKB_ALLOC_FCLONE is set, allocate from fclone cache instead of head cache "
"and allocate a cloned (child) skb. If SKB_ALLOC_RX is set, __GFP_MEMALLOC "
"will be used for allocations in case the data is required for writeback"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:633
msgid "``int node``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:632
msgid "numa node to allocate memory on"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:633
msgid ""
"Allocate a new :c:type:`sk_buff`. The returned buffer has no headroom and a "
"tail room of at least size bytes. The object has a reference count of one. "
"The return is the buffer. On a failure the return is ``NULL``."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:637
msgid ""
"Buffers may only be allocated from interrupts using a **gfp_mask** of "
"``GFP_ATOMIC``."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:709
msgid "get_free_pages mask, passed to alloc_skb"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:710
msgid ""
"Allocate a new :c:type:`sk_buff` and assign it a usage count of one. The "
"buffer has NET_SKB_PAD headroom built in. Users should allocate the headroom "
"they think they need without accounting for the built in space. The built in "
"space is used for optimisations."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:784
msgid "allocate skbuff for rx in a specific NAPI instance"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2806
#: include/linux/netdevice.h:2848 include/linux/netdevice.h:2864
#: include/linux/netdevice.h:2886 include/linux/netdevice.h:2907
#: ../../../networking/kapi:26: net/core/skbuff.c:790
#: ../../../networking/kapi:92: net/core/dev.c:7154
msgid "``struct napi_struct *napi``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:785
msgid "napi instance this buffer was allocated for"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:787
msgid ""
"Allocate a new sk_buff for use in NAPI receive.  This buffer will attempt to "
"allocate the head from a special reserved region used only for NAPI Rx "
"allocation.  By doing this we can save several CPU cycles by avoiding having "
"to disable and re-enable IRQs."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1156
msgid "private function"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1158
msgid ""
"Free an sk_buff. Release anything attached to the buffer. Clean the state. "
"This is an internal helper function. Users should always call kfree_skb"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1191
msgid "free an sk_buff with special reason"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1192
msgid "the socket to receive **skb**, or NULL if not applicable"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1194
msgid "reason why this skb is dropped"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1195
msgid ""
"Drop a reference to the buffer and free it if the usage count has hit zero. "
"Meanwhile, pass the receiving socket and drop reason to 'kfree_skb' "
"tracepoint."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1368
msgid "report an sk_buff xmit error"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1369
msgid "buffer that triggered an error"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1370
msgid ""
"Report xmit error if a device callback is tracking this skb. skb must be "
"freed afterwards."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1385
msgid "free an skbuff"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1387
msgid ""
"Drop a ref to the buffer and free it if the usage count has hit zero "
"Functions identically to kfree_skb, but kfree_skb assumes that the frame is "
"being dropped after a failure and notes that"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1575
msgid "allocate sk_buff to wrap frag list forming a msg"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1581
msgid "``struct sk_buff *first``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1576
msgid "first sk_buff of the msg"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1600
msgid "morph one skb into another"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1606
msgid "``struct sk_buff *dst``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1601
msgid "the skb to receive the contents"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1603
msgid "``struct sk_buff *src``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1602
msgid "the skb to supply the contents"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1603
msgid ""
"This is identical to skb_clone except that the target skb is supplied by the "
"user."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1606
msgid "The target skb is returned upon exit."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1917
msgid "copy userspace skb frags buffers to kernel"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1918
msgid "the skb to modify"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1919 net/core/skbuff.c:2020
#: net/core/skbuff.c:2097 net/core/skbuff.c:2146 net/core/skbuff.c:2212
#: net/core/skbuff.c:2434
msgid "allocation priority"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1920
msgid ""
"This must be called on skb with SKBFL_ZEROCOPY_ENABLE. It will copy all "
"frags into kernel and drop the reference to userspace pages."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1924 net/core/skbuff.c:2026
msgid ""
"If this function is called from an interrupt gfp_mask() must be "
"``GFP_ATOMIC``."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:1927
msgid ""
"Returns 0 on success or a negative error code on failure to allocate kernel "
"memory to copy to."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2018
msgid "duplicate an sk_buff"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2019
msgid "buffer to clone"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2021
msgid ""
"Duplicate an :c:type:`sk_buff`. The new one is not owned by a socket. Both "
"copies share the same packet data but not structure. The new buffer has a "
"reference count of 1. If the allocation fails the function returns ``NULL`` "
"otherwise the new buffer is returned."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2095
msgid "create private copy of an sk_buff"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2096 net/core/skbuff.c:2144
#: net/core/skbuff.c:2431 ../../../networking/kapi:32: net/core/datagram.c:501
#: net/core/datagram.c:526 net/core/datagram.c:542 net/core/datagram.c:776
msgid "buffer to copy"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2098
msgid ""
"Make a copy of both an :c:type:`sk_buff` and its data. This is used when the "
"caller wishes to modify the data and needs a private copy of the data to "
"alter. Returns ``NULL`` on failure or the pointer to the buffer on success. "
"The returned buffer has a reference count of 1."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2103
msgid ""
"As by-product this function converts non-linear :c:type:`sk_buff` to linear "
"one, so that :c:type:`sk_buff` becomes completely private and caller is "
"allowed to modify all the data of returned buffer. This means that this "
"function is not recommended for use in circumstances when only header is "
"going to be modified. Use pskb_copy() instead."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2143
msgid "create copy of an sk_buff with private head."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2146
msgid "``int headroom``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2145
msgid "headroom of new skb"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2148
msgid "``bool fclone``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2147
msgid ""
"if true allocate the copy of the skb from the fclone cache instead of the "
"head cache; it is recommended to set this to true for the cases where the "
"copy will likely be cloned"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2150
msgid ""
"Make a copy of both an :c:type:`sk_buff` and part of its data, located in "
"header. Fragmented data remain shared. This is used when the caller wishes "
"to modify only header of :c:type:`sk_buff` and needs private copy of the "
"header to alter. Returns ``NULL`` on failure or the pointer to the buffer on "
"success. The returned buffer has a reference count of 1."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2208 net/core/skbuff.c:2379
msgid "reallocate header of :c:type:`sk_buff`"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2209 net/core/skbuff.c:2380
#: net/core/skbuff.c:2774
msgid "buffer to reallocate"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2211
msgid "``int nhead``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2210
msgid "room to add at head"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2212
msgid "``int ntail``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2211
msgid "room to add at tail"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2213
msgid ""
"Expands (or creates identical copy, if **nhead** and **ntail** are zero) "
"header of **skb**. :c:type:`sk_buff` itself is not changed. :c:type:"
"`sk_buff` MUST have reference count of 1. Returns zero in the case of "
"success or error, if expansion failed. In the last case, :c:type:`sk_buff` "
"is not changed."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2218 net/core/skbuff.c:2785
msgid ""
"All the pointers pointing into skb header may change and must be reloaded "
"after call to this function."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2382
msgid ""
"Unlike skb_realloc_headroom, this one does not allocate a new skb if "
"possible; copies skb->sk to new skb as needed and frees original skb in case "
"of failures."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2386
msgid "It expect increased headroom and generates warning otherwise."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2430
msgid "copy and expand sk_buff"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2433
msgid "``int newheadroom``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2432
msgid "new free bytes at head"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2434
msgid "``int newtailroom``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2433
msgid "new free bytes at tail"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2435
msgid ""
"Make a copy of both an :c:type:`sk_buff` and its data and while doing so "
"allocate additional space."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2438
msgid ""
"This is used when the caller wishes to modify the data and needs a private "
"copy of the data to alter as well as more space for new fields. Returns "
"``NULL`` on failure or the pointer to the buffer on success. The returned "
"buffer has a reference count of 1."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2443
msgid ""
"You must pass ``GFP_ATOMIC`` as the allocation priority if this function is "
"called from an interrupt."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2504
msgid ""
"May return error in out of memory cases. The skb is freed on error if "
"**free_on_error** is true."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2545
msgid "add data to the tail of a potentially fragmented buffer"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2546
msgid "start of the buffer to use"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2548
msgid "``struct sk_buff *tail``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2547
msgid "tail fragment of the buffer to use"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2548 net/core/skbuff.c:2570
#: net/core/skbuff.c:2591
msgid "amount of data to add"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2549
msgid ""
"This function extends the used data area of the potentially fragmented "
"buffer. **tail** must be the last fragment of **skb** -- or **skb** itself. "
"If this would exceed the total buffer size the kernel will panic. A pointer "
"to the first byte of the extra data is returned."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2568
msgid "add data to a buffer"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2569 net/core/skbuff.c:2590
#: net/core/skbuff.c:2609 net/core/skbuff.c:2626
msgid "buffer to use"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2571
msgid ""
"This function extends the used data area of the buffer. If this would exceed "
"the total buffer size the kernel will panic. A pointer to the first byte of "
"the extra data is returned."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2589
msgid "add data to the start of a buffer"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2592
msgid ""
"This function extends the used data area of the buffer at the buffer start. "
"If this would exceed the total buffer headroom the kernel will panic. A "
"pointer to the first byte of the extra data is returned."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2608
msgid "remove data from the start of a buffer"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2610 net/core/skbuff.c:2627
msgid "amount of data to remove"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2611
msgid ""
"This function removes data from the start of a buffer, returning the memory "
"to the headroom. A pointer to the next data in the buffer is returned. Once "
"the data has been pulled future pushes will overwrite the old data."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2624
msgid "remove data from the start of a buffer returning its original position."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2628
#: ../../../networking/kapi:59: net/sunrpc/xdr.c:410 net/sunrpc/xdr.c:1146
#: net/sunrpc/xdr.c:1215 ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:401
msgid "``size_t len``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2628
msgid ""
"This function removes data from the start of a buffer, returning the memory "
"to the headroom. A pointer to the original data in the buffer is returned "
"after checking if there is enough data to pull. Once the data has been "
"pulled future pushes will overwrite the old data."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2648
msgid "remove end from a buffer"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2651
msgid ""
"Cut the length of a buffer down by removing data from the tail. If the "
"buffer is already under the length specified it is not modified. The skb "
"must be linear."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2773
msgid "advance tail of skb header"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2775
msgid "number of bytes to advance tail"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2776
msgid ""
"The function makes a sense only on a fragmented :c:type:`sk_buff`, it "
"expands header moving its tail forward and copying necessary data from "
"fragmented part."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2780
msgid ":c:type:`sk_buff` MUST have reference count of 1."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2782
msgid ""
"Returns ``NULL`` (and :c:type:`sk_buff` does not change) if pull failed or "
"value of new tail of skb in the case of success."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2927
msgid "copy bits from skb to kernel buffer"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2928
msgid "source skb"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2930 net/core/skbuff.c:3362
#: net/core/skbuff.c:4465 net/core/skbuff.c:5215 ../../../networking/kapi:32:
#: net/core/datagram.c:503 net/core/datagram.c:528 net/core/datagram.c:544
msgid "``int offset``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2929 net/core/skbuff.c:4464
msgid "offset in source"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2931 net/core/skbuff.c:4466
msgid "``void *to``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2930 net/core/skbuff.c:3360
#: net/core/skbuff.c:3781 net/core/skbuff.c:4465 ../../../networking/kapi:95:
#: net/ethernet/eth.c:199
msgid "destination buffer"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2931 net/core/skbuff.c:3363
#: net/core/skbuff.c:4466
msgid "number of bytes to copy"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2932
msgid ""
"Copy the specified number of bytes from the source skb to the destination "
"buffer."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2935
msgid "CAUTION ! :"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:2936
msgid ""
"If its prototype is ever changed, check arch/{*}/net/{*}.S files, since it "
"is called from BPF assembly code."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:3359
msgid "store bits from kernel buffer to skb"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:3361
msgid "offset in destination"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:3363
msgid "``const void *from``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:3362 net/core/skbuff.c:3782
msgid "source buffer"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:3364
msgid ""
"Copy the specified number of bytes from the source buffer to the destination "
"skb.  This function handles all the messy bits of traversing fragment lists "
"and such."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:3780
msgid "Zero copy skb to skb"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:3786 net/core/skbuff.c:6070
msgid "``struct sk_buff *to``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:3783 net/core/skbuff.c:6067
msgid "``struct sk_buff *from``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:3783
msgid "number of bytes to copy from source buffer"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:3785
#: ../../../networking/kapi:32: net/core/datagram.c:879
msgid "``int hlen``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:3784
msgid "size of linear headroom in destination buffer"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:3785
msgid ""
"Copies up to `len` bytes from `from` to `to` by creating references to the "
"frags in the source buffer."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:3788
msgid ""
"The `hlen` as calculated by skb_zerocopy_headlen() specifies the headroom in "
"the `to` buffer."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:3791
msgid ""
"Return value: 0: everything is OK -ENOMEM: couldn't orphan frags of **from** "
"due to lack of memory -EFAULT: skb_copy_bits() found some problem with skb "
"geometry"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:3887
msgid ""
"Remove the head of the list. The list lock is taken so the function may be "
"used safely with other locking list functions. The head item is returned or "
"``NULL`` if the list is empty."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:3908
msgid ""
"Remove the tail of the list. The list lock is taken so the function may be "
"used safely with other locking list functions. The tail item is returned or "
"``NULL`` if the list is empty."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:3929
msgid ""
"Delete all buffers on an :c:type:`sk_buff` list. Each buffer is removed from "
"the list and one reference dropped. This function takes the list lock and is "
"atomic with respect to other list locking functions."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4004
msgid ""
"Queue a buffer at the start of the list. This function takes the list lock "
"and can be used safely with other locking :c:type:`sk_buff` functions safely."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4025
msgid ""
"Queue a buffer at the tail of the list. This function takes the list lock "
"and can be used safely with other locking :c:type:`sk_buff` functions safely."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4043
msgid "remove a buffer from a list"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4044
msgid "buffer to remove"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4046
msgid ""
"Remove a packet from a list. The list locks are taken and this function is "
"atomic with respect to other list locked calls"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4049
msgid "You must know what list the SKB is on."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4063
msgid "append a buffer"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4069
msgid "``struct sk_buff *old``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4064
msgid "buffer to insert after"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4065
msgid "buffer to insert"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4067
msgid ""
"Place a packet after a given packet in a list. The list locks are taken and "
"this function is atomic with respect to other list locked calls. A buffer "
"cannot be placed on two lists at the same time."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4148
msgid "Split fragmented skb to two parts at length len."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4149
msgid "the buffer to split"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4151
msgid "``struct sk_buff *skb1``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4150
msgid "the buffer to receive the second part"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4152
#: ../../../networking/kapi:59: net/sunrpc/xdr.c:96
msgid "``const u32 len``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4151
msgid "new length for skb"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4314
msgid "Prepare a sequential read of skb data"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4315
msgid "the buffer to read"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4317 net/core/skbuff.c:4514
msgid "``unsigned int from``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4316
msgid "lower offset of data to be read"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4318 net/core/skbuff.c:4515
msgid "``unsigned int to``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4317
msgid "upper offset of data to be read"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4319 net/core/skbuff.c:4340
#: net/core/skbuff.c:4454 net/core/skbuff.c:4468
msgid "``struct skb_seq_state *st``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4318 net/core/skbuff.c:4339
#: net/core/skbuff.c:4449
msgid "state variable"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4319
msgid ""
"Initializes the specified state variable. Must be called before invoking "
"skb_seq_read() for the first time."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4336
msgid "Sequentially read skb data"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4342
msgid "``unsigned int consumed``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4337
msgid "number of bytes consumed by the caller so far"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4339
msgid "``const u8 **data``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4338
msgid "destination pointer for data to be returned"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4340
msgid ""
"Reads a block of skb data at **consumed** relative to the lower offset "
"specified to skb_prepare_seq_read(). Assigns the head of the data block to "
"**data** and returns the length of the block or 0 if the end of the skb data "
"or the upper offset has been reached."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4346
msgid ""
"The caller is not required to consume all of the data returned, i.e. "
"**consumed** is typically set to the number of bytes already consumed and "
"the next call to skb_seq_read() will return the remaining part of the block."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4351
msgid "Note 1: The size of each block of data returned can be arbitrary,"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4352
msgid ""
"this limitation is the cost for zerocopy sequential reads of potentially non "
"linear data."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4355
msgid "Note 2: Fragment lists within fragments are not implemented"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4356
msgid ""
"at the moment, state->root_skb could be replaced with a stack for this "
"purpose."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4448
msgid "Abort a sequential read of skb data"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4450
msgid "Must be called if skb_seq_read() was not called until it returned 0."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4462
msgid "copy from a skb_seq_state to a buffer"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4463
msgid "source skb_seq_state"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4467
msgid ""
"Copy **len** bytes from **offset** bytes into the source **st** to the "
"destination buffer **to**. `offset` should increase (or be unchanged) with "
"each subsequent call to this function. If offset needs to decrease from the "
"previous use `st` should be reset first."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4473
msgid "0 on success or -EINVAL if the copy ended early"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4511
msgid "Find a text pattern in skb data"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4512
msgid "the buffer to look in"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4513
msgid "search offset"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4514
msgid "search limit"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4516
msgid "``struct ts_config *config``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4515
msgid "textsearch configuration"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4516
msgid ""
"Finds a pattern in the skb data according to the specified textsearch "
"configuration. Use textsearch_next() to retrieve subsequent occurrences of "
"the pattern. Returns the offset to the first occurrence or UINT_MAX if no "
"match was found."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4561
msgid "pull skb and update receive checksum"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4564
msgid ""
"This function performs an skb_pull on the packet and updates the "
"CHECKSUM_COMPLETE checksum.  It should be used on receive path processing "
"instead of skb_pull unless you know that the checksum difference is zero (e."
"g., a valid IP header) or you are setting ip_summed to CHECKSUM_NONE."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4687
msgid "Perform protocol segmentation on skb."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4693
msgid "``struct sk_buff *head_skb``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4688
msgid "buffer to segment"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4689
msgid "features for the output path (see dev->features)"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:4690
msgid ""
"This function performs segmentation on the given skb.  It returns a pointer "
"to the first in a list of new skbs for the segments. In case of error it "
"returns ERR_PTR(err)."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5211
msgid "Fill a scatter-gather list from a socket buffer"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5212
msgid "Socket buffer containing the buffers to be mapped"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5214
msgid "``struct scatterlist *sg``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5213
msgid "The scatter-gather list to map into"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5214
msgid "The offset into the buffer's contents to start mapping"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5215
msgid "Length of buffer space to be mapped"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5216
msgid ""
"Fill the specified scatter-gather list with mappings/pointers into a region "
"of the buffer space attached to a socket buffer. Returns either the number "
"of scatterlist items used, or -EMSGSIZE if the contents could not fit."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5264
msgid "Check that a socket buffer's data buffers are writable"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5265
msgid "The socket buffer to check."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5267
msgid "``int tailbits``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5266
msgid "Amount of trailing space to be added"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5268
msgid "``struct sk_buff **trailer``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5267
msgid "Returned pointer to the skb where the **tailbits** space begins"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5268
msgid ""
"Make sure that the data buffers attached to a socket buffer are writable. If "
"they are not, private copies are made of the data buffers and the socket "
"buffer is set to use these instead."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5272
msgid ""
"If **tailbits** is given, make sure that there is space to write "
"**tailbits** bytes of data beyond current end of socket buffer.  **trailer** "
"will be set to point to the skb in which this space begins."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5276
msgid ""
"The number of scatterlist elements required to completely map the COW'd and "
"extended socket buffer will be returned."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5450
msgid "create clone of skb, and take reference to socket"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5451
msgid "the skb to clone"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5452
msgid ""
"This function creates a clone of a buffer that holds a reference on "
"sk_refcnt.  Buffers created via this function are meant to be returned using "
"sock_queue_err_skb, or free via kfree_skb."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5456
msgid ""
"When passing buffers allocated with this function to sock_queue_err_skb it "
"is necessary to wrap the call with sock_hold/sock_put in order to prevent "
"the socket from being released prior to being enqueued on the sk_error_queue."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5698
msgid "set up and verify partial csum values for packet"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5699
msgid "the skb to set"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5701
msgid "``u16 start``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5700
msgid "the number of bytes after skb->data to start checksumming."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5702
msgid "``u16 off``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5701
msgid "the offset from start to place the checksum."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5702
msgid ""
"For untrusted partially-checksummed packets, we need to make sure the values "
"for skb->csum_start and skb->csum_offset are valid so we don't oops."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5705
msgid ""
"This function checks and sets those values and skb->ip_summed: if this "
"returns false you should drop the packet."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5933
msgid "set up partial checksum offset"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5934
msgid "the skb to set up"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5936
msgid "``bool recalculate``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5935
msgid "if true the pseudo-header checksum will be recalculated"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5998
msgid "validate checksum of an skb"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:5999
msgid "the skb to check"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6001
msgid "``unsigned int transport_len``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6000
msgid "the data length beyond the network header"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6002
msgid "``__sum16(*skb_chkf)(struct sk_buff *skb)``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6001
msgid "checksum function to use"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6002
msgid ""
"Applies the given checksum function skb_chkf to the provided skb. Returns a "
"checked and maybe trimmed skb. Returns NULL on error."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6005
msgid ""
"If the skb has data beyond the given transport length, then a trimmed & "
"cloned skb is checked and returned."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6008
msgid ""
"Caller needs to set the skb transport header and free any returned skb if it "
"differs from the provided skb."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6064
msgid "try to merge skb to prior one"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6065
msgid "prior buffer"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6066
msgid "buffer to add"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6068
msgid "``bool *fragstolen``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6067
msgid "pointer to boolean"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6069
msgid "``int *delta_truesize``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6068
msgid "how much more was allocated than was requested"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6162
msgid "scrub an skb"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6164
msgid "buffer to clean"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6166
msgid "``bool xnet``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6165
msgid "packet is crossing netns"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6166
msgid ""
"skb_scrub_packet can be used after encapsulating or decapsulating a packet "
"into/from a tunnel. Some information have to be cleared during these "
"operations. skb_scrub_packet can also be used to clean a skb before "
"injecting it in another namespace (**xnet** == true). We have to clear all "
"information in the skb that could impact namespace isolation."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6399
msgid "Drop the Ethernet header at the head of a packet"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6401 net/core/skbuff.c:6427
msgid "Socket buffer to modify"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6402
msgid "Drop the Ethernet header of **skb**."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6404
msgid ""
"Expects that skb->data points to the mac header and that no VLAN tags are "
"present."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6407 net/core/skbuff.c:6434
#: net/core/skbuff.c:6490 net/core/skbuff.c:6543 net/core/skbuff.c:6586
#: net/core/skbuff.c:6618
msgid "Returns 0 on success, -errno otherwise."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6425
msgid "Add a new Ethernet header at the head of a packet"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6429
msgid "``const unsigned char *dst``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6428
msgid "Destination MAC address of the new header"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6430
msgid "``const unsigned char *src``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6429
msgid "Source MAC address of the new header"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6430
msgid "Prepend **skb** with a new Ethernet header."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6432
msgid "Expects that skb->data points to the mac header, which must be empty."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6479
msgid "push a new MPLS header after mac_len bytes from start of the packet"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6484 net/core/skbuff.c:6584
msgid "``__be32 mpls_lse``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6483
msgid "MPLS label stack entry to push"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6485
msgid "``__be16 mpls_proto``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6484
msgid "ethertype of the new MPLS header (expects 0x8847 or 0x8848)"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6486 net/core/skbuff.c:6540
msgid "``int mac_len``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6485 net/core/skbuff.c:6539
msgid "length of the MAC header"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6487 net/core/skbuff.c:6541
msgid "``bool ethernet``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6486
msgid ""
"flag to indicate if the resulting packet after skb_mpls_push is ethernet"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6488 net/core/skbuff.c:6541
#: net/core/skbuff.c:6584 net/core/skbuff.c:6616
msgid "Expects skb->data at mac header."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6535
msgid "pop the outermost MPLS header"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6539
msgid "``__be16 next_proto``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6538
msgid "ethertype of header after popped MPLS header"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6540
msgid "flag to indicate if the packet is ethernet"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6580
msgid "modify outermost MPLS header and update csum"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6583
msgid "new MPLS label stack entry to update to"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6613
msgid "decrement the TTL of the outermost MPLS header"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6645
msgid "allocate skb with page frags"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6651
msgid "``unsigned long header_len``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6647
msgid "size of linear part"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6649
msgid "``unsigned long data_len``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6648
msgid "needed length in frags"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6650
msgid "``int order``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6649
msgid "max page order desired."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6651
msgid "``int *errcode``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6650
msgid "pointer to error code if any"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6652
msgid ""
"This can be used to allocate a paged skb, given a maximal order for frags."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6933
msgid "try to get rid of fragments/frag_list if possible"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6935
msgid ""
"Can be used to save memory before skb is added to a busy queue. If packet "
"has bytes in frags and enough tail room in skb->head, pull all of them, so "
"that we can free the frags right now and adjust truesize."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6940
msgid "**Notes**"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:6940
msgid ""
"We do not reallocate skb->head thus can not fail. Caller must re-evaluate "
"skb->truesize if needed."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:7029
msgid "attach the specified extension storage to this skb"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:7032 net/core/skbuff.c:7057
msgid "``enum skb_ext_id id``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:7031
msgid "extension id"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:7033
msgid "``struct skb_ext *ext``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:7032
msgid "extension storage previously allocated via __skb_ext_alloc()"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:7033
msgid "Existing extensions, if any, are cleared."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:7035
msgid "Returns the pointer to the extension."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:7054
msgid "allocate space for given extension, COW if needed"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:7056
msgid "extension to allocate space for"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:7057
msgid ""
"Allocates enough space for the given extension. If the extension is already "
"present, a pointer to that extension is returned."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:7061
msgid ""
"If the skb was cloned, COW applies and the returned memory can be modified "
"without changing the extension space of clones buffers."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:7064
msgid "Returns pointer to the extension or NULL on allocation failure."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:7238
msgid "Splice (or copy) pages to skbuff"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:7239
msgid "The buffer to add pages to"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:7241
msgid "``struct iov_iter *iter``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:7240
msgid "Iterator representing the pages to be added"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:7242
msgid "``ssize_t maxsize``"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:7241
msgid "Maximum amount of pages to be added"
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:7242
msgid ""
"This is a common helper function for supporting MSG_SPLICE_PAGES.  It "
"extracts pages from an iterator and adds them to the socket buffer if "
"possible, copying them to fragments if not possible (such as if they're slab "
"pages)."
msgstr ""

#: ../../../networking/kapi:26: net/core/skbuff.c:7247
msgid ""
"Returns the amount of data spliced/copied or -EMSGSIZE if there's "
"insufficient space in the buffer to transfer anything."
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:162
msgid "General socket capability test"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:163 net/core/sock.c:181
#: net/core/sock.c:196
msgid "Socket to use a capability on or through"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:165
msgid "``struct user_namespace *user_ns``"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:164
msgid "The user namespace of the capability to use"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:166 net/core/sock.c:183
#: net/core/sock.c:198
msgid "``int cap``"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:165 net/core/sock.c:197
msgid "The capability to use"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:166
msgid ""
"Test to see if the opener of the socket had when the socket was created and "
"the current process has the capability **cap** in the user namespace "
"**user_ns**."
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:180
msgid "Socket global capability test"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:182
msgid "The global capability to use"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:183
msgid ""
"Test to see if the opener of the socket had when the socket was created and "
"the current process has the capability **cap** in all user namespaces."
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:195
msgid "Network namespace socket capability test"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:198
msgid ""
"Test to see if the opener of the socket had when the socket was created and "
"the current process has the capability **cap** over the network namespace "
"the socket is a member of."
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:295
msgid "sets ``SOCK_MEMALLOC``"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:296
msgid "socket to set it on"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:297
msgid ""
"Set ``SOCK_MEMALLOC`` on a socket for access to emergency reserves. It's the "
"responsibility of the admin to adjust min_free_kbytes to meet the "
"requirements"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:2283
msgid "All socket objects are allocated here"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:2284
#: ../../../networking/kapi:92: net/core/dev.c:850 net/core/dev.c:871
#: net/core/dev.c:905 net/core/dev.c:930 net/core/dev.c:954 net/core/dev.c:991
#: net/core/dev.c:1202 net/core/dev.c:1229
msgid "the applicable net namespace"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:2285
msgid "protocol family"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:2286 net/core/sock.c:2456
msgid "for allocation (``GFP_KERNEL``, ``GFP_ATOMIC``, etc)"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:2288
msgid "``struct proto *prot``"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:2287
msgid "struct proto associated with this new sock instance"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:2288
msgid "is this to be a kernel socket?"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:2454
msgid "clone a socket, and lock its clone"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:2455
msgid "the socket to clone"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:2457
msgid "``const gfp_t priority``"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:2457
msgid "Caller must unlock socket even in error path (bh_unlock_sock(newsk))"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:3091
msgid "check that a page_frag contains enough room"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:3097
msgid "``unsigned int sz``"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:3092
msgid "minimum size of the fragment we want to get"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:3094
msgid "``struct page_frag *pfrag``"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:3093
msgid "pointer to page_frag"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:3095
#: ../../../networking/kapi:92: net/core/dev.c:909 net/core/dev.c:995
msgid "``gfp_t gfp``"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:3096
msgid ""
"While this allocator tries to use high order pages, there is no guarantee "
"that allocations succeed. Therefore, **sz** MUST be less or equal than "
"PAGE_SIZE."
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:3214
msgid "wait for data to arrive at sk_receive_queue"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:3215
#: ../../../networking/kapi:35: net/core/stream.c:55
msgid "sock to wait on"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:3217
msgid "``long *timeo``"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:3216
#: ../../../networking/kapi:35: net/core/stream.c:120
msgid "for how long"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:3217
msgid "last skb seen on sk_receive_queue"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:3218
msgid ""
"Now socket state including sk->sk_err is changed only under lock, hence we "
"may omit checks after joining wait queue. We check receive queue before "
"schedule() only as optimization; it is very likely that release_sock() added "
"new data."
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:3356
msgid "increase sk_forward_alloc and memory_allocated"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:3358
msgid "memory size to allocate"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:3360
msgid "``int kind``"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:3359
msgid "allocation type"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:3360
msgid ""
"If kind is SK_MEM_SEND, it means wmem allocation. Otherwise it means rmem "
"allocation. This function assumes that protocols which have memory_pressure "
"use sk_wmem_queued as write buffer accounting."
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:3397
msgid "reclaim sk_forward_alloc and memory_allocated"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:3400
msgid "``int amount``"
msgstr ""

#: ../../../networking/kapi:29: net/core/sock.c:3399
msgid "number of bytes (rounded down to a PAGE_SIZE multiple)"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:208
msgid "Receive a datagram skbuff"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:211
msgid "``struct sk_buff_head *queue``"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:210
msgid "socket queue from which to receive"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:212 net/core/datagram.c:358
msgid "``unsigned int flags``"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:211 net/core/datagram.c:357
msgid "MSG\\_ flags"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:213
msgid "``int *off``"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:212
msgid ""
"an offset in bytes to peek skb from. Returns an offset within an skb where "
"data actually starts"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:214
msgid "error code returned"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:216
msgid "``struct sk_buff **last``"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:215
msgid ""
"set to last peeked message to inform the wait function what to look for when "
"peeking"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:217
msgid ""
"Get a datagram skbuff, understands the peeking, nonblocking wakeups and "
"possible races. This replaces identical code in packet, raw and udp, as well "
"as the IPX AX.25 and Appletalk. It also finally fixes the long standing peek "
"and read race for datagram sockets. If you alter this routine remember it "
"must be re-entrant."
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:223
msgid ""
"This function will lock the socket if a skb is returned, so the caller needs "
"to unlock the socket in that case (usually by calling skb_free_datagram). "
"Returns NULL with **err** set to -EAGAIN if no data was available or to some "
"other value if an error was detected."
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:229
msgid "It does not lock socket since today. This function is"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:230
msgid "free of race conditions. This measure should/can improve"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:231
msgid "significantly datagram socket latencies at high loads,"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:232
msgid "when data copying to user space takes lots of time."
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:233
msgid "(BTW I've just killed the last cli() in IP/IPv6/core/netlink/packet"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:234
msgid "Great win.)"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:235
msgid "--ANK (980729)"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:237
msgid ""
"The order of the tests when we find no data waiting are specified quite "
"explicitly by POSIX 1003.1g, don't change them without having the standard "
"around please."
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:354
msgid "Free a datagram skbuff forcibly"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:356
msgid "datagram skbuff"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:358
msgid ""
"This function frees a datagram skbuff that was received by "
"skb_recv_datagram.  The flags argument must match the one used for "
"skb_recv_datagram."
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:362
msgid ""
"If the MSG_PEEK flag is set, and the packet is still on the receive queue of "
"the socket, it will be taken off the queue before it is freed."
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:366
msgid ""
"This function currently only disables BH when acquiring the sk_receive_queue "
"lock.  Therefore it must not be used in a context where that lock is "
"acquired in an IRQ context."
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:370
msgid "It returns 0 if the packet was removed by us."
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:499
msgid "Copy datagram to an iovec iterator and update a CRC32C value."
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:502 net/core/datagram.c:527
msgid "offset in the buffer to start copying from"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:504 net/core/datagram.c:529
msgid "``struct iov_iter *to``"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:503 net/core/datagram.c:528
msgid "iovec iterator to copy to"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:504 net/core/datagram.c:529
msgid "amount of data to copy from buffer to iovec"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:506
msgid "``u32 *crcp``"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:505
msgid "pointer to CRC32C value to update"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:507
msgid "0 on success, -EFAULT if there was a fault during copy."
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:525
msgid "Copy a datagram to an iovec iterator."
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:541
msgid "Copy a datagram from an iov_iter."
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:543
msgid "offset in the buffer to start copying to"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:545 net/core/datagram.c:778
msgid "``struct iov_iter *from``"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:544
msgid "the copy source"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:545
msgid "amount of data to copy to buffer from iovec"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:546
msgid "Returns 0 or -EFAULT."
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:775
msgid "Build a zerocopy datagram from an iov_iter"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:777
msgid "the source to copy from"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:778
msgid ""
"The function will first copy up to headlen, and then pin the userspace pages "
"and build frags through them."
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:781
msgid "Returns 0, -EFAULT or -EMSGSIZE."
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:876
msgid "Copy and checksum skb to user iovec."
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:877
msgid "skbuff"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:878
msgid "hardware length"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:879
msgid "destination"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:880
msgid "Caller _must_ check that skb will fit to this iovec."
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:883
msgid ""
"0       - success. -EINVAL - checksum failure. -EFAULT - fault during copy."
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:923
msgid "generic datagram poll"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:924
msgid "file struct"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:927
msgid "``poll_table *wait``"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:926
msgid "poll table"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:927
msgid ""
"Datagram poll: Again totally generic. This also handles sequenced packet "
"sockets providing the socket receive queue is only ever holding data ready "
"to receive."
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:932
msgid "when you *don't* use this routine for this protocol,"
msgstr ""

#: ../../../networking/kapi:32: net/core/datagram.c:933
msgid ""
"and you use a different write policy from sock_writeable() then please "
"supply your own write_space callback."
msgstr ""

#: ../../../networking/kapi:35: net/core/stream.c:54
msgid "Wait for a socket to get into the connected state"
msgstr ""

#: ../../../networking/kapi:35: net/core/stream.c:57 net/core/stream.c:121
msgid "``long *timeo_p``"
msgstr ""

#: ../../../networking/kapi:35: net/core/stream.c:56
msgid "for how long to wait"
msgstr ""

#: ../../../networking/kapi:35: net/core/stream.c:57
msgid "Must be called with the socket locked."
msgstr ""

#: ../../../networking/kapi:35: net/core/stream.c:118
msgid "Wait for more memory for a socket"
msgstr ""

#: ../../../networking/kapi:35: net/core/stream.c:119
msgid "socket to wait for memory"
msgstr ""

#: ../../../networking/kapi.rst:39
msgid "Socket Filter"
msgstr ""

#: ../../../networking/kapi:41: net/core/filter.c:121
msgid "run a packet through a socket filter"
msgstr ""

#: ../../../networking/kapi:41: net/core/filter.c:122
msgid "sock associated with :c:type:`sk_buff`"
msgstr ""

#: ../../../networking/kapi:41: net/core/filter.c:123
msgid "buffer to filter"
msgstr ""

#: ../../../networking/kapi:41: net/core/filter.c:125
msgid "``unsigned int cap``"
msgstr ""

#: ../../../networking/kapi:41: net/core/filter.c:124
msgid "limit on how short the eBPF program may trim the packet"
msgstr ""

#: ../../../networking/kapi:41: net/core/filter.c:126
msgid "``enum skb_drop_reason *reason``"
msgstr ""

#: ../../../networking/kapi:41: net/core/filter.c:125
msgid "record drop reason on errors (negative return value)"
msgstr ""

#: ../../../networking/kapi:41: net/core/filter.c:126
msgid ""
"Run the eBPF program and then cut skb->data to correct size returned by the "
"program. If pkt_len is 0 we toss packet. If skb->len is smaller than pkt_len "
"we keep whole skb->data. This is the socket level wrapper to bpf_prog_run. "
"It returns 0 if the packet should be accepted or -EPERM if the packet should "
"be tossed."
msgstr ""

#: ../../../networking/kapi:41: net/core/filter.c:1378
msgid "create an unattached filter"
msgstr ""

#: ../../../networking/kapi:41: net/core/filter.c:1384 net/core/filter.c:1428
msgid "``struct bpf_prog **pfp``"
msgstr ""

#: ../../../networking/kapi:41: net/core/filter.c:1379 net/core/filter.c:1423
msgid "the unattached filter that is created"
msgstr ""

#: ../../../networking/kapi:41: net/core/filter.c:1381
msgid "``struct sock_fprog_kern *fprog``"
msgstr ""

#: ../../../networking/kapi:41: net/core/filter.c:1380 net/core/filter.c:1424
#: net/core/filter.c:1546
msgid "the filter program"
msgstr ""

#: ../../../networking/kapi:41: net/core/filter.c:1381
msgid ""
"Create a filter independent of any socket. We first run some sanity checks "
"on it to make sure it does not explode on us later. If an error occurs or "
"there is insufficient memory for the filter a negative errno code is "
"returned. On success the return is zero."
msgstr ""

#: ../../../networking/kapi:41: net/core/filter.c:1422
msgid "create an unattached filter from user buffer"
msgstr ""

#: ../../../networking/kapi:41: net/core/filter.c:1425 net/core/filter.c:1551
msgid "``struct sock_fprog *fprog``"
msgstr ""

#: ../../../networking/kapi:41: net/core/filter.c:1426
msgid "``bpf_aux_classic_check_t trans``"
msgstr ""

#: ../../../networking/kapi:41: net/core/filter.c:1425
msgid "post-classic verifier transformation handler"
msgstr ""

#: ../../../networking/kapi:41: net/core/filter.c:1427
msgid "``bool save_orig``"
msgstr ""

#: ../../../networking/kapi:41: net/core/filter.c:1426
msgid "save classic BPF program"
msgstr ""

#: ../../../networking/kapi:41: net/core/filter.c:1427
msgid ""
"This function effectively does the same as bpf_prog_create(), only that it "
"builds up its insns buffer from user space provided buffer. It also allows "
"for passing a bpf_aux_classic_check_t handler."
msgstr ""

#: ../../../networking/kapi:41: net/core/filter.c:1545
msgid "attach a socket filter"
msgstr ""

#: ../../../networking/kapi:41: net/core/filter.c:1547
msgid "the socket to use"
msgstr ""

#: ../../../networking/kapi:41: net/core/filter.c:1548
msgid ""
"Attach the user's filter code. We first run some sanity checks on it to make "
"sure it does not explode on us later. If an error occurs or there is "
"insufficient memory for the filter a negative errno code is returned. On "
"success the return is zero."
msgstr ""

#: ../../../networking/kapi.rst:45
msgid "Generic Network Statistics"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:22
msgid "byte/packet throughput statistics"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:23
msgid "``bytes``"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:24
msgid "number of seen bytes"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:24
msgid "``packets``"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:25
msgid "number of seen packets"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:32
#: include/uapi/linux/gen_stats.h:42 ../../../networking/kapi:50:
#: net/core/gen_stats.c:299 ../../../networking/kapi:53:
#: net/core/gen_estimator.c:202 net/core/gen_estimator.c:248
msgid "rate estimator"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:33
#: include/uapi/linux/gen_stats.h:43
msgid "``bps``"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:34
#: include/uapi/linux/gen_stats.h:44
msgid "current byte rate"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:34
#: include/uapi/linux/gen_stats.h:44
msgid "``pps``"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:35
#: include/uapi/linux/gen_stats.h:45
msgid "current packet rate"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:52
msgid "queuing statistics"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:53
msgid "``qlen``"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:54
msgid "queue length"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:54
msgid "``backlog``"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:55
msgid "backlog size of queue"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:55
msgid "``drops``"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:56
msgid "number of dropped packets"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:56
msgid "``requeues``"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:57
msgid "number of requeues"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:57
msgid "``overlimits``"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:58
msgid "number of enqueues over the limit"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:68
msgid "rate estimator configuration"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:69
msgid "``interval``"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:70
msgid "sampling period"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:70
msgid "``ewma_log``"
msgstr ""

#: ../../../networking/kapi:47: include/uapi/linux/gen_stats.h:71
msgid "the log of measurement window weight"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:40 net/core/gen_stats.c:96
msgid "start dumping procedure in compatibility mode"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:41 net/core/gen_stats.c:97
msgid "socket buffer to put statistics TLVs into"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:42 net/core/gen_stats.c:98
msgid "TLV type for top level statistic TLV"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:44
msgid "``int tc_stats_type``"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:43
msgid "TLV type for backward compatibility struct tc_stats TLV"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:45
msgid "``int xstats_type``"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:44
msgid "TLV type for backward compatibility xstats TLV"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:46
#: net/core/gen_stats.c:100 ../../../networking/kapi:53:
#: net/core/gen_estimator.c:118 net/core/gen_estimator.c:225
msgid "``spinlock_t *lock``"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:45 net/core/gen_stats.c:99
msgid "statistics lock"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:47
#: net/core/gen_stats.c:101 net/core/gen_stats.c:249 net/core/gen_stats.c:276
#: net/core/gen_stats.c:303 net/core/gen_stats.c:379 net/core/gen_stats.c:419
#: net/core/gen_stats.c:456
msgid "``struct gnet_dump *d``"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:46
#: net/core/gen_stats.c:100 net/core/gen_stats.c:244 net/core/gen_stats.c:271
#: net/core/gen_stats.c:298 net/core/gen_stats.c:374 net/core/gen_stats.c:414
#: net/core/gen_stats.c:451
msgid "dumping handle"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:48
#: net/core/gen_stats.c:102
msgid "``int padattr``"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:47
#: net/core/gen_stats.c:101
msgid "padding attribute"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:48
#: net/core/gen_stats.c:102
msgid ""
"Initializes the dumping handle, grabs the statistic lock and appends an "
"empty TLV header to the socket buffer for use a container for all other "
"statistic TLVS."
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:52
msgid ""
"The dumping handle is marked to be in backward compatibility mode telling "
"all gnet_stats_copy_XXX() functions to fill a local copy of struct tc_stats."
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:55
#: net/core/gen_stats.c:106
msgid ""
"Returns 0 on success or -1 if the room in the socket buffer was not "
"sufficient."
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:243
msgid "copy basic statistics into statistic TLV"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:246
#: net/core/gen_stats.c:273
msgid "``struct gnet_stats_basic_sync __percpu *cpu``"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:245
#: net/core/gen_stats.c:272
msgid "copy statistic per cpu"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:247
#: net/core/gen_stats.c:274
msgid "``struct gnet_stats_basic_sync *b``"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:246
#: net/core/gen_stats.c:273 ../../../networking/kapi:53:
#: net/core/gen_estimator.c:114 net/core/gen_estimator.c:221
msgid "basic statistics"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:248
#: net/core/gen_stats.c:275 ../../../networking/kapi:53:
#: net/core/gen_estimator.c:119 net/core/gen_estimator.c:226
msgid "``bool running``"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:247
#: net/core/gen_stats.c:274
msgid ""
"true if **b** represents a running qdisc, thus **b**'s internal values might "
"change during basic reads. Only used if **cpu** is NULL"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:251
#: net/core/gen_stats.c:278 ../../../networking/kapi:92: net/core/dev.c:1235
msgid "**Context**"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:251
#: net/core/gen_stats.c:278
msgid "task; must not be run from IRQ or BH contexts"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:252
#: net/core/gen_stats.c:279
msgid ""
"Appends the basic statistics to the top level TLV created by "
"gnet_stats_start_copy()."
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:255
#: net/core/gen_stats.c:282 net/core/gen_stats.c:303 net/core/gen_stats.c:382
#: net/core/gen_stats.c:421 net/core/gen_stats.c:457
msgid ""
"Returns 0 on success or -1 with the statistic lock released if the room in "
"the socket buffer was not sufficient."
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:270
msgid "copy basic hw statistics into statistic TLV"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:297
msgid "copy rate estimator statistics into statistics TLV"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:300
#: ../../../networking/kapi:53: net/core/gen_estimator.c:117
#: net/core/gen_estimator.c:207 net/core/gen_estimator.c:224
#: net/core/gen_estimator.c:253
msgid "``struct net_rate_estimator __rcu **rate_est``"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:300
msgid ""
"Appends the rate estimator statistics to the top level TLV created by "
"gnet_stats_start_copy()."
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:373
msgid "copy queue statistics into statistics TLV"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:376
msgid "``struct gnet_stats_queue __percpu *cpu_q``"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:375
msgid "per cpu queue statistics"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:377
msgid "``struct gnet_stats_queue *q``"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:376
msgid "queue statistics"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:378
msgid "``__u32 qlen``"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:377
msgid "queue length statistics"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:378
msgid ""
"Appends the queue statistics to the top level TLV created by "
"gnet_stats_start_copy(). Using per cpu queue statistics if they are "
"available."
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:413
msgid "copy application specific statistics into statistics TLV"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:416
msgid "``void *st``"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:415
msgid "application specific statistics data"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:416
msgid "length of data"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:417
msgid ""
"Appends the application specific statistics to the top level TLV created by "
"gnet_stats_start_copy() and remembers the data for XSTATS if the dumping "
"handle is in backward compatibility mode."
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:450
msgid "finish dumping procedure"
msgstr ""

#: ../../../networking/kapi:50: net/core/gen_stats.c:452
msgid ""
"Corrects the length of the top level TLV to include all TLVs added by "
"gnet_stats_copy_XXX() calls. Adds the backward compatibility TLVs if "
"gnet_stats_start_copy_compat() was used and releases the statistics lock."
msgstr ""

#: ../../../networking/kapi:53: net/core/gen_estimator.c:113
msgid "create a new rate estimator"
msgstr ""

#: ../../../networking/kapi:53: net/core/gen_estimator.c:119
#: net/core/gen_estimator.c:226
msgid "``struct gnet_stats_basic_sync *bstats``"
msgstr ""

#: ../../../networking/kapi:53: net/core/gen_estimator.c:116
#: net/core/gen_estimator.c:223
msgid "``struct gnet_stats_basic_sync __percpu *cpu_bstats``"
msgstr ""

#: ../../../networking/kapi:53: net/core/gen_estimator.c:115
#: net/core/gen_estimator.c:222
msgid "bstats per cpu"
msgstr ""

#: ../../../networking/kapi:53: net/core/gen_estimator.c:116
#: net/core/gen_estimator.c:223
msgid "rate estimator statistics"
msgstr ""

#: ../../../networking/kapi:53: net/core/gen_estimator.c:117
#: net/core/gen_estimator.c:224
msgid "lock for statistics and control path"
msgstr ""

#: ../../../networking/kapi:53: net/core/gen_estimator.c:118
msgid ""
"true if **bstats** represents a running qdisc, thus **bstats**' internal "
"values might change during basic reads. Only used if **bstats_cpu** is NULL"
msgstr ""

#: ../../../networking/kapi:53: net/core/gen_estimator.c:122
#: net/core/gen_estimator.c:229
msgid "``struct nlattr *opt``"
msgstr ""

#: ../../../networking/kapi:53: net/core/gen_estimator.c:121
#: net/core/gen_estimator.c:228
msgid "rate estimator configuration TLV"
msgstr ""

#: ../../../networking/kapi:53: net/core/gen_estimator.c:122
msgid ""
"Creates a new rate estimator with :c:type:`bstats` as source and :c:type:"
"`rate_est` as destination. A new timer with the interval specified in the "
"configuration TLV is created. Upon each interval, the latest statistics will "
"be read from :c:type:`bstats` and the estimated rate will be stored in :c:"
"type:`rate_est` with the statistics lock grabbed during this period."
msgstr ""

#: ../../../networking/kapi:53: net/core/gen_estimator.c:128
#: net/core/gen_estimator.c:232
msgid "Returns 0 on success or a negative error code."
msgstr ""

#: ../../../networking/kapi:53: net/core/gen_estimator.c:201
msgid "remove a rate estimator"
msgstr ""

#: ../../../networking/kapi:53: net/core/gen_estimator.c:203
msgid "Removes the rate estimator."
msgstr ""

#: ../../../networking/kapi:53: net/core/gen_estimator.c:220
msgid "replace rate estimator configuration"
msgstr ""

#: ../../../networking/kapi:53: net/core/gen_estimator.c:225
msgid ""
"true if **bstats** represents a running qdisc, thus **bstats**' internal "
"values might change during basic reads. Only used if **cpu_bstats** is NULL"
msgstr ""

#: ../../../networking/kapi:53: net/core/gen_estimator.c:229
msgid ""
"Replaces the configuration of a rate estimator by calling "
"gen_kill_estimator() and gen_new_estimator()."
msgstr ""

#: ../../../networking/kapi:53: net/core/gen_estimator.c:247
msgid "test if estimator is currently in use"
msgstr ""

#: ../../../networking/kapi:53: net/core/gen_estimator.c:249
msgid "Returns true if estimator is active, and false if not."
msgstr ""

#: ../../../networking/kapi.rst:57
msgid "SUN RPC subsystem"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:41
msgid "Encode fixed length opaque data"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:47 net/sunrpc/xdr.c:77
#: net/sunrpc/xdr.c:928 net/sunrpc/xdr.c:1401
msgid "``__be32 *p``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:42 net/sunrpc/xdr.c:72
msgid "pointer to current position in XDR buffer."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:44 net/sunrpc/xdr.c:74
msgid "``const void *ptr``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:43 net/sunrpc/xdr.c:73
msgid "pointer to data to encode (or NULL)"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:45 net/sunrpc/xdr.c:75
#: net/sunrpc/xdr.c:1715
msgid "``unsigned int nbytes``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:44 net/sunrpc/xdr.c:74
msgid "size of data."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:45
msgid ""
"Copy the array of data of length nbytes at ptr to the XDR buffer at position "
"p, then align to the next 32-bit boundary by padding with zero bytes (see "
"RFC1832)."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:49
msgid "if ptr is NULL, only the padding is performed."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:51 net/sunrpc/xdr.c:75
msgid "Returns the updated current XDR buffer position"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:71
msgid "Encode variable length opaque data"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:93
msgid "'\\0'-terminate a string residing in an xdr_buf"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:99 net/sunrpc/xdr.c:1655
msgid "``const struct xdr_buf *buf``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:94
msgid "XDR buffer where string resides"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:95
msgid "length of string, in bytes"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:140
msgid "Copy components of an xdr_buf into a bio_vec array"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:146
msgid "``struct bio_vec *bvec``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:141
msgid "bio_vec array to populate"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:143
msgid "``unsigned int bvec_size``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:142
msgid "element count of **bio_vec**"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:144
msgid "``const struct xdr_buf *xdr``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:143
msgid "xdr_buf to be copied"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:144
msgid "Returns the number of entries consumed in **bvec**."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:191
msgid "Prepare receive buffer for a large reply"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:197
msgid "``struct xdr_buf *xdr``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:192
msgid "xdr_buf into which reply will be placed"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:193
msgid "expected offset where data payload will start, in bytes"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:195 net/sunrpc/xdr.c:408
#: net/sunrpc/xdr.c:1259 net/sunrpc/xdr.c:1426 ../../../networking/kapi:83:
#: net/sunrpc/clnt.c:1354
msgid "``struct page **pages``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:194
#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1353
msgid "vector of struct page pointers"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:196 net/sunrpc/xdr.c:1260
#: net/sunrpc/xdr.c:1653 ../../../networking/kapi:83: net/sunrpc/clnt.c:1355
msgid "``unsigned int base``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:195
#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1354
msgid "offset in first page where receive should start, in bytes"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:196
#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1355
msgid "expected size of the upper layer data payload, in bytes"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:411
msgid "``char *p``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:406
msgid "pointer to destination"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:407
msgid "array of pages"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:409
msgid "``size_t pgbase``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:408
msgid "offset of source data"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:409
msgid "length"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:410
msgid ""
"Copies data into an arbitrary memory location from an array of pages The "
"copy is assumed to be non-overlapping."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:889
msgid "Return the current offset from the start of the xdr_stream"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:895 net/sunrpc/xdr.c:917
msgid "``const struct xdr_stream *xdr``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:890 net/sunrpc/xdr.c:912
#: net/sunrpc/xdr.c:1213
msgid "pointer to struct xdr_stream"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:911
msgid "Return the current offset from the start of the xdr pages"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:924
msgid "Initialize a struct xdr_stream for sending data."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:930 net/sunrpc/xdr.c:971
#: net/sunrpc/xdr.c:990 net/sunrpc/xdr.c:1069 net/sunrpc/xdr.c:1106
#: net/sunrpc/xdr.c:1149 net/sunrpc/xdr.c:1218 net/sunrpc/xdr.c:1233
#: net/sunrpc/xdr.c:1262 net/sunrpc/xdr.c:1403 net/sunrpc/xdr.c:1428
#: net/sunrpc/xdr.c:1447 net/sunrpc/xdr.c:1496 net/sunrpc/xdr.c:1563
#: net/sunrpc/xdr.c:1592 net/sunrpc/xdr.c:1622 net/sunrpc/xdr.c:1717
#: net/sunrpc/xdr.c:1764 net/sunrpc/xdr.c:1795 net/sunrpc/xdr.c:2226
#: net/sunrpc/xdr.c:2259 net/sunrpc/xdr.c:2287
msgid "``struct xdr_stream *xdr``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:925 net/sunrpc/xdr.c:966
#: net/sunrpc/xdr.c:1398 net/sunrpc/xdr.c:1423 net/sunrpc/xdr.c:1442
#: net/sunrpc/xdr.c:1491 net/sunrpc/xdr.c:1558 net/sunrpc/xdr.c:1587
#: net/sunrpc/xdr.c:1617
msgid "pointer to xdr_stream struct"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:927 net/sunrpc/xdr.c:968
#: net/sunrpc/xdr.c:1400 net/sunrpc/xdr.c:1425 net/sunrpc/xdr.c:1818
msgid "``struct xdr_buf *buf``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:926
msgid "pointer to XDR buffer in which to encode data"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:927 net/sunrpc/xdr.c:1400
msgid "current pointer inside XDR buffer"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:929 net/sunrpc/xdr.c:1402
msgid "``struct rpc_rqst *rqst``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:928 net/sunrpc/xdr.c:1401
msgid "pointer to controlling rpc_rqst, for debugging"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:930
msgid "at the moment the RPC client only passes the length of our"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:931
msgid ""
"scratch buffer in the xdr_buf's header kvec. Previously this meant we needed "
"to call xdr_adjust_iovec() after encoding the data. With the new scheme, the "
"xdr_stream manages the details of the buffer length, and takes care of "
"adjusting the kvec length for us."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:965
msgid "Initialize an xdr_stream for encoding into pages"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:967
msgid "pointer to XDR buffer into which to encode data"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:984
msgid "Ensure all data is written to buffer"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:985 net/sunrpc/xdr.c:1064
#: net/sunrpc/xdr.c:1101 net/sunrpc/xdr.c:1144 net/sunrpc/xdr.c:1228
#: net/sunrpc/xdr.c:1257 net/sunrpc/xdr.c:2221 net/sunrpc/xdr.c:2254
#: net/sunrpc/xdr.c:2282
msgid "pointer to xdr_stream"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:986
msgid ""
"We handle encoding across page boundaries by giving the caller a temporary "
"location to write to, then later copying the data into place; "
"xdr_commit_encode does that copying."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:990
msgid ""
"Normally the caller doesn't need to call this directly, as the following "
"xdr_reserve_space will do it.  But an explicit call may be required at the "
"end of encoding, or any other time when the xdr_buf data might be read."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1063
msgid "Reserve buffer space for sending"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1066 net/sunrpc/xdr.c:1103
#: net/sunrpc/xdr.c:1493
msgid "``size_t nbytes``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1065 net/sunrpc/xdr.c:1102
msgid "number of bytes to reserve"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1066
msgid ""
"Checks that we have enough buffer space to encode 'nbytes' more bytes of "
"data. If so, update the total xdr_buf length, and adjust the length of the "
"current kvec."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1070
msgid ""
"The returned pointer is valid only until the next call to "
"xdr_reserve_space() or xdr_commit_encode() on **xdr**. The current "
"implementation of this API guarantees that space reserved for a four-byte "
"data item remains valid until **xdr** is destroyed, but that might not "
"always be true in the future."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1100
msgid "Reserves a large amount of buffer space for sending"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1103
msgid ""
"The size argument passed to xdr_reserve_space() is determined based on the "
"number of bytes remaining in the current page to avoid invalidating iov_base "
"pointers when xdr_commit_encode() is called."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1107 net/sunrpc/xdr.c:1720
#: net/sunrpc/xdr.c:2225 net/sunrpc/xdr.c:2258 net/sunrpc/xdr.c:2286
msgid "Return values:"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1108
msgid "``0``: success ``-EMSGSIZE``: not enough space is available in **xdr**"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1143
msgid "truncate an encode buffer"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1145
msgid "new length of buffer"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1146
msgid ""
"Truncates the xdr stream, so that xdr->buf->len == len, and xdr->p points at "
"offset len from the start of the buffer, and head, tail, and page lengths "
"are adjusted to correspond."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1150
msgid ""
"If this means moving xdr->p to a different buffer, we assume that the end "
"pointer should be set to the end of the current page, except in the case of "
"the head buffer when we assume the head buffer's current length represents "
"the end of the available buffer."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1155
msgid ""
"This is *not* safe to use on a buffer that already has inlined page cache "
"pages (as in a zero-copy server read reply), except for the simple case of "
"truncating from one position in the tail to another."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1212
msgid "Truncate a decoding stream"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1214
msgid "Number of bytes to remove"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1227
msgid "decrease available buffer space"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1230
msgid "``int newbuflen``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1229
msgid "new maximum number of bytes available"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1230
msgid ""
"Adjust our idea of how much space is available in the buffer. If we've "
"already used too much space in the buffer, returns -1. If the available "
"space is already smaller than newbuflen, returns 0 and does nothing.  "
"Otherwise, adjusts xdr->buf->buflen to newbuflen and ensures xdr->end is set "
"at most offset newbuflen from the start of the buffer."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1256
msgid "Insert a list of pages into an XDR buffer for sending"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1258
msgid "array of pages to insert"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1259
msgid "starting offset of first data byte in **pages**"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1260
msgid "number of data bytes in **pages** to insert"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1261
msgid ""
"After the **pages** are added, the tail iovec is instantiated pointing to "
"end of the head buffer, and the stream is set up to encode subsequent items "
"into the tail."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1397
msgid "Initialize an xdr_stream for decoding data."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1399 net/sunrpc/xdr.c:1424
msgid "pointer to XDR buffer from which to decode data"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1422
msgid "Initialize an xdr_stream for decoding into pages"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1425
msgid "list of pages to decode into"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1426
msgid "length in bytes of buffer in pages"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1441
msgid "Clean up the xdr_stream after decoding data."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1490
msgid "Retrieve XDR data to decode"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1492
msgid "number of bytes of data to decode"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1493
msgid ""
"Check if the input buffer is long enough to enable us to decode 'nbytes' "
"more bytes of data starting at the current position. If so return the "
"current pointer, then update the current pointer position."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1557
msgid "align page-based XDR data to current pointer position"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1559 net/sunrpc/xdr.c:1618
msgid "number of bytes of page data"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1560
msgid ""
"Moves data beyond the current pointer position from the XDR head[] buffer "
"into the page list. Any data that lies beyond current position + **len** "
"bytes is moved into the XDR tail[]. The xdr_stream current position is then "
"advanced past that data to align to the next XDR object in the tail."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1565
msgid "Returns the number of XDR encoded bytes now contained in the pages"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1586
msgid "Sets the length of the XDR pages"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1588
msgid "new length of the XDR page data"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1589
msgid ""
"Either grows or shrinks the length of the xdr pages by setting pagelen to "
"**len** bytes. When shrinking, any extra data is moved into buf->tail, "
"whereas when growing any data beyond the current pointer is moved into the "
"tail."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1593
msgid "Returns True if the operation was successful, and False otherwise."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1616
msgid "decode data from the XDR page"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1619
msgid ""
"Moves data beyond the current pointer position from the XDR head[] buffer "
"into the page list. Any data that lies beyond current position + \"len\" "
"bytes is moved into the XDR tail[]. The current pointer is then repositioned "
"at the beginning of the first XDR page."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1649
msgid "set subbuf to a portion of buf"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1650
msgid "an xdr buffer"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1652 net/sunrpc/xdr.c:1714
msgid "``struct xdr_buf *subbuf``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1651 net/sunrpc/xdr.c:1713
msgid "the result buffer"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1652
msgid "beginning of range in bytes"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1653
msgid "length of range in bytes"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1654
msgid ""
"sets **subbuf** to an xdr buffer representing the portion of **buf** of "
"length **len** starting at offset **base**."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1657
msgid "**buf** and **subbuf** may be pointers to the same struct xdr_buf."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1659
msgid "Returns -1 if base or length are out of bounds."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1711
msgid "set **subbuf** to a portion of **xdr**"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1712
msgid "an xdr_stream set up for decoding"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1714
msgid "length of **xdr** to extract, in bytes"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1715
msgid ""
"Sets up **subbuf** to represent a portion of **xdr**. The portion starts at "
"the current offset in **xdr**, and extends for a length of **nbytes**. If "
"this is successful, **xdr** is advanced to the next XDR data item following "
"that portion."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1721
msgid ""
"``true``: **subbuf** has been initialized, and **xdr** has been advanced. "
"``false``: a bounds error has occurred"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1758
msgid "Move part of a stream to another position"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1759
msgid "the source xdr_stream"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1760
msgid "the source offset of the segment"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1762
msgid "``unsigned int target``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1761
msgid "the target offset of the segment"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1762
msgid "the number of bytes to move"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1763
msgid ""
"Moves **length** bytes from **offset** to **target** in the xdr_stream, "
"overwriting anything in its space. Returns the number of bytes in the "
"segment."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1789
msgid "zero out a portion of an xdr_stream"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1790
msgid "an xdr_stream to zero out"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1791
msgid "the starting point in the stream"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1792
msgid "the number of bytes to zero"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1812
msgid "lop at most \"len\" bytes off the end of \"buf\""
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1813
msgid "buf to be trimmed"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1814
msgid "number of bytes to reduce \"buf\" by"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:1815
msgid ""
"Trim an xdr_buf by the given number of bytes by fixing up the lengths. Note "
"that it's possible that we'll trim less than that amount if the xdr_buf is "
"too small, or if (for instance) it's all in the head and the parser has "
"already read too far into it."
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:2220
msgid "Decode and duplicate variable length string"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:2223
msgid "``char **str``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:2222
msgid "location to store pointer to string"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:2224
msgid "``size_t maxlen``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:2223
msgid "maximum acceptable string length"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:2225
msgid "``gfp_t gfp_flags``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:2224
msgid "GFP mask to use"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:2226
msgid ""
"On success, returns length of NUL-terminated string stored in ***ptr** ``-"
"EBADMSG`` on XDR buffer overflow ``-EMSGSIZE`` if the size of the string "
"would exceed **maxlen** ``-ENOMEM`` on memory allocation failure"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:2253
msgid "Decode struct opaque_auth (RFC5531 S8.2)"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:2256
msgid "``u32 *flavor``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:2255
msgid "location to store decoded flavor"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:2257
msgid "``void **body``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:2256
msgid "location to store decode body"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:2258
msgid "``unsigned int *body_len``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:2257
msgid "location to store length of decoded body"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:2259
msgid ""
"On success, returns the number of buffer bytes consumed ``-EBADMSG`` on XDR "
"buffer overflow ``-EMSGSIZE`` if the decoded size of the body field exceeds "
"400 octets"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:2281
msgid "Encode struct opaque_auth (RFC5531 S8.2)"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:2284
msgid "``u32 flavor``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:2283
msgid "verifier flavor to encode"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:2285
msgid "``void *body``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:2284
msgid "content of body to encode"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:2286
msgid "``unsigned int body_len``"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:2285
msgid "length of body to encode"
msgstr ""

#: ../../../networking/kapi:59: net/sunrpc/xdr.c:2287
msgid ""
"On success, returns length in bytes of XDR buffer consumed ``-EBADMSG`` on "
"XDR buffer overflow ``-EMSGSIZE`` if the size of **body** exceeds 400 octets"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:78
msgid "Register a server-side RPC transport class"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:84
#: net/sunrpc/svc_xprt.c:110
msgid "``struct svc_xprt_class *xcl``"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:79
msgid "New transport class to be registered"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:80
msgid "Returns zero on success; otherwise a negative errno is returned."
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:104
msgid "Unregister a server-side RPC transport class"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:105
msgid "Transport class to be unregistered"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:152
msgid "Close a transport"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:158
#: net/sunrpc/svc_xprt.c:221 net/sunrpc/svc_xprt.c:475
#: net/sunrpc/svc_xprt.c:1059
msgid "``struct svc_xprt *xprt``"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:153
#: ../../../networking/kapi:65: net/sunrpc/xprt.c:960 net/sunrpc/xprt.c:976
msgid "transport instance"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:154
msgid ""
"Used in contexts that need to defer the work of shutting down the transport "
"to an nfsd thread."
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:215
msgid "start next receiver thread"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:216
msgid "controlling transport"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:217
msgid ""
"The caller must hold the XPT_BUSY bit and must not thereafter touch "
"transport data."
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:221
msgid ""
"XPT_DATA only gets cleared when a read-attempt finds no (or insufficient) "
"data."
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:290
msgid "Add a new listener to **serv** from socket address"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:296
#: net/sunrpc/svc_xprt.c:338 net/sunrpc/svc_xprt.c:583
#: net/sunrpc/svc_xprt.c:1121 net/sunrpc/svc_xprt.c:1281
#: net/sunrpc/svc_xprt.c:1315 net/sunrpc/svc_xprt.c:1374
msgid "``struct svc_serv *serv``"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:291
#: net/sunrpc/svc_xprt.c:333
msgid "target RPC service"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:293
#: net/sunrpc/svc_xprt.c:335
msgid "``const char *xprt_name``"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:292
#: net/sunrpc/svc_xprt.c:334
msgid "transport class name"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:293
#: net/sunrpc/svc_xprt.c:335 ../../../networking/kapi:92: net/core/dev.c:2065
#: net/core/dev.c:2093
msgid "network namespace"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:295
msgid "``struct sockaddr *sap``"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:294
msgid "socket address pointer"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:295
#: net/sunrpc/svc_xprt.c:338
msgid "SVC_SOCK flags"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:297
#: net/sunrpc/svc_xprt.c:340
msgid "``const struct cred *cred``"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:296
#: net/sunrpc/svc_xprt.c:339
msgid "credential to bind to this transport"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:297
#: net/sunrpc/svc_xprt.c:340
msgid "Return local xprt port on success or ``-EPROTONOSUPPORT`` on failure"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:332
msgid "Add a new listener to **serv**"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:337
msgid "``const int family``"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:338
#: net/sunrpc/svc_xprt.c:1315
msgid "``const unsigned short port``"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:337
msgid "listener port"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:397
msgid "Format rq_addr field for printing"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:403
#: net/sunrpc/svc_xprt.c:518 net/sunrpc/svc_xprt.c:842
msgid "``struct svc_rqst *rqstp``"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:398
msgid "svc_rqst struct containing address to print"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:400
#: net/sunrpc/svc_xprt.c:1371
msgid "``char *buf``"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:399
msgid "target buffer for formatted address"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:400
#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1381
msgid "length of target buffer"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:469
msgid "Queue a transport on an idle nfsd thread"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:470
msgid "transport with data pending"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:512
msgid "change the space reserved for the reply to a request."
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:513
msgid "The request in question"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:515
msgid "``int space``"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:514
msgid "new max space to reserve"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:515
msgid ""
"Each request reserves some space on the output queue of the transport to "
"make sure the reply fits.  This function reduces that reserved space to be "
"the amount of space used already, plus **space**."
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:577
msgid "Wake up a service thread for non-transport work"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:578
msgid "RPC service"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:579
msgid ""
"Some svc_serv's will have occasional work to do, even when a xprt is not "
"waiting to be serviced. This function is there to \"kick\" a task in one of "
"those services so that it can wake up and do that work. Note that we only "
"bother with pool 0 as we don't need to wake up more than one thread for this "
"purpose."
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:836
msgid "Receive and process the next request on any transport"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:837
msgid "an idle RPC service thread"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:838
msgid ""
"This code is carefully organised not to touch any cachelines in the shared "
"svc_serv structure, only cachelines in the local svc_pool."
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1053
msgid "Close a client connection"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1054
#: ../../../networking/kapi:65: net/sunrpc/xprt.c:785
msgid "transport to disconnect"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1115
msgid "Destroy transports associated with **serv**"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1116
msgid "RPC service to be shut down"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1117
msgid "target network namespace"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1119
msgid "``bool unregister``"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1118
msgid "true if it is OK to unregister the destroyed xprts"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1119
msgid ""
"Server threads may still be running (especially in the case where the "
"service is still running in other network namespaces)."
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1122
msgid ""
"So we shut down sockets the same way we would on a running server, by "
"setting XPT_CLOSE, enqueuing, and letting a thread pick it up to do the "
"close.  In the case there are no such other threads, threads running, "
"svc_clean_up_xprts() does a simple version of a server's main event loop, "
"and in the case where there are other threads, we may need to wait a little "
"while and then check again to see if they're done."
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1275
#: net/sunrpc/svc_xprt.c:1309
msgid "find an RPC transport instance"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1276
#: net/sunrpc/svc_xprt.c:1310
msgid "pointer to svc_serv to search"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1278
#: net/sunrpc/svc_xprt.c:1312
msgid "``const char *xcl_name``"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1277
#: net/sunrpc/svc_xprt.c:1311
msgid "C string containing transport's class name"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1278
#: net/sunrpc/svc_xprt.c:1312
msgid "owner net pointer"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1280
msgid "``const struct sockaddr *sa``"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1279
msgid "sockaddr containing address"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1280
msgid ""
"Return the transport instance pointer for the endpoint accepting connections/"
"peer traffic from the specified transport class, and matching sockaddr."
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1314
msgid "``const sa_family_t af``"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1313
msgid "Address family of transport's local address"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1314
msgid "transport's IP port number"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1315
msgid ""
"Return the transport instance pointer for the endpoint accepting connections/"
"peer traffic from the specified transport class, address family and port."
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1319
msgid ""
"Specifying 0 for the address family or port is effectively a wild-card, and "
"will result in matching the first transport in the service's list that has a "
"matching class name."
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1368
msgid "format a buffer with a list of transport names"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1369
msgid "pointer to an RPC service"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1370
msgid "pointer to a buffer to be filled in"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1372
msgid "``const int buflen``"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1371
msgid "length of buffer to be filled in"
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1372
msgid ""
"Fills in **buf** with a string containing a list of transport names, each "
"name terminated with '\\n'."
msgstr ""

#: ../../../networking/kapi:62: net/sunrpc/svc_xprt.c:1375
msgid ""
"Returns positive length of the filled-in string on success; otherwise a "
"negative errno value is returned if an error occurs."
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:91
msgid "register a transport implementation"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:97 net/sunrpc/xprt.c:133
msgid "``struct xprt_class *transport``"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:92
msgid "transport to register"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:93
msgid ""
"If a transport implementation is loaded as a kernel module, it can call this "
"interface to make itself known to the RPC client."
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:97
msgid ""
"0:           transport successfully registered -EEXIST:     transport "
"already registered -EINVAL:     transport module being unloaded"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:127
msgid "unregister a transport implementation"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:128
msgid "transport to unregister"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:130
msgid ""
"0:           transport successfully unregistered -ENOENT:     transport "
"never registered"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:226
msgid "convert a netid into a transport identifier"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:232
msgid "``const char *netid``"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:227
msgid "transport to load"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:229
msgid ""
"> 0:         transport identifier -ENOENT:     transport module not available"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:257
msgid "serialize write access to transports"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:263 net/sunrpc/xprt.c:419
#: net/sunrpc/xprt.c:436 net/sunrpc/xprt.c:498 net/sunrpc/xprt.c:553
#: net/sunrpc/xprt.c:593 net/sunrpc/xprt.c:608 net/sunrpc/xprt.c:634
#: net/sunrpc/xprt.c:758 net/sunrpc/xprt.c:790 net/sunrpc/xprt.c:981
#: net/sunrpc/xprt.c:1066 net/sunrpc/xprt.c:2165 net/sunrpc/xprt.c:2178
#: ../../../networking/kapi:83: net/sunrpc/clnt.c:2958 net/sunrpc/clnt.c:3040
msgid "``struct rpc_xprt *xprt``"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:259
msgid "pointer to the target transport"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:261 net/sunrpc/xprt.c:416
#: net/sunrpc/xprt.c:433 net/sunrpc/xprt.c:519 net/sunrpc/xprt.c:550
#: net/sunrpc/xprt.c:1196 net/sunrpc/xprt.c:1217 net/sunrpc/xprt.c:1259
#: net/sunrpc/xprt.c:1277 ../../../networking/kapi:80:
#: net/sunrpc/rpcb_clnt.c:669
msgid "``struct rpc_task *task``"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:258
msgid "task that is requesting access to the transport"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:260
msgid ""
"This prevents mixing the payload of separate requests, and prevents "
"transport connects from colliding with writes.  No congestion control is "
"provided."
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:413 net/sunrpc/xprt.c:430
msgid "allow other requests to use a transport"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:414 net/sunrpc/xprt.c:431
msgid "transport with other tasks potentially waiting"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:415 net/sunrpc/xprt.c:432
msgid "task that is releasing access to the transport"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:416
msgid "Note that \"task\" can be NULL.  No congestion control is provided."
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:433
msgid ""
"Note that \"task\" can be NULL.  Another task is awoken to use the transport "
"if the transport's congestion window allows it."
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:492
msgid "Request congestion control credits"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:493
msgid "pointer to transport"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:495 net/sunrpc/xprt.c:1098
#: net/sunrpc/xprt.c:1111 ../../../networking/kapi:83: net/sunrpc/clnt.c:1357
msgid "``struct rpc_rqst *req``"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:494
msgid "pointer to RPC request"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:495 net/sunrpc/xprt.c:515
msgid "Useful for transports that require congestion control."
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:513
msgid "housekeeping when request is complete"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:514 net/sunrpc/xprt.c:1191
#: net/sunrpc/xprt.c:1212
msgid "RPC request that recently completed"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:547
msgid "adjust transport congestion window"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:548
msgid "pointer to xprt"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:549
msgid "recently completed RPC request used to adjust window"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:551
msgid "``int result``"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:550
msgid "result code of completed RPC request"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:551
msgid ""
"The transport code maintains an estimate on the maximum number of out- "
"standing RPC requests, using a smoothed version of the congestion avoidance "
"implemented in 44BSD. This is basically the Van Jacobson congestion "
"algorithm: If a retransmit occurs, the congestion window is halved; "
"otherwise, it is incremented by 1/cwnd when"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:557
msgid "a reply is received and"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:558
msgid "a full number of requests are outstanding and"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:559
msgid "the congestion window hasn't been updated recently."
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:587
msgid "wake all tasks on a transport's pending queue"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:588 net/sunrpc/xprt.c:629
msgid "transport with waiting tasks"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:590
#: ../../../networking/kapi:68: net/sunrpc/sched.c:756
msgid "``int status``"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:589
msgid "result code to plant in each task before waking it"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:602
msgid "wait for transport output buffer to clear"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:603
msgid "transport"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:604
msgid ""
"Note that we only set the timer for the case of RPC_IS_SOFT(), since we "
"don't in general want to force a socket disconnection due to an incomplete "
"RPC call transmission."
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:628
msgid "wake the task waiting for transport output buffer space"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:630
msgid "Can be called in a soft IRQ context, so xprt_write_space never sleeps."
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:752
msgid "mark a transport as disconnected"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:753
msgid "transport to flag for disconnect"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:784
msgid "force a transport to disconnect"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:959
msgid "compute the wait before scheduling a connect"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:965
msgid "``const struct rpc_xprt *xprt``"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:975
msgid "compute the new re-establish timeout"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:978
msgid "``unsigned long init_to``"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:977
msgid "initial reestablish timeout"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:1060
msgid "find an RPC request corresponding to an XID"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:1061
msgid "transport on which the original request was transmitted"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:1063
msgid "``__be32 xid``"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:1062
msgid "RPC XID of incoming reply"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:1063 net/sunrpc/xprt.c:1192
#: net/sunrpc/xprt.c:1214
msgid "Caller holds xprt->queue_lock."
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:1092
msgid "Pin a request on the transport receive list"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:1093 net/sunrpc/xprt.c:1106
msgid "Request to pin"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:1094
msgid ""
"Caller must ensure this is atomic with the call to xprt_lookup_rqst() so "
"should be holding xprt->queue_lock."
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:1105
msgid "Unpin a request on the transport receive list"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:1107
msgid "Caller should be holding xprt->queue_lock."
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:1190
msgid "Update RPC RTT statistics"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:1211
msgid "called when reply processing is complete"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:1214
msgid "``int copied``"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:1213
msgid "actual number of bytes received from the transport"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:1253
msgid "wait for reply"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:1254 net/sunrpc/xprt.c:1272
msgid "pointer to rpc_task"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:1255
msgid ""
"Set a request's retransmit timeout based on the transport's default timeout "
"parameters.  Used by transports that don't adjust the retransmit timeout "
"based on round-trip time estimation, and put the task to sleep on the "
"pending queue."
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:1271
msgid "wait for reply using RTT estimator"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:1273
msgid ""
"Set a request's retransmit timeout using the RTT estimator, and put the task "
"to sleep on the pending queue."
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:2159
msgid "return a reference to an RPC transport."
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:2160 net/sunrpc/xprt.c:2173
msgid "pointer to the transport"
msgstr ""

#: ../../../networking/kapi:65: net/sunrpc/xprt.c:2172
msgid "release a reference to an RPC transport."
msgstr ""

#: ../../../networking/kapi:68: net/sunrpc/sched.c:722
msgid "wake up all rpc_tasks"
msgstr ""

#: ../../../networking/kapi:68: net/sunrpc/sched.c:728 net/sunrpc/sched.c:759
msgid "``struct rpc_wait_queue *queue``"
msgstr ""

#: ../../../networking/kapi:68: net/sunrpc/sched.c:723 net/sunrpc/sched.c:754
msgid "rpc_wait_queue on which the tasks are sleeping"
msgstr ""

#: ../../../networking/kapi:68: net/sunrpc/sched.c:724 net/sunrpc/sched.c:756
msgid "Grabs queue->lock"
msgstr ""

#: ../../../networking/kapi:68: net/sunrpc/sched.c:753
msgid "wake up all rpc_tasks and set their status value."
msgstr ""

#: ../../../networking/kapi:68: net/sunrpc/sched.c:755
msgid "status value to set"
msgstr ""

#: ../../../networking/kapi:74: net/sunrpc/stats.c:120
msgid "allocate an rpc_iostats structure"
msgstr ""

#: ../../../networking/kapi:74: net/sunrpc/stats.c:126
#: ../../../networking/kapi:83: net/sunrpc/clnt.c:673 net/sunrpc/clnt.c:694
#: net/sunrpc/clnt.c:717 net/sunrpc/clnt.c:840 net/sunrpc/clnt.c:899
#: net/sunrpc/clnt.c:1254 net/sunrpc/clnt.c:1287 net/sunrpc/clnt.c:1384
#: net/sunrpc/clnt.c:1410 net/sunrpc/clnt.c:1541 net/sunrpc/clnt.c:1596
#: net/sunrpc/clnt.c:1612 net/sunrpc/clnt.c:1632 net/sunrpc/clnt.c:1662
#: net/sunrpc/clnt.c:2960 net/sunrpc/clnt.c:3032 net/sunrpc/clnt.c:3080
msgid "``struct rpc_clnt *clnt``"
msgstr ""

#: ../../../networking/kapi:74: net/sunrpc/stats.c:121
msgid "RPC program, version, and xprt"
msgstr ""

#: ../../../networking/kapi:74: net/sunrpc/stats.c:139
msgid "release an rpc_iostats structure"
msgstr ""

#: ../../../networking/kapi:74: net/sunrpc/stats.c:145 net/sunrpc/stats.c:197
msgid "``struct rpc_iostats *stats``"
msgstr ""

#: ../../../networking/kapi:74: net/sunrpc/stats.c:140
msgid "doomed rpc_iostats structure"
msgstr ""

#: ../../../networking/kapi:74: net/sunrpc/stats.c:150 net/sunrpc/stats.c:194
msgid "tally up per-task stats"
msgstr ""

#: ../../../networking/kapi:74: net/sunrpc/stats.c:156 net/sunrpc/stats.c:200
msgid "``const struct rpc_task *task``"
msgstr ""

#: ../../../networking/kapi:74: net/sunrpc/stats.c:151 net/sunrpc/stats.c:195
msgid "completed rpc_task"
msgstr ""

#: ../../../networking/kapi:74: net/sunrpc/stats.c:153
msgid "``struct rpc_iostats *op_metrics``"
msgstr ""

#: ../../../networking/kapi:74: net/sunrpc/stats.c:152
msgid "stat structure for OP that will accumulate stats from **task**"
msgstr ""

#: ../../../networking/kapi:74: net/sunrpc/stats.c:196
msgid "array of stat structures"
msgstr ""

#: ../../../networking/kapi:74: net/sunrpc/stats.c:197
msgid "Uses the statidx from **task**"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:125
msgid "queue an upcall message to userspace"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:131
#: net/sunrpc/rpc_pipe.c:625 net/sunrpc/rpc_pipe.c:691
msgid "``struct rpc_pipe *pipe``"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:126
msgid "upcall pipe on which to queue given message"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:128
msgid "``struct rpc_pipe_msg *msg``"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:127
msgid "message to queue"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:128
msgid ""
"Call with an **inode** created by rpc_mkpipe() to queue an upcall. A "
"userspace process may then later read the upcall by performing a read on an "
"open file for this inode.  It is up to the caller to initialize the fields "
"of **msg** (other than **msg->list**) appropriately."
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:619
msgid "make an rpc_pipefs file for kernel<->userspace communication"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:625
msgid "``struct dentry *parent``"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:621
msgid "dentry of directory to create new \"pipe\" in"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:623
#: ../../../networking/kapi:92: net/core/dev.c:852 net/core/dev.c:873
#: net/core/dev.c:907 net/core/dev.c:1304 net/core/dev.c:1417
#: net/core/dev.c:11868
msgid "``const char *name``"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:622
msgid "name of pipe"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:624
msgid "``void *private``"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:623
msgid "private data to associate with the pipe, for the caller's use"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:624
msgid ":c:type:`rpc_pipe` containing input parameters"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:625
msgid ""
"Data is made available for userspace to read by calls to "
"rpc_queue_upcall().  The actual reads will result in calls to **ops-"
">upcall**, which will be called with the file pointer, message, and "
"userspace buffer to copy to."
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:630
msgid ""
"Writes can come at any time, and do not necessarily have to be responses to "
"upcalls.  They will result in calls to **msg->downcall**."
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:633
msgid ""
"The **private** argument passed here will be available to all these methods "
"from the file pointer, via RPC_I(file_inode(file))->private."
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:685
msgid "remove a pipe"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:686
msgid "the pipe to be removed"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:687
msgid ""
"After this call, lookups will no longer find the pipe, and any attempts to "
"read or write using preexisting opens of the pipe will return -EPIPE."
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:703
msgid "initialise a struct rpc_pipe_dir_head"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:709
#: net/sunrpc/rpc_pipe.c:757 net/sunrpc/rpc_pipe.c:782
#: net/sunrpc/rpc_pipe.c:804
msgid "``struct rpc_pipe_dir_head *pdh``"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:704
#: net/sunrpc/rpc_pipe.c:756 net/sunrpc/rpc_pipe.c:781
#: net/sunrpc/rpc_pipe.c:803
msgid "pointer to struct rpc_pipe_dir_head"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:714
msgid "initialise a struct rpc_pipe_dir_object"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:720
#: net/sunrpc/rpc_pipe.c:758 net/sunrpc/rpc_pipe.c:783
msgid "``struct rpc_pipe_dir_object *pdo``"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:715
#: net/sunrpc/rpc_pipe.c:757 net/sunrpc/rpc_pipe.c:782
msgid "pointer to struct rpc_pipe_dir_object"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:717
msgid "``const struct rpc_pipe_dir_object_ops *pdo_ops``"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:716
msgid "pointer to const struct rpc_pipe_dir_object_ops"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:718
msgid "``void *pdo_data``"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:717
msgid "pointer to caller-defined data"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:754
msgid "associate a rpc_pipe_dir_object to a directory"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:755
#: net/sunrpc/rpc_pipe.c:780 net/sunrpc/rpc_pipe.c:802
msgid "pointer to struct net"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:779
msgid "remove a rpc_pipe_dir_object from a directory"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:805
msgid "``int (*match)(struct rpc_pipe_dir_object *, void *)``"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:804
msgid "match struct rpc_pipe_dir_object to data"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:806
msgid "``struct rpc_pipe_dir_object *(*alloc)(void *)``"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:805
msgid "allocate a new struct rpc_pipe_dir_object"
msgstr ""

#: ../../../networking/kapi:77: net/sunrpc/rpc_pipe.c:806
msgid "user defined data for match() and alloc()"
msgstr ""

#: ../../../networking/kapi:80: net/sunrpc/rpcb_clnt.c:663
msgid "obtain the port for a given RPC service on a given host"
msgstr ""

#: ../../../networking/kapi:80: net/sunrpc/rpcb_clnt.c:664
msgid "task that is waiting for portmapper request"
msgstr ""

#: ../../../networking/kapi:80: net/sunrpc/rpcb_clnt.c:665
msgid ""
"This one can be called for an ongoing RPC request, and can be used in an "
"async (rpciod) context."
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:511
msgid "create an RPC client and transport with one call"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:517
msgid "``struct rpc_create_args *args``"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:512
msgid "rpc_clnt create argument structure"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:513
msgid "Creates and initializes an RPC transport and an RPC client."
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:515
msgid ""
"It can ping the server in order to determine if it is up, and to see if it "
"supports this program and version.  RPC_CLNT_CREATE_NOPING disables this "
"behavior so asynchronous tasks can also use rpc_create."
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:667
msgid "Clone an RPC client structure"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:669 net/sunrpc/clnt.c:690
msgid "RPC client whose parameters are copied"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:670 net/sunrpc/clnt.c:692
msgid "Returns a fresh RPC client or an ERR_PTR."
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:688
msgid "Clone an RPC client structure and set its auth"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:692
msgid "``rpc_authflavor_t flavor``"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:691
msgid "security flavor for new client"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:711
msgid "switch the RPC transport on the fly"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:712
msgid "pointer to a struct rpc_clnt"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:714
msgid "``struct xprt_create *args``"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:713
msgid "pointer to the new transport arguments"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:715
msgid "``const struct rpc_timeout *timeout``"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:714
msgid "pointer to the new timeout parameters"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:715
msgid ""
"This function allows the caller to switch the RPC transport for the rpc_clnt "
"structure 'clnt' to allow it to connect to a mirrored NFS server, for "
"instance.  It assumes that the caller has ensured that there are no active "
"RPC tasks by using some form of locking."
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:720
msgid ""
"Returns zero if \"clnt\" is now using the new xprt.  Otherwise a negative "
"errno is returned, and \"clnt\" continues to use the old xprt."
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:834
msgid "Apply a function to all transports"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:835
msgid "pointer to client"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:837
msgid "``int (*fn)(struct rpc_clnt *, struct rpc_xprt *, void *)``"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:836
msgid "function to apply"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:837
msgid "void pointer to function data"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:838
msgid ""
"Iterates through the list of RPC transports currently attached to the client "
"and applies the function fn(clnt, xprt, data)."
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:841
msgid ""
"On error, the iteration stops, and the function returns the error value."
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:893
msgid "try to cancel a set of RPC tasks"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:894
msgid "Pointer to RPC client"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:896
msgid "``int error``"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:895
msgid "RPC task error value to set"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:897
msgid "``bool (*fnmatch)(const struct rpc_task *, const void *)``"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:896
msgid "Pointer to selector function"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:898
#: ../../../networking/kapi:95: net/ethernet/eth.c:120
msgid "``const void *data``"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:897
msgid "User data"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:898
msgid ""
"Uses **fnmatch** to define a set of RPC tasks that are to be cancelled. The "
"argument **error** must be a negative error value."
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1046
msgid "bind a new RPC program to an existing client"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1052
msgid "``struct rpc_clnt *old``"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1047
msgid "old rpc_client"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1049
msgid "``const struct rpc_program *program``"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1048
msgid "rpc program to set"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1050
msgid "``u32 vers``"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1049
msgid "rpc program version"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1050
msgid ""
"Clones the rpc client and sets up a new RPC program. This is mainly of use "
"for enabling different RPC programs to share the same transport. The Sun "
"NFSv2/v3 ACL protocol can do this."
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1221
msgid "Allocate a new RPC task, then run rpc_execute against it"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1227
msgid "``const struct rpc_task_setup *task_setup_data``"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1222
msgid "pointer to task initialisation data"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1248
msgid "Perform a synchronous RPC call"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1249 net/sunrpc/clnt.c:1282
msgid "pointer to RPC client"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1251 net/sunrpc/clnt.c:1284
msgid "``const struct rpc_message *msg``"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1250 net/sunrpc/clnt.c:1283
msgid "RPC call parameters"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1251 net/sunrpc/clnt.c:1284
msgid "RPC call flags"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1281
msgid "Perform an asynchronous RPC call"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1286
msgid "``const struct rpc_call_ops *tk_ops``"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1285
msgid "RPC call ops"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1286
msgid "user call data"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1351
msgid "Prepare to receive a reply data payload into pages"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1352
msgid "RPC request to prepare"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1357
msgid "``unsigned int hdrsize``"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1356
msgid "expected size of upper layer reply header, in XDR words"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1378
msgid "extract remote peer address from clnt's xprt"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1379 net/sunrpc/clnt.c:1405
#: net/sunrpc/clnt.c:1536
msgid "RPC client structure"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1381 net/sunrpc/clnt.c:1538
msgid "``struct sockaddr *buf``"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1380 net/sunrpc/clnt.c:1537
msgid "target buffer"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1382
msgid "``size_t bufsize``"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1382
msgid "Returns the number of bytes that are actually in the stored address."
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1404
msgid "return remote peer address in printable format"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1407
msgid "``enum rpc_display_format_t format``"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1406
msgid "address format"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1407
msgid ""
"NB: the lifetime of the memory referenced by the returned pointer is the "
"same as the rpc_xprt itself.  As long as the caller uses this pointer, it "
"must hold the RCU read lock."
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1535
msgid "discover local endpoint address for an RPC client"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1539
msgid "``size_t buflen``"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1538
msgid "size of target buffer, in bytes"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1539
msgid ""
"Returns zero and fills in \"buf\" and \"buflen\" if successful; otherwise, a "
"negative errno is returned."
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1542
msgid ""
"This works even if the underlying transport is not currently connected, or "
"if the upper layer never previously provided a source address."
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1545
msgid ""
"The result of this function call is transient: multiple calls in succession "
"may give different results, depending on how local networking configuration "
"changes over time."
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1590
msgid "Get the network namespace for this RPC client"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1591 net/sunrpc/clnt.c:1607
#: net/sunrpc/clnt.c:1627
msgid "RPC client to query"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1606
msgid "Get maximum payload size for a transport, in bytes"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1608
msgid ""
"For stream transports, this is one RPC record fragment (see RFC 1831), as we "
"don't support multi-record requests yet.  For datagram transports, this is "
"the size of an IP packet minus the IP, UDP, and RPC header sizes."
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1626
msgid "Get maximum backchannel payload size, in bytes"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1656
msgid "force transport to check that remote port is unchanged"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:1657
msgid "client to rebind"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:2954
msgid "Test and add a new transport to a rpc_clnt"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:2955 net/sunrpc/clnt.c:3075
msgid "pointer to struct rpc_clnt"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:2957 net/sunrpc/clnt.c:3039
msgid "``struct rpc_xprt_switch *xps``"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:2956
msgid "pointer to struct rpc_xprt_switch,"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:2957
msgid "pointer struct rpc_xprt"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:2959
msgid "``void *in_max_connect``"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:2958
msgid "pointer to the max_connect value for the passed in xprt transport"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:3037
msgid "struct rpc_clnt to get the new transport"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:3038
msgid "the rpc_xprt_switch to hold the new transport"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:3039
msgid "the rpc_xprt to test"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:3040
msgid ""
"a struct rpc_add_xprt_test pointer that holds the test function and test "
"function call data"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:3027
msgid "This is an rpc_clnt_add_xprt setup() function which returns 1 so:"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:3028
msgid ""
"1) caller of the test function must dereference the rpc_xprt_switch and the "
"rpc_xprt. 2) test function must call rpc_xprt_switch_add_xprt, usually in "
"the rpc_call_done routine."
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:3033
msgid ""
"Upon success (return of 1), the test function adds the new transport to the "
"rpc_clnt xprt switch"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:3074
msgid "Add a new transport to a rpc_clnt"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:3077
msgid "``struct xprt_create *xprtargs``"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:3076
msgid "pointer to struct xprt_create"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:3078
msgid ""
"``int (*setup)(struct rpc_clnt *, struct rpc_xprt_switch *, struct rpc_xprt "
"*, void *)``"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:3077
msgid "callback to test and/or set up the connection"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:3078
msgid "pointer to setup function data"
msgstr ""

#: ../../../networking/kapi:83: net/sunrpc/clnt.c:3079
msgid ""
"Creates a new transport using the parameters set in args and adds it to "
"clnt. If ping is set, then test that connectivity succeeds before adding the "
"new transport."
msgstr ""

#: ../../../networking/kapi.rst:87
msgid "Network device support"
msgstr ""

#: ../../../networking/kapi.rst:90
msgid "Driver Support"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:593
msgid "add packet handler"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:599 net/core/dev.c:625
#: net/core/dev.c:661
msgid "``struct packet_type *pt``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:594 net/core/dev.c:620
#: net/core/dev.c:656
msgid "packet type declaration"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:595
msgid ""
"Add a protocol handler to the networking stack. The passed :c:type:"
"`packet_type` is linked into kernel lists and may not be freed until it has "
"been removed from the kernel lists."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:599
msgid ""
"This call does not sleep therefore it can not guarantee all CPU's that are "
"in middle of receiving packets will see the new packet type (until the next "
"received packet)."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:619 net/core/dev.c:655
msgid "remove packet handler"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:621 net/core/dev.c:657
msgid ""
"Remove a protocol handler that was previously added to the kernel protocol "
"handlers by dev_add_pack(). The passed :c:type:`packet_type` is removed from "
"the kernel lists and can be freed or reused once this function returns."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:626
msgid ""
"The packet type might still be in use by receivers and must not be freed "
"until after all the CPU's have gone through a quiescent state."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:662
msgid ""
"This call sleeps to guarantee that no CPU is looking at the packet type "
"after return."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:682
msgid "get 'iflink' value of a interface"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:535
#: include/linux/etherdevice.h:618 ../../../networking/kapi:104:
#: include/linux/netdevice.h:2744 include/linux/netdevice.h:3663
#: include/linux/netdevice.h:3887 include/linux/netdevice.h:3930
#: include/linux/netdevice.h:3975 include/linux/netdevice.h:3990
#: include/linux/netdevice.h:4124 include/linux/netdevice.h:4485
#: include/linux/netdevice.h:4534 include/linux/netdevice.h:4574
#: include/linux/netdevice.h:4586 include/linux/netdevice.h:4600
#: ../../../networking/kapi:92: net/core/dev.c:688 net/core/dev.c:2513
#: net/core/dev.c:9575 ../../../networking/kapi:95: net/ethernet/eth.c:123
#: net/ethernet/eth.c:245
msgid "``const struct net_device *dev``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:683 net/core/dev.c:700
msgid "targeted interface"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:684
msgid ""
"Indicates the ifindex the interface is linked to. Physical interfaces have "
"the same 'ifindex' and 'iflink' values."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:699
msgid "Retrieve tunnel egress information."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:701
msgid "The packet."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:702
msgid ""
"For better visibility of tunnel traffic OVS needs to retrieve egress tunnel "
"information for a packet. Following API allows user to get this info."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:849 net/core/dev.c:870
#: net/core/dev.c:904
msgid "find a device by its name"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:851 net/core/dev.c:872
#: net/core/dev.c:906
msgid "name to find"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:852
msgid ""
"Find an interface by name. Must be called under RTNL semaphore. If the name "
"is found a pointer to the device is returned. If the name is not found then "
"``NULL`` is returned. The reference counters are not incremented so the "
"caller must be careful with locks."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:873
msgid ""
"Find an interface by name. If the name is found a pointer to the device is "
"returned. If the name is not found then ``NULL`` is returned. The reference "
"counters are not incremented so the caller must be careful with locks. The "
"caller must hold RCU lock."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:908 net/core/dev.c:994
msgid "``netdevice_tracker *tracker``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:907 net/core/dev.c:993
msgid "tracking object for the acquired reference"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:908 net/core/dev.c:994
msgid "allocation flags for the tracker"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:909
msgid ""
"Find an interface by name. This can be called from any context and does its "
"own locking. The returned handle has the usage count incremented and the "
"caller must use netdev_put() to release it when it is no longer needed. "
"``NULL`` is returned if no matching device is found."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:929 net/core/dev.c:953
#: net/core/dev.c:990
msgid "find a device by its ifindex"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:932 net/core/dev.c:956
#: net/core/dev.c:993
msgid "``int ifindex``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:931 net/core/dev.c:955
#: net/core/dev.c:992
msgid "index of device"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:932
msgid ""
"Search for an interface by index. Returns ``NULL`` if the device is not "
"found or a pointer to the device. The device has not had its reference "
"counter increased so the caller must be careful about locking. The caller "
"must hold the RTNL semaphore."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:956
msgid ""
"Search for an interface by index. Returns ``NULL`` if the device is not "
"found or a pointer to the device. The device has not had its reference "
"counter increased so the caller must be careful about locking. The caller "
"must hold RCU lock."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:995
msgid ""
"Search for an interface by index. Returns NULL if the device is not found or "
"a pointer to the device. The device returned has had a reference added and "
"the pointer is safe until the user calls netdev_put() to indicate they have "
"finished with it."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1201 net/core/dev.c:1228
msgid "find a device by its hardware address"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1204 net/core/dev.c:1231
#: ../../../networking/kapi:95: net/ethernet/eth.c:71
msgid "``unsigned short type``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1203 net/core/dev.c:1230
msgid "media type of device"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1205 net/core/dev.c:1232
msgid "``const char *ha``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1204 net/core/dev.c:1231
msgid "hardware address"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1205
msgid ""
"Search for an interface by MAC address. Returns NULL if the device is not "
"found or a pointer to the device. The caller must hold RCU. The returned "
"device has not had its ref count increased and the caller must therefore be "
"careful about locking"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1232
msgid ""
"Similar to dev_getbyhwaddr_rcu(), but the owner needs to hold rtnl_lock."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1236
msgid "rtnl_lock() must be held."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1237
msgid "pointer to the net_device, or NULL if not found"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1298
msgid "check if name is okay for network device"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1299
msgid "name string"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1300
msgid ""
"Network device names need to be valid file names to allow sysfs to work.  We "
"also disallow any kind of whitespace."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1414
msgid "allocate a name for a device"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1415 net/core/dev.c:7855
#: net/core/dev.c:7878 net/core/dev.c:7900 net/core/dev.c:7915
#: net/core/dev.c:7979 net/core/dev.c:8150 net/core/dev.c:8178
#: net/core/dev.c:8205 net/core/dev.c:8496 net/core/dev.c:8515
#: net/core/dev.c:8790 net/core/dev.c:8815 net/core/dev.c:8876
#: net/core/dev.c:8990 net/core/dev.c:9248 net/core/dev.c:9281
#: net/core/dev.c:9395 net/core/dev.c:9570 net/core/dev.c:9836
#: net/core/dev.c:12029 net/core/dev.c:12140 net/core/dev.c:12353
msgid "device"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1416
msgid "name format string"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1417
msgid ""
"Passed a format string - eg \"lt``d``\" it will try and find a suitable id. "
"It scans list of devices to build up a free map, then chooses the first "
"empty slot. The caller must hold the dev_base or rtnl lock while allocating "
"the name and adding the device in order to avoid duplicates. Limited to "
"bits_per_byte * page size devices (ie 32K on most platforms). Returns the "
"number of the unit assigned or a negative errno code."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1563
msgid "device changes features"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1564
msgid "device to cause notification"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1565
msgid "Called to indicate a device has changed features."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1590
msgid ""
"notify network peers about existence of **dev**, to be called when rtnl lock "
"is already held."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2739
#: include/linux/netdevice.h:2804 include/linux/netdevice.h:2846
#: include/linux/netdevice.h:2862 include/linux/netdevice.h:3582
#: include/linux/netdevice.h:3605 include/linux/netdevice.h:3639
#: include/linux/netdevice.h:3658 include/linux/netdevice.h:3802
#: include/linux/netdevice.h:3858 include/linux/netdevice.h:3882
#: include/linux/netdevice.h:3893 include/linux/netdevice.h:3905
#: include/linux/netdevice.h:3925 include/linux/netdevice.h:3943
#: include/linux/netdevice.h:3957 include/linux/netdevice.h:3970
#: include/linux/netdevice.h:3985 include/linux/netdevice.h:3998
#: include/linux/netdevice.h:4119 include/linux/netdevice.h:4419
#: include/linux/netdevice.h:4431 include/linux/netdevice.h:4480
#: include/linux/netdevice.h:4499 include/linux/netdevice.h:4517
#: include/linux/netdevice.h:4529 include/linux/netdevice.h:4541
#: include/linux/netdevice.h:4557 include/linux/netdevice.h:4569
#: include/linux/netdevice.h:4581 include/linux/netdevice.h:4595
#: include/linux/netdevice.h:4761 ../../../networking/kapi:92:
#: net/core/dev.c:1592 net/core/dev.c:1610 net/core/dev.c:3449
#: net/core/dev.c:3464 net/core/dev.c:9966 ../../../networking/kapi:95:
#: net/ethernet/eth.c:244 net/ethernet/eth.c:272 net/ethernet/eth.c:289
#: net/ethernet/eth.c:302 net/ethernet/eth.c:341 ../../../networking/kapi:98:
#: net/sched/sch_generic.c:578 net/sched/sch_generic.c:597
#: net/sched/sch_generic.c:614
msgid "network device"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1593 net/core/dev.c:1611
msgid ""
"Generate traffic such that interested network peers are aware of **dev**, "
"such as by generating a gratuitous ARP. This may be used when a device wants "
"to inform the rest of the network about some sort of reconfiguration such as "
"a failover event or virtual machine migration."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1609
msgid "notify network peers about existence of **dev**"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1934
msgid "register a network notifier block"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1940 net/core/dev.c:1995
#: net/core/dev.c:2067 net/core/dev.c:2095
msgid "``struct notifier_block *nb``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1935 net/core/dev.c:1990
#: net/core/dev.c:2066 net/core/dev.c:2094
msgid "notifier"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1936 net/core/dev.c:2067
msgid ""
"Register a notifier to be called when network device events occur. The "
"notifier passed is linked into the kernel structures and must not be reused "
"until it has been unregistered. A negative errno code is returned on a "
"failure."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1941 net/core/dev.c:2072
msgid ""
"When registered all registration and up events are replayed to the new "
"notifier to allow device to have a race free view of the network device list."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1989
msgid "unregister a network notifier block"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1991
msgid ""
"Unregister a notifier previously registered by "
"register_netdevice_notifier(). The notifier is unlinked into the kernel "
"structures and may then be reused. A negative errno code is returned on a "
"failure."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:1996 net/core/dev.c:2100
msgid ""
"After unregistering unregister and down device events are synthesized for "
"all devices on the device list to the removed notifier to remove the need "
"for special case cleanup code."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:2064
msgid "register a per-netns network notifier block"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:2091
msgid "unregister a per-netns network notifier block"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:2095
msgid ""
"Unregister a notifier previously registered by "
"register_netdevice_notifier_net(). The notifier is unlinked from the kernel "
"structures and may then be reused. A negative errno code is returned on a "
"failure."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:2271
msgid "call all network notifier blocks"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:2277
msgid "``unsigned long val``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:2272
msgid "value passed unmodified to notifier function"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:2273
msgid "net_device pointer passed unmodified to notifier function"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:2274
msgid ""
"Call all network notifier blocks.  Parameters and return value are as for "
"raw_notifier_call_chain()."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:2437
msgid "loopback an skb to another netif"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:2439
msgid "destination network device"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:2440
msgid "buffer to forward"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:2441
msgid "return values:"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:2442
msgid ""
"NET_RX_SUCCESS  (no congestion) NET_RX_DROP     (packet was dropped, but "
"freed)"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:2445
msgid ""
"dev_forward_skb can be used for injecting an skb from the start_xmit "
"function of one device into the receive queue of another device."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:2449
msgid ""
"The receiving device may be in another namespace, so we have to clear all "
"information in the skb that could impact namespace isolation."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:2507
msgid "return true if any network interface taps are in use"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:2511
msgid "network device to check for the presence of taps"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:2508
msgid "The caller must hold the RCU lock"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3213
msgid "set actual number of RX queues used"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3214 net/core/dev.c:3245
msgid "Network device"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3216 net/core/dev.c:3248
msgid "``unsigned int rxq``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3215 net/core/dev.c:3247
msgid "Actual number of RX queues"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3216
msgid ""
"This must be called either with the rtnl_lock held or before registration of "
"the net device.  Returns 0 on success, or a negative error code.  If called "
"before registration, it always succeeds."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3244
msgid "set actual number of RX and TX queues used"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3247
msgid "``unsigned int txq``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3246
msgid "Actual number of TX queues"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3248
msgid ""
"Set the real number of both TX and RX queues. Does nothing if the number of "
"queues is already correct."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3288
msgid "set the max size of TSO frames supported"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3289 net/core/dev.c:3308
#: net/core/dev.c:3325
msgid "netdev to update"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3290
msgid "max skb->len of a TSO frame"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3291
msgid ""
"Set the limit on the size of TSO super-frames the device can handle. Unless "
"explicitly set the stack will assume the value of ``GSO_LEGACY_MAX_SIZE``."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3307
msgid "set the max number of segs supported for TSO"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3310
msgid "``unsigned int segs``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3309
msgid "max number of TCP segments"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3310
msgid ""
"Set the limit on the number of TCP segments the device can generate from a "
"single TSO super-frame. Unless explicitly set the stack will assume the "
"value of ``GSO_MAX_SEGS``."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3324
msgid "copy all TSO limits from a lower device to an upper"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3330
msgid "``struct net_device *to``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3327
msgid "``const struct net_device *from``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3326
msgid "netdev from which to copy the limits"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3336
msgid "default number of RSS queues"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3337
msgid ""
"Default value is the number of physical cores if there are only 1 or 2, or "
"divided by 2 if there are more."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3448
msgid "mark device as removed"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3450
msgid "Mark device as removed from system and therefore no longer available."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3463
msgid "mark device as attached"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:3465
msgid "Mark device as attached from system and restart if needed."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:4260
msgid "loop back **skb**"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:4261
msgid "network namespace this loopback is happening in"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:4262
msgid "sk needed to be a netfilter okfn"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:4263 net/core/dev.c:4651
msgid "buffer to transmit"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:4650
msgid "transmit a buffer"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:4653
msgid "``struct net_device *sb_dev``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:4652
msgid "suboordinate device used for L2 forwarding offload"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:4653
msgid ""
"Queue a buffer for transmission to a network device. The caller must have "
"set the device and priority and built the buffer before calling this "
"function. The function can be called from an interrupt."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:4657
msgid ""
"When calling this method, interrupts MUST be enabled. This is because the BH "
"enable code must have IRQs enabled so that it will not deadlock."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:4660
msgid ""
"Regardless of the return value, the skb is consumed, so it is currently "
"difficult to retry a send to this method. (You can bump the ref count before "
"sending to hold a reference for retry if you are careful.)"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:4665
msgid "0                          - buffer successfully transmitted"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:4666
msgid "positive qdisc return code - NET_XMIT_DROP etc."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:4667
msgid "negative errno             - other errors"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5091
msgid "check whether an RFS hardware filter may be removed"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5092
msgid "Device on which the filter was set"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5094
msgid "``u16 rxq_index``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5093
msgid "RX queue index"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5095
msgid "``u32 flow_id``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5094
msgid "Flow ID passed to ndo_rx_flow_steer()"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5096
msgid "``u16 filter_id``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5095
msgid "Filter ID returned by ndo_rx_flow_steer()"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5096
msgid ""
"Drivers that implement ndo_rx_flow_steer() should periodically call this "
"function for each installed filter and remove the filters for which it "
"returns ``true``."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5597
msgid "Slightly optimized version of netif_rx"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5598 net/core/dev.c:5619
msgid "buffer to post"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5599
msgid ""
"This behaves as netif_rx except that it does not disable bottom halves. As a "
"result this function may only be invoked from the interrupt context (either "
"hard or soft interrupt)."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5618
msgid "post buffer to the network code"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5620
msgid ""
"This function receives a packet from a device driver and queues it for the "
"upper (protocol) levels to process via the backlog NAPI device. It always "
"succeeds. The buffer may be dropped during processing for congestion control "
"or by the protocol layers. The network buffer is passed via the backlog NAPI "
"device. Modern NIC driver should use NAPI and GRO. This function can used "
"from interrupt and from process context. The caller from process context "
"must not disable interrupts before invoking this function."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5630
msgid ""
"return values: NET_RX_SUCCESS  (no congestion) NET_RX_DROP     (packet was "
"dropped)"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5743
msgid "check if receive handler is registered"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5744
msgid "device to check"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5745
msgid ""
"Check if a receive handler is already registered for a given device. Return "
"true if there one."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5748 net/core/dev.c:5767
#: net/core/dev.c:5795
msgid "The caller must hold the rtnl_mutex."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5759
msgid "register receive handler"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5760
msgid "device to register a handler for"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5762
msgid "``rx_handler_func_t *rx_handler``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5761
msgid "receive handler to register"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5763
msgid "``void *rx_handler_data``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5762
msgid "data pointer that is used by rx handler"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5763
msgid ""
"Register a receive handler for a device. This handler will then be called "
"from __netif_receive_skb. A negative errno code is returned on a failure."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5769
msgid "For a general description of rx_handler, see enum rx_handler_result."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5791
msgid "unregister receive handler"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5792
msgid "device to unregister a handler from"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:5793
msgid "Unregister a receive handler from a device."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:6085
msgid "special purpose version of netif_receive_skb"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:6087
msgid ""
"More direct receive version of netif_receive_skb().  It should only be used "
"by callers that have a need to skip RPS and Generic XDP. Caller must also "
"take care of handling if ``(page_is_)pfmemalloc``."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:6091 net/core/dev.c:6323
#: net/core/dev.c:6350
msgid ""
"This function may only be called from softirq context and interrupts should "
"be enabled."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:6094 net/core/dev.c:6326
msgid ""
"Return values (usually ignored): NET_RX_SUCCESS: no congestion NET_RX_DROP: "
"packet was dropped"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:6317
msgid "process receive buffer from network"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:6319
msgid ""
"netif_receive_skb() is the main receive data processing function. It always "
"succeeds. The buffer may be dropped during processing for congestion control "
"or by the protocol layers."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:6345
msgid "process many receive buffers from network"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:6351 net/core/dev.c:12142
#: net/core/dev.c:12345
msgid "``struct list_head *head``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:6346
msgid "list of skbs to process."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:6347
msgid ""
"Since return value of netif_receive_skb() is normally ignored, and wouldn't "
"be meaningful for a list, this function returns void."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:6582 net/core/dev.c:6631
msgid "schedule for receive"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:525
#: include/linux/netdevice.h:550 include/linux/netdevice.h:570
#: include/linux/netdevice.h:582 include/linux/netdevice.h:626
#: ../../../networking/kapi:92: net/core/dev.c:6588 net/core/dev.c:6605
#: net/core/dev.c:6637 net/core/dev.c:7505 net/core/dev.c:7540
msgid "``struct napi_struct *n``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:6583 net/core/dev.c:6632
msgid "entry to schedule"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:6584
msgid ""
"The entry's receive function will be scheduled to run. Consider using "
"__napi_schedule_irqoff() if hard irqs are masked."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:6599
msgid "check if napi can be scheduled"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:6600
msgid "napi context"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:6601
msgid ""
"Test if NAPI routine is already running, and if not mark it as running.  "
"This is used as a condition variable to insure only one NAPI poll instance "
"runs.  We also make sure there is no pending NAPI disable."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:6633
msgid "Variant of __napi_schedule() assuming hard irqs are masked."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:6635
msgid ""
"On PREEMPT_RT enabled kernels this maps to __napi_schedule() because the "
"interrupt disabled assumption might not be true due to force-threaded "
"interrupts and spinlock substitution."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7132
msgid "enable threaded NAPIs"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7133
msgid "net_device instance"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7134
msgid ""
"Enable threaded mode for the NAPI instances of the device. This may be "
"useful for devices where multiple NAPI instances get scheduled by a single "
"interrupt. Threaded NAPI allows moving the NAPI processing to cores other "
"than the core where IRQ is mapped."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7139
msgid "This function should be called before **dev** is registered."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7149
msgid "Associate queue with the napi"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7150
msgid "device to which NAPI and queue belong"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7152
msgid "``unsigned int queue_index``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7151
msgid "Index of queue"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7153
msgid "``enum netdev_queue_type type``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7152
msgid "queue type as RX or TX"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7153
msgid "NAPI context, pass NULL to clear previously set NAPI"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7154
msgid ""
"Set queue with its corresponding napi context. This should be done after "
"registering the NAPI handler for the queue-vector and the queues have been "
"mapped to the corresponding interrupt vector."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7499
msgid "prevent NAPI from scheduling"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:520
#: include/linux/netdevice.h:545 include/linux/netdevice.h:565
#: include/linux/netdevice.h:577 include/linux/netdevice.h:604
#: include/linux/netdevice.h:622 include/linux/netdevice.h:2805
#: include/linux/netdevice.h:2847 include/linux/netdevice.h:2863
#: include/linux/netdevice.h:2881 include/linux/netdevice.h:2902
#: ../../../networking/kapi:92: net/core/dev.c:7500 net/core/dev.c:7535
msgid "NAPI context"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7501
msgid ""
"Stop NAPI from being scheduled on this context. Waits till any outstanding "
"processing completes. Takes netdev_lock() for associated net_device."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7534
msgid "enable NAPI scheduling"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7536
msgid ""
"Enable scheduling of a NAPI instance. Must be paired with napi_disable(). "
"Takes netdev_lock() for associated net_device."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7854 net/core/dev.c:7877
msgid "Check if device is linked to an upper device"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7857 net/core/dev.c:7880
#: net/core/dev.c:8792 net/core/dev.c:8817 net/core/dev.c:8878
msgid "``struct net_device *upper_dev``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7856 net/core/dev.c:7879
msgid "upper device to check"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7857
msgid ""
"Find out if a device is linked to specified upper device and return true in "
"case it is. Note that this checks only immediate upper device, not through a "
"complete stack of devices. The caller must hold the RTNL lock."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7880
msgid ""
"Find out if a device is linked to specified upper device and return true in "
"case it is. Note that this checks the entire upper device chain. The caller "
"must hold rcu lock."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7899
msgid "Check if device is linked to some device"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7901
msgid ""
"Find out if a device is linked to an upper device and return true in case it "
"is. The caller must hold the RTNL lock."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7914 net/core/dev.c:8514
msgid "Get master upper device"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7916
msgid ""
"Find a master upper device and return pointer to it or NULL in case it's not "
"there. The caller must hold the RTNL lock."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7978
msgid "Get the next dev from upper list"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7981 net/core/dev.c:8152
#: net/core/dev.c:8180 net/core/dev.c:8207
msgid "``struct list_head **iter``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7980 net/core/dev.c:8151
#: net/core/dev.c:8179 net/core/dev.c:8206
msgid "list_head ** of the current position"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:7981
msgid ""
"Gets the next device from the dev's upper list, starting from iter position. "
"The caller must hold RCU read lock."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8148
msgid "Get the next ->private from the lower neighbour list"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8152
msgid ""
"Gets the next netdev_adjacent->private from the dev's lower neighbour list, "
"starting from iter position. The caller must hold either hold the RTNL lock "
"or its own locking that guarantees that the neighbour lower list will remain "
"unchanged."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8175
msgid "Get the next ->private from the lower neighbour list, RCU variant"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8180
msgid ""
"Gets the next netdev_adjacent->private from the dev's lower neighbour list, "
"starting from iter position. The caller must hold RCU read lock."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8203
msgid "Get the next device from the lower neighbour list"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8207
msgid ""
"Gets the next netdev_adjacent from the dev's lower neighbour list, starting "
"from iter position. The caller must hold RTNL lock or its own locking that "
"guarantees that the neighbour lower list will remain unchanged."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8493
msgid "Get the first ->private from the lower neighbour list, RCU variant"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8497
msgid ""
"Gets the first netdev_adjacent->private from the dev's lower neighbour list. "
"The caller must hold RCU read lock."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8516
msgid ""
"Find a master upper device and return pointer to it or NULL in case it's not "
"there. The caller must hold the RCU read lock."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8789
msgid "Add a link to the upper device"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8791 net/core/dev.c:8816
#: net/core/dev.c:8877
msgid "new upper device"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:843
#: drivers/net/phy/phy.c:912 ../../../networking/kapi:116:
#: drivers/net/phy/phy.c:488 drivers/net/phy/phy.c:682
#: drivers/net/phy/phy.c:711 ../../../networking/kapi:161:
#: drivers/net/phy/sfp-bus.c:517 ../../../networking/kapi:92:
#: net/core/dev.c:8793 net/core/dev.c:8820 net/core/dev.c:9839
msgid "``struct netlink_ext_ack *extack``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8792 net/core/dev.c:8819
#: net/core/dev.c:9838
msgid "netlink extended ack"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8793
msgid ""
"Adds a link to device which is upper to this one. The caller must hold the "
"RTNL lock. On a failure a negative errno code is returned. On success the "
"reference counts are adjusted and the function returns zero."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8814
msgid "Add a master link to the upper device"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8818
msgid "``void *upper_priv``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8817
msgid "upper device private"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8819
msgid "``void *upper_info``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8818
msgid "upper info to be passed down via notifier"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8820
msgid ""
"Adds a link to device which is upper to this one. In this case, only one "
"master upper device can be linked, although other non-master devices might "
"be linked as well. The caller must hold the RTNL lock. On a failure a "
"negative errno code is returned. On success the reference counts are "
"adjusted and the function returns zero."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8875
msgid "Removes a link to upper device"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8878
msgid ""
"Removes a link to device which is upper to this one. The caller must hold "
"the RTNL lock."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8989
msgid "Dispatch event about slave change"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8992
msgid "``struct netdev_bonding_info *bonding_info``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8991
msgid "info to dispatch"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:8992
msgid ""
"Send NETDEV_BONDING_INFO to netdev notifiers with info. The caller must hold "
"the RTNL lock."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9247
msgid "Get the xmit slave of master device"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9249
msgid "The packet"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9251
msgid "``bool all_slaves``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9250
msgid "assume all the slaves are active"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9251
msgid ""
"The reference counters are not incremented so the caller must be careful "
"with locks. The caller must hold RCU lock. ``NULL`` is returned if no slave "
"is found."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9280
msgid "Get the lowest device in chain given device and socket"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9282
msgid "the socket"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9283
msgid "``NULL`` is returned if no lower device is found."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9394
msgid "Dispatch event about lower device state change"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9400
msgid "``struct net_device *lower_dev``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9397
msgid "``void *lower_state_info``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9396
msgid "state to dispatch"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9397
msgid ""
"Send NETDEV_CHANGELOWERSTATE to netdev notifiers with info. The caller must "
"hold the RTNL lock."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9569
msgid "get flags reported to userspace"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9571
msgid "Get the combination of flag bits exported through APIs to userspace."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9835
msgid "Call NETDEV_PRE_CHANGEADDR."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9838
msgid "``const char *addr``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9837
msgid "new address"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9840 net/core/dev.c:9972
msgid "0 on success, -errno on failure."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9965
msgid "Get the device's port parent identifier"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9968
msgid "``struct netdev_phys_item_id *ppid``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9967
msgid "pointer to a storage for the port's parent identifier"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9969
msgid "``bool recurse``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9968
msgid "allow/disallow recursion to lower devices"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:9969
msgid "Get the devices's port parent identifier."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:10008
msgid "Indicate if two network devices have the same port parent identifier"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:10014
msgid "``struct net_device *a``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:10010
msgid "first network device"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:10012
msgid "``struct net_device *b``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:10011
msgid "second network device"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:10955 net/core/dev.c:10970
msgid "recalculate device features"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:10956 net/core/dev.c:10971
msgid "the device to check"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:10957
msgid ""
"Recalculate dev->features set and send notifications if it has changed. "
"Should be called after driver or hardware dependent conditions might have "
"changed that influence the features."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:10972
msgid ""
"Recalculate dev->features set and send notifications even if they have not "
"changed. Should be called instead of netdev_update_features() if also dev-"
">vlan_features might have changed to allow the changes to be propagated to "
"stacked VLAN devices."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:10987
msgid "transfer operstate"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:10993
msgid "``const struct net_device *rootdev``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:10988
msgid "the root or lower level device to transfer state from"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:10989
msgid "the device to transfer operstate to"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:10990
msgid ""
"Transfer operational state from root to device. This is normally called when "
"a stacking relationship exists between the root device and the device(a leaf "
"device)."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11175 net/core/dev.c:11390
msgid "register a network device"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11176 net/core/dev.c:11391
msgid "device to register"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11177
msgid ""
"Take a prepared network device structure and make it externally accessible. "
"A ``NETDEV_REGISTER`` message is sent to the netdev notifier chain. Callers "
"must hold the rtnl lock - you may want register_netdev() instead of this."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11392
msgid ""
"Take a completed network device structure and add it to the kernel "
"interfaces. A ``NETDEV_REGISTER`` message is sent to the netdev notifier "
"chain. 0 is returned on success. A negative errno code is returned on a "
"failure to set up the device, or if the name is a duplicate."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11397
msgid ""
"This is a wrapper around register_netdevice that takes the rtnl semaphore "
"and expands the device name if you passed a format string to alloc_netdev."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11709
msgid "get network device statistics"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11710 net/core/dev.c:11805
msgid "device to get statistics from"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11712
msgid "``struct rtnl_link_stats64 *storage``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11711 net/core/dev.c:11771
#: net/core/dev.c:11806
msgid "place to store stats"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11712
msgid ""
"Get network statistics from device. Return **storage**. The device driver "
"may provide its own method by setting dev->netdev_ops->get_stats64 or dev-"
">netdev_ops->get_stats; otherwise the internal statistics structure is used."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11770
msgid "get per-cpu network device statistics"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11776 net/core/dev.c:11807
msgid "``struct rtnl_link_stats64 *s``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11773
msgid "``const struct pcpu_sw_netstats __percpu *netstats``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11772
msgid "per-cpu network stats to read from"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11773
msgid ""
"Read per-cpu network statistics and populate the related fields in **s**."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11804
msgid "ndo_get_stats64 implementation"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11807
msgid ""
"Populate **s** from dev->stats and dev->tstats. Can be used as "
"ndo_get_stats64() callback."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11847
msgid "enable SW IRQ coalescing by default"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11848
msgid "netdev to enable the IRQ coalescing on"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11849
msgid ""
"Sets a conservative default for SW IRQ coalescing. Users can use sysfs "
"attributes to override the default values."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11865
msgid "allocate network device"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11871 net/core/dev.c:12101
#: ../../../networking/kapi:95: net/ethernet/eth.c:371
msgid "``int sizeof_priv``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11866 net/core/dev.c:12096
msgid "size of private data to allocate space for"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11867
msgid "device name format string"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11869
msgid "``unsigned char name_assign_type``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11868
msgid "origin of device name"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11870
msgid "``void (*setup)(struct net_device *)``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11869
msgid "callback to initialize device"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11871
#: ../../../networking/kapi:95: net/ethernet/eth.c:369
msgid "``unsigned int txqs``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11870
msgid "the number of TX subqueues to allocate"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11872
#: ../../../networking/kapi:95: net/ethernet/eth.c:370
msgid "``unsigned int rxqs``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11871
msgid "the number of RX subqueues to allocate"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:11872
msgid ""
"Allocates a struct net_device with private data area for driver use and "
"performs basic initialization.  Also allocates subqueue structs for each "
"queue on the device."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:12028
msgid "free network device"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:12030
msgid ""
"This function does the last stage of destroying an allocated device "
"interface. The reference to the device object is released. If this is the "
"last reference then it will be freed.Must be called in process context."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:12095
msgid "Allocate and initialize a dummy net device."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:12098
msgid "the allocated net_device on success, NULL otherwise"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:12108
msgid "Synchronize with packet receive processing"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:12109
msgid ""
"Wait for packets currently being received to be done. Does not block later "
"packets from starting."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:12139 net/core/dev.c:12352
msgid "remove device from the kernel"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:12141
msgid "list"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:12142
msgid ""
"This function shuts down a device interface and removes it from the kernel "
"tables. If head not NULL, device is queued to be unregistered later."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:12146
msgid ""
"Callers must hold the rtnl semaphore.  You may want unregister_netdev() "
"instead of this."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:12339
msgid "unregister many devices"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:12340
msgid "list of devices"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:12342
msgid "As most callers use a stack allocated list_head,"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:12343
msgid "we force a list_del() to make sure stack won't be corrupted later."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:12354
msgid ""
"This function shuts down a device interface and removes it from the kernel "
"tables."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:12357
msgid ""
"This is just a wrapper for unregister_netdevice that takes the rtnl "
"semaphore.  In general you want to use this and not unregister_netdevice."
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:12622
msgid "increment feature set by one"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:12628
msgid "``netdev_features_t all``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:12623
msgid "current feature set"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:12625
msgid "``netdev_features_t one``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:12624
msgid "new feature set"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:12626
msgid "``netdev_features_t mask``"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:12625
msgid "mask feature set"
msgstr ""

#: ../../../networking/kapi:92: net/core/dev.c:12626
msgid ""
"Computes a new feature set after adding a device with feature set **one** to "
"the master device with current feature set **all**.  Will not enable "
"anything that is off in **mask**. Returns the new feature set."
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:67
msgid "create the Ethernet header"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:69
msgid "source device"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:70 net/ethernet/eth.c:213
msgid "Ethernet type field"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:72
msgid "``const void *daddr``"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:71
msgid "destination address (NULL leave destination address)"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:73
msgid "``const void *saddr``"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:72
msgid "source address (NULL use device source address)"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:73
msgid "packet length (<= skb->len)"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:74
msgid ""
"Set the protocol type. For a packet of type ETH_P_802_3/2 we put the length "
"in here instead."
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:117
msgid "determine the length of header for an ethernet frame"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:118
msgid "pointer to network device"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:119
msgid "pointer to start of frame"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:121
msgid "``u32 len``"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:120
msgid "total length of frame"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:121
msgid ""
"Make a best effort attempt to pull the length for all of the headers for a "
"given frame in a linear buffer."
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:147
msgid "determine the packet's protocol ID."
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:148
msgid "received socket data"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:149
msgid "receiving network device"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:150
msgid ""
"The rule here is that we assume 802.3 if the type field is short enough to "
"be a length. This is normal practice and works for any 'now in use' protocol."
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:197
msgid "extract hardware address from packet"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:198
msgid "packet to extract header from"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:200
msgid "``unsigned char *haddr``"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:210
msgid "fill cache entry from neighbour"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:216
msgid "``const struct neighbour *neigh``"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:211
msgid "source neighbour"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:213 net/ethernet/eth.c:248
msgid "``struct hh_cache *hh``"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:212 net/ethernet/eth.c:243
msgid "destination cache entry"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:214
msgid "``__be16 type``"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:214
msgid "Create an Ethernet header template from the neighbour."
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:242
msgid "update cache entry"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:246
msgid "``const unsigned char *haddr``"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:245
msgid "new hardware address"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:246
msgid "Called by Address Resolution module to notify changes in address."
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:259
msgid "extract protocol from L2 header"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:260
msgid "packet to extract protocol from"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:271
msgid "prepare for mac change"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:274 net/ethernet/eth.c:291
#: net/ethernet/eth.c:304
msgid "``void *p``"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:273 net/ethernet/eth.c:290
#: net/ethernet/eth.c:303
msgid "socket address"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:288
msgid "commit mac change"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:301
msgid "set new Ethernet hardware address"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:304
msgid "Change hardware address of device."
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:306
msgid ""
"This doesn't change hardware matching, so needs to be overridden for most "
"real devices."
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:340
msgid "setup Ethernet network device"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:342
msgid ""
"Fill in the fields of the device structure with Ethernet-generic values."
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:365
msgid "Allocates and sets up an Ethernet device"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:366
msgid ""
"Size of additional driver-private structure to be allocated for this "
"Ethernet device"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:368
msgid "The number of TX queues this device has."
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:369
msgid "The number of RX queues this device has."
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:370
msgid ""
"Fill in the fields of the device structure with Ethernet-generic values. "
"Basically does everything except registering the device."
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:373
msgid ""
"Constructs a new net device, complete with a private data area of size "
"(sizeof_priv).  A 32-byte (not bit) alignment is enforced for this private "
"data area."
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:507 net/ethernet/eth.c:624
msgid "Set netdev's MAC address from a given device"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:508 net/ethernet/eth.c:611
#: net/ethernet/eth.c:625
msgid "Pointer to the device"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:510 net/ethernet/eth.c:627
msgid "``struct net_device *netdev``"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:509 net/ethernet/eth.c:626
msgid "Pointer to netdev to write the address to"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:510
msgid ""
"Wrapper around eth_platform_get_mac_address() which writes the address "
"directly to netdev->dev_addr."
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:577
msgid "Get the MAC from the firmware node"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:3323
#: ../../../networking/kapi:95: net/ethernet/eth.c:583
msgid "``struct fwnode_handle *fwnode``"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:578
msgid "Pointer to the firmware node"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:580 net/ethernet/eth.c:613
msgid "``char *addr``"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:579 net/ethernet/eth.c:612
msgid "Address of buffer to store the MAC in"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:580
msgid ""
"Search the firmware node for the best MAC address to use.  'mac-address' is "
"checked first, because that is supposed to contain to \"most recent\" MAC "
"address. If that isn't set, then 'local-mac-address' is checked next, "
"because that is the default address.  If that isn't set, then the obsolete "
"'address' is checked, just in case we're using an old device tree."
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:586
msgid ""
"Note that the 'address' property is supposed to contain a virtual address of "
"the register set, but some DTS files have redefined that property to be the "
"MAC address."
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:590
msgid ""
"All-zero MAC addresses are rejected, because those could be properties that "
"exist in the firmware tables, but were not updated by the firmware.  For "
"example, the DTS could define 'mac-address' and 'local-mac-address', with "
"zero MAC addresses.  Some older U-Boots only initialized 'local-mac-"
"address'. In this case, the real MAC is in 'local-mac-address', and 'mac-"
"address' exists but is all zeros."
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:610
msgid "Get the MAC for a given device"
msgstr ""

#: ../../../networking/kapi:95: net/ethernet/eth.c:627
msgid ""
"Wrapper around device_get_mac_address() which writes the address directly to "
"netdev->dev_addr."
msgstr ""

#: ../../../networking/kapi:98: net/sched/sch_generic.c:577
msgid "set carrier"
msgstr ""

#: ../../../networking/kapi:98: net/sched/sch_generic.c:579
msgid "Device has detected acquisition of carrier."
msgstr ""

#: ../../../networking/kapi:98: net/sched/sch_generic.c:596
msgid "clear carrier"
msgstr ""

#: ../../../networking/kapi:98: net/sched/sch_generic.c:598
msgid "Device has detected loss of carrier."
msgstr ""

#: ../../../networking/kapi:98: net/sched/sch_generic.c:613
msgid "report carrier state event"
msgstr ""

#: ../../../networking/kapi:98: net/sched/sch_generic.c:615
msgid ""
"Device has detected a carrier event but the carrier state wasn't changed. "
"Use in drivers when querying carrier state asynchronously, to avoid missing "
"events (link flaps) if link recovers before it's queried."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:81
msgid "Determine if given Ethernet address is link-local"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:87
#: include/linux/etherdevice.h:110 include/linux/etherdevice.h:129
#: include/linux/etherdevice.h:163 include/linux/etherdevice.h:174
#: include/linux/etherdevice.h:189 include/linux/etherdevice.h:200
#: include/linux/etherdevice.h:320 include/linux/etherdevice.h:464
msgid "``const u8 *addr``"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:82
#: include/linux/etherdevice.h:105 include/linux/etherdevice.h:124
#: include/linux/etherdevice.h:158 include/linux/etherdevice.h:169
#: include/linux/etherdevice.h:184 include/linux/etherdevice.h:195
#: include/linux/etherdevice.h:231 include/linux/etherdevice.h:245
#: include/linux/etherdevice.h:256 include/linux/etherdevice.h:345
#: include/linux/etherdevice.h:398 include/linux/etherdevice.h:459
#: include/linux/etherdevice.h:531
msgid "Pointer to a six-byte array containing the Ethernet address"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:84
msgid ""
"true if address is link local reserved addr (01:80:c2:00:00:0X) per IEEE "
"802.1Q 8.6.3 Frame filtering."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:86
#: include/linux/etherdevice.h:108 include/linux/etherdevice.h:172
#: include/linux/etherdevice.h:200
msgid "Please note: addr must be aligned to u16."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:104
msgid "Determine if give Ethernet address is all zeros."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:107
msgid "true if the address is all zeroes."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:123
msgid "Determine if the Ethernet address is a multicast."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:126
msgid ""
"true if the address is a multicast address. By definition the broadcast "
"address is also a multicast address."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:157
msgid "Determine if the Ethernet address is locally-assigned one (IEEE 802)."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:160
msgid "true if the address is a local address."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:168
msgid "Determine if the Ethernet address is broadcast"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:171
msgid "true if the address is the broadcast address."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:183
msgid "Determine if the Ethernet address is unicast"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:186
msgid "true if the address is a unicast address."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:194
msgid "Determine if the given Ethernet address is valid"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:196
msgid ""
"Check that the Ethernet address (MAC) is not 00:00:00:00:00:00, is not a "
"multicast address, and is not FF:FF:FF:FF:FF:FF."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:200
msgid "true if the address is valid."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:212
msgid "Determine if a given Ethertype/length is a protocol"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:218
msgid "``__be16 proto``"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:213
msgid "Ethertype/length value to be tested"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:214
msgid ""
"Check that the value from the Ethertype/length field is a valid Ethertype."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:217
msgid "true if the valid is an 802.3 supported Ethertype."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:230
msgid "Generate software assigned random Ethernet address"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:236
#: include/linux/etherdevice.h:250 include/linux/etherdevice.h:261
#: include/linux/etherdevice.h:478 include/linux/etherdevice.h:496
#: include/linux/etherdevice.h:509 include/linux/etherdevice.h:521
msgid "``u8 *addr``"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:232
msgid ""
"Generate a random Ethernet address (MAC) that is not multicast and has the "
"local assigned bit set."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:244
msgid "Assign broadcast address"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:246
msgid "Assign the broadcast address to the given address array."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:255
msgid "Assign zero address"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:257
msgid "Assign the zero address to the given address array."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:266
msgid "Generate software assigned random Ethernet and set device flag"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:268
#: include/linux/etherdevice.h:318
msgid "pointer to net_device structure"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:269
msgid ""
"Generate a random Ethernet address (MAC) to be used by a net device and set "
"addr_assign_type so the state can be read by sysfs and be used by userspace."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:284
msgid "Calculate CRC from netdev_hw_addr"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:290
msgid "``struct netdev_hw_addr *ha``"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:285
msgid "pointer to hardware address"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:286
msgid "Calculate CRC from a hardware address as basis for filter hashes."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:295
msgid "Copy an Ethernet address"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:301
msgid "``u8 *dst``"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:296
msgid "Pointer to a six-byte array Ethernet address destination"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:298
msgid "``const u8 *src``"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:297
msgid "Pointer to a six-byte array Ethernet address source"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:298
msgid "Please note: dst & src must both be aligned to u16."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:317
msgid "Assign Ethernet address to a net_device"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:319
msgid "address to assign"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:320
msgid ""
"Assign given address to the net_device, addr_assign_type is not changed."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:329
msgid "Copy dev_addr from another net_device"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:335
msgid "``struct net_device *dst``"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:330
msgid "pointer to net_device to copy dev_addr to"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:332
msgid "``struct net_device *src``"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:331
msgid "pointer to net_device to copy dev_addr from"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:332
msgid ""
"Copy the Ethernet address from one net_device to another along with the "
"address attributes (addr_assign_type)."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:344
#: include/linux/etherdevice.h:368
msgid "Compare two Ethernet addresses"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:350
#: include/linux/etherdevice.h:374 include/linux/etherdevice.h:403
#: include/linux/etherdevice.h:421
msgid "``const u8 *addr1``"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:347
#: include/linux/etherdevice.h:371 include/linux/etherdevice.h:400
#: include/linux/etherdevice.h:418
msgid "``const u8 *addr2``"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:346
#: include/linux/etherdevice.h:399
msgid "Pointer other six-byte array containing the Ethernet address"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:347
#: include/linux/etherdevice.h:400
msgid "Compare two Ethernet addresses, returns true if equal"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:349
msgid "Please note: addr1 & addr2 must both be aligned to u16."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:369
msgid "Pointer to an array of 8 bytes"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:370
msgid "Pointer to an other array of 8 bytes"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:371
msgid "Compare two Ethernet addresses, returns true if equal, false otherwise."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:373
msgid ""
"The function doesn't need any conditional branches and possibly uses word "
"memory accesses on CPU allowing cheap unaligned memory reads. arrays = "
"{ byte1, byte2, byte3, byte4, byte5, byte6, pad1, pad2 }"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:377
msgid ""
"Please note that alignment of addr1 & addr2 are only guaranteed to be 16 "
"bits."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:397
msgid "Compare two not u16 aligned Ethernet addresses"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:402
msgid "Please note: Use only when any Ethernet address may not be u16 aligned."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:415
msgid "Compare two Ethernet addresses with a mask"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:416
msgid "Pointer to a six-byte array containing the 1st Ethernet address"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:417
msgid "Pointer to a six-byte array containing the 2nd Ethernet address"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:419
msgid "``const u8 *mask``"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:418
msgid "Pointer to a six-byte array containing the Ethernet address bitmask"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:419
msgid ""
"Compare two Ethernet addresses with a mask, returns true if for every bit "
"set in the bitmask the equivalent bits in the ethernet addresses are equal. "
"Using a mask with all bits set is a slower ether_addr_equal."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:458
msgid "Convert an Ethernet address into a u64 value."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:461
msgid "a u64 value of the address"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:475
msgid "Convert a u64 to an Ethernet address."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:481
msgid "``u64 u``"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:476
msgid "u64 to convert to an Ethernet MAC address"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:477
msgid "Pointer to a six-byte array to contain the Ethernet address"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:490
msgid "Decrement the given MAC address"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:492
msgid "Pointer to a six-byte array containing Ethernet address to decrement"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:503
msgid "Increment the given MAC address."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:504
#: include/linux/etherdevice.h:518
msgid "Pointer to a six-byte array containing Ethernet address to increment."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:515
msgid "Add (or subtract) an offset to/from the given MAC address."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:520
msgid "``long offset``"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:517
msgid "Offset to add."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:529
msgid "Tell if given Ethernet address belongs to the device."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:530
msgid "Pointer to a device structure"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:532
msgid "``const u8 addr[6 + 2]``"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:532
msgid ""
"Compare passed address with all addresses of the device. Return true if the "
"address if one of the device addresses."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:535
msgid ""
"Note that this function calls ether_addr_equal_64bits() so take care of the "
"right padding."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:557
msgid "Compare two Ethernet headers"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:563
msgid "``const void *a``"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:558
#: include/linux/etherdevice.h:559
msgid "Pointer to Ethernet header"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:560
msgid "``const void *b``"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:560
msgid ""
"Compare two Ethernet headers, returns 0 if equal. This assumes that the "
"network header (i.e., IP header) is 4-byte aligned OR the platform can "
"handle unaligned access.  This is the case for all packets coming into "
"netif_receive_skb or similar entry points."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:594
msgid "Generate and assign Ethernet address to a port"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:595
msgid "pointer to port's net_device structure"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:597
msgid "``const u8 *base_addr``"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:596
msgid "base Ethernet address"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:598
msgid "``unsigned int id``"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:597
msgid "offset to add to the base address"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:598
msgid ""
"Generate a MAC address using a base address and an offset and assign it to a "
"net_device. Commonly used by switch drivers which need to compute addresses "
"for all their ports. addr_assign_type is not changed."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:615
msgid "Assign packet type if destination address does not match"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:616
msgid "Assigned a packet type if address does not match **dev** address"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:617
msgid "Network device used to compare packet address against"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:618
msgid ""
"If the destination MAC address of the packet does not match the network "
"device address, assign an appropriate packet type."
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:648
msgid "Pad buffer to minimum number of octets for Ethernet frame"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:649
msgid "Buffer to pad"
msgstr ""

#: ../../../networking/kapi:101: include/linux/etherdevice.h:650
msgid ""
"An Ethernet frame should have a minimum size of 60 bytes.  This function "
"takes short frames and pads them with zeros up to the 60 byte limit."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:349
msgid "structure to support Generic Receive Offload"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:350
msgid "``bitmask``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:351
msgid "bitmask to indicate used buckets in **hash**"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:352
msgid "hashtable of pending aggregated skbs, separated by flows"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:352
msgid "``rx_list``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:353
msgid "list of pending ``GRO_NORMAL`` skbs"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:353
msgid "``rx_count``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:354
msgid "cached current length of **rx_list**"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:354
msgid "``cached_napi_id``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:355
msgid "napi_struct::napi_id cached for hotpath, 0 for standalone"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:519
msgid "test if NAPI is scheduled"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:521
msgid ""
"This check is \"best-effort\". With no locking implemented, a NAPI can be "
"scheduled or terminate right after this check and produce not precise "
"results."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:525
msgid ""
"NAPI_STATE_SCHED is an internal state, napi_is_scheduled should not be used "
"normally and napi_schedule should be used instead."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:529
msgid ""
"Use only if the driver really needs to check if a NAPI is scheduled for "
"example in the context of delayed timer that can be skipped if a NAPI is "
"already scheduled."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:534
msgid "True if NAPI is scheduled, False otherwise."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:544
#: include/linux/netdevice.h:564
msgid "schedule NAPI poll"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:546
msgid "Schedule NAPI poll routine to be called if it is not already running."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:549
msgid ""
"true if we schedule a NAPI or false if not. Refer to napi_schedule_prep() "
"for additional reason on why a NAPI might not be scheduled."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:566
msgid "Variant of napi_schedule(), assuming hard irqs are masked."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:576
msgid "NAPI processing complete"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:579
msgid "``int work_done``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:578
msgid "number of packets processed"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:579
msgid ""
"Mark NAPI processing as complete. Should only be called if poll budget has "
"not been completely consumed. Prefer over napi_complete()."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:583
msgid "false if device should avoid rearming interrupts."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:603
msgid "wait until NAPI is not running"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:609
msgid "``const struct napi_struct *n``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:605
msgid ""
"Wait until NAPI is done being scheduled on this context. Waits till any "
"outstanding processing completes but does not disable future activations."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:620
msgid "if napi is running, set the NAPIF_STATE_MISSED"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:623
msgid ""
"If napi is running, set the NAPIF_STATE_MISSED, and return true if NAPI is "
"scheduled."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1665
msgid ":c:type:`struct net_device <net_device>` priv_flags"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1671
msgid "``IFF_802_1Q_VLAN``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1672
msgid "802.1Q VLAN device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1674
msgid "``IFF_EBRIDGE``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1675
msgid "Ethernet bridging device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1677
msgid "``IFF_BONDING``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1678
msgid "bonding master or slave"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1680
msgid "``IFF_ISATAP``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1681
msgid "ISATAP interface (RFC4214)"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1683
msgid "``IFF_WAN_HDLC``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1684
msgid "WAN HDLC device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1686
msgid "``IFF_XMIT_DST_RELEASE``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1687
msgid "dev_hard_start_xmit() is allowed to release skb->dst"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1690
msgid "``IFF_DONT_BRIDGE``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1691
msgid "disallow bridging this ether dev"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1693
msgid "``IFF_DISABLE_NETPOLL``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1694
msgid "disable netpoll at run-time"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1696
msgid "``IFF_MACVLAN_PORT``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1697
msgid "device used as macvlan port"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1699
msgid "``IFF_BRIDGE_PORT``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1700
msgid "device used as bridge port"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1702
msgid "``IFF_OVS_DATAPATH``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1703
msgid "device used as Open vSwitch datapath port"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1705
msgid "``IFF_TX_SKB_SHARING``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1706
msgid "The interface supports sharing skbs on transmit"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1708
msgid "``IFF_UNICAST_FLT``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1709
msgid "Supports unicast filtering"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1711
msgid "``IFF_TEAM_PORT``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1712
msgid "device used as team port"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1714
msgid "``IFF_SUPP_NOFCS``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1715
msgid "device supports sending custom FCS"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1717
msgid "``IFF_LIVE_ADDR_CHANGE``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1718
msgid "device supports hardware address change when it's running"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1721
msgid "``IFF_MACVLAN``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1722
msgid "Macvlan device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1724
msgid "``IFF_XMIT_DST_RELEASE_PERM``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1725
msgid "IFF_XMIT_DST_RELEASE not taking into account underlying stacked devices"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1728
msgid "``IFF_L3MDEV_MASTER``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1729
msgid "device is an L3 master device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1731
msgid "``IFF_NO_QUEUE``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1732
msgid "device can run without qdisc attached"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1734
msgid "``IFF_OPENVSWITCH``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1735
msgid "device is a Open vSwitch master"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1737
msgid "``IFF_L3MDEV_SLAVE``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1738
msgid "device is enslaved to an L3 master device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1740
msgid "``IFF_TEAM``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1741
msgid "device is a team device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1743
msgid "``IFF_RXFH_CONFIGURED``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1744
msgid "device has had Rx Flow indirection table configured"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1746
msgid "``IFF_PHONY_HEADROOM``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1747
msgid ""
"the headroom value is controlled by an external entity (i.e. the master "
"device for bridged veth)"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1750
msgid "``IFF_MACSEC``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1751
msgid "device is a MACsec device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1753
msgid "``IFF_NO_RX_HANDLER``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1754
msgid "device doesn't support the rx_handler hook"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1756
msgid "``IFF_FAILOVER``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1757
msgid "device is a failover master device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1759
msgid "``IFF_FAILOVER_SLAVE``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1760
msgid "device is lower dev of a failover master device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1762
msgid "``IFF_L3MDEV_RX_HANDLER``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1763
msgid "only invoke the rx handler of L3 master device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1765
msgid "``IFF_NO_ADDRCONF``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1766
msgid "prevent ipv6 addrconf"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1768
msgid "``IFF_TX_SKB_NO_LINEAR``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1769
msgid ""
"device/driver is capable of xmitting frames with skb_headlen(skb) == 0 (data "
"starts from frag0)"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1666
msgid ""
"These are the :c:type:`struct net_device <net_device>`, they are only set "
"internally by drivers and used in the kernel. These flags are invisible to "
"userspace; this means that the order of these flags can change during any "
"kernel release."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1671
msgid ""
"You should add bitfield booleans after either net_device::priv_flags "
"(hotpath) or ::threaded (slowpath) instead of extending these flags."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1771
msgid "The DEVICE structure."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1777
msgid "``priv_flags``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1778
msgid ""
"flags invisible to userspace defined as bits, see enum netdev_priv_flags for "
"the definitions"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1779
msgid "``lltx``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1780
msgid ""
"device supports lockless Tx. Deprecated for real HW drivers. Mainly used by "
"logical interfaces, such as bonding and tunnels"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1782
msgid "``netmem_tx``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1783
msgid "device support netmem_tx."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1834
msgid "``netdev_ops``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1835
msgid ""
"Includes several pointers to callbacks, if one wants to override the ndo_*() "
"functions"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1844
msgid "``header_ops``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1845
msgid "Includes callbacks for creating,parsing,caching,etc of Layer 2 headers."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1933
msgid "``_tx``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1934
msgid "Array of TX queues"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1817
msgid "``gso_partial_features``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1818
msgid "value(s) from NETIF_F_GSO\\*"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1935
msgid "``real_num_tx_queues``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1936
msgid "Number of TX queues currently active in device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1990
msgid "``gso_max_size``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1991
msgid "Maximum size of generic segmentation offload"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1995
msgid "``gso_ipv4_max_size``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1996
msgid "Maximum size of generic segmentation offload, for IPv4."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1992
msgid "``gso_max_segs``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1993
msgid "Maximum number of segments that can be passed to the NIC for GSO"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1999
msgid "``num_tc``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2000
msgid "Number of traffic classes in the net device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1856
msgid "``mtu``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1857
msgid "Interface MTU value"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1863
msgid "``needed_headroom``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1864
msgid ""
"Extra headroom the hardware may need, but not in all cases can this be "
"guaranteed"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2000
msgid "``tc_to_txq``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1883
#: include/linux/netdevice.h:1922 include/linux/netdevice.h:1924
#: include/linux/netdevice.h:1939 include/linux/netdevice.h:1943
#: include/linux/netdevice.h:1956 include/linux/netdevice.h:1962
#: include/linux/netdevice.h:2001 include/linux/netdevice.h:2002
#: include/linux/netdevice.h:2006
msgid "XXX: need comments on this one"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1942
msgid "``xps_maps``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1944
msgid "``nf_hooks_egress``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1945
msgid "netfilter hooks executed for egress packets"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1943
msgid "``tcx_egress``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1944
msgid "BPF & clsact qdisc specific data for egress processing"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1972
msgid "``lstats``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1973
msgid "Loopback statistics: packets, bytes"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1973
msgid "``tstats``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1974
msgid "Tunnel statistics: RX/TX packets, RX/TX bytes"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1974
msgid "``dstats``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1975
msgid "Dummy statistics: RX/TX/drop packets, RX/TX bytes"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1796
msgid "Generic network queuing layer state, see netdev_state_t"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1848
msgid "Interface flags (a la BSD)"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1860
msgid "``hard_header_len``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1861
msgid "Maximum hardware header length."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1805
#: ../../../networking/kapi:125: include/linux/phy.h:915
msgid "``features``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1806
msgid "Currently active device features"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1902
msgid "``ip6_ptr``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1903
msgid "IPv6 specific data"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1918
msgid "``xdp_prog``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1919
msgid "XDP sockets filter program pointer"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1802
msgid "``ptype_specific``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1803
msgid "Device-specific, protocol-specific packet handlers"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1819
msgid "``ifindex``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1820
msgid "interface index"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1917
msgid "``real_num_rx_queues``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1918
msgid "Number of RX queues currently active in device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1914
msgid "``_rx``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1915
msgid "Array of RX queues"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2050
msgid "``gro_max_size``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2051
msgid "Maximum size of aggregated packet in generic receive offload (GRO)"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2052
msgid "``gro_ipv4_max_size``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2053
msgid ""
"Maximum size of aggregated packet in generic receive offload (GRO), for IPv4."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1920
msgid "``rx_handler``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1921
msgid "handler for received packets"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1921
msgid "``rx_handler_data``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1962
msgid "``nd_net``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1963
msgid "Network namespace this network device is inside protected by **lock**"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1961
msgid "``npinfo``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1922
msgid "``tcx_ingress``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1923
msgid "BPF & clsact qdisc specific data for ingress processing"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1784
#: ../../../networking/kapi:125: include/linux/phy.h:355
#: include/linux/phy.h:913
msgid "``name``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1785
msgid ""
"This is the first field of the \"visible\" part of this structure (i.e. as "
"seen by users in the \"Space.c\" file).  It is the name of the interface."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1788
msgid "``name_node``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1789
msgid "Name hashlist node"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1789
msgid "``ifalias``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1790
msgid "SNMP alias"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1790
msgid "``mem_end``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1791
msgid "Shared memory end"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1791
msgid "``mem_start``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1792
msgid "Shared memory start"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1792
msgid "``base_addr``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1793
msgid "Device I/O address"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1796
msgid "``dev_list``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1797
msgid "The global list of network devices"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1797
msgid "``napi_list``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1798
msgid "List entry used for polling NAPI devices"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1798
msgid "``unreg_list``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1799
msgid ""
"List entry  when we are unregistering the device; see the function "
"unregister_netdev"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1800
msgid "``close_list``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1801
msgid "List entry used when we are closing the device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1801
msgid "``ptype_all``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1802
msgid "Device-specific packet handlers for all protocols"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1804
msgid "``adj_list``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1805
msgid "Directly linked devices, like slaves for bonding"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1848
msgid "``xdp_features``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1849
msgid "XDP capability supported by the device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1836
msgid "``xdp_metadata_ops``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1837
msgid "Includes pointers to XDP metadata callbacks."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1837
msgid "``xsk_tx_metadata_ops``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1838
msgid "Includes pointers to AF_XDP TX metadata callbacks."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1849
msgid "``gflags``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1850
msgid "Global flags ( kept as legacy )"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1865
msgid "``needed_tailroom``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1866
msgid ""
"Extra tailroom the hardware may need, but not in all cases can this be "
"guaranteed. Some cases also use LL_MAX_HEADER instead to allocate the skb"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1806
msgid "``hw_features``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1807
msgid "User-changeable features"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1808
msgid "``wanted_features``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1809
msgid "User-requested features"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1809
msgid "``vlan_features``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1810
msgid "Mask of features inheritable by VLAN devices"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1811
msgid "``hw_enc_features``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1812
msgid ""
"Mask of features inherited by encapsulating devices This field indicates "
"what encapsulation offloads the hardware is capable of doing, and drivers "
"will need to set them appropriately."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1816
msgid "``mpls_features``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1817
msgid "Mask of features inheritable by MPLS"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1857
msgid "``min_mtu``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1858
msgid "Interface Minimum MTU value"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1858
msgid "``max_mtu``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1859
msgid "Interface Maximum MTU value"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1860
msgid "Interface hardware type"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1861
msgid "``min_header_len``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1862
msgid "Minimum hardware header length"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1883
msgid "``name_assign_type``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1884
msgid "network interface name assignment type"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1820
#: ../../../networking/kapi:107: include/net/net_shaper.h:77
msgid "``group``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1821
msgid "The group the device belongs to"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1822
#: ../../../networking/kapi:125: include/linux/phy.h:379
msgid "``stats``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1823
msgid ""
"Statistics struct, which was left as a legacy, use rtnl_link_stats64 instead"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1825
msgid "``core_stats``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1826
msgid "core networking counters, do not use this in drivers"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1827
msgid "``carrier_up_count``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1828
msgid "Number of times the carrier has been up"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1828
msgid "``carrier_down_count``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1829
msgid "Number of times the carrier has been down"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1830
msgid "``wireless_handlers``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1831
msgid ""
"List of functions to handle Wireless Extensions, instead of ioctl, see <net/"
"iw_handler.h> for details."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1838
msgid "``ethtool_ops``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1839
msgid "Management operations"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1839
msgid "``l3mdev_ops``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1840
msgid "Layer 3 master device operations"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1840
msgid "``ndisc_ops``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1841
msgid ""
"Includes callbacks for different IPv6 neighbour discovery handling. "
"Necessary for e.g. 6LoWPAN."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1842
msgid "``xfrmdev_ops``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1843
msgid "Transformation offload operations"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1843
msgid "``tlsdev_ops``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1844
msgid "Transport Layer Security offload operations"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1852
msgid "``operstate``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1853
msgid "RFC2863 operstate"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1853
msgid "``link_mode``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1854
msgid "Mapping policy to operstate"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1854
msgid "``if_port``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1855
msgid "Selectable AUI, TP, ..."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1855
msgid "``dma``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1856
msgid "DMA channel"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1871
msgid "``perm_addr``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1872
msgid "Permanent hw address"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1872
msgid "``addr_assign_type``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1873
msgid "Hw address assignment type"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1873
msgid "``addr_len``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1874
msgid "Hardware address length"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1874
msgid "``upper_level``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1875
msgid "Maximum depth level of upper devices."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1875
msgid "``lower_level``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1876
msgid "Maximum depth level of lower devices."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1876
msgid "``threaded``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1877
msgid "napi threaded state."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1877
msgid "``neigh_priv_len``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1878
msgid "Used in neigh_alloc()"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1878
msgid "``dev_id``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1879
msgid "Used to differentiate devices that share the same link layer address"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1880
msgid "``dev_port``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1881
msgid "Used to differentiate devices that share the same function"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1793
#: ../../../networking/kapi:125: include/linux/phy.h:411
#: include/linux/phy.h:568
msgid "``irq``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1794
msgid "Device IRQ number"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1850
msgid "``priv_len``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1851
msgid "Size of the ->priv flexible array"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1882
msgid "``addr_list_lock``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1888
msgid "``uc``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1889
msgid "unicast mac addresses"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1889
msgid "``mc``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1890
msgid "multicast mac addresses"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1890
msgid "``dev_addrs``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1891
msgid "list of device hw addresses"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1891
msgid "``queues_kset``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1892
msgid "Group of all Kobjects in the Tx and RX queues"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2048
msgid "``unlink_list``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2049
msgid ""
"As netif_addr_lock() can be called recursively, keep a list of interfaces to "
"be deleted."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1892
msgid "``promiscuity``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1893
msgid ""
"Number of times the NIC is told to work in promiscuous mode; if it becomes 0 "
"the NIC will exit promiscuous mode"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1895
msgid "``allmulti``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1896
msgid "Counter, enables or disables allmulticast mode"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1884
msgid "``uc_promisc``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1885
msgid ""
"Counter that indicates promiscuous mode has been enabled due to the need to "
"listen to additional unicast addresses in a device that does not implement "
"ndo_set_rx_mode()"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2046
msgid "``nested_level``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2047
msgid "Used as a parameter of spin_lock_nested() of dev->addr_list_lock."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1901
msgid "``ip_ptr``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1902
msgid "IPv4 specific data"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2284
msgid "``fib_nh_head``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2285
msgid "nexthops associated with this netdev"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1897
msgid "``vlan_info``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1898
msgid "VLAN info"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1898
msgid "``dsa_ptr``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1899
msgid "dsa specific data"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1899
msgid "``tipc_ptr``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1900
msgid "TIPC specific data"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1900
msgid "``atalk_ptr``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1901
msgid "AppleTalk link"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1903
msgid "``ax25_ptr``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1904
msgid "AX.25 specific data"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1904
msgid "``ieee80211_ptr``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1905
msgid "IEEE 802.11 specific data, assign before registering"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1905
msgid "``ieee802154_ptr``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1906
msgid "IEEE 802.15.4 low-rate Wireless Personal Area Network device struct"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1907
msgid "``mpls_ptr``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1908
msgid "mpls_dev struct pointer"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1908
msgid "``mctp_ptr``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1909
msgid "MCTP specific data"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1909
msgid "``psp_dev``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1910
msgid "PSP crypto device registered for this netdev"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1911
msgid "``dev_addr``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1912
msgid "Hw address (before bcast, because most packets are unicast)"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1915
msgid "``num_rx_queues``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1916
msgid "Number of RX queues allocated at register_netdev() time"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2054
msgid "``xdp_zc_max_segs``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2055
msgid "Maximum number of segments supported by AF_XDP zero copy driver"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1923
msgid "``ingress_queue``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1924
msgid "``nf_hooks_ingress``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1925
msgid "netfilter hooks executed for ingress packets"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1925
msgid "``broadcast``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1926
msgid "hw bcast address"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1927
msgid "``rx_cpu_rmap``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1928
msgid ""
"CPU reverse-mapping for RX completion interrupts, indexed by RX queue "
"number. Assigned by driver. This must only be set if the ndo_rx_flow_steer "
"operation is defined"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1931
msgid "``index_hlist``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1932
msgid "Device index hash chain"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1934
msgid "``num_tx_queues``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1935
msgid "Number of TX queues allocated at alloc_netdev_mq() time"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1936
msgid "``qdisc``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1937
msgid "Root qdisc from userspace point of view"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1937
msgid "``tx_queue_len``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1938
msgid "Max frames per queue allowed"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1938
msgid "``tx_global_lock``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1939
msgid "``xdp_bulkq``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1940
msgid "XDP device bulk queue"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1945
msgid "``qdisc_hash``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1946
msgid "qdisc hash table"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1948
msgid "``watchdog_timer``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1949
msgid "List of timers"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1946
msgid "``watchdog_timeo``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1947
msgid ""
"Represents the timeout that is used by the watchdog (see dev_watchdog())"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1950
msgid "``proto_down_reason``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1951
msgid "reason a netdev interface is held down"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1954
msgid "``todo_list``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1955
msgid "Delayed register/unregister"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1951
msgid "``pcpu_refcnt``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1952
#: include/linux/netdevice.h:1953
msgid "Number of references to this device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1952
msgid "``dev_refcnt``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1953
msgid "``refcnt_tracker``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1954
msgid "Tracker directory for tracked references to this device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1955
msgid "``link_watch_list``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1957
msgid "``reg_state``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1958
msgid "Register/unregister state machine"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1958
msgid "``dismantle``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1959
msgid "Device is going to be freed"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2376
msgid "``moving_ns``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2377
msgid "device is changing netns, protected by **lock**"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2378
msgid "``rtnl_link_initializing``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2379
msgid "Device being created, suppress events"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1959
msgid "``needs_free_netdev``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1960
msgid "Should unregister perform free_netdev?"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1960
msgid "``priv_destructor``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1961
msgid "Called from unregister"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1965
msgid "``ml_priv``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1966
msgid "Mid-layer private"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1966
msgid "``ml_priv_type``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1967
msgid "Mid-layer private type"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1968
msgid "``pcpu_stat_type``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1969
msgid ""
"Type of device statistics which the core should allocate/free: none, lstats, "
"tstats, dstats. none means the driver is handling statistics allocation/ "
"freeing internally."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1976
msgid "``garp_port``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1977
msgid "GARP"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1977
msgid "``mrp_port``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1978
msgid "MRP"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1979
msgid "``dm_private``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1980
msgid "Drop monitor private"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1982
msgid "Class/net/name entry"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1982
msgid "``sysfs_groups``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1983
msgid "Space for optional device, statistics and wireless sysfs groups"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1985
msgid "``sysfs_rx_queue_group``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1986
msgid "Space for optional per-rx queue attributes"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1986
msgid "``rtnl_link_ops``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1987
msgid "Rtnl_link_ops"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1987
msgid "``stat_ops``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1988
msgid "Optional ops for queue-aware statistics"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1988
msgid "``queue_mgmt_ops``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1989
msgid "Optional ops for queue management"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1991
msgid "``tso_max_size``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1992
msgid "Device (as in HW) limit on the max TSO request size"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1994
msgid "``tso_max_segs``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1995
msgid "Device (as in HW) limit on the max TSO segment count"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1998
msgid "``dcbnl_ops``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1999
msgid "Data Center Bridging netlink ops"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2001
msgid "``prio_tc_map``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2003
msgid "``fcoe_ddp_xid``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2004
msgid "Max exchange id for FCoE LRO by ddp"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2005
msgid "``priomap``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2006
msgid "``link_topo``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2007
msgid "Physical link topology tracking attached PHYs"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2007
#: ../../../networking/kapi:125: include/linux/phy.h:893
#: include/linux/phy.h:1486
msgid "``phydev``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2008
msgid "Physical device may attach itself for hardware timestamping"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2009
#: ../../../networking/kapi:125: include/linux/phy.h:571
msgid "``sfp_bus``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2010
msgid "attached :c:type:`struct sfp_bus <sfp_bus>` structure."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2011
msgid "``qdisc_tx_busylock``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2012
msgid "lockdep class annotating Qdisc->busylock spinlock"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2013
msgid "``proto_down``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2014
msgid ""
"protocol port state information can be sent to the switch driver and used to "
"set the phys state of the switch port."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2017
msgid "``irq_affinity_auto``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2018
msgid ""
"driver wants the core to store and re-assign the IRQ affinity. Set by "
"netif_enable_irq_affinity(), then the driver must create a persistent napi "
"by netif_napi_add_config() and finally bind the napi to IRQ (via "
"netif_napi_set_irq())."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2023
msgid "``rx_cpu_rmap_auto``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2024
msgid ""
"driver wants the core to manage the ARFS rmap. Set by calling "
"netif_enable_cpu_rmap()."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2026
msgid "``see_all_hwtstamp_requests``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2027
msgid ""
"device wants to see calls to ndo_hwtstamp_set() for all timestamp requests "
"regardless of source, even if those aren't HWTSTAMP_SOURCE_NETDEV"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2030
msgid "``change_proto_down``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2031
msgid "device supports setting carrier via IFLA_PROTO_DOWN"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2031
msgid "``netns_immutable``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2032
msgid "interface can't change network namespaces"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2032
msgid "``fcoe_mtu``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2033
msgid "device supports maximum FCoE MTU, 2158 bytes"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2034
msgid "``net_notifier_list``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2035
msgid ""
"List of per-net netdev notifier block that follow this device when it is "
"moved to another network namespace."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2038
#: ../../../networking/kapi:125: include/linux/phy.h:576
msgid "``macsec_ops``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2039
msgid "MACsec offloading ops"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2040
msgid "``udp_tunnel_nic_info``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2041
msgid ""
"static structure describing the UDP tunnel offload capabilities of the device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2042
msgid "``udp_tunnel_nic``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2043
msgid "UDP tunnel offload state"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2457
msgid "``cfg``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2458
msgid "net_device queue-related configuration"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2460
msgid "``cfg_pending``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2461
msgid "same as **cfg** but when device is being actively"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2462
msgid ""
"reconfigured includes any changes to the configuration requested by the "
"user, but which may or may not be rejected."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2043
msgid "``ethtool``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2044
msgid "ethtool related state"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2044
msgid "``xdp_state``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2045
msgid "stores info on attached XDP BPF programs"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2057
msgid "``dev_addr_shadow``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2058
msgid "Copy of **dev_addr** to catch direct writes."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2058
msgid "``linkwatch_dev_tracker``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2059
msgid "refcount tracker used by linkwatch."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2059
msgid "``watchdog_dev_tracker``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2060
msgid "refcount tracker used by watchdog."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2060
msgid "``dev_registered_tracker``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2061
msgid "tracker for reference held while registered"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2062
msgid "``offload_xstats_l3``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2063
msgid "L3 HW stats for this netdevice."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2064
msgid "``devlink_port``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2065
msgid ""
"Pointer to related devlink port structure. Assigned by a driver before "
"netdev registration using SET_NETDEV_DEVLINK_PORT macro. This pointer is "
"static during the time netdevice is registered."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2069
msgid "``dpll_pin``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2070
msgid ""
"Pointer to the SyncE source pin of a DPLL subsystem, where the clock is "
"recovered."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2482
msgid "``page_pools``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2483
msgid "page pools created for this netdevice"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2486
msgid "``irq_moder``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2487
msgid "dim parameters used if IS_ENABLED(CONFIG_DIMLIB)."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2072
msgid "``max_pacing_offload_horizon``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2073
msgid "max EDT offload horizon in nsec."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2073
msgid "``napi_config``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2074
msgid "An array of napi_config structures containing per-NAPI settings."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2075
msgid "``num_napi_configs``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2076
msgid ""
"number of allocated NAPI config structs, always >= max(num_rx_queues, "
"num_tx_queues)."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2078
msgid "``napi_defer_hard_irqs``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2079
msgid ""
"If not zero, provides a counter that would allow to avoid NIC hard IRQ, on "
"busy queues."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2077
msgid "``gro_flush_timeout``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2078
msgid "timeout for GRO layer in NAPI"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2496
msgid "``up``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2497
msgid "copy of **state**'s IFF_UP, but safe to read with just **lock**."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2498
msgid ""
"May report false negatives while the device is being opened or closed "
"(**lock** does not protect .ndo_open, or .ndo_close)."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2503
msgid "``request_ops_lock``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2504
msgid ""
"request the core to run all **netdev_ops** and **ethtool_ops** under the "
"**lock**."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2509
#: ../../../networking/kapi:125: include/linux/phy.h:624
msgid "``lock``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2510
msgid ""
"netdev-scope lock, protects a small selection of fields. Should always be "
"taken using netdev_lock() / netdev_unlock() helpers. Drivers are free to use "
"it for other protection."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2514
msgid ""
"For the drivers that implement shaper or queue API, the scope of this lock "
"is expanded to cover most ndo/queue/ethtool/sysfs operations. Drivers may "
"opt-in to this behavior by setting **request_ops_lock**."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2519
msgid ""
"**lock** protection mixes with rtnl_lock in multiple ways, fields are either:"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2522
msgid "simply protected by the instance **lock**;"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2524
msgid "double protected - writers hold both locks, readers hold either;"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2526
msgid ""
"ops protected - protected by the lock held around the NDOs and other "
"callbacks, that is the instance lock on devices for which "
"netdev_need_ops_lock() returns true, otherwise by rtnl_lock;"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2530
msgid ""
"double ops protected - always protected by rtnl_lock but for devices for "
"which netdev_need_ops_lock() returns true - also the instance lock."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2534
msgid "Simply protects:"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2535
msgid ""
"**gro_flush_timeout**, **napi_defer_hard_irqs**, **napi_list**, "
"**net_shaper_hierarchy**, **reg_state**, **threaded**"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2538
msgid "Double protects:"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2539
msgid "**up**, **moving_ns**, **nd_net**, **xdp_features**"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2541
msgid "Double ops protects:"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2542
msgid "**real_num_rx_queues**, **real_num_tx_queues**"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2544
msgid "Also protects some fields in:"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2545
msgid "struct napi_struct, struct netdev_queue, struct netdev_rx_queue"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2547
msgid "Ordering: take after rtnl_lock."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2552
msgid "``net_shaper_hierarchy``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2553
msgid "data tracking the current shaper status"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2554
msgid "see include/net/net_shapers.h"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2081
msgid "``neighbours``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2082
msgid ""
"List heads pointing to this device's neighbours' dev_list, one per address-"
"family."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2083
msgid "``hwprov``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2084
msgid "Tracks which PTP performs hardware packet time stamping."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1851
#: ../../../networking/kapi:125: include/linux/phy.h:357
#: include/linux/phy.h:628
msgid "``priv``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1852
msgid "Flexible array containing private data"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1772
msgid ""
"Actually, this whole structure is a big mistake.  It mixes I/O data with "
"strictly \"high-level\" data, and it has to know about almost every data "
"structure used in the INET module."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1777
msgid "interface address info:"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:1780
msgid ""
"FIXME: cleanup struct net_device such that network protocol info moves out."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2738
msgid "access network device private data"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2740
msgid "Get network device private data"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2803
msgid "initialize a NAPI context"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2807
#: include/linux/netdevice.h:2849 include/linux/netdevice.h:2865
msgid "``int (*poll)(struct napi_struct *, int)``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2806
#: include/linux/netdevice.h:2848 include/linux/netdevice.h:2864
msgid "polling function"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2807
msgid ""
"netif_napi_add() must be used to initialize a NAPI context prior to calling "
"*any* of the other NAPI-related functions."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2845
msgid "initialize a NAPI context with persistent config"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2850
msgid "``int index``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2849
msgid "the NAPI index"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2861
msgid "initialize a NAPI context to be used for Tx only"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2865
msgid ""
"This variant of netif_napi_add() should be used from drivers using NAPI to "
"exclusively poll a TX queue. This will avoid we add it into napi_hash[], "
"thus polluting this hash table."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2880
#: include/linux/netdevice.h:2901
msgid "remove a NAPI context"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2882
msgid ""
"Warning: caller must observe RCU grace period before freeing memory "
"containing **napi**. Drivers might want to call this helper to combine all "
"the needed RCU grace periods into a single one."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:2903
msgid ""
"netif_napi_del() removes a NAPI context from the network device NAPI list"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3581
msgid "allow transmit"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3583
msgid "Allow upper layers to call the device hard_start_xmit routine."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3604
msgid "restart transmit"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3606
msgid ""
"Allow upper layers to call the device hard_start_xmit routine. Used for flow "
"control when transmit resources are available."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3638
msgid "stop transmitted packets"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3640
msgid ""
"Stop upper layers calling the device hard_start_xmit routine. Used for flow "
"control when transmit resources are unavailable."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3657
msgid "test if transmit queue is flowblocked"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3659
msgid "Test if transmit queue on device is currently unable to send."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3685
msgid "set dql minimum limit"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3691
#: include/linux/netdevice.h:3719 include/linux/netdevice.h:3733
#: include/linux/netdevice.h:3747 include/linux/netdevice.h:3830
msgid "``struct netdev_queue *dev_queue``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3686
#: include/linux/netdevice.h:3714 include/linux/netdevice.h:3728
msgid "pointer to transmit queue"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3688
msgid "``unsigned int min_limit``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3687
msgid "dql minimum limit"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3688
msgid ""
"Forces xmit_more() to return true until the minimum threshold defined by "
"**min_limit** is reached (or until the tx queue is empty). Warning: to be "
"use with care, misuse will impact the latency."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3713
#: include/linux/netdevice.h:3727
msgid "prefetch bql data for write"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3715
msgid ""
"BQL enabled drivers might use this helper in their ndo_start_xmit(), to give "
"appropriate hint to the CPU."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3729
msgid ""
"BQL enabled drivers might use this helper in their TX completion path, to "
"give appropriate hint to the CPU."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3741
msgid "report the number of bytes queued to a given tx queue"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3742
#: include/linux/netdevice.h:3825
msgid "network device queue"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3744
#: include/linux/netdevice.h:3804 include/linux/netdevice.h:3828
#: include/linux/netdevice.h:3861
msgid "``unsigned int bytes``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3743
msgid "number of bytes queued to the device queue"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3744
msgid ""
"Report the number of bytes queued for sending/completion to the network "
"device hardware queue. **bytes** should be a good approximation and should "
"exactly match netdev_completed_queue() **bytes**. This is typically called "
"once per packet, from ndo_start_xmit()."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3801
msgid "report the number of bytes queued to hardware"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3803
msgid "number of bytes queued to the hardware device queue"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3804
msgid ""
"Report the number of bytes queued for sending/completion to the network "
"device hardware queue#0. **bytes** should be a good approximation and should "
"exactly match netdev_completed_queue() **bytes**. This is typically called "
"once per packet, from ndo_start_xmit()."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3824
msgid "report number of packets/bytes at TX completion."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3827
#: include/linux/netdevice.h:3860
msgid "``unsigned int pkts``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3826
msgid "number of packets (currently ignored)"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3827
msgid "number of bytes dequeued from the device queue"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3828
msgid ""
"Must be called at most once per TX completion round (and not per individual "
"packet), so that BQL can adjust its limits appropriately."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3857
msgid "report bytes and packets completed by device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3859
msgid "actual number of packets sent over the medium"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3860
msgid "actual number of bytes sent over the medium"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3861
msgid ""
"Report the number of bytes and packets transmitted by the network device "
"hardware queue over the physical medium, **bytes** must exactly match the "
"**bytes** amount passed to netdev_sent_queue()"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3881
msgid "reset the BQL stats and state of a netdev queue"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3884
msgid "``u32 qid``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3883
msgid "stack index of the queue to reset"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3892
msgid "reset the packets and bytes count of a network device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3898
msgid "``struct net_device *dev_queue``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3894
msgid ""
"Reset the bytes and packet count of a network device and clear the software "
"flow control OFF bit for this network device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3904
msgid "check if selected tx queue exceeds device queues"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3907
#: include/linux/netdevice.h:3945 include/linux/netdevice.h:3959
#: include/linux/netdevice.h:3972 include/linux/netdevice.h:4000
msgid "``u16 queue_index``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3906
msgid "given tx queue index"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3907
msgid ""
"Returns 0 if given tx queue index >= number of device tx queues, otherwise "
"returns the originally passed tx queue index."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3924
msgid "test if up"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3926
msgid "Test if the device has been brought up."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3942
#: include/linux/netdevice.h:3997
msgid "allow sending packets on subqueue"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3944
#: include/linux/netdevice.h:3958 include/linux/netdevice.h:3971
#: include/linux/netdevice.h:3999
msgid "sub queue index"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3945
msgid ""
"Start individual transmit queue of a device with multiple transmit queues."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3956
msgid "stop sending packets on subqueue"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3959
msgid ""
"Stop individual transmit queue of a device with multiple transmit queues."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3969
#: include/linux/netdevice.h:3984
msgid "test status of subqueue"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3972
#: include/linux/netdevice.h:3987
msgid ""
"Check individual transmit queue of a device with multiple transmit queues."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:3986
msgid "sub queue buffer pointer"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4000
msgid ""
"Resume individual transmit queue of a device with multiple transmit queues."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4017
msgid "Test a CPU or Rx queue set in a mask"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4023
#: include/linux/netdevice.h:4039
msgid "``unsigned long j``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4018
#: include/linux/netdevice.h:4034 include/linux/netdevice.h:4054
#: include/linux/netdevice.h:4076
msgid "CPU/Rx queue index"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4020
msgid "``const unsigned long *mask``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4019
msgid "bitmask of all cpus/rx queues"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4021
#: include/linux/netdevice.h:4037 include/linux/netdevice.h:4057
#: include/linux/netdevice.h:4080
msgid "``unsigned int nr_bits``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4020
#: include/linux/netdevice.h:4036 include/linux/netdevice.h:4056
#: include/linux/netdevice.h:4079
msgid "number of bits in the bitmask"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4021
msgid "Test if a CPU or Rx queue index is set in a mask of all CPU/Rx queues."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4033
msgid "Test for online CPU/Rx queue"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4036
msgid "``const unsigned long *online_mask``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4035
msgid "bitmask for CPUs/Rx queues that are online"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4038
msgid "true if a CPU/Rx queue is online."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4053
msgid "get the next CPU/Rx queue in a cpu/Rx queues mask"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4059
#: include/linux/netdevice.h:4081
msgid "``int n``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4056
msgid "``const unsigned long *srcp``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4055
msgid "the cpumask/Rx queue mask pointer"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4058
msgid ""
"next (after n) CPU/Rx queue index in the mask; >= nr_bits if no further CPUs/"
"Rx queues set."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4075
msgid "get the next CPU/Rx queue in \\*src1p & \\*src2p"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4078
msgid "``const unsigned long *src1p``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4077
msgid "the first CPUs/Rx queues mask pointer"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4079
msgid "``const unsigned long *src2p``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4078
msgid "the second CPUs/Rx queues mask pointer"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4081
msgid ""
"next (after n) CPU/Rx queue index set in both masks; >= nr_bits if no "
"further CPUs/Rx queues set in both."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4118
msgid "test if device has multiple transmit queues"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4120
msgid "Check if device has multiple transmit queues"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4418
msgid "get reference to device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4420
msgid ""
"Hold reference to device to keep it from being freed. Try using "
"netdev_hold() instead."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4430
msgid "release reference to device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4432
msgid ""
"Release reference to device to allow it to be freed. Try using netdev_put() "
"instead."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4469
msgid "sync linkwatch for the given device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4470
msgid "network device to sync linkwatch for"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4471
msgid ""
"Sync linkwatch for the given device, removing it from the pending work list "
"(if queued)."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4479
msgid "test if carrier present"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4481
msgid "Check if carrier is present on device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4498
msgid "mark device as dormant."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4500
msgid "Mark device as dormant (as per RFC2863)."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4502
msgid ""
"The dormant state indicates that the relevant interface is not actually in a "
"condition to pass packets (i.e., it is not 'up') but is in a \"pending\" "
"state, waiting for some external event.  For \"on- demand\" interfaces, this "
"new state identifies the situation where the interface is waiting for events "
"to place it in the up state."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4516
msgid "set device as not dormant."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4518
msgid "Device is not in dormant state."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4528
msgid "test if device is dormant"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4530
msgid "Check if device is dormant."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4540
msgid "mark device as under test."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4542
msgid "Mark device as under test (as per RFC2863)."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4544
msgid ""
"The testing state indicates that some test(s) must be performed on the "
"interface. After completion, of the test, the interface state will change to "
"up, dormant, or down, as appropriate."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4556
msgid "set device as not under test."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4558
msgid "Device is not in testing state."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4568
msgid "test if device is under test"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4570
msgid "Check if device is under test"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4580
msgid "test if device is operational"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4582
msgid "Check if carrier is operational"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4594
msgid "is device available or removed"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4596
msgid "Check if device has not been removed from system."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4760
msgid "grab network device transmit lock"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4762
msgid "Get network device transmit lock"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4943
msgid "Synchronize device's unicast list"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4944
#: include/linux/netdevice.h:4962 include/linux/netdevice.h:4988
#: include/linux/netdevice.h:5006
msgid "device to sync"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4946
#: include/linux/netdevice.h:4990
msgid "``int (*sync)(struct net_device *, const unsigned char *)``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4945
#: include/linux/netdevice.h:4989
msgid "function to call if address should be added"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4947
#: include/linux/netdevice.h:4964 include/linux/netdevice.h:4991
#: include/linux/netdevice.h:5008
msgid "``int (*unsync)(struct net_device *, const unsigned char *)``"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4946
#: include/linux/netdevice.h:4963 include/linux/netdevice.h:4990
#: include/linux/netdevice.h:5007
msgid "function to call if address should be removed"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4947
#: include/linux/netdevice.h:4991
msgid ""
"Add newly added addresses to the interface, and release addresses that have "
"been deleted."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4961
#: include/linux/netdevice.h:5005
msgid "Remove synchronized addresses from device"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4964
msgid "Remove all addresses that were added to the device by dev_uc_sync()."
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:4987
msgid "Synchronize device's multicast list"
msgstr ""

#: ../../../networking/kapi:104: include/linux/netdevice.h:5008
msgid "Remove all addresses that were added to the device by dev_mc_sync()."
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:33
msgid ""
"represents a shaping node on the NIC H/W zeroed field are considered not set."
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:35
#: ../../../networking/kapi:125: include/linux/phy.h:388
msgid "``parent``"
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:36
msgid "Unique identifier for the shaper parent, usually implied"
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:36
msgid "``handle``"
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:37
msgid "Unique identifier for this shaper"
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:37
msgid "``metric``"
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:38
msgid "Specify if the rate limits refers to PPS or BPS"
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:38
msgid "``bw_min``"
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:39
msgid "Minimum guaranteed rate for this shaper"
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:39
msgid "``bw_max``"
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:40
msgid "Maximum peak rate allowed for this shaper"
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:40
msgid "``burst``"
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:41
msgid "Maximum burst for the peek rate of this shaper"
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:42
msgid "Scheduling priority for this shaper"
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:42
msgid "``weight``"
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:43
msgid "Scheduling weight for this shaper"
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:60
msgid "Operations on device H/W shapers"
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:78
msgid "create the specified shapers scheduling group"
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:80
msgid ""
"Nest the **leaves** shapers identified under the * **node** shaper. All the "
"shapers belong to the device specified by **binding**. The **leaves** arrays "
"size is specified by **leaves_count**. Create either the **leaves** and the "
"**node** shaper; or if they already exists, links them together in the "
"desired way. **leaves** scope must be NET_SHAPER_SCOPE_QUEUE."
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:92
msgid "``set``"
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:93
msgid "Updates the specified shaper"
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:95
msgid ""
"Updates or creates the **shaper** on the device specified by **binding**."
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:101
msgid "``delete``"
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:102
msgid "Removes the specified shaper"
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:104
msgid ""
"Removes the shaper configuration as identified by the given **handle** on "
"the device specified by **binding**, restoring the default behavior."
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:111
msgid "``capabilities``"
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:112
msgid "get the shaper features supported by the device"
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:114
msgid ""
"Fills the bitmask **cap** with the supported capabilities for the specified "
"**scope** and device specified by **binding**."
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:61
msgid ""
"The operations applies to either net_device and devlink objects. The initial "
"shaping configuration at device initialization is empty: does not constraint "
"the rate in any way. The network core keeps track of the applied user-"
"configuration in the net_device or devlink structure. The operations are "
"serialized via a per device lock."
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:68
msgid ""
"Device not supporting any kind of nesting should not provide the group "
"operation."
msgstr ""

#: ../../../networking/kapi:107: include/net/net_shaper.h:71
msgid ""
"Each shaper is uniquely identified within the device with a 'handle' "
"comprising the shaper scope and a scope-specific id."
msgstr ""

#: ../../../networking/kapi.rst:111
msgid "PHY Support"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:116
msgid "Convenience function to print out the current phy status"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:122
#: drivers/net/phy/phy.c:141 drivers/net/phy/phy.c:184
#: drivers/net/phy/phy.c:204 drivers/net/phy/phy.c:307
#: drivers/net/phy/phy.c:522 drivers/net/phy/phy.c:544
#: drivers/net/phy/phy.c:563 drivers/net/phy/phy.c:589
#: drivers/net/phy/phy.c:845 drivers/net/phy/phy.c:914
#: drivers/net/phy/phy.c:1042 drivers/net/phy/phy.c:1063
#: drivers/net/phy/phy.c:1091 drivers/net/phy/phy.c:1123
#: drivers/net/phy/phy.c:1223 drivers/net/phy/phy.c:1271
#: drivers/net/phy/phy.c:1305 drivers/net/phy/phy.c:1357
#: drivers/net/phy/phy.c:1449 drivers/net/phy/phy.c:1478
#: drivers/net/phy/phy.c:1636 drivers/net/phy/phy.c:1680
#: drivers/net/phy/phy.c:1714 drivers/net/phy/phy.c:1728
#: drivers/net/phy/phy.c:1815 drivers/net/phy/phy.c:1835
#: drivers/net/phy/phy.c:1856 drivers/net/phy/phy.c:1886
#: drivers/net/phy/phy.c:1908 drivers/net/phy/phy.c:1967
#: drivers/net/phy/phy.c:1999 drivers/net/phy/phy.c:2021
#: ../../../networking/kapi:116: drivers/net/phy/phy.c:168
#: drivers/net/phy/phy.c:255 drivers/net/phy/phy.c:472
#: drivers/net/phy/phy.c:489 drivers/net/phy/phy.c:509
#: drivers/net/phy/phy.c:610 drivers/net/phy/phy.c:632
#: drivers/net/phy/phy.c:653 drivers/net/phy/phy.c:684
#: drivers/net/phy/phy.c:713 drivers/net/phy/phy.c:814
#: drivers/net/phy/phy.c:1000 drivers/net/phy/phy.c:1321
#: drivers/net/phy/phy.c:1372 drivers/net/phy/phy.c:1423
#: drivers/net/phy/phy.c:1432 drivers/net/phy/phy.c:1492
#: drivers/net/phy/phy.c:1932 ../../../networking/kapi:119:
#: drivers/net/phy/phy-core.c:176 drivers/net/phy/phy-core.c:266
#: drivers/net/phy/phy-core.c:288 drivers/net/phy/phy-core.c:413
#: drivers/net/phy/phy-core.c:435 drivers/net/phy/phy-core.c:456
#: drivers/net/phy/phy-core.c:479 drivers/net/phy/phy-core.c:501
#: drivers/net/phy/phy-core.c:526 drivers/net/phy/phy-core.c:547
#: drivers/net/phy/phy-core.c:570 drivers/net/phy/phy-core.c:602
#: drivers/net/phy/phy-core.c:629 drivers/net/phy/phy-core.c:652
#: drivers/net/phy/phy-core.c:693 drivers/net/phy/phy-core.c:708
#: drivers/net/phy/phy-core.c:737 drivers/net/phy/phy-core.c:776
#: drivers/net/phy/phy-core.c:796 drivers/net/phy/phy-core.c:817
#: drivers/net/phy/phy-core.c:840 ../../../networking/kapi:122:
#: drivers/net/phy/phy-c45.c:55 drivers/net/phy/phy-c45.c:69
#: drivers/net/phy/phy-c45.c:83 drivers/net/phy/phy-c45.c:113
#: drivers/net/phy/phy-c45.c:266 drivers/net/phy/phy-c45.c:318
#: drivers/net/phy/phy-c45.c:339 drivers/net/phy/phy-c45.c:359
#: drivers/net/phy/phy-c45.c:393 drivers/net/phy/phy-c45.c:418
#: drivers/net/phy/phy-c45.c:520 drivers/net/phy/phy-c45.c:575
#: drivers/net/phy/phy-c45.c:603 drivers/net/phy/phy-c45.c:653
#: drivers/net/phy/phy-c45.c:900 drivers/net/phy/phy-c45.c:943
#: drivers/net/phy/phy-c45.c:959 drivers/net/phy/phy-c45.c:997
#: drivers/net/phy/phy-c45.c:1070 drivers/net/phy/phy-c45.c:1165
#: drivers/net/phy/phy-c45.c:1204 drivers/net/phy/phy-c45.c:1249
#: drivers/net/phy/phy-c45.c:1284 drivers/net/phy/phy-c45.c:1337
#: drivers/net/phy/phy-c45.c:1452 drivers/net/phy/phy-c45.c:1475
#: drivers/net/phy/phy-c45.c:1507 drivers/net/phy/phy-c45.c:1532
#: ../../../networking/kapi:125: include/linux/phy.h:1336
#: include/linux/phy.h:1356 include/linux/phy.h:1365 include/linux/phy.h:1376
#: include/linux/phy.h:1392 include/linux/phy.h:1420 include/linux/phy.h:1432
#: include/linux/phy.h:1447 include/linux/phy.h:1461 include/linux/phy.h:1554
#: include/linux/phy.h:1567 include/linux/phy.h:1581 include/linux/phy.h:1592
#: include/linux/phy.h:1603 include/linux/phy.h:1619 include/linux/phy.h:1635
#: include/linux/phy.h:1649 include/linux/phy.h:1663 include/linux/phy.h:1675
#: include/linux/phy.h:1692 include/linux/phy.h:1701 include/linux/phy.h:1710
#: include/linux/phy.h:1720 include/linux/phy.h:1754 include/linux/phy.h:1769
#: include/linux/phy.h:1803 include/linux/phy.h:1813
#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:559
#: drivers/net/phy/phy_device.c:1148 drivers/net/phy/phy_device.c:1187
#: drivers/net/phy/phy_device.c:1209 drivers/net/phy/phy_device.c:1256
#: drivers/net/phy/phy_device.c:1329 drivers/net/phy/phy_device.c:1588
#: drivers/net/phy/phy_device.c:1615 drivers/net/phy/phy_device.c:1830
#: drivers/net/phy/phy_device.c:1966 drivers/net/phy/phy_device.c:2078
#: drivers/net/phy/phy_device.c:2179 drivers/net/phy/phy_device.c:2191
#: drivers/net/phy/phy_device.c:2221 drivers/net/phy/phy_device.c:2278
#: drivers/net/phy/phy_device.c:2326 drivers/net/phy/phy_device.c:2342
#: drivers/net/phy/phy_device.c:2442 drivers/net/phy/phy_device.c:2472
#: drivers/net/phy/phy_device.c:2523 drivers/net/phy/phy_device.c:2587
#: drivers/net/phy/phy_device.c:2639 drivers/net/phy/phy_device.c:2754
#: drivers/net/phy/phy_device.c:2778 drivers/net/phy/phy_device.c:2795
#: drivers/net/phy/phy_device.c:2811 drivers/net/phy/phy_device.c:2839
#: drivers/net/phy/phy_device.c:2856 drivers/net/phy/phy_device.c:2870
#: drivers/net/phy/phy_device.c:2882 drivers/net/phy/phy_device.c:2906
#: drivers/net/phy/phy_device.c:2930 drivers/net/phy/phy_device.c:2955
#: drivers/net/phy/phy_device.c:2993 drivers/net/phy/phy_device.c:3072
#: drivers/net/phy/phy_device.c:3096 ../../../networking/kapi:131:
#: drivers/net/phy/phy_device.c:274 drivers/net/phy/phy_device.c:1241
#: drivers/net/phy/phy_device.c:1348 drivers/net/phy/phy_device.c:1992
#: drivers/net/phy/phy_device.c:2044
msgid "``struct phy_device *phydev``"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:117
#: drivers/net/phy/phy.c:302 drivers/net/phy/phy.c:518
#: drivers/net/phy/phy.c:540 drivers/net/phy/phy.c:559
#: drivers/net/phy/phy.c:585 drivers/net/phy/phy.c:841
#: drivers/net/phy/phy.c:910 drivers/net/phy/phy.c:1058
#: drivers/net/phy/phy.c:1086 drivers/net/phy/phy.c:1118
#: drivers/net/phy/phy.c:1218 drivers/net/phy/phy.c:1266
#: drivers/net/phy/phy.c:1300 ../../../networking/kapi:116:
#: drivers/net/phy/phy.c:163 drivers/net/phy/phy.c:505
#: drivers/net/phy/phy.c:648 drivers/net/phy/phy.c:679
#: drivers/net/phy/phy.c:708 drivers/net/phy/phy.c:809
#: drivers/net/phy/phy.c:995 ../../../networking/kapi:119:
#: drivers/net/phy/phy-core.c:496 drivers/net/phy/phy-core.c:521
#: drivers/net/phy/phy-core.c:542 drivers/net/phy/phy-core.c:565
#: drivers/net/phy/phy-core.c:597 drivers/net/phy/phy-core.c:624
#: drivers/net/phy/phy-core.c:647 ../../../networking/kapi:125:
#: include/linux/phy.h:1387 include/linux/phy.h:1415 include/linux/phy.h:1427
#: include/linux/phy.h:1442 include/linux/phy.h:1549 include/linux/phy.h:1562
#: include/linux/phy.h:1576 include/linux/phy.h:1587 include/linux/phy.h:1599
#: include/linux/phy.h:1615 include/linux/phy.h:1631 include/linux/phy.h:1645
#: include/linux/phy.h:1658 include/linux/phy.h:1671 include/linux/phy.h:1687
#: include/linux/phy.h:1696 include/linux/phy.h:1706 include/linux/phy.h:1715
#: include/linux/phy.h:1764 include/linux/phy.h:1799 include/linux/phy.h:1809
msgid "the phy_device struct"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:135
msgid "determine if rate matching is supported"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:136
msgid "The phy device to return rate matching for"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:138
#: ../../../networking/kapi:147: include/linux/phylink.h:250
#: include/linux/phylink.h:350 ../../../networking/kapi:150:
#: drivers/net/phy/phylink.c:1821
msgid "``phy_interface_t iface``"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:137
msgid "The interface mode to use"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:138
msgid ""
"This determines the type of rate matching (if any) that **phy** supports "
"using **iface**. **iface** may be ``PHY_INTERFACE_MODE_NA`` to determine if "
"any interface supports rate matching."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:143
msgid ""
"The type of rate matching **phy** supports for **iface**, or "
"``RATE_MATCH_NONE``."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:178
msgid "restart auto-negotiation"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:179
#: drivers/net/phy/phy.c:199 drivers/net/phy/phy.c:1352
#: drivers/net/phy/phy.c:1444 drivers/net/phy/phy.c:1473
#: drivers/net/phy/phy.c:1631 drivers/net/phy/phy.c:1675
#: drivers/net/phy/phy.c:1723 drivers/net/phy/phy.c:1810
#: drivers/net/phy/phy.c:1830 drivers/net/phy/phy.c:1851
#: drivers/net/phy/phy.c:1881 drivers/net/phy/phy.c:1903
#: drivers/net/phy/phy.c:1962 drivers/net/phy/phy.c:1995
#: drivers/net/phy/phy.c:2017 ../../../networking/kapi:116:
#: drivers/net/phy/phy.c:1316 drivers/net/phy/phy.c:1367
#: drivers/net/phy/phy.c:1418 ../../../networking/kapi:122:
#: drivers/net/phy/phy-c45.c:50 drivers/net/phy/phy-c45.c:64
#: drivers/net/phy/phy-c45.c:79 drivers/net/phy/phy-c45.c:108
#: drivers/net/phy/phy-c45.c:261 drivers/net/phy/phy-c45.c:313
#: drivers/net/phy/phy-c45.c:334 drivers/net/phy/phy-c45.c:354
#: drivers/net/phy/phy-c45.c:388 drivers/net/phy/phy-c45.c:413
#: drivers/net/phy/phy-c45.c:515 drivers/net/phy/phy-c45.c:571
#: drivers/net/phy/phy-c45.c:598 drivers/net/phy/phy-c45.c:648
#: drivers/net/phy/phy-c45.c:895 drivers/net/phy/phy-c45.c:938
#: drivers/net/phy/phy-c45.c:954 drivers/net/phy/phy-c45.c:992
#: drivers/net/phy/phy-c45.c:1065 drivers/net/phy/phy-c45.c:1160
#: drivers/net/phy/phy-c45.c:1199 drivers/net/phy/phy-c45.c:1244
#: drivers/net/phy/phy-c45.c:1279 drivers/net/phy/phy-c45.c:1332
#: drivers/net/phy/phy-c45.c:1447 drivers/net/phy/phy-c45.c:1470
#: drivers/net/phy/phy-c45.c:1502 drivers/net/phy/phy-c45.c:1527
#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:554
#: drivers/net/phy/phy_device.c:1325 drivers/net/phy/phy_device.c:1825
#: drivers/net/phy/phy_device.c:1961 drivers/net/phy/phy_device.c:2073
#: drivers/net/phy/phy_device.c:2174 drivers/net/phy/phy_device.c:2186
#: drivers/net/phy/phy_device.c:2216 drivers/net/phy/phy_device.c:2273
#: drivers/net/phy/phy_device.c:2321 drivers/net/phy/phy_device.c:2337
#: drivers/net/phy/phy_device.c:2437 drivers/net/phy/phy_device.c:2467
#: drivers/net/phy/phy_device.c:2518 drivers/net/phy/phy_device.c:2582
#: drivers/net/phy/phy_device.c:2634 drivers/net/phy/phy_device.c:2773
#: drivers/net/phy/phy_device.c:2790 drivers/net/phy/phy_device.c:2851
#: drivers/net/phy/phy_device.c:2865 drivers/net/phy/phy_device.c:2877
#: drivers/net/phy/phy_device.c:2901 ../../../networking/kapi:131:
#: drivers/net/phy/phy_device.c:1236 drivers/net/phy/phy_device.c:1987
#: drivers/net/phy/phy_device.c:2039
msgid "target phy_device struct"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:180
msgid ""
"Restart the autonegotiation on **phydev**.  Returns >= 0 on success or "
"negative errno on error."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:198
#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2320
msgid "return auto-negotiation status"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:201
msgid ""
"Return the auto-negotiation status from this **phydev** Returns > 0 on "
"success or < 0 on error. 0 means that auto-negotiation is still pending."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:234
msgid ""
"check if there is a valid PHY setting which matches speed, duplex, and "
"feature mask"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:240
#: drivers/net/phy/phy.c:1726 ../../../networking/kapi:119:
#: drivers/net/phy/phy-core.c:20 ../../../networking/kapi:125:
#: include/linux/phy.h:301 ../../../networking/kapi:147:
#: include/linux/phylink.h:389 include/linux/phylink.h:634
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:404
msgid "``int speed``"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:236
msgid "speed to match"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:238
#: ../../../networking/kapi:147: include/linux/phylink.h:390
#: include/linux/phylink.h:635
msgid "``int duplex``"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:237
msgid "duplex to match"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:239
msgid "``unsigned long *features``"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:238
msgid "A mask of the valid settings"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:240
msgid "Returns true if there is a valid setting, false otherwise."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:301
msgid "generic PHY MII ioctl interface"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:304
#: drivers/net/phy/phy.c:435 drivers/net/phy/phy.c:451
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3418
msgid "``struct ifreq *ifr``"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:303
#: drivers/net/phy/phy.c:434 drivers/net/phy/phy.c:450
msgid ":c:type:`struct ifreq <ifreq>` for socket ioctl's"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:305
#: drivers/net/phy/phy.c:436 drivers/net/phy/phy.c:452
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3419
msgid "``int cmd``"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:304
#: drivers/net/phy/phy.c:435 drivers/net/phy/phy.c:451
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3418
msgid "ioctl cmd to execute"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:305
msgid ""
"Note that this function is currently incompatible with the PHYCONTROL "
"layer.  It changes registers without regard to current state.  Use at own "
"risk."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:432
msgid "generic ndo_eth_ioctl implementation"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:433
#: drivers/net/phy/phy.c:449
msgid "the net_device struct"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:447
msgid "generic ndo_eth_ioctl implementation but test first"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:452
msgid ""
"Same as phy_do_ioctl, but ensures that net_device is running before handling "
"the ioctl."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:516
msgid "Trigger the state machine to run now"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:538
msgid "Get the statistic counter names"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:542
#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:499
msgid "``u8 *data``"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:541
msgid "Where to put the strings"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:557
msgid "Get the number of statistic counters"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:583
msgid "Get the statistic counters"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:587
msgid "``struct ethtool_stats *stats``"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:586
msgid "What counters to get"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:588
msgid "``u64 *data``"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:587
msgid "Where to store the counters"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:839
#: ../../../networking/kapi:125: include/linux/phy.h:1096
msgid "Start a cable test"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:842
#: drivers/net/phy/phy.c:911 ../../../networking/kapi:116:
#: drivers/net/phy/phy.c:681 drivers/net/phy/phy.c:710
msgid "extack for reporting useful error messages"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:908
#: ../../../networking/kapi:125: include/linux/phy.h:1099
msgid "Start a raw TDR cable test"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:913
msgid "``const struct phy_tdr_config *config``"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:912
msgid "Configuration of the test to run"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1036
msgid "query which in-band signalling modes are supported"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1037
#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:688
#: drivers/net/phy/phy-core.c:703 drivers/net/phy/phy-core.c:732
#: drivers/net/phy/phy-core.c:771 drivers/net/phy/phy-core.c:791
#: drivers/net/phy/phy-core.c:812 drivers/net/phy/phy-core.c:835
#: ../../../networking/kapi:125: include/linux/phy.h:1456
msgid "a pointer to a :c:type:`struct phy_device <phy_device>`"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1039
#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:111
#: ../../../networking/kapi:125: include/linux/phy.h:209
#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1258
#: drivers/net/phy/phy_device.c:1286 drivers/net/phy/phy_device.c:1617
#: drivers/net/phy/phy_device.c:1790 ../../../networking/kapi:147:
#: include/linux/phylink.h:221 include/linux/phylink.h:233
#: include/linux/phylink.h:367 include/linux/phylink.h:388
#: include/linux/phylink.h:540 include/linux/phylink.h:586
#: include/linux/phylink.h:633 include/linux/phylink.h:761
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:230
#: drivers/net/phy/phylink.c:428 drivers/net/phy/phylink.c:1065
#: drivers/net/phy/phylink.c:4145 drivers/net/phy/phylink.c:4182
msgid "``phy_interface_t interface``"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1038
msgid "the interface mode for the PHY"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1039
msgid ""
"Returns zero if it is unknown what in-band signalling is supported by the "
"PHY (e.g. because the PHY driver doesn't implement the method.) Otherwise, "
"returns a bit mask of the LINK_INBAND_* values from :c:type:`enum "
"link_inband_signalling <link_inband_signalling>` to describe which inband "
"modes are supported by the PHY for this interface mode."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1057
msgid "configure the desired PHY in-band mode"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1060
msgid "``unsigned int modes``"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1059
msgid "in-band modes to configure"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1061
msgid "disables, enables or enables-with-bypass in-band signalling"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1062
msgid "between the PHY and host system."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1064
msgid "zero on success, or negative errno value."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1085
#: drivers/net/phy/phy.c:1117
msgid "start auto-negotiation for this PHY device"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1088
#: drivers/net/phy/phy.c:1120
msgid "Sanitizes the settings (if we're not autonegotiating"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1089
#: drivers/net/phy/phy.c:1121
msgid ""
"them), and then calls the driver's config_aneg function. If the PHYCONTROL "
"Layer is operating, we change the state to reflect the beginning of Auto-"
"negotiation or forcing."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1217
msgid "set speed to lowest speed supported by both link partners"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1220
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3497
msgid "``bool sync``"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1219
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3496
msgid "perform action synchronously"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1221
msgid "Typically used to save energy when waiting for a WoL packet"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1223
msgid ""
"WARNING: Setting sync to false may cause the system being unable to suspend "
"in case the PHY generates an interrupt when finishing the autonegotiation. "
"This interrupt may wake up the system immediately after suspend. Therefore "
"use sync = false only if you're sure it's safe with the respective network "
"chip."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1265
msgid "(re)set advertised speeds to all supported speeds"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1268
msgid "Used to revert the effect of phy_speed_down"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1299
msgid "start PHY state machine tracking"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1302
msgid "The PHY infrastructure can run a state machine"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1303
msgid ""
"which tracks whether the PHY is starting up, negotiating, etc.  This "
"function starts the delayed workqueue which tracks the state of the PHY. If "
"you want to maintain your own state machine, do not call this function."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1351
msgid "enter ERROR state for this PHY device"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1353
msgid ""
"Moves the PHY to the ERROR state in response to a read or write error, and "
"tells the controller the link is down. Must be called with phydev->lock held."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1443
msgid "request and enable interrupt for a PHY device"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1446
msgid "Request and enable the interrupt for the given PHY."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1447
msgid ""
"If this fails, then we set irq to PHY_POLL. This should only be called with "
"a valid IRQ number."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1472
msgid "disable and free interrupt for a PHY device"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1475
msgid "Disable and free the interrupt for the given PHY."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1476
msgid "This should only be called with a valid IRQ number."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1630
msgid "Bring down the PHY link, and stop checking the status"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1674
msgid "start or restart a PHY device"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1677
msgid "Indicates the attached device's readiness to"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1678
msgid ""
"handle PHY-related work.  Used during startup to start the PHY, and after a "
"call to phy_stop() to resume operation. Also used to indicate the MDIO bus "
"has cleared an error condition."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1708
msgid "MAC says the link has changed"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1709
msgid "phy_device struct with changed link"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1710
msgid ""
"The MAC layer is able to indicate there has been a change in the PHY link "
"status. Trigger the state machine and work a work queue."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1722
msgid "Configure loopback mode of PHY"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1725
#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1246
msgid "``bool enable``"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1724
msgid "enable or disable loopback mode"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1725
msgid "enable loopback mode with speed"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1726
msgid ""
"Configure loopback mode of PHY and signal link down and link up if speed is "
"changing."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1730
msgid "0 on success, negative error code on failure."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1809
msgid "indicate whether the MAC can stop tx clock"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1811
msgid ""
"Indicate whether the MAC can disable the transmit xMII clock while in LPI "
"state. Returns 1 if the MAC may stop the transmit clock, 0 if the MAC must "
"not stop the transmit clock, or negative error."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1829
msgid "configure PHY receive clock in LPI"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1832
#: drivers/net/phy/phy.c:1853
msgid "``bool clk_stop_enable``"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1831
msgid "flag to indicate whether the clock can be stopped"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1832
msgid ""
"Configure whether the PHY can disable its receive clock during LPI mode, See "
"IEEE 802.3 sections 22.2.2.2, 35.2.2.10, and 45.2.3.1.4."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1836
msgid "0 or negative error."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1850
msgid "init and check the EEE feature"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1852
msgid "PHY may stop the clock during LPI"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1854
msgid ""
"it checks if the Energy-Efficient Ethernet (EEE) is supported by looking at "
"the MMD registers 3.20 and 7.60/61 and it programs the MMD register 3.0 "
"setting the \"Clock stop enable\" bit if required."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1880
msgid "report the EEE wake error count"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1883
msgid ""
"it is to report the number of time where the PHY failed to complete its "
"normal wake sequence."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1902
#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1501
msgid "get EEE supported and status"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1905
#: drivers/net/phy/phy.c:1964 ../../../networking/kapi:122:
#: drivers/net/phy/phy-c45.c:1504 drivers/net/phy/phy-c45.c:1529
msgid "``struct ethtool_keee *data``"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1904
#: drivers/net/phy/phy.c:1963 ../../../networking/kapi:122:
#: drivers/net/phy/phy-c45.c:1503 drivers/net/phy/phy-c45.c:1528
msgid "ethtool_keee data"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1906
msgid "get the current EEE settings, filling in all members of **data**."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1961
#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1526
msgid "set EEE supported and status"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1965
msgid "it is to program the Advertisement EEE register."
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1993
msgid "Configure Wake On LAN"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1997
#: drivers/net/phy/phy.c:2019 ../../../networking/kapi:150:
#: drivers/net/phy/phylink.c:2680 drivers/net/phy/phylink.c:2701
msgid "``struct ethtool_wolinfo *wol``"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:1996
msgid "Configuration requested"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:2015
msgid "Get the current Wake On LAN configuration"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:2018
msgid "Store the current configuration here"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:2057
msgid "Restart auto negotiation"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:2063
msgid "``struct net_device *ndev``"
msgstr ""

#: ../../../networking/kapi:113: drivers/net/phy/phy.c:2058
msgid "Network device to restart autoneg for"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:162
msgid "configure the PHY device for the requested interrupts"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:165
msgid "``bool interrupts``"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:164
msgid "interrupt flags to configure for this **phydev**"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:165
msgid "Returns 0 on success or < 0 on error."
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:217
msgid "return all speeds currently supported by a phy device"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:223
#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1509
#: drivers/net/phy/phy_device.c:1531 ../../../networking/kapi:147:
#: include/linux/phylink.h:386 ../../../networking/kapi:150:
#: drivers/net/phy/phylink.c:2210
msgid "``struct phy_device *phy``"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:218
msgid "The phy device to return supported speeds of."
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:220
msgid "``unsigned int *speeds``"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:219
msgid "buffer to store supported speeds in."
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:220
msgid "size of speeds buffer."
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:222
msgid ""
"Returns the number of supported speeds, and fills the speeds buffer with the "
"supported speeds. If speeds buffer is too small to contain all currently "
"supported speeds, will return as many speeds as can fit."
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:249
msgid "make sure the PHY is set to supported speed and duplex"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:250
msgid "the target phy_device struct"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:252
msgid "Make sure the PHY is set to supported speeds and"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:253
msgid ""
"duplexes.  Drop down by one in this order:  1000/FULL, 1000/HALF, 100/FULL, "
"100/HALF, 10/FULL, 10/HALF."
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:466
msgid "Get hardware timestamping configuration from PHY"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:468
#: drivers/net/phy/phy.c:485
msgid "the PHY device structure"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:470
#: drivers/net/phy/phy.c:487
msgid "``struct kernel_hwtstamp_config *config``"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:469
#: drivers/net/phy/phy.c:486
msgid "structure holding the timestamping configuration"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:470
msgid ""
"Query the PHY device for its current hardware timestamping configuration."
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:483
msgid "Modify PHY hardware timestamping configuration"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:487
msgid "netlink extended ack structure, for error reporting"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:503
msgid "Trigger the state machine to run soon"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:507
msgid "``unsigned long jiffies``"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:506
msgid "Run the state machine after these jiffies"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:604
msgid "Retrieve standardized PHY statistics"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:605
#: drivers/net/phy/phy.c:627
msgid "Pointer to the PHY device"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:607
msgid "``struct ethtool_eth_phy_stats *phy_stats``"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:606
msgid "Pointer to ethtool_eth_phy_stats structure"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:608
msgid "``struct ethtool_phy_stats *phydev_stats``"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:607
msgid "Pointer to ethtool_phy_stats structure"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:608
msgid ""
"Fetches PHY statistics using a kernel-defined interface for consistent "
"diagnostics. Unlike phy_ethtool_get_stats(), which allows custom stats, this "
"function enforces a standardized format for better interoperability."
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:626
msgid "Retrieve extended link statistics for a PHY"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:629
msgid "``struct ethtool_link_ext_stats *link_stats``"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:628
msgid "Pointer to the structure to store extended link statistics"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:629
msgid ""
"Populates the ethtool_link_ext_stats structure with link down event counts "
"and additional driver-specific link statistics, if available."
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:647
msgid "Get PLCA RS configuration"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:650
#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1281
msgid "``struct phy_plca_cfg *plca_cfg``"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:649
msgid "where to store the retrieved configuration"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:650
msgid ""
"Retrieve the PLCA configuration from the PHY. Return 0 on success or a "
"negative value if an error occurred."
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:678
msgid "Check PLCA configuration before enabling"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:681
#: drivers/net/phy/phy.c:710 ../../../networking/kapi:122:
#: drivers/net/phy/phy-c45.c:1334
msgid "``const struct phy_plca_cfg *plca_cfg``"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:680
msgid "current PLCA configuration"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:682
msgid ""
"Checks whether the PLCA and PHY configuration are consistent and it is safe "
"to enable PLCA. Returns 0 on success or a negative value if the PLCA or PHY "
"configuration is not consistent."
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:707
msgid "Set PLCA RS configuration"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:709
msgid "new PLCA configuration to apply"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:711
msgid ""
"Sets the PLCA configuration in the PHY. Return 0 on success or a negative "
"value if an error occurred."
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:808
msgid "Get PLCA RS status information"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:811
#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1449
msgid "``struct phy_plca_status *plca_st``"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:810
msgid "where to store the retrieved status information"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:811
msgid ""
"Retrieve the PLCA status information from the PHY. Return 0 on success or a "
"negative value if an error occurred."
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:994
msgid "check link status and set state accordingly"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:997
msgid ""
"Check for link and whether autoneg was triggered / is running and set state "
"accordingly"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1315
msgid "stop the PHY state machine tracking"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1318
msgid "Stops the state machine delayed workqueue, sets the"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1319
msgid ""
"state to UP (unless it wasn't up yet). This function must be called BEFORE "
"phy_detach."
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1366
msgid "Disable the PHY interrupts from the PHY side"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1376
msgid "PHY interrupt handler"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1382
msgid "``int irq``"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1377
msgid "interrupt line"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1379
msgid "``void *phy_dat``"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1378
msgid "phy_device pointer"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1380
msgid "Handle PHY interrupt"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1417
msgid "Enable the interrupts from the PHY side"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1426
msgid "Update PHY device statistics if supported."
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1427
msgid "Pointer to the PHY device structure."
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1428
msgid ""
"If the PHY driver provides an update_stats callback, this function invokes "
"it to update the PHY statistics. If not, it returns 0."
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1432
msgid "0 on success, or a negative error code if the callback fails."
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1486
msgid "Determine the next PHY update time"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1487
msgid "Pointer to the phy_device structure"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1488
msgid ""
"This function queries the PHY driver to get the time for the next polling "
"event. If the driver does not implement the callback, a default value is "
"used."
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1493
msgid "The time for the next polling event in jiffies"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1612
msgid "Handle the state machine"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1618
msgid "``struct work_struct *work``"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1613
msgid "work_struct that describes the work to be done"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1926
msgid "Adjusts MAC LPI configuration without PHY renegotiation"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1928
msgid "pointer to the target PHY device structure"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1930
msgid "``const struct eee_config *old_cfg``"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1929
msgid "pointer to the eee_config structure containing the old EEE settings"
msgstr ""

#: ../../../networking/kapi:116: drivers/net/phy/phy.c:1930
msgid ""
"This function updates the Energy Efficient Ethernet (EEE) configuration for "
"cases where only the MAC's Low Power Idle (LPI) configuration changes, "
"without triggering PHY renegotiation. It ensures that the MAC is properly "
"informed of the new LPI settings by cycling the link down and up, which is "
"necessary for the MAC to adopt the new configuration. This adjustment is "
"done only if there is a change in the tx_lpi_enabled or tx_lpi_timer "
"configuration."
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:14
msgid "Return a string representing the PHY link speed"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:16
msgid "Speed of the link"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:67
msgid "Return string describing the duplex"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:73
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:401
msgid "``unsigned int duplex``"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:69
msgid "Duplex setting to describe"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:84
msgid "Return a string describing the rate matching"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:90
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:426
msgid "``int rate_matching``"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:86
msgid "Type of rate matching to describe"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:105
msgid ""
"Return the number of links that can be carried by a given MAC-PHY physical "
"link. Returns 0 if this is unknown, the number of links else."
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:109
msgid "The interface mode we want to get the number of ports"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:170
msgid "Set the maximum speed the PHY should support"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:172
#: drivers/net/phy/phy-core.c:262 drivers/net/phy/phy-core.c:283
#: drivers/net/phy/phy-core.c:409 drivers/net/phy/phy-core.c:431
#: drivers/net/phy/phy-core.c:452 drivers/net/phy/phy-core.c:475
#: ../../../networking/kapi:125: include/linux/phy.h:1351
#: include/linux/phy.h:1361 include/linux/phy.h:1371 include/linux/phy.h:1483
msgid "The phy_device struct"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:174
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:383
msgid "``u32 max_speed``"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:173
msgid "Maximum speed"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:174
msgid ""
"The PHY might be more capable than the MAC. For example a Fast Ethernet is "
"connected to a 1G PHY. This function allows the MAC to indicate its maximum "
"speed, and so limit what the PHY will advertise."
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:260
msgid "Determine pause autoneg results"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:263
msgid ""
"Once autoneg has completed the local pause settings can be resolved.  "
"Determine if pause and asymmetric pause should be used by the MAC."
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:282
msgid "resolve the advertisements into PHY settings"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:284
msgid ""
"Resolve our and the link partner advertisements into their corresponding "
"speed and duplex. If full duplex was negotiated, extract the pause mode from "
"the link partner mask."
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:407
#: drivers/net/phy/phy-core.c:429
msgid "Convenience function for reading a register from an MMD on a given PHY."
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:411
#: drivers/net/phy/phy-core.c:433 drivers/net/phy/phy-core.c:454
#: drivers/net/phy/phy-core.c:477 drivers/net/phy/phy-core.c:567
#: drivers/net/phy/phy-core.c:599 drivers/net/phy/phy-core.c:626
#: drivers/net/phy/phy-core.c:649 ../../../networking/kapi:125:
#: include/linux/phy.h:1601 include/linux/phy.h:1617 include/linux/phy.h:1633
#: include/linux/phy.h:1647 ../../../networking/kapi:134:
#: drivers/net/phy/mdio_bus.c:533 drivers/net/phy/mdio_bus.c:565
#: drivers/net/phy/mdio_bus.c:679 drivers/net/phy/mdio_bus.c:702
#: drivers/net/phy/mdio_bus.c:778 drivers/net/phy/mdio_bus.c:803
#: drivers/net/phy/mdio_bus.c:873 drivers/net/phy/mdio_bus.c:919
#: ../../../networking/kapi:137: drivers/net/phy/mdio_bus.c:599
msgid "``int devad``"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:410
msgid "The MMD to read from (0..31)"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:412
#: drivers/net/phy/phy-core.c:434 drivers/net/phy/phy-core.c:455
#: drivers/net/phy/phy-core.c:478 drivers/net/phy/phy-core.c:498
#: drivers/net/phy/phy-core.c:523 drivers/net/phy/phy-core.c:544
#: drivers/net/phy/phy-core.c:568 drivers/net/phy/phy-core.c:600
#: drivers/net/phy/phy-core.c:627 drivers/net/phy/phy-core.c:650
#: drivers/net/phy/phy-core.c:774 drivers/net/phy/phy-core.c:794
#: drivers/net/phy/phy-core.c:815 drivers/net/phy/phy-core.c:838
#: ../../../networking/kapi:125: include/linux/phy.h:1389
#: include/linux/phy.h:1417 include/linux/phy.h:1429 include/linux/phy.h:1444
#: include/linux/phy.h:1458 include/linux/phy.h:1551 include/linux/phy.h:1564
#: include/linux/phy.h:1578 include/linux/phy.h:1589 include/linux/phy.h:1602
#: include/linux/phy.h:1618 include/linux/phy.h:1634 include/linux/phy.h:1648
#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:438
#: drivers/net/phy/mdio_bus.c:469 drivers/net/phy/mdio_bus.c:501
#: drivers/net/phy/mdio_bus.c:534 drivers/net/phy/mdio_bus.c:566
#: drivers/net/phy/mdio_bus.c:632 drivers/net/phy/mdio_bus.c:657
#: drivers/net/phy/mdio_bus.c:680 drivers/net/phy/mdio_bus.c:703
#: drivers/net/phy/mdio_bus.c:729 drivers/net/phy/mdio_bus.c:755
#: drivers/net/phy/mdio_bus.c:779 drivers/net/phy/mdio_bus.c:804
#: drivers/net/phy/mdio_bus.c:852 drivers/net/phy/mdio_bus.c:874
#: drivers/net/phy/mdio_bus.c:897 drivers/net/phy/mdio_bus.c:920
#: ../../../networking/kapi:137: drivers/net/phy/mdio_bus.c:600
msgid "``u32 regnum``"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:411
msgid "The register on the MMD to read (0..65535)"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:412
msgid "Same rules as for __phy_read();"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:432
#: drivers/net/phy/phy-core.c:453 drivers/net/phy/phy-core.c:476
#: ../../../networking/kapi:125: include/linux/phy.h:1484
msgid "The MMD to read from"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:433
#: drivers/net/phy/phy-core.c:454 drivers/net/phy/phy-core.c:477
#: ../../../networking/kapi:125: include/linux/phy.h:1485
msgid "The register on the MMD to read"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:434
msgid "Same rules as for phy_read();"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:450
#: drivers/net/phy/phy-core.c:473
msgid "Convenience function for writing a register on an MMD on a given PHY."
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:456
#: drivers/net/phy/phy-core.c:479 drivers/net/phy/phy-core.c:795
#: ../../../networking/kapi:125: include/linux/phy.h:1430
#: include/linux/phy.h:1445 include/linux/phy.h:1552 include/linux/phy.h:1565
#: include/linux/phy.h:1579 include/linux/phy.h:1590 include/linux/phy.h:1603
#: include/linux/phy.h:1619 include/linux/phy.h:1635 include/linux/phy.h:1649
#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:470
#: drivers/net/phy/mdio_bus.c:567 drivers/net/phy/mdio_bus.c:730
#: drivers/net/phy/mdio_bus.c:756 drivers/net/phy/mdio_bus.c:780
#: drivers/net/phy/mdio_bus.c:805
msgid "``u16 val``"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:455
#: drivers/net/phy/phy-core.c:478 ../../../networking/kapi:125:
#: include/linux/phy.h:1429 include/linux/phy.h:1444
#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:469
#: drivers/net/phy/mdio_bus.c:566 drivers/net/phy/mdio_bus.c:729
#: drivers/net/phy/mdio_bus.c:755 drivers/net/phy/mdio_bus.c:779
#: drivers/net/phy/mdio_bus.c:804
msgid "value to write to **regnum**"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:456
msgid "Same rules as for __phy_write();"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:479
msgid "Same rules as for phy_write();"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:495
msgid "Function for modifying a PHY register"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:497
#: drivers/net/phy/phy-core.c:522 drivers/net/phy/phy-core.c:567
#: drivers/net/phy/phy-core.c:599 drivers/net/phy/phy-core.c:626
#: drivers/net/phy/phy-core.c:649 ../../../networking/kapi:125:
#: include/linux/phy.h:1601 include/linux/phy.h:1617 include/linux/phy.h:1633
#: include/linux/phy.h:1647 ../../../networking/kapi:134:
#: drivers/net/phy/mdio_bus.c:500 ../../../networking/kapi:137:
#: drivers/net/phy/mdio_bus.c:599
msgid "register number to modify"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:499
#: drivers/net/phy/phy-core.c:524 drivers/net/phy/phy-core.c:545
#: drivers/net/phy/phy-core.c:569 drivers/net/phy/phy-core.c:601
#: drivers/net/phy/phy-core.c:628 drivers/net/phy/phy-core.c:651
#: drivers/net/phy/phy-core.c:816 drivers/net/phy/phy-core.c:839
#: ../../../networking/kapi:125: include/linux/phy.h:1459
#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:502
#: drivers/net/phy/mdio_bus.c:853 drivers/net/phy/mdio_bus.c:875
#: drivers/net/phy/mdio_bus.c:898 drivers/net/phy/mdio_bus.c:921
#: ../../../networking/kapi:137: drivers/net/phy/mdio_bus.c:601
msgid "``u16 mask``"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:498
#: drivers/net/phy/phy-core.c:523 drivers/net/phy/phy-core.c:544
#: drivers/net/phy/phy-core.c:568 drivers/net/phy/phy-core.c:600
#: drivers/net/phy/phy-core.c:627 drivers/net/phy/phy-core.c:650
#: drivers/net/phy/phy-core.c:815 drivers/net/phy/phy-core.c:838
#: ../../../networking/kapi:125: include/linux/phy.h:1458
#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:501
#: drivers/net/phy/mdio_bus.c:852 drivers/net/phy/mdio_bus.c:874
#: drivers/net/phy/mdio_bus.c:897 drivers/net/phy/mdio_bus.c:920
#: ../../../networking/kapi:137: drivers/net/phy/mdio_bus.c:600
msgid "bit mask of bits to clear"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:500
#: drivers/net/phy/phy-core.c:525 drivers/net/phy/phy-core.c:546
#: drivers/net/phy/phy-core.c:570 drivers/net/phy/phy-core.c:602
#: drivers/net/phy/phy-core.c:629 drivers/net/phy/phy-core.c:652
#: drivers/net/phy/phy-core.c:817 drivers/net/phy/phy-core.c:840
#: ../../../networking/kapi:125: include/linux/phy.h:1460
#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:503
#: drivers/net/phy/mdio_bus.c:854 drivers/net/phy/mdio_bus.c:876
#: drivers/net/phy/mdio_bus.c:899 drivers/net/phy/mdio_bus.c:922
#: ../../../networking/kapi:137: drivers/net/phy/mdio_bus.c:602
msgid "``u16 set``"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:499
#: drivers/net/phy/phy-core.c:524 drivers/net/phy/phy-core.c:545
#: drivers/net/phy/phy-core.c:569 drivers/net/phy/phy-core.c:601
#: drivers/net/phy/phy-core.c:628 drivers/net/phy/phy-core.c:651
msgid "new value of bits set in mask to write to **regnum**"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:501
#: drivers/net/phy/phy-core.c:526 drivers/net/phy/phy-core.c:547
#: drivers/net/phy/phy-core.c:603 drivers/net/phy/phy-core.c:630
#: drivers/net/phy/phy-core.c:653 ../../../networking/kapi:125:
#: include/linux/phy.h:1390 include/linux/phy.h:1431 include/linux/phy.h:1660
#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:440
#: drivers/net/phy/mdio_bus.c:472 drivers/net/phy/mdio_bus.c:506
#: drivers/net/phy/mdio_bus.c:536 drivers/net/phy/mdio_bus.c:569
#: drivers/net/phy/mdio_bus.c:635 drivers/net/phy/mdio_bus.c:658
#: drivers/net/phy/mdio_bus.c:681 drivers/net/phy/mdio_bus.c:706
#: drivers/net/phy/mdio_bus.c:733 drivers/net/phy/mdio_bus.c:757
#: drivers/net/phy/mdio_bus.c:781 drivers/net/phy/mdio_bus.c:808
#: ../../../networking/kapi:137: drivers/net/phy/mdio_bus.c:605
msgid "**NOTE**"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:501
#: drivers/net/phy/phy-core.c:526 drivers/net/phy/phy-core.c:547
#: drivers/net/phy/phy-core.c:603 drivers/net/phy/phy-core.c:630
#: drivers/net/phy/phy-core.c:653 ../../../networking/kapi:125:
#: include/linux/phy.h:1390 include/linux/phy.h:1431
#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:636
#: drivers/net/phy/mdio_bus.c:658 drivers/net/phy/mdio_bus.c:681
#: drivers/net/phy/mdio_bus.c:707 drivers/net/phy/mdio_bus.c:734
#: drivers/net/phy/mdio_bus.c:757 drivers/net/phy/mdio_bus.c:781
#: drivers/net/phy/mdio_bus.c:809
msgid ""
"MUST NOT be called from interrupt context, because the bus read/write "
"functions may wait for an interrupt to conclude the operation."
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:505
#: drivers/net/phy/phy-core.c:573 drivers/net/phy/phy-core.c:607
#: drivers/net/phy/phy-core.c:817 ../../../networking/kapi:125:
#: include/linux/phy.h:1463
msgid ""
"Returns negative errno, 0 if there was no change, and 1 in case of change"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:520
#: ../../../networking/kapi:125: include/linux/phy.h:1455
msgid "Convenience function for modifying a PHY register"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:541
msgid "Convenience function for modifying a given PHY register"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:543
#: ../../../networking/kapi:125: include/linux/phy.h:1428
#: include/linux/phy.h:1443 include/linux/phy.h:1550 include/linux/phy.h:1563
#: include/linux/phy.h:1577 include/linux/phy.h:1588
#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:468
#: drivers/net/phy/mdio_bus.c:565 drivers/net/phy/mdio_bus.c:728
#: drivers/net/phy/mdio_bus.c:754 drivers/net/phy/mdio_bus.c:778
#: drivers/net/phy/mdio_bus.c:803 drivers/net/phy/mdio_bus.c:851
#: drivers/net/phy/mdio_bus.c:873 drivers/net/phy/mdio_bus.c:896
#: drivers/net/phy/mdio_bus.c:919
msgid "register number to write"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:564
#: drivers/net/phy/phy-core.c:596
msgid "Function for modifying a register on MMD"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:566
#: drivers/net/phy/phy-core.c:598 drivers/net/phy/phy-core.c:625
#: drivers/net/phy/phy-core.c:648 ../../../networking/kapi:125:
#: include/linux/phy.h:1600 include/linux/phy.h:1616 include/linux/phy.h:1632
#: include/linux/phy.h:1646
msgid "the MMD containing register to modify"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:570
msgid ""
"Unlocked helper function which allows a MMD register to be modified as new "
"register value = (old register value & ~mask) | set"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:623
#: drivers/net/phy/phy-core.c:646
msgid "Convenience function for modifying a register on MMD"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:687
msgid "take the bus lock and save the current page"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:689
msgid ""
"Take the MDIO bus lock, and return the current page number. On error, "
"returns a negative errno. phy_restore_page() must always be called after "
"this, irrespective of success or failure of this call."
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:702
msgid "take the bus lock, save the current page, and set a page"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:705
#: drivers/net/phy/phy-core.c:773 drivers/net/phy/phy-core.c:793
#: drivers/net/phy/phy-core.c:814 drivers/net/phy/phy-core.c:837
msgid "``int page``"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:704
msgid "desired page"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:705
msgid ""
"Take the MDIO bus lock to protect against concurrent access, save the "
"current PHY page, and set the current page.  On error, returns a negative "
"errno, otherwise returns the previous page number. phy_restore_page() must "
"always be called after this, irrespective of success or failure of this call."
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:731
msgid "restore the page register and release the bus lock"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:734
msgid "``int oldpage``"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:733
msgid "the old page, return value from phy_save_page() or phy_select_page()"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:735
msgid "``int ret``"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:734
msgid "operation's return code"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:735
msgid ""
"Release the MDIO bus lock, restoring **oldpage** if it is a valid page. This "
"function propagates the earliest error code from the group of operations."
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:740
msgid ""
"**oldpage** if it was a negative value, otherwise **ret** if it was a "
"negative errno value, otherwise phy_write_page()'s negative value if it were "
"in error, otherwise **ret**."
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:770
msgid "Convenience function for reading a paged register"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:772
#: drivers/net/phy/phy-core.c:792 drivers/net/phy/phy-core.c:813
#: drivers/net/phy/phy-core.c:836
msgid "the page for the phy"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:773
#: drivers/net/phy/phy-core.c:793 drivers/net/phy/phy-core.c:814
#: drivers/net/phy/phy-core.c:837 ../../../networking/kapi:125:
#: include/linux/phy.h:1457
msgid "register number"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:774
msgid "Same rules as for phy_read()."
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:790
msgid "Convenience function for writing a paged register"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:794
msgid "value to write"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:795
msgid "Same rules as for phy_write()."
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:811
msgid "Function for modifying a paged register"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:816
#: drivers/net/phy/phy-core.c:839 ../../../networking/kapi:125:
#: include/linux/phy.h:1459 ../../../networking/kapi:134:
#: drivers/net/phy/mdio_bus.c:502 drivers/net/phy/mdio_bus.c:853
#: drivers/net/phy/mdio_bus.c:875 drivers/net/phy/mdio_bus.c:898
#: drivers/net/phy/mdio_bus.c:921 ../../../networking/kapi:137:
#: drivers/net/phy/mdio_bus.c:601
msgid "bit mask of bits to set"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:834
msgid "Convenience function for modifying a paged register"
msgstr ""

#: ../../../networking/kapi:119: drivers/net/phy/phy-core.c:840
msgid "Same rules as for phy_read() and phy_write()."
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:49
msgid "wakes up the PMA module"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:63
msgid "suspends the PMA module"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:77
msgid "configures forced master/slave role of BaseT1 devices."
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:107
msgid "configures a forced speed"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:260
msgid "configure advertisement registers"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:262
msgid ""
"Configure advertisement registers based on modes set in phydev->advertising"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:264
msgid ""
"Returns negative errno code on failure, 0 if advertisement didn't change, or "
"1 if advertised modes changed."
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:312
msgid "disable auto-negotiation"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:314
msgid ""
"Disable auto-negotiation in the Clause 45 PHY. The link parameters are "
"controlled through the PMA/PMD MMD registers."
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:317
msgid "Returns zero on success, negative errno code on failure."
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:333
#: drivers/net/phy/phy-c45.c:353 ../../../networking/kapi:128:
#: drivers/net/phy/phy_device.c:2185
msgid "Enable and restart auto-negotiation"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:335
#: drivers/net/phy/phy-c45.c:356 drivers/net/phy/phy-c45.c:389
msgid "This assumes that the auto-negotiation MMD is present."
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:337
msgid "Enable and restart auto-negotiation."
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:356
#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2188
msgid "``bool restart``"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:355
#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2187
msgid "whether aneg restart is requested"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:358
#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2188
msgid "Check, and restart auto-negotiation if needed."
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:387
msgid "return auto-negotiation complete status"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:391
msgid ""
"Reads the status register from the auto-negotiation MMD, returning: - "
"positive if auto-negotiation is complete - negative errno code on error - "
"zero otherwise"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:412
msgid "read the overall link status from the MMDs"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:414
msgid ""
"Read the link status from the specified MMDs, and if they all indicate that "
"the link is up, set phydev->link to 1.  If an error is encountered, a "
"negative errno will be returned, otherwise zero."
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:514
msgid "read the link partner advertisement and pause"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:516
msgid ""
"Read the Clause 45 defined base (7.19) and 10G (7.33) status registers, "
"filling in the link partner advertisement, pause and asym_pause members in "
"**phydev**.  This assumes that the auto-negotiation MMD is present, and the "
"backplane bit (7.48.0) is clear.  Clause 45 PHY drivers are expected to fill "
"in the remainder of the link partner advert from vendor registers."
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:569
msgid "read forced master/slave configuration"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:597
msgid "read link speed etc from PMA"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:647
msgid "read mdix status from PMA"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:894
msgid "read supported EEE link modes"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:937
msgid "configure EEE advertisement"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:953
msgid "read supported baset1 link modes from PMA"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:955
msgid ""
"Read the supported link modes from the extended BASE-T1 ability register"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:991
#: drivers/net/phy/phy-c45.c:1064
msgid "read supported link modes from PMA"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:993
msgid ""
"Read the supported link modes from the PMA/PMD extended ability register "
"(Register 1.11)."
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1066
msgid ""
"Read the supported link modes from the PMA Status 2 (1.8) register. If bit "
"1.8.9 is set, the list of supported modes is build using the values in the "
"PMA Extended Abilities (1.11) register, indicating 1000BASET an 10G related "
"modes. If bit 1.11.14 is set, then the list is also extended with the modes "
"in the 2.5G/5G PMA Extended register (1.21), indicating if 2.5GBASET and "
"5GBASET are supported."
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1159
msgid "read PHY status"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1161
msgid "Reads status from PHY and sets phy_device members accordingly."
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1198
msgid "restart auto-negotiation or forced setup"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1201
#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2219
#: drivers/net/phy/phy_device.c:2275
msgid "If auto-negotiation is enabled, we configure the"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1202
msgid ""
"advertising, and then restart auto-negotiation.  If it is not enabled, then "
"we force a configuration."
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1243
msgid "configure fast retrain registers"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1245
msgid "enable fast retrain or not"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1247
msgid "If fast-retrain is enabled, we configure PHY as"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1248
msgid ""
"advertising fast retrain capable and THP Bypass Request, then enable fast "
"retrain. If it is not enabled, we configure fast retrain disabled."
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1278
msgid "get PLCA configuration from standard registers"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1280
msgid "output structure to store the PLCA configuration"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1282
#: drivers/net/phy/phy-c45.c:1336 drivers/net/phy/phy-c45.c:1450
msgid "if the PHY complies to the Open Alliance TC14 10BASE-T1S PLCA"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1283
msgid ""
"Management Registers specifications, this function can be used to retrieve "
"the current PLCA configuration from the standard registers in MMD 31."
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1331
msgid "set PLCA configuration using standard registers"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1333
msgid ""
"structure containing the PLCA configuration. Fields set to -1 are not to be "
"changed."
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1337
msgid ""
"Management Registers specifications, this function can be used to modify the "
"PLCA configuration using the standard registers in MMD 31."
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1446
msgid "get PLCA status from standard registers"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1448
msgid "output structure to store the PLCA status"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1451
msgid ""
"Management Registers specifications, this function can be used to retrieve "
"the current PLCA status information from the standard registers in MMD 31."
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1469
msgid "get EEE status"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1472
msgid "``unsigned long *lp``"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1471
msgid "variable to store LP advertised linkmodes"
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1473
msgid ""
"this function will read link partner PHY advertisement and compare it to "
"local advertisement to return current EEE state."
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1505
msgid "it reports the Supported/Advertisement/LP Advertisement capabilities."
msgstr ""

#: ../../../networking/kapi:122: drivers/net/phy/phy-c45.c:1530
msgid ""
"sets the Supported/Advertisement/LP Advertisement capabilities. If "
"eee_enabled is false, no links modes are advertised, but the previously "
"advertised link modes are retained. This allows EEE to be enabled/disabled "
"in a non-destructive way. Returns either error code, 0 if there was no "
"change, or positive value if there was a change which triggered auto-neg."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:70
msgid "Interface Mode definitions"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:76
msgid "``PHY_INTERFACE_MODE_NA``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:77
msgid "Not Applicable - don't touch"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:79
msgid "``PHY_INTERFACE_MODE_INTERNAL``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:80
msgid "No interface, MAC and PHY combined"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:82
msgid "``PHY_INTERFACE_MODE_MII``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:83
msgid "Media-independent interface"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:85
msgid "``PHY_INTERFACE_MODE_GMII``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:86
msgid "Gigabit media-independent interface"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:88
msgid "``PHY_INTERFACE_MODE_SGMII``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:89
msgid "Serial gigabit media-independent interface"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:91
msgid "``PHY_INTERFACE_MODE_TBI``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:92
msgid "Ten Bit Interface"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:94
msgid "``PHY_INTERFACE_MODE_REVMII``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:95
msgid "Reverse Media Independent Interface"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:97
msgid "``PHY_INTERFACE_MODE_RMII``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:98
msgid "Reduced Media Independent Interface"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:100
msgid "``PHY_INTERFACE_MODE_REVRMII``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:101
msgid "Reduced Media Independent Interface in PHY role"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:103
msgid "``PHY_INTERFACE_MODE_RGMII``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:104
msgid "Reduced gigabit media-independent interface"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:106
msgid "``PHY_INTERFACE_MODE_RGMII_ID``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:107
msgid "RGMII with Internal RX+TX delay"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:109
msgid "``PHY_INTERFACE_MODE_RGMII_RXID``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:110
msgid "RGMII with Internal RX delay"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:112
msgid "``PHY_INTERFACE_MODE_RGMII_TXID``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:113
msgid "RGMII with Internal TX delay"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:115
msgid "``PHY_INTERFACE_MODE_RTBI``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:116
msgid "Reduced TBI"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:118
msgid "``PHY_INTERFACE_MODE_SMII``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:119
msgid "Serial MII"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:121
msgid "``PHY_INTERFACE_MODE_XGMII``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:122
msgid "10 gigabit media-independent interface"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:124
msgid "``PHY_INTERFACE_MODE_XLGMII``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:125
msgid "40 gigabit media-independent interface"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:127
msgid "``PHY_INTERFACE_MODE_MOCA``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:128
msgid "Multimedia over Coax"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:130
msgid "``PHY_INTERFACE_MODE_PSGMII``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:131
msgid "Penta SGMII"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:133
msgid "``PHY_INTERFACE_MODE_QSGMII``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:134
msgid "Quad SGMII"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:136
msgid "``PHY_INTERFACE_MODE_TRGMII``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:137
msgid "Turbo RGMII"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:139
msgid "``PHY_INTERFACE_MODE_100BASEX``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:140
msgid "100 BaseX"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:142
msgid "``PHY_INTERFACE_MODE_1000BASEX``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:143
msgid "1000 BaseX"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:145
msgid "``PHY_INTERFACE_MODE_2500BASEX``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:146
msgid "2500 BaseX"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:148
msgid "``PHY_INTERFACE_MODE_5GBASER``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:149
msgid "5G BaseR"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:151
msgid "``PHY_INTERFACE_MODE_RXAUI``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:152
msgid "Reduced XAUI"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:154
msgid "``PHY_INTERFACE_MODE_XAUI``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:155
msgid "10 Gigabit Attachment Unit Interface"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:157
msgid "``PHY_INTERFACE_MODE_10GBASER``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:158
msgid "10G BaseR"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:160
msgid "``PHY_INTERFACE_MODE_25GBASER``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:161
msgid "25G BaseR"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:163
msgid "``PHY_INTERFACE_MODE_USXGMII``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:164
msgid "Universal Serial 10GE MII"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:166
msgid "``PHY_INTERFACE_MODE_10GKR``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:167
msgid "10GBASE-KR - with Clause 73 AN"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:169
msgid "``PHY_INTERFACE_MODE_QUSGMII``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:170
msgid "Quad Universal SGMII"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:172
msgid "``PHY_INTERFACE_MODE_1000BASEKX``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:173
msgid "1000Base-KX - with Clause 73 AN"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:175
msgid "``PHY_INTERFACE_MODE_10G_QXGMII``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:176
msgid "10G-QXGMII - 4 ports over 10G USXGMII"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:178
msgid "``PHY_INTERFACE_MODE_50GBASER``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:179
msgid "50GBase-R - with Clause 134 FEC"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:181
msgid "``PHY_INTERFACE_MODE_LAUI``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:182
msgid "50 Gigabit Attachment Unit Interface"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:184
msgid "``PHY_INTERFACE_MODE_100GBASEP``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:185
msgid "100GBase-P - with Clause 134 FEC"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:187
msgid "``PHY_INTERFACE_MODE_MIILITE``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:188
msgid "MII-Lite - MII without RXER TXER CRS COL"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:190
msgid "``PHY_INTERFACE_MODE_MAX``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:191
msgid "Book keeping"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:111
msgid "Describes the interface between the MAC and PHY."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:203
msgid "map phy_interface_t enum to device tree binding of phy-mode"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:204
#: include/linux/phy.h:609
msgid "enum phy_interface_t value"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:206
msgid ""
"maps enum :c:type:`phy_interface_t` defined in this file into the device "
"tree binding of 'phy-mode', so that Ethernet device driver can get PHY "
"interface from device tree."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:295
msgid "map link speed to the clock rate"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:296
msgid "link speed value"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:298
msgid ""
"maps RGMII supported link speeds into the clock rates. This can also be used "
"for MII, GMII, and RMII interface modes as the clock rates are identical, "
"but the caller must be aware that errors for unsupported clock rates will "
"not be signalled."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:303
msgid "clock rate or negative errno"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:335
msgid "Statistics counters for MDIO busses"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:336
msgid "``transfers``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:337
msgid "Total number of transfers, i.e. **writes** + **reads**"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:337
msgid "``errors``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:338
msgid "Number of MDIO transfers that returned an error"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:338
msgid "``writes``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:339
msgid "Number of write transfers"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:339
msgid "``reads``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:340
msgid "Number of read transfers"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:340
msgid "``syncp``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:341
msgid "Synchronisation for incrementing statistics"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:352
msgid "Represents an MDIO bus"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:354
msgid "``owner``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:355
msgid "Who owns this device"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:356
msgid "User friendly name for this MDIO device, or driver name"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:356
msgid "``id``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:357
msgid "Unique identifier for this bus, typical from bus hierarchy"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:358
msgid "Driver private data"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:367
msgid "``read``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:368
msgid "Perform a read transfer on the bus"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:369
msgid "``write``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:370
msgid "Perform a write transfer on the bus"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:371
msgid "``read_c45``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:372
msgid "Perform a C45 read transfer on the bus"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:373
msgid "``write_c45``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:374
msgid "Perform a C45 write transfer on the bus"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:376
msgid "``reset``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:377
msgid "Perform a reset of the bus"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:380
msgid "Statistic counters per device on the bus"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:383
msgid "``mdio_lock``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:384
msgid ""
"A lock to ensure that only one thing can read/write the MDIO bus at a time"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:389
msgid "Parent device of this bus"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:391
msgid "State of bus structure"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:399
msgid "Kernel device representation"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:401
msgid "``mdio_map``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:402
msgid "list of all MDIO devices on bus"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:404
msgid "``phy_mask``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:405
msgid "PHY addresses to be ignored when probing"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:407
msgid "``phy_ignore_ta_mask``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:408
msgid "PHY addresses to ignore the TA/read failure"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:412
msgid ""
"An array of interrupts, each PHY's interrupt at the index matching its "
"address"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:416
msgid "``reset_delay_us``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:417
msgid "GPIO reset pulse width in microseconds"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:418
msgid "``reset_post_delay_us``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:419
msgid "GPIO reset deassert delay in microseconds"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:420
msgid "``reset_gpiod``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:421
msgid "Reset GPIO descriptor pointer"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:423
msgid "``shared_lock``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:424
msgid "protect access to the shared element"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:427
#: include/linux/phy.h:627
msgid "``shared``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:428
msgid "shared state across different PHYs"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:358
msgid ""
"The Bus class for PHYs.  Devices which provide access to PHYs should "
"register using this structure"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:436
msgid "Allocate an MDIO bus structure"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:437
msgid ""
"The internal state of the MDIO bus will be set of MDIOBUS_ALLOCATED ready "
"for the driver to register the bus."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:468
msgid "PHY state machine states:"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:474
msgid "``PHY_DOWN``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:475
msgid ""
"PHY device and driver are not ready for anything.  probe should be called if "
"and only if the PHY is in this state, given that the PHY device exists. - "
"PHY driver probe function will set the state to **PHY_READY**"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:480
msgid "``PHY_READY``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:481
msgid ""
"PHY is ready to send and receive packets, but the controller is not.  By "
"default, PHYs which do not implement probe will be set to this state by "
"phy_probe(). - start will set the state to UP"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:486
msgid "``PHY_HALTED``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:487
msgid ""
"PHY is up, but no polling or interrupts are done. - phy_start moves to "
"**PHY_UP**"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:490
msgid "``PHY_ERROR``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:491
msgid "PHY is up, but is in an error state. - phy_stop moves to **PHY_HALTED**"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:494
msgid "``PHY_UP``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:495
msgid ""
"The PHY and attached device are ready to do work. Interrupts should be "
"started here. - timer moves to **PHY_NOLINK** or **PHY_RUNNING**"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:499
msgid "``PHY_RUNNING``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:500
msgid ""
"PHY is currently up, running, and possibly sending and/or receiving packets "
"- irq or timer will set **PHY_NOLINK** if link goes down - phy_stop moves to "
"**PHY_HALTED**"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:505
msgid "``PHY_NOLINK``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:506
msgid ""
"PHY is up, but not currently plugged in. - irq or timer will set "
"**PHY_RUNNING** if link comes back - phy_stop moves to **PHY_HALTED**"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:510
msgid "``PHY_CABLETEST``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:511
msgid ""
"PHY is performing a cable test. Packet reception/sending is not expected to "
"work, carrier will be indicated as down. PHY will be poll once per second, "
"or on interrupt for it current state. Once complete, move to UP to restart "
"the PHY. - phy_stop aborts the running test and moves to **PHY_HALTED**"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:519
msgid "802.3-c45 Device Identifiers"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:520
msgid "``devices_in_package``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:521
msgid "IEEE 802.3 devices in package register value."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:521
msgid "``mmds_present``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:522
msgid "bit vector of MMDs present."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:522
msgid "``device_ids``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:523
msgid "The device identifier for each present device."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:534
msgid "An instance of a PHY"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:536
msgid "``mdio``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:537
msgid "MDIO bus this PHY is on"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:537
msgid "``drv``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:538
msgid "Pointer to the driver for this PHY instance"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:538
msgid "``devlink``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:539
msgid ""
"Create a link between phy dev and mac dev, if the external phy used by "
"current mac interface is managed by another mac interface."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:540
msgid "``phyindex``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:541
msgid ""
"Unique id across the phy's parent tree of phys to address the PHY from "
"userspace, similar to ifindex. A zero index means the PHY wasn't assigned an "
"id yet."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:543
#: include/linux/phy.h:910
msgid "``phy_id``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:544
msgid "UID for this device found during discovery"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:544
msgid "``c45_ids``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:545
msgid "802.3-c45 Device Identifiers if is_c45."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:545
msgid "``is_c45``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:546
msgid "Set to true if this PHY uses clause 45 addressing."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:546
msgid "``is_internal``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:547
msgid "Set to true if this PHY is internal to a MAC."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:547
msgid "``is_pseudo_fixed_link``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:548
msgid "Set to true if this PHY is an Ethernet switch, etc."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:548
msgid "``is_gigabit_capable``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:549
msgid "Set to true if PHY supports 1000Mbps"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:549
msgid "``has_fixups``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:550
msgid "Set to true if this PHY has fixups/quirks."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:550
msgid "``suspended``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:551
msgid "Set to true if this PHY has been suspended successfully."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:551
msgid "``suspended_by_mdio_bus``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:552
msgid "Set to true if this PHY was suspended by MDIO bus."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:552
msgid "``sysfs_links``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:553
msgid "Internal boolean tracking sysfs symbolic links setup/removal."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:553
msgid "``loopback_enabled``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:554
msgid "Set true if this PHY has been loopbacked successfully."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:554
msgid "``downshifted_rate``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:555
msgid "Set true if link speed has been downshifted."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:555
msgid "``is_on_sfp_module``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:556
msgid "Set true if PHY is located on an SFP module."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:556
#: ../../../networking/kapi:147: include/linux/phylink.h:142
msgid "``mac_managed_pm``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:557
msgid "Set true if MAC driver takes of suspending/resuming PHY"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:557
msgid "``wol_enabled``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:558
msgid "Set to true if the PHY or the attached MAC have Wake-on-LAN enabled."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:559
msgid "``is_genphy_driven``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:560
msgid "PHY is driven by one of the generic PHY drivers"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:594
msgid "``autoneg``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:595
msgid "Flag autoneg being used"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:596
#: ../../../networking/kapi:147: include/linux/phylink.h:116
msgid "``link``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:597
msgid "Current link state"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:597
msgid "``autoneg_complete``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:598
msgid "Flag auto negotiation of the link has completed"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:601
msgid "``interrupts``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:602
msgid "Flag interrupts have been enabled"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:602
msgid "``irq_suspended``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:603
msgid ""
"Flag indicating PHY is suspended and therefore interrupt handling shall be "
"postponed until PHY has resumed"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:604
msgid "``irq_rerun``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:605
msgid ""
"Flag indicating interrupts occurred while PHY was suspended, requiring a "
"rerun of the interrupt handler after resume"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:606
msgid "``default_timestamp``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:607
msgid ""
"Flag indicating whether we are using the phy timestamp as the default one"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:595
#: ../../../networking/kapi:147: include/linux/phylink.h:112
msgid "``rate_matching``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:596
msgid "Current rate matching mode"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:561
msgid "State of the PHY for management purposes"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:561
msgid "``dev_flags``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:562
msgid "Device-specific flags used by the PHY driver."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:608
#: ../../../networking/kapi:147: include/linux/phylink.h:108
msgid "``interface``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:609
msgid "``possible_interfaces``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:610
msgid ""
"bitmap if interface modes that the attached PHY will switch between "
"depending on media speed."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:578
#: ../../../networking/kapi:147: include/linux/phylink.h:109
msgid "``speed``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:579
msgid "Current link speed"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:579
#: ../../../networking/kapi:147: include/linux/phylink.h:110
msgid "``duplex``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:580
msgid "Current duplex"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:580
#: ../../../networking/kapi:158: include/linux/sfp.h:540
msgid "``port``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:581
msgid "Current port"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:581
#: ../../../networking/kapi:147: include/linux/phylink.h:111
msgid "``pause``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:582
msgid "Current pause"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:582
msgid "``asym_pause``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:583
msgid "Current asymmetric pause"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:620
msgid "``master_slave_get``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:621
msgid "Current master/slave advertisement"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:619
msgid "``master_slave_set``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:620
msgid "User requested master/slave configuration"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:621
msgid "``master_slave_state``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:622
msgid "Current master/slave configuration"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:583
msgid "``supported``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:584
msgid "Combined MAC/PHY supported linkmodes"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:584
#: ../../../networking/kapi:147: include/linux/phylink.h:105
msgid "``advertising``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:585
msgid "Currently advertised linkmodes"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:591
#: ../../../networking/kapi:147: include/linux/phylink.h:106
msgid "``lp_advertising``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:592
msgid "Current link partner advertised linkmodes"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:585
msgid "``adv_old``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:586
msgid "Saved advertised while power saving for WoL"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:586
msgid "``supported_eee``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:587
msgid "supported PHY EEE linkmodes"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:587
msgid "``advertising_eee``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:588
msgid "Currently advertised EEE linkmodes"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:593
msgid "``eee_disabled_modes``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:594
msgid "Energy efficient ethernet modes not to be advertised"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:588
msgid "``enable_tx_lpi``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:589
msgid "When True, MAC should transmit LPI to PHY"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:589
msgid "``eee_active``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:590
msgid "phylib private state, indicating that EEE has been negotiated"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:590
msgid "``eee_cfg``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:591
msgid "User configuration of EEE"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:592
msgid "``host_interfaces``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:593
msgid "PHY interface modes supported by host"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:614
msgid "``phy_led_triggers``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:615
msgid "Array of LED triggers"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:615
msgid "``phy_num_led_triggers``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:616
msgid "Number of triggers in **phy_led_triggers**"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:617
msgid "``last_triggered``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:618
msgid "last LED trigger for link speed"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:616
msgid "``led_link_trigger``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:617
msgid "LED trigger for link up/down"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:618
msgid "``leds``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:619
msgid "list of PHY LED structures"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:569
msgid "IRQ number of the PHY's interrupt (-1 if none)"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:629
msgid "Pointer to driver private data"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:628
msgid "Pointer to private data shared by phys in one package"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:611
msgid "``skb``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:612
msgid "Netlink message for cable diagnostics"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:613
msgid "``ehdr``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:614
msgid "nNtlink header for cable diagnostics"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:612
msgid "``nest``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:613
msgid "Netlink nest used for cable diagnostics"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:625
msgid "``state_queue``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:626
msgid "Work queue for state machine"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:625
msgid "Mutex for serialization access to PHY"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:570
msgid "``sfp_bus_attached``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:571
msgid "Flag indicating whether the SFP bus has been attached"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:572
msgid "SFP bus attached to this PHY's fiber port"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:569
#: ../../../networking/kapi:147: include/linux/phylink.h:452
msgid "``phylink``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:570
msgid "Pointer to phylink instance for this PHY"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:572
msgid "``attached_dev``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:573
msgid "The attached enet driver's device instance ptr"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:622
msgid "``mii_ts``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:623
msgid "Pointer to time stamper callbacks"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:623
msgid "``psec``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:624
msgid "Pointer to Power Sourcing Equipment control struct"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:598
msgid "``mdix``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:599
msgid "Current crossover"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:599
msgid "``mdix_ctrl``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:600
msgid "User setting of crossover"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:600
msgid "``pma_extable``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:601
msgid "Cached value of PMA/PMD Extended Abilities Register"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:626
msgid "``link_down_events``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:627
msgid "Number of times link was lost"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:575
msgid "``phy_link_change``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:576
msgid "Callback for phylink for notification of link change"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:573
msgid "``adjust_link``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:574
msgid ""
"Callback for the enet controller to respond to changes: in the link state."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:577
msgid "MACsec offloading ops."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:562
msgid ""
"Bits [15:0] are free to use by the PHY driver to communicate driver specific "
"behavior."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:564
msgid "Bits [23:16] are currently reserved for future use."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:565
msgid "Bits [31:24] are reserved for defining generic PHY driver behavior."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:568
msgid ""
"interrupts currently only supports enabled or disabled, but could be changed "
"in the future to support enabling and disabling specific interrupts"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:572
msgid ""
"Contains some infrastructure for polling and interrupt handling, as well as "
"handling shifts in PHY hardware state"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:784
msgid "Configuration of a TDR raw test"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:786
msgid "``first``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:787
msgid "Distance for first data collection point"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:787
msgid "``last``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:788
msgid "Distance for last data collection point"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:788
msgid "``step``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:789
msgid "Step between data collection points"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:789
msgid "``pair``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:790
msgid "Bitmap of cable pairs to collect data for"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:790
msgid ""
"A structure containing possible configuration parameters for a TDR cable "
"test. The driver does not need to implement all the parameters, but should "
"report what is actually used. All distances are in centimeters."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:805
msgid "in-band signalling modes that are supported"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:811
msgid "``LINK_INBAND_DISABLE``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:812
msgid "in-band signalling can be disabled"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:814
msgid "``LINK_INBAND_ENABLE``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:815
msgid "in-band signalling can be enabled without bypass"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:817
msgid "``LINK_INBAND_BYPASS``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:818
msgid "in-band signalling can be enabled with bypass"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:810
msgid ""
"The possible and required bits can only be used if the valid bit is set. If "
"possible is clear, that means inband signalling can not be used. Required is "
"only valid when possible is set, and means that inband signalling must be "
"used."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:823
msgid ""
"Configuration of the PLCA (Physical Layer Collision Avoidance) "
"Reconciliation Sublayer."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:826
msgid "``version``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:827
msgid ""
"read-only PLCA register map version. -1 = not available. Ignored when "
"setting the configuration. Format is the same as reported by the PLCA IDVER "
"register (31.CA00). -1 = not available."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:829
msgid "``enabled``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:830
msgid ""
"PLCA configured mode (enabled/disabled). -1 = not available / don't set. 0 = "
"disabled, anything else = enabled."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:831
msgid "``node_id``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:832
msgid ""
"the PLCA local node identifier. -1 = not available / don't set. Allowed "
"values [0 .. 254]. 255 = node disabled."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:833
msgid "``node_cnt``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:834
msgid ""
"the PLCA node count (maximum number of nodes having a TO). Only meaningful "
"for the coordinator (node_id = 0). -1 = not available / don't set. Allowed "
"values [1 .. 255]."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:836
msgid "``to_tmr``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:837
msgid ""
"The value of the PLCA to_timer in bit-times, which determines the PLCA "
"transmit opportunity window opening. See IEEE802.3 Clause 148 for more "
"details. The to_timer shall be set equal over all nodes. -1 = not "
"available / don't set. Allowed values [0 .. 255]."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:840
msgid "``burst_cnt``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:841
msgid ""
"controls how many additional frames a node is allowed to send in single "
"transmit opportunity (TO). The default value of 0 means that the node is "
"allowed exactly one frame per TO. A value of 1 allows two frames per TO, and "
"so on. -1 = not available / don't set. Allowed values [0 .. 255]."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:845
msgid "``burst_tmr``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:846
msgid ""
"controls how many bit times to wait for the MAC to send a new frame before "
"interrupting the burst. This value should be set to a value greater than the "
"MAC inter-packet gap (which is typically 96 bits). -1 = not available / "
"don't set. Allowed values [0 .. 255]."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:849
msgid ""
"A structure containing configuration parameters for setting/getting the PLCA "
"RS configuration. The driver does not need to implement all the parameters, "
"but should report what is actually used."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:865
msgid ""
"Status of the PLCA (Physical Layer Collision Avoidance) Reconciliation "
"Sublayer."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:868
msgid "``pst``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:869
msgid ""
"The PLCA status as reported by the PST bit in the PLCA STATUS register(31."
"CA03), indicating BEACON activity."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:870
msgid ""
"A structure containing status information of the PLCA RS configuration. The "
"driver does not need to implement all the parameters, but should report what "
"is actually used."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:890
msgid "An LED driven by the PHY"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:893
msgid "List of LEDs"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:894
msgid "PHY this LED is attached to"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:894
msgid "``led_cdev``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:895
msgid "Standard LED class structure"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:895
msgid "``index``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:896
msgid "Number of the LED"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:907
msgid "Driver structure for a particular PHY type"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:909
msgid "``mdiodrv``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:910
msgid "Data common to all MDIO devices"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:911
msgid ""
"The result of reading the UID registers of this PHY type, and ANDing them "
"with the phy_id_mask.  This driver only works for PHYs with IDs which match "
"this field"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:914
msgid "The friendly name of this PHY type"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:914
msgid "``phy_id_mask``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:915
msgid "Defines the important bits of the phy_id"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:916
msgid "A mandatory list of features (speed, duplex, etc) supported by this PHY"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:918
msgid ""
"A bitfield defining certain other features this PHY supports (like "
"interrupts)"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:919
msgid "``driver_data``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:920
msgid "Static driver data"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:939
msgid "``soft_reset``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:940
msgid "Called to issue a PHY software reset"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:944
msgid "``config_init``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:945
msgid "Called to initialize the PHY, including after a reset"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:950
msgid "``probe``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:951
msgid ""
"Called during discovery.  Used to set up device-specific structures, if any"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:956
msgid "``get_features``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:957
msgid ""
"Probe the hardware to determine what abilities it has.  Should only set "
"phydev->supported."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:962
msgid "``inband_caps``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:963
msgid ""
"query whether in-band is supported for the given PHY interface mode. Returns "
"a bitmask of bits defined by enum link_inband_signalling."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:970
msgid "``config_inband``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:971
msgid "configure in-band mode for the PHY"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:975
msgid "``get_rate_matching``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:976
msgid ""
"Get the supported type of rate matching for a particular phy interface. This "
"is used by phy consumers to determine whether to advertise lower-speed modes "
"for that interface. It is assumed that if a rate matching mode is supported "
"on an interface, then that interface's rate can be adapted to all slower "
"link speeds supported by the phy. If the interface is not supported, this "
"should return ``RATE_MATCH_NONE``."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:987
msgid "``suspend``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:988
msgid "Suspend the hardware, saving state if needed"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:989
msgid "``resume``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:990
msgid "Resume the hardware, restoring state if needed"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:993
msgid "``config_aneg``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:994
msgid ""
"Configures the advertisement and resets autonegotiation if phydev->autoneg "
"is on, forces the speed to the current settings in phydev if phydev->autoneg "
"is off"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1000
msgid "``aneg_done``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1001
msgid "Determines the auto negotiation result"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1003
msgid "``read_status``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1004
msgid "Determines the negotiated speed and duplex"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1007
msgid "``config_intr``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1008
msgid ""
"Enables or disables interrupts. It should also clear any pending interrupts "
"prior to enabling the IRQs and after disabling them."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1013
msgid "``handle_interrupt``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1014
msgid "Override default interrupt handling"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1016
msgid "``remove``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1017
msgid "Clears up any memory if needed"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1020
msgid "``match_phy_device``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1021
msgid ""
"Returns true if this is a suitable driver for the given phydev.  If NULL, "
"matching is based on phy_id and phy_id_mask."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1028
msgid "``set_wol``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1029
msgid ""
"Some devices (e.g. qnap TS-119P II) require PHY register changes to enable "
"Wake on LAN, so set_wol is provided to be called in the ethernet driver's "
"set_wol function."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1036
msgid "``get_wol``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1037
msgid "See set_wol, but for checking whether Wake on LAN is enabled."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1042
msgid "``link_change_notify``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1043
msgid ""
"Called to inform a PHY device driver when the core is about to change the "
"link state. This callback is supposed to be used as fixup hook for drivers "
"that need to take action when the link state changes. Drivers are by no "
"means allowed to mess with the PHY device structure in their implementations."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1052
msgid "``read_mmd``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1053
msgid ""
"PHY specific driver override for reading a MMD register.  This function is "
"optional for PHY specific drivers.  When not provided, the default MMD read "
"function will be used by phy_read_mmd(), which will use either a direct read "
"for Clause 45 PHYs or an indirect read for Clause 22 PHYs.  devnum is the "
"MMD device number within the PHY device, regnum is the register within the "
"selected MMD device."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1064
msgid "``write_mmd``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1065
msgid ""
"PHY specific driver override for writing a MMD register.  This function is "
"optional for PHY specific drivers.  When not provided, the default MMD write "
"function will be used by phy_write_mmd(), which will use either a direct "
"write for Clause 45 PHYs, or an indirect write for Clause 22 PHYs.  devnum "
"is the MMD device number within the PHY device, regnum is the register "
"within the selected MMD device.  val is the value to be written."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1076
msgid "``read_page``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1077
msgid "Return the current PHY register page number"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1078
msgid "``write_page``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1079
msgid "Set the current PHY register page number"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1082
msgid "``module_info``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1083
msgid "Get the size and type of the eeprom contained within a plug-in module"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1089
msgid "``module_eeprom``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1090
msgid "Get the eeprom information from the plug-in module"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1095
msgid "``cable_test_start``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1098
msgid "``cable_test_tdr_start``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1103
msgid "``cable_test_get_status``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1104
msgid "Once per second, or on interrupt, request the status of the test."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1110
msgid "``get_phy_stats``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1111
msgid ""
"Retrieve PHY statistics. **dev**: The PHY device for which the statistics "
"are retrieved. **eth_stats**: structure where Ethernet PHY stats will be "
"stored. **stats**: structure where additional PHY-specific stats will be "
"stored."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1116
msgid ""
"Retrieves the supported PHY statistics and populates the provided "
"structures. The input structures are pre-initialized with "
"`ETHTOOL_STAT_NOT_SET`, and the driver must only modify members "
"corresponding to supported statistics. Unmodified members will remain set to "
"`ETHTOOL_STAT_NOT_SET` and will not be returned to userspace."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1126
msgid "``get_link_stats``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1127
msgid ""
"Retrieve link statistics. **dev**: The PHY device for which the statistics "
"are retrieved. **link_stats**: structure where link-specific stats will be "
"stored."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1131
msgid ""
"Retrieves link-related statistics for the given PHY device. The input "
"structure is pre-initialized with `ETHTOOL_STAT_NOT_SET`, and the driver "
"must only modify members corresponding to supported statistics. Unmodified "
"members will remain set to `ETHTOOL_STAT_NOT_SET` and will not be returned "
"to userspace."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1140
msgid "``update_stats``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1141
msgid ""
"Trigger periodic statistics updates. **dev**: The PHY device for which "
"statistics updates are triggered."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1144
msgid ""
"Periodically gathers statistics from the PHY device to update locally "
"maintained 64-bit counters. This is necessary for PHYs that implement "
"reduced-width counters (e.g., 16-bit or 32-bit) which can overflow more "
"frequently compared to 64-bit counters. By invoking this callback, drivers "
"can fetch the current counter values, handle overflow detection, and "
"accumulate the results into local 64-bit counters for accurate reporting "
"through the `get_phy_stats` and `get_link_stats` interfaces."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1153
msgid "Return: 0 on success or a negative error code on failure."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1156
msgid "``get_sset_count``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1157
msgid "Number of statistic counters"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1158
msgid "``get_strings``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1159
msgid "Names of the statistic counters"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1160
msgid "``get_stats``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1161
msgid "Return the statistic counter values"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1165
msgid "``get_tunable``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1166
msgid "Return the value of a tunable"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1168
msgid "``set_tunable``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1169
msgid "Set the value of a tunable"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1173
msgid "``set_loopback``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1174
msgid ""
"Set the loopback mode of the PHY enable selects if the loopback mode is "
"enabled or disabled. If the loopback mode is enabled, then the speed of the "
"loopback mode can be requested with the speed argument. If the speed "
"argument is zero, then any speed can be selected. If the speed argument is > "
"0, then this speed shall be selected for the loopback mode or EOPNOTSUPP "
"shall be returned if speed selection is not supported."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1182
msgid "``get_sqi``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1183
msgid "Get the signal quality indication"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1184
msgid "``get_sqi_max``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1185
msgid "Get the maximum signal quality indication"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1188
msgid "``get_plca_cfg``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1189
msgid "Return the current PLCA configuration"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1191
msgid "``set_plca_cfg``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1192
msgid "Set the PLCA configuration"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1194
msgid "``get_plca_status``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1195
msgid "Return the current PLCA status info"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1199
msgid "``led_brightness_set``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1200
msgid ""
"Set a PHY LED brightness. Index indicates which of the PHYs led should be "
"set. Value follows the standard LED class meaning, e.g. LED_OFF, LED_HALF, "
"LED_FULL."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1208
msgid "``led_blink_set``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1209
msgid ""
"Set a PHY LED blinking.  Index indicates which of the PHYs led should be "
"configured to blink. Delays are in milliseconds and if both are zero then a "
"sensible default should be chosen.  The call should adjust the timings in "
"that case and if it can't match the values specified exactly."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1219
msgid "``led_hw_is_supported``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1220
msgid ""
"Can the HW support the given rules. **dev**: PHY device which has the LED "
"**index**: Which LED of the PHY device **rules** The core is interested in "
"these rules"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1225
msgid "Return 0 if yes,  -EOPNOTSUPP if not, or an error code."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1229
msgid "``led_hw_control_set``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1230
msgid ""
"Set the HW to control the LED **dev**: PHY device which has the LED "
"**index**: Which LED of the PHY device **rules** The rules used to control "
"the LED"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1235
msgid "Returns 0, or a an error code."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1239
msgid "``led_hw_control_get``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1240
msgid ""
"Get how the HW is controlling the LED **dev**: PHY device which has the LED "
"**index**: Which LED of the PHY device **rules** Pointer to the rules used "
"to control the LED"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1245
msgid ""
"Set ***rules** to how the HW is currently blinking. Returns 0 on success, or "
"a error code if the current blinking cannot be represented in rules, or some "
"other error happens."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1252
msgid "``led_polarity_set``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1253
msgid ""
"Set the LED polarity modes **dev**: PHY device which has the LED **index**: "
"Which LED of the PHY device **modes**: bitmap of LED polarity modes"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1258
msgid ""
"Configure LED with all the required polarity modes in **modes** to make it "
"correctly turn ON or OFF."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1261
msgid "Returns 0, or an error code."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1266
msgid "``get_next_update_time``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1267
msgid "Get the time until the next update event **dev**: PHY device"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1270
msgid ""
"Callback to determine the time (in jiffies) until the next update event for "
"the PHY state  machine. Allows PHY drivers to dynamically adjust polling "
"intervals based on link state or other conditions."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1275
msgid "Returns the time in jiffies until the next update event."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:920
msgid ""
"All functions are optional. If config_aneg or read_status are not "
"implemented, the phy core uses the genphy versions. Note that none of these "
"functions should be called from interrupt time. The goal is for the bus read/"
"write functions to be able to block when the bus transaction is happening, "
"and be freed up by an interrupt (The MPC85xx has this ability, though it is "
"not currently supported in the driver)."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1290
msgid "compare **id1** with **id2** taking account of **mask**"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1296
msgid "``u32 id1``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1291
msgid "first PHY ID"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1293
msgid "``u32 id2``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1292
msgid "second PHY ID"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1294
msgid "``u32 mask``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1293
msgid "the PHY ID mask, set bits are significant in matching"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1294
msgid ""
"Return true if the bits from **id1** and **id2** specified by **mask** "
"match. This uses an equivalent test to (**id** & **mask**) == (**phy_id** & "
"**mask**)."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1304
msgid "compare **id** with **vendor** mask"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1310
#: include/linux/phy.h:1323 include/linux/phy.h:1333
msgid "``u32 id``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1305
#: include/linux/phy.h:1318
msgid "PHY ID"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1307
msgid "``u32 vendor_mask``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1306
msgid "PHY Vendor mask"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1308
msgid ""
"true if the bits from **id** match **vendor** using the generic PHY Vendor "
"mask."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1317
msgid "compare **id** with **model** mask"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1320
msgid "``u32 model_mask``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1319
msgid "PHY Model mask"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1321
msgid ""
"true if the bits from **id** match **model** using the generic PHY Model "
"mask."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1330
msgid "compare **id** with the PHY's Clause 22 ID"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1331
msgid "the PHY device"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1332
msgid "the PHY ID to be matched"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1333
msgid ""
"Compare the **phydev** clause 22 ID with the provided **id** and return true "
"or false depending whether it matches, using the bound driver mask. The "
"**phydev** must be bound to a driver."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1350
msgid "Convenience function to check whether PHY is started"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1359
msgid ""
"Convenience function to check whether PHY is driven by one of the generic "
"PHY drivers"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1362
msgid "true if PHY is driven by one of the genphy drivers"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1370
msgid "Don't advertise an EEE mode."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1373
#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2751
msgid "``u32 link_mode``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1372
msgid "The EEE mode to be disabled"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1386
msgid "Convenience function for reading a given PHY register"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1388
#: include/linux/phy.h:1416 ../../../networking/kapi:134:
#: drivers/net/phy/mdio_bus.c:437 drivers/net/phy/mdio_bus.c:533
#: drivers/net/phy/mdio_bus.c:631 drivers/net/phy/mdio_bus.c:656
#: drivers/net/phy/mdio_bus.c:679 drivers/net/phy/mdio_bus.c:702
msgid "register number to read"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1414
msgid "convenience function for reading a given PHY register"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1417
#: include/linux/phy.h:1445 include/linux/phy.h:1552 include/linux/phy.h:1565
#: include/linux/phy.h:1603 include/linux/phy.h:1619
msgid "The caller must have taken the MDIO bus lock."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1426
#: include/linux/phy.h:1441
msgid "Convenience function for writing a given PHY register"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1460
msgid ""
"Unlocked helper function which allows a PHY register to be modified as new "
"register value = (old register value & ~mask) | set"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1482
msgid ""
"``phy_read_mmd_poll_timeout (phydev, devaddr, regnum, val, cond, sleep_us, "
"timeout_us, sleep_before_read)``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1480
msgid ""
"Periodically poll a PHY register until a condition is met or a timeout occurs"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1485
msgid "``devaddr``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1486
msgid "``regnum``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1487
msgid "``val``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1486
msgid "Variable to read the register into"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1488
msgid "``cond``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1487
msgid "Break condition (usually involving **val**)"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1489
msgid "``sleep_us``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1488
msgid ""
"Maximum time to sleep between reads in us (0 tight-loops). Please read "
"usleep_range() function description for details and limitations."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1492
msgid "``timeout_us``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1491
msgid "Timeout in us, 0 means never timeout"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1493
msgid "``sleep_before_read``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1492
msgid "if it is true, sleep **sleep_us** before read."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1494
msgid ""
"0 on success and -ETIMEDOUT upon a timeout. In either case, the last read "
"value at **args** is stored in **val**. Must not be called from atomic "
"context if sleep_us or timeout_us are used."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1548
#: include/linux/phy.h:1575
msgid "Convenience function for setting bits in a PHY register"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1551
#: include/linux/phy.h:1578 include/linux/phy.h:1602 include/linux/phy.h:1634
msgid "bits to set"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1561
#: include/linux/phy.h:1586
msgid "Convenience function for clearing bits in a PHY register"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1564
#: include/linux/phy.h:1589 include/linux/phy.h:1618 include/linux/phy.h:1648
msgid "bits to clear"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1597
#: include/linux/phy.h:1629
msgid "Convenience function for setting bits in a register on MMD"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1613
#: include/linux/phy.h:1643
msgid "Convenience function for clearing bits in a register on MMD"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1657
msgid "Convenience function for testing a given PHY irq"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1660
msgid ""
"must be kept in sync with addition/removal of PHY_POLL and PHY_MAC_INTERRUPT"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1669
msgid ""
"Convenience function for testing whether polling is used to detect PHY "
"status changes"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1686
msgid "Tests whether a PHY time stamp configuration."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1695
msgid "Tests whether a PHY supports receive time stamping."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1704
msgid ""
"Tests whether a PHY reports time stamping and/or PTP hardware clock "
"capabilities."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1714
msgid "Tests whether a PHY supports transmit time stamping."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1748
msgid "Is the PHY hwtstamp the default timestamp"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1749
#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1583
msgid "Pointer to phy_device"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1750
msgid ""
"This is used to get default timestamping device taking into account the new "
"API choice, which is selecting the timestamping from MAC by default if the "
"phydev does not have default_timestamp flag enabled."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1755
msgid "True if phy is the default hw timestamp, false otherwise."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1763
msgid "Convenience function for testing if a PHY is on an SFP module"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1772
msgid ""
"Convenience function for testing if a PHY interface mode is RGMII (all "
"variants)"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1778
#: include/linux/phy.h:1789
msgid "``phy_interface_t mode``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1774
msgid "the :c:type:`phy_interface_t` enum"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1783
msgid "does the PHY interface mode use 802.3z negotiation"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1785
msgid "one of :c:type:`enum phy_interface_t <phy_interface_t>`"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1786
msgid ""
"Returns true if the PHY interface mode uses the 16-bit negotiation word as "
"defined in 802.3z. (See 802.3-2015 37.2.1 Config_Reg encoding)"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1797
msgid ""
"Convenience function for testing if a PHY interface is RGMII (all variants)"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:1807
msgid ""
"Convenience function for testing if this PHY is the CPU port facing side of "
"an Ethernet switch, or similar."
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:2138
msgid "``phy_module_driver (__phy_drivers, __count)``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:2136
msgid "Helper macro for registering PHY drivers"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:2142
msgid "``__phy_drivers``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:2137
msgid "array of PHY drivers to register"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:2139
msgid "``__count``"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:2138
msgid "Numbers of members in array"
msgstr ""

#: ../../../networking/kapi:125: include/linux/phy.h:2139
msgid ""
"Helper macro for PHY drivers which do not do anything special in module init/"
"exit. Each module may only use this macro once, and calling it replaces "
"module_init() and module_exit()."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:468
msgid "remove a phy_fixup from the list"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:474
#: drivers/net/phy/phy_device.c:1284 drivers/net/phy/phy_device.c:1789
#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:429
msgid "``const char *bus_id``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:469
msgid "A string matches fixup->bus_id (or PHY_ANY_ID) in phy_fixup_list"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:471
#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:426
msgid "``u32 phy_uid``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:470
msgid "A phy id matches fixup->phy_id (or PHY_ANY_UID) in phy_fixup_list"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:472
#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:428
msgid "``u32 phy_uid_mask``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:471
msgid "Applied to phy_uid and fixup->phy_uid before comparison"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:553
msgid "match a PHY device with a PHY driver"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:556
msgid "``const struct phy_driver *phydrv``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:555
msgid "target phy_driver struct"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:557
msgid ""
"Checks whether the given PHY device matches the specified PHY driver. For "
"Clause 45 PHYs, iterates over the available device identifiers and compares "
"them against the driver's expected PHY ID, applying the provided mask. For "
"Clause 22 PHYs, a direct ID comparison is performed."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:563
msgid "1 if the PHY device matches the driver, 0 otherwise."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1089
msgid "reads the specified PHY device and returns its **phy_device** struct"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1095
#: drivers/net/phy/phy_device.c:1223 ../../../networking/kapi:131:
#: drivers/net/phy/phy_device.c:936 drivers/net/phy/phy_device.c:1034
#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:440
#: drivers/net/phy/mdio_bus.c:471 drivers/net/phy/mdio_bus.c:503
#: drivers/net/phy/mdio_bus.c:535 drivers/net/phy/mdio_bus.c:567
#: drivers/net/phy/mdio_bus.c:634 drivers/net/phy/mdio_bus.c:659
#: drivers/net/phy/mdio_bus.c:681 drivers/net/phy/mdio_bus.c:704
#: drivers/net/phy/mdio_bus.c:731 drivers/net/phy/mdio_bus.c:757
#: drivers/net/phy/mdio_bus.c:780 drivers/net/phy/mdio_bus.c:805
#: drivers/net/phy/mdio_bus.c:853 drivers/net/phy/mdio_bus.c:874
#: drivers/net/phy/mdio_bus.c:898 drivers/net/phy/mdio_bus.c:920
#: ../../../networking/kapi:137: drivers/net/phy/mdio_bus.c:601
msgid "``struct mii_bus *bus``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1091
#: drivers/net/phy/phy_device.c:1218 ../../../networking/kapi:131:
#: drivers/net/phy/phy_device.c:931 drivers/net/phy/phy_device.c:1029
msgid "the target MII bus"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1093
#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:933
#: drivers/net/phy/phy_device.c:1031 ../../../networking/kapi:134:
#: drivers/net/phy/mdio_bus.c:437 drivers/net/phy/mdio_bus.c:468
#: drivers/net/phy/mdio_bus.c:500 drivers/net/phy/mdio_bus.c:532
#: drivers/net/phy/mdio_bus.c:564 drivers/net/phy/mdio_bus.c:631
#: drivers/net/phy/mdio_bus.c:656 drivers/net/phy/mdio_bus.c:678
#: drivers/net/phy/mdio_bus.c:701 drivers/net/phy/mdio_bus.c:728
#: drivers/net/phy/mdio_bus.c:754 drivers/net/phy/mdio_bus.c:777
#: drivers/net/phy/mdio_bus.c:802 drivers/net/phy/mdio_bus.c:851
#: drivers/net/phy/mdio_bus.c:872 drivers/net/phy/mdio_bus.c:896
#: drivers/net/phy/mdio_bus.c:918 ../../../networking/kapi:137:
#: drivers/net/phy/mdio_bus.c:598
msgid "``int addr``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1092
#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:932
#: drivers/net/phy/phy_device.c:1030
msgid "PHY address on the MII bus"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1094
msgid "``bool is_c45``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1093
msgid "If true the PHY uses the 802.3 clause 45 protocol"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1094
msgid "Probe for a PHY at **addr** on **bus**."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1096
msgid ""
"When probing for a clause 22 PHY, then read the ID registers. If we find a "
"valid ID, allocate and return a :c:type:`struct phy_device <phy_device>`."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1099
msgid ""
"When probing for a clause 45 PHY, read the \"devices in package\" registers. "
"If the \"devices in package\" appears valid, read the ID registers for each "
"MMD, allocate and return a :c:type:`struct phy_device <phy_device>`."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1103
msgid ""
"Returns an allocated :c:type:`struct phy_device <phy_device>` on success, ``-"
"ENODEV`` if there is no PHY present, or ``-EIO`` on bus access error."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1142
msgid "Register the phy device on the MDIO bus"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1143
msgid "phy_device structure to be added to the MDIO bus"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1181
msgid "Remove a previously registered phy device from the MDIO bus"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1182
msgid "phy_device structure to remove"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1183
msgid ""
"This doesn't free the phy_device itself, it merely reverses the effects of "
"phy_device_register(). Use phy_device_free() to free the device after "
"calling this function."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1203
msgid "Read 802.3-c45 IDs for phy device."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1204
msgid "phy_device structure to read 802.3-c45 IDs"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1205
msgid ""
"Returns zero on success, ``-EIO`` on bus access error, or ``-ENODEV`` if the "
"\"devices in package\" is invalid."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1217
msgid "finds the first PHY device on the bus"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1253
msgid "connect an ethernet device to a specific phy_device"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1254
#: drivers/net/phy/phy_device.c:1282
msgid "the network device to connect"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1255
msgid "the pointer to the phy device"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1257
#: drivers/net/phy/phy_device.c:1285 ../../../networking/kapi:131:
#: drivers/net/phy/phy_device.c:1238
msgid "``void (*handler)(struct net_device *)``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1256
#: drivers/net/phy/phy_device.c:1284
msgid "callback function for state change notifications"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1257
#: drivers/net/phy/phy_device.c:1285 drivers/net/phy/phy_device.c:1616
#: drivers/net/phy/phy_device.c:1789
msgid "PHY device's interface"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1281
msgid "connect an ethernet device to a PHY device"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1283
msgid "the id string of the PHY device to connect"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1287
msgid "Convenience function for connecting ethernet"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1288
msgid ""
"devices to PHY devices.  The default behavior is for the PHY infrastructure "
"to handle everything, and only notify the connected driver when the link "
"status changes.  If you don't want, or can't use the provided functionality, "
"you may choose to call only the subset of functions which provide the "
"desired functionality."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1323
msgid "disable interrupts, stop state machine, and detach a PHY device"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1506
msgid "Connect the SFP module's PHY to the upstream PHY"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1512
#: drivers/net/phy/phy_device.c:1534 drivers/net/phy/phy_device.c:1554
#: drivers/net/phy/phy_device.c:1571 ../../../networking/kapi:161:
#: drivers/net/phy/sfp-bus.c:641
msgid "``void *upstream``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1507
#: drivers/net/phy/phy_device.c:1529
msgid "pointer to the upstream phy device"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1508
#: drivers/net/phy/phy_device.c:1530
msgid "pointer to the SFP module's phy device"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1509
msgid ""
"This helper allows keeping track of PHY devices on the link. It adds the SFP "
"module's phy to the phy namespace of the upstream phy"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1513
msgid "0 on success, otherwise a negative error code."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1528
msgid "Disconnect the SFP module's PHY from the upstream PHY"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1531
msgid ""
"This helper allows keeping track of PHY devices on the link. It removes the "
"SFP module's phy to the phy namespace of the upstream phy. As the module phy "
"will be destroyed, re-inserting the same module will add a new phy with a "
"new index."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1548
msgid "attach the SFP bus to the PHY upstream network device"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1549
#: drivers/net/phy/phy_device.c:1566
msgid "pointer to the phy device"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1551
#: drivers/net/phy/phy_device.c:1568 ../../../networking/kapi:161:
#: drivers/net/phy/sfp-bus.c:339 drivers/net/phy/sfp-bus.c:434
#: drivers/net/phy/sfp-bus.c:485 drivers/net/phy/sfp-bus.c:501
#: drivers/net/phy/sfp-bus.c:519 drivers/net/phy/sfp-bus.c:539
#: drivers/net/phy/sfp-bus.c:556 drivers/net/phy/sfp-bus.c:579
#: drivers/net/phy/sfp-bus.c:644 drivers/net/phy/sfp-bus.c:694
#: drivers/net/phy/sfp-bus.c:715
msgid "``struct sfp_bus *bus``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1550
#: drivers/net/phy/phy_device.c:1567
msgid "sfp bus representing cage being attached"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1551
msgid "This is used to fill in the sfp_upstream_ops .attach member."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1565
msgid "detach the SFP bus from the PHY upstream network device"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1568
msgid "This is used to fill in the sfp_upstream_ops .detach member."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1582
msgid "probe for a SFP cage attached to this PHY device"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1585
#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:642
msgid "``const struct sfp_upstream_ops *ops``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1584
msgid "SFP's upstream operations"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1612
msgid "attach a network device to a given PHY device pointer"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1613
#: drivers/net/phy/phy_device.c:1787
msgid "network device to attach"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1614
msgid "Pointer to phy_device to attach"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1616
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2248
#: drivers/net/phy/phylink.c:2267
msgid "``u32 flags``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1615
msgid "PHY device's dev_flags"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1618
msgid "Called by drivers to attach to a particular PHY"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1619
msgid ""
"device. The phy_device is found, and properly hooked up to the phy_driver.  "
"If no driver is attached, then a generic driver is used.  The phy_device is "
"given a ptr to the attaching device, and given a callback for link status "
"change.  The phy_device is returned to the attaching driver. This function "
"takes a reference on the phy device."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1786
msgid "attach a network device to a particular PHY device"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1788
msgid "Bus ID of PHY device to attach"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1791
msgid "Same as phy_attach_direct() except that a PHY bus_id"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1792
msgid "string is passed instead of a pointer to a struct phy_device."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1824
msgid "detach a PHY device from its network device"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1826
msgid ""
"This detaches the phy device from its network device and the phy driver, and "
"drops the reference count taken in phy_attach_direct()."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1960
msgid "perform a PHY reset if needed"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1963
msgid "Some PHYs are known to need a reset after their refclk was"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:1964
msgid ""
"enabled. This function evaluates the flags and perform the reset if it's "
"needed. Returns < 0 on error, 0 if the phy wasn't reset and 1 if the phy was "
"reset."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2072
msgid "configures/forces speed/duplex from **phydev**"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2075
msgid "Configures MII_BMCR to force speed/duplex"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2076
msgid ""
"to the values in phydev. Assumes that the values are valid. Please see "
"phy_sanitize_settings()."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2173
msgid "Enable and Restart Autonegotiation"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2215
#: drivers/net/phy/phy_device.c:2272
msgid "restart auto-negotiation or write BMCR"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2218
msgid "``bool changed``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2217
msgid "whether autoneg is requested"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2220
msgid ""
"advertising, and then restart auto-negotiation.  If it is not enabled, then "
"we write the BMCR."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2276
msgid ""
"advertising, and then restart auto-negotiation.  If it is not enabled, then "
"we write the BMCR. This function is intended for use with Clause 37 1000Base-"
"X mode."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2323
msgid "Reads the status register and returns 0 either if"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2324
msgid ""
"auto-negotiation is incomplete, or if there was an error. Returns "
"BMSR_ANEGCOMPLETE if auto-negotiation is done."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2336
msgid "update link status in **phydev**"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2339
msgid "Update the value in phydev->link to reflect the"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2340
msgid ""
"current link value.  In order to do this, we need to read the status "
"register twice, keeping the second value."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2436
msgid "read the link parameters for !aneg mode"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2438
msgid ""
"Read the current duplex and speed state for a PHY operating with "
"autonegotiation disabled."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2466
#: drivers/net/phy/phy_device.c:2517
msgid "check the link status and update current link state"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2469
#: drivers/net/phy/phy_device.c:2521
msgid "Check the link, then figure out the current state"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2470
msgid ""
"by comparing what we advertise with what the link partner advertises.  Start "
"by checking the gigabit possibilities, then move on to 10/100."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2520
msgid "``bool *changed``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2519
msgid "pointer where to store if link changed"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2522
msgid ""
"by comparing what we advertise with what the link partner advertises. This "
"function is for Clause 37 1000Base-X mode."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2525
msgid "If link has changed, **changed** is set to true, false otherwise."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2581
msgid "software reset the PHY via BMCR_RESET bit"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2584
msgid ""
"Perform a software PHY reset using the standard BMCR_RESET bit and poll for "
"the reset bit to be cleared."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2587
#: drivers/net/phy/phy_device.c:2639 drivers/net/phy/phy_device.c:3072
#: drivers/net/phy/phy_device.c:3095
msgid "0 on success, < 0 on failure"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2633
msgid "read PHY abilities from Clause 22 registers"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2636
msgid "Reads the PHY's abilities and populates phydev->supported accordingly."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2748
msgid "Remove a supported link mode"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2749
msgid "phy_device structure to remove link mode from"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2750
msgid "Link mode to be removed"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2752
msgid ""
"Some MACs don't support all link modes which the PHY does.  e.g. a 1G MAC "
"often does not support 1000Half. Add a helper to remove a link mode."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2772
msgid "Advertise all supported modes"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2775
msgid ""
"Called to advertise all supported modes, doesn't touch pause mode "
"advertising."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2789
msgid "Advertise all supported EEE modes"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2792
msgid ""
"Per default phylib preserves the EEE advertising at the time of phy probing, "
"which might be a subset of the supported EEE modes. Use this function when "
"all supported EEE modes should be advertised. This does not trigger auto-"
"negotiation, so must be called before phy_start()/ phylink_start() which "
"will start auto-negotiation."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2805
msgid "Set initial EEE policy configuration"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2806
#: drivers/net/phy/phy_device.c:2834
msgid "Target phy_device struct"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2807
msgid ""
"This function configures the initial policy for Energy Efficient Ethernet "
"(EEE) on the specified PHY device, influencing that EEE capabilities are "
"advertised before the link is established. It should be called during PHY "
"registration by the MAC driver and/or the PHY driver (for SmartEEE PHYs) if "
"MAC supports LPI or PHY is capable to compensate missing LPI functionality "
"of the MAC."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2814
msgid ""
"The function sets default EEE policy parameters, including preparing the PHY "
"to advertise EEE capabilities based on hardware support."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2817
msgid ""
"It also sets the expected configuration for Low Power Idle (LPI) in the MAC "
"driver. If the PHY framework determines that both local and remote "
"advertisements support EEE, and the negotiated link mode is compatible with "
"EEE, it will set enable_tx_lpi = true. The MAC driver is expected to act on "
"this setting by enabling the LPI timer if enable_tx_lpi is set."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2833
msgid "Disable EEE for the PHY"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2835
msgid ""
"This function is used by MAC drivers for MAC's which don't support EEE. It "
"disables EEE on the PHY layer."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2850
msgid "Enable support of symmetrical pause"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2853
msgid ""
"Called by the MAC to indicate is supports symmetrical Pause, but not asym "
"pause."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2864
msgid "Enable support of asym pause"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2867
msgid "Called by the MAC to indicate is supports Asym Pause."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2876
msgid "Configure symmetric Pause"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2879
#: drivers/net/phy/phy_device.c:2903
msgid "``bool rx``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2878
#: drivers/net/phy/phy_device.c:2902
msgid "Receiver Pause is supported"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2880
#: drivers/net/phy/phy_device.c:2904
msgid "``bool tx``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2879
#: drivers/net/phy/phy_device.c:2903
msgid "Transmit Pause is supported"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2881
msgid "``bool autoneg``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2880
msgid "Auto neg should be used"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2882
msgid ""
"Configure advertised Pause support depending on if receiver pause and pause "
"auto neg is supported. Generally called from the set_pauseparam .ndo."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2900
msgid "Configure Pause and Asym Pause"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2905
msgid ""
"Configure advertised Pause support depending on if transmit and receiver "
"pause is supported. If there has been a change in adverting, trigger a new "
"autoneg. Generally called from the set_pauseparam .ndo."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2924
msgid "Test if the PHY/MAC support the pause configuration"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2925
#: drivers/net/phy/phy_device.c:2950 drivers/net/phy/phy_device.c:2988
#: drivers/net/phy/phy_device.c:3067 drivers/net/phy/phy_device.c:3091
msgid "phy_device struct"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2927
msgid "``struct ethtool_pauseparam *pp``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2926
msgid "requested pause configuration"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2928
msgid ""
"Test if the PHY/MAC combination supports the Pause configuration the user is "
"requesting. Returns True if it is supported, false otherwise."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2949
msgid "resolve negotiated pause modes"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2952
msgid "``bool *tx_pause``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2951
msgid "pointer to bool to indicate whether transmit pause should be enabled."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2954
msgid "``bool *rx_pause``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2953
msgid "pointer to bool to indicate whether receive pause should be enabled."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2955
msgid ""
"Resolve and return the flow control modes according to the negotiation "
"result. This includes checking that we are operating in full duplex mode. "
"See linkmode_resolve_pause() for further details."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2987
msgid "returns the index of the internal delay"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2990
msgid "``const int *delay_values``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2989
msgid "array of delays the PHY supports"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2990
msgid "the size of the delay array"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2992
msgid "``bool is_rx``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2991
msgid "boolean to indicate to get the rx internal delay"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:2992
msgid ""
"Returns the index within the array of internal delay passed in. If the "
"device property is not present then the interface type is checked if the "
"interface defines use of internal delay then a 1 is returned otherwise a 0 "
"is returned. The array must be in ascending order. If PHY does not have an "
"ascending order array then size = 0 and the value of the delay property is "
"returned. Return -EINVAL if the delay is invalid or cannot be found."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:3066
msgid "stores tx amplitude gain in **val**"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:3068
#: drivers/net/phy/phy_device.c:3092
msgid "pointer to the devices device struct"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:3070
msgid "``enum ethtool_link_mode_bit_indices linkmode``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:3069
msgid "linkmode for which the tx amplitude gain should be retrieved"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:3071
#: drivers/net/phy/phy_device.c:3094
msgid "``u32 *val``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:3070
msgid "tx amplitude gain"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:3090
msgid "stores MAC termination in **val**"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:3093
msgid "MAC termination"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:3317
msgid "Given a fwnode, find the mdio_device"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:3318
msgid "pointer to the mdio_device's fwnode"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:3319
msgid ""
"If successful, returns a pointer to the mdio_device with the embedded struct "
"device refcount incremented by one, or NULL on failure. The caller should "
"call put_device() on the mdio_device after its use."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:3340
msgid "For provided phy_fwnode, find phy_device."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:3346
msgid "``struct fwnode_handle *phy_fwnode``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:3342
msgid "Pointer to the phy's fwnode."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:3343
msgid ""
"If successful, returns a pointer to the phy_device with the embedded struct "
"device refcount incremented by one, or NULL on failure."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:3365
msgid "Get the phy_node using the named reference."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:3371
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1819
#: drivers/net/phy/phylink.c:2266 ../../../networking/kapi:161:
#: drivers/net/phy/sfp-bus.c:599
msgid "``const struct fwnode_handle *fwnode``"
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:3366
msgid "Pointer to fwnode from which phy_node has to be obtained."
msgstr ""

#: ../../../networking/kapi:128: drivers/net/phy/phy_device.c:3367
msgid ""
"Refer return conditions of fwnode_find_reference(). For ACPI, only \"phy-"
"handle\" is supported. Legacy DT properties \"phy\" and \"phy-device\" are "
"not supported in ACPI. DT supports all the three named references to the phy "
"node."
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:268
msgid "test whether consumer driver uses PAL state machine"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:269
msgid "the target PHY device structure"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:270
msgid ""
"Ultimately, this aims to indirectly determine whether the PHY is attached to "
"a consumer which uses the state machine by calling phy_start() and "
"phy_stop()."
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:274
msgid ""
"When the PHY driver consumer uses phylib, it must have previously called "
"phy_connect_direct() or one of its derivatives, so that phy_prepare_link() "
"has set up a hook for monitoring state changes."
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:278
msgid ""
"When the PHY driver is used by the MAC driver consumer through phylink (the "
"only other provider of a phy_link_change() method), using the PHY state "
"machine is not optional."
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:283
msgid "true if consumer calls phy_start() and phy_stop(), false otherwise."
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:423
msgid "creates a new phy_fixup and adds it to the list"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:424
msgid "A string which matches phydev->mdio.dev.bus_id (or PHY_ANY_ID)"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:425
msgid ""
"Used to match against phydev->phy_id (the UID of the PHY) It can also be "
"PHY_ANY_UID"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:427
msgid "Applied to phydev->phy_id and fixup->phy_uid before comparison"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:430
msgid "``int (*run)(struct phy_device *)``"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:429
msgid "The actual code to be run when a matching PHY is found"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:930
msgid "reads the specified addr for its 802.3-c45 IDs."
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:934
msgid "``struct phy_c45_device_ids *c45_ids``"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:933
msgid "where to store the c45 ID information."
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:934
msgid ""
"Read the PHY \"devices in package\". If this appears to be valid, read the "
"PHY identifiers for each device. Return the \"devices in package\" and "
"identifiers in **c45_ids**."
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:938
msgid ""
"Returns zero on success, ``-EIO`` on bus access error, or ``-ENODEV`` if the "
"\"devices in package\" is invalid or no device responds."
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:1028
msgid "reads the specified addr for its clause 22 ID."
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:1032
msgid "``u32 *phy_id``"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:1031
msgid "where to store the ID retrieved."
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:1032
msgid ""
"Read the 802.3 clause 22 PHY ID from the PHY at **addr** on the **bus**, "
"placing it in **phy_id**. Return zero on successful read and the ID is "
"valid, ``-EIO`` on bus access error, or ``-ENODEV`` if no device responds or "
"invalid ID."
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:1235
msgid "prepares the PHY layer to monitor link status"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:1237
msgid "callback function for link status change notifications"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:1239
msgid "Tells the PHY infrastructure to handle the"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:1240
msgid ""
"gory details on monitoring link status (whether through polling or an "
"interrupt), and to call back to the connected device driver when the link "
"status changes. If you want to monitor your own link state, don't call this "
"function."
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:1342
msgid "Safely wait until a PHY reset has properly completed"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:1343
msgid "The PHY device to poll"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:1345
msgid "According to IEEE 802.3, Section 2, Subsection 22.2.4.1.1, as"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:1346
msgid ""
"published in 2008, a PHY reset may take up to 0.5 seconds.  The MII BMCR "
"register must be polled until the BMCR_RESET bit clears."
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:1349
msgid ""
"Furthermore, any attempts to write to PHY registers may have no effect or "
"even generate MDIO bus errors until this is complete."
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:1352
msgid ""
"Some PHYs (such as the Marvell 88E1111) don't entirely conform to the "
"standard and do not fully reset after the BMCR_RESET bit is set, and may "
"even *REQUIRE* a soft-reset to properly restart autonegotiation.  In an "
"effort to support such broken PHYs, this function is separate from the "
"standard phy_init_hw() which will zero all the other bits in the BMCR and "
"reapply all driver-specific and board-specific fixups."
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:1986
#: drivers/net/phy/phy_device.c:2038
msgid "sanitize and advertise auto-negotiation parameters"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:1989
msgid "``const unsigned long *advert``"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:1988
msgid "auto-negotiation parameters to advertise"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:1990
#: drivers/net/phy/phy_device.c:2041
msgid "Writes MII_ADVERTISE with the appropriate values,"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:1991
msgid ""
"after sanitizing the values to make sure we only advertise what is "
"supported.  Returns < 0 on error, 0 if the PHY's advertisement hasn't "
"changed, and > 0 if it has changed."
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:2042
msgid ""
"after sanitizing the values to make sure we only advertise what is "
"supported.  Returns < 0 on error, 0 if the PHY's advertisement hasn't "
"changed, and > 0 if it has changed. This function is intended for Clause 37 "
"1000Base-X mode."
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:3389
msgid "probe and init a PHY device"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:3390
msgid "device to probe and init"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:3391
msgid ""
"Take care of setting up the phy_device structure, set the state to READY."
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:3543
msgid "register a phy_driver with the PHY layer"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:3549
msgid "``struct phy_driver *new_driver``"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:3544
msgid "new phy_driver to register"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:3546
msgid "``struct module *owner``"
msgstr ""

#: ../../../networking/kapi:131: drivers/net/phy/phy_device.c:3545
msgid "module owning this PHY"
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:370
msgid "Given the name of a mdiobus, find the mii_bus."
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:376
msgid "``const char *mdio_name``"
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:371
msgid "The name of a mdiobus."
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:372
msgid ""
"Returns a reference to the mii_bus, or NULL if none found.  The embedded "
"struct device will have its reference count incremented, and this must be "
"put_deviced'ed once the bus is finished with."
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:388
msgid "Given an mii_bus node, find the mii_bus."
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:394
msgid "``struct device_node *mdio_bus_np``"
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:389
msgid "Pointer to the mii_bus."
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:390
msgid ""
"Returns a reference to the mii_bus, or NULL if none found.  The embedded "
"struct device will have its reference count incremented, and this must be "
"put once the bus is finished with."
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:394
msgid ""
"Because the association of a device_node and mii_bus is made via "
"of_mdiobus_register(), the mii_bus cannot be found before it is registered "
"with of_mdiobus_register()."
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:434
msgid "Unlocked version of the mdiobus_read function"
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:435
#: drivers/net/phy/mdio_bus.c:466 drivers/net/phy/mdio_bus.c:498
#: drivers/net/phy/mdio_bus.c:530 drivers/net/phy/mdio_bus.c:562
#: drivers/net/phy/mdio_bus.c:629 drivers/net/phy/mdio_bus.c:654
#: drivers/net/phy/mdio_bus.c:676 drivers/net/phy/mdio_bus.c:699
#: drivers/net/phy/mdio_bus.c:726 drivers/net/phy/mdio_bus.c:752
#: drivers/net/phy/mdio_bus.c:775 drivers/net/phy/mdio_bus.c:800
#: drivers/net/phy/mdio_bus.c:849 drivers/net/phy/mdio_bus.c:870
#: drivers/net/phy/mdio_bus.c:894 drivers/net/phy/mdio_bus.c:916
#: ../../../networking/kapi:137: drivers/net/phy/mdio_bus.c:596
msgid "the mii_bus struct"
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:436
#: drivers/net/phy/mdio_bus.c:467 drivers/net/phy/mdio_bus.c:499
#: drivers/net/phy/mdio_bus.c:531 drivers/net/phy/mdio_bus.c:563
#: drivers/net/phy/mdio_bus.c:630 drivers/net/phy/mdio_bus.c:655
#: drivers/net/phy/mdio_bus.c:677 drivers/net/phy/mdio_bus.c:700
#: drivers/net/phy/mdio_bus.c:727 drivers/net/phy/mdio_bus.c:753
#: drivers/net/phy/mdio_bus.c:776 drivers/net/phy/mdio_bus.c:801
#: drivers/net/phy/mdio_bus.c:850 drivers/net/phy/mdio_bus.c:871
#: drivers/net/phy/mdio_bus.c:895 drivers/net/phy/mdio_bus.c:917
#: ../../../networking/kapi:137: drivers/net/phy/mdio_bus.c:597
msgid "the phy address"
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:438
#: drivers/net/phy/mdio_bus.c:534
msgid "Read a MDIO bus register. Caller must hold the mdio bus lock."
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:441
#: drivers/net/phy/mdio_bus.c:473 drivers/net/phy/mdio_bus.c:507
#: drivers/net/phy/mdio_bus.c:537 drivers/net/phy/mdio_bus.c:570
#: ../../../networking/kapi:137: drivers/net/phy/mdio_bus.c:606
msgid "MUST NOT be called from interrupt context."
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:465
#: drivers/net/phy/mdio_bus.c:561
msgid "Unlocked version of the mdiobus_write function"
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:470
#: drivers/net/phy/mdio_bus.c:567
msgid "Write a MDIO bus register. Caller must hold the mdio bus lock."
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:497
#: ../../../networking/kapi:137: drivers/net/phy/mdio_bus.c:595
msgid "Unlocked version of the mdiobus_modify function"
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:503
#: ../../../networking/kapi:137: drivers/net/phy/mdio_bus.c:602
msgid ""
"Read, modify, and if any change, write the register value back to the "
"device. Any error returns a negative number."
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:529
msgid "Unlocked version of the mdiobus_c45_read function"
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:532
#: drivers/net/phy/mdio_bus.c:564 drivers/net/phy/mdio_bus.c:678
#: drivers/net/phy/mdio_bus.c:701 drivers/net/phy/mdio_bus.c:777
#: drivers/net/phy/mdio_bus.c:802 drivers/net/phy/mdio_bus.c:872
#: drivers/net/phy/mdio_bus.c:918 ../../../networking/kapi:137:
#: drivers/net/phy/mdio_bus.c:598
msgid "device address to read"
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:628
msgid "Nested version of the mdiobus_read function"
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:632
#: drivers/net/phy/mdio_bus.c:703 drivers/net/phy/mdio_bus.c:730
#: drivers/net/phy/mdio_bus.c:805
msgid ""
"In case of nested MDIO bus access avoid lockdep false positives by using "
"mutex_lock_nested()."
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:653
#: drivers/net/phy/mdio_bus.c:675
msgid "Convenience function for reading a given MII mgmt register"
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:698
msgid "Nested version of the mdiobus_c45_read function"
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:725
msgid "Nested version of the mdiobus_write function"
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:751
#: drivers/net/phy/mdio_bus.c:774
msgid "Convenience function for writing a given MII mgmt register"
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:799
msgid "Nested version of the mdiobus_c45_write function"
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:847
#: drivers/net/phy/mdio_bus.c:868
msgid "Convenience function for modifying a given mdio device register"
msgstr ""

#: ../../../networking/kapi:134: drivers/net/phy/mdio_bus.c:892
#: drivers/net/phy/mdio_bus.c:914
msgid ""
"Convenience function for modifying a given mdio device register and "
"returning if it changed"
msgstr ""

#: ../../../networking/kapi:137: drivers/net/phy/mdio_bus.c:135
msgid "mii_bus device release callback"
msgstr ""

#: ../../../networking/kapi:137: drivers/net/phy/mdio_bus.c:141
msgid "``struct device *d``"
msgstr ""

#: ../../../networking/kapi:137: drivers/net/phy/mdio_bus.c:136
msgid "the target struct device that contains the mii_bus"
msgstr ""

#: ../../../networking/kapi:137: drivers/net/phy/mdio_bus.c:138
msgid ""
"called when the last reference to an mii_bus is dropped, to free the "
"underlying memory."
msgstr ""

#: ../../../networking/kapi:137: drivers/net/phy/mdio_bus.c:937
msgid "determine if given MDIO driver supports the given MDIO device"
msgstr ""

#: ../../../networking/kapi:137: drivers/net/phy/mdio_bus.c:939
msgid "target MDIO device"
msgstr ""

#: ../../../networking/kapi:137: drivers/net/phy/mdio_bus.c:941
msgid "``const struct device_driver *drv``"
msgstr ""

#: ../../../networking/kapi:137: drivers/net/phy/mdio_bus.c:940
msgid "given MDIO driver"
msgstr ""

#: ../../../networking/kapi:137: drivers/net/phy/mdio_bus.c:942
msgid "Given a MDIO device, and a MDIO driver, return 1 if"
msgstr ""

#: ../../../networking/kapi:137: drivers/net/phy/mdio_bus.c:943
msgid ""
"the driver supports the device.  Otherwise, return 0. This may require "
"calling the devices own match function, since different classes of MDIO "
"devices have different match criteria."
msgstr ""

#: ../../../networking/kapi.rst:141
msgid "PHYLINK"
msgstr ""

#: ../../../networking/kapi.rst:143
msgid ""
"PHYLINK interfaces traditional network drivers with PHYLIB, fixed-links, and "
"SFF modules (eg, hot-pluggable SFP) that may contain PHYs.  PHYLINK provides "
"management of the link state and link modes."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:104
msgid "link state structure"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:106
msgid "ethtool bitmask containing advertised link modes"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:107
msgid "ethtool bitmask containing link partner advertised link modes"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:109
#: include/linux/phylink.h:366 include/linux/phylink.h:387
#: include/linux/phylink.h:632 include/linux/phylink.h:756
msgid "link :c:type:`typedef phy_interface_t <phy_interface_t>` mode"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:110
msgid "link speed, one of the SPEED_* constants."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:111
msgid "link duplex mode, one of DUPLEX_* constants."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:112
msgid "link pause state, described by MLO_PAUSE_* constants."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:113
msgid ""
"rate matching being performed, one of the RATE_MATCH_* constants. If rate "
"matching is taking place, then the speed/duplex of the medium link mode "
"(**speed** and **duplex**) and the speed/duplex of the phy interface mode "
"(**interface**) are different."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:117
msgid "true if the link is up."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:117
msgid "``an_complete``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:118
msgid "true if autonegotiation has completed."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:137
msgid "PHYLINK configuration structure"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:139
msgid "a pointer to a struct device associated with the MAC"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:140
msgid "operation type of PHYLINK instance"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:140
msgid "``poll_fixed_state``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:141
msgid "if true, starts link_poll, if MAC link is at ``MLO_AN_FIXED`` mode."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:143
msgid "if true, indicate the MAC driver is responsible for PHY PM."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:143
msgid "``mac_requires_rxc``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:144
msgid ""
"if true, the MAC always requires a receive clock from PHY. The PHY driver "
"should start the clock signal as soon as possible and avoid stopping it "
"during suspend events."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:146
msgid "``default_an_inband``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:147
msgid ""
"if true, defaults to MLO_AN_INBAND rather than MLO_AN_PHY. A fixed-link "
"specification will override."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:148
msgid "``eee_rx_clk_stop_enable``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:149
msgid "if true, PHY can stop the receive clock during LPI"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:149
msgid "``get_fixed_state``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:150
msgid ""
"callback to execute to determine the fixed link state, if MAC link is at "
"``MLO_AN_FIXED`` mode."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:151
#: include/linux/phylink.h:449
msgid "``supported_interfaces``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:152
msgid ""
"bitmap describing which PHY_INTERFACE_MODE_xxx are supported by the MAC/PCS."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:153
msgid "``lpi_interfaces``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:154
msgid "bitmap describing which PHY interface modes can support LPI signalling."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:155
msgid "``mac_capabilities``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:156
msgid "MAC pause/speed/duplex capabilities."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:156
msgid "``lpi_capabilities``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:157
msgid "MAC speeds which can support LPI signalling"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:157
msgid "``lpi_timer_default``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:158
msgid "Default EEE LPI timer setting."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:158
msgid "``eee_enabled_default``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:159
msgid "If set, EEE will be enabled by phylink at creation time"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:181
msgid "MAC operations structure."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:182
msgid "``mac_get_caps``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:183
#: include/linux/phylink.h:218
msgid "Get MAC capabilities for interface mode."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:183
msgid "``mac_select_pcs``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:184
#: include/linux/phylink.h:230
msgid "Select a PCS for the interface mode."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:184
msgid "``mac_prepare``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:185
msgid "prepare for a major reconfiguration of the interface."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:185
msgid "``mac_config``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:186
msgid "configure the MAC for the selected mode and state."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:186
msgid "``mac_finish``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:187
msgid "finish a major reconfiguration of the interface."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:187
msgid "``mac_link_down``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:188
msgid "take the link down."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:188
msgid "``mac_link_up``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:189
msgid "allow the link to come up."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:189
msgid "``mac_disable_tx_lpi``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:190
msgid "disable LPI."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:190
msgid "``mac_enable_tx_lpi``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:191
msgid "enable and configure LPI."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:191
msgid "The individual methods are described more fully below."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:224
#: include/linux/phylink.h:236 include/linux/phylink.h:252
#: include/linux/phylink.h:277 include/linux/phylink.h:352
#: include/linux/phylink.h:369 include/linux/phylink.h:389
#: include/linux/phylink.h:424 include/linux/phylink.h:433
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:386
#: drivers/net/phy/phylink.c:1822
msgid "``struct phylink_config *config``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:219
#: include/linux/phylink.h:231 include/linux/phylink.h:247
#: include/linux/phylink.h:272 include/linux/phylink.h:347
#: include/linux/phylink.h:364 include/linux/phylink.h:384
#: include/linux/phylink.h:419 include/linux/phylink.h:428
msgid "a pointer to a :c:type:`struct phylink_config <phylink_config>`."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:220
msgid "PHY interface mode."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:221
msgid ""
"Optional method. When not provided, config->mac_capabilities will be used. "
"When implemented, this returns the MAC capabilities for the specified "
"interface mode where there is some special handling required by the MAC "
"driver (e.g. not supporting half-duplex in certain interface modes.)"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:232
msgid "PHY interface mode for PCS"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:233
msgid ""
"Return the :c:type:`struct phylink_pcs <phylink_pcs>` for the specified "
"interface mode, or NULL if none is required, or an error pointer on error."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:236
msgid ""
"This must not modify any state. It is used to query which PCS should be "
"used. Phylink will use this during validation to ensure that the "
"configuration is valid, and when setting a configuration to internally set "
"the PCS that will be used."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:246
msgid "prepare to change the PHY interface mode"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:249
#: include/linux/phylink.h:274 include/linux/phylink.h:349
#: include/linux/phylink.h:366 include/linux/phylink.h:387
msgid "``unsigned int mode``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:248
#: include/linux/phylink.h:273 include/linux/phylink.h:348
msgid "one of ``MLO_AN_FIXED``, ``MLO_AN_PHY``, ``MLO_AN_INBAND``."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:249
#: include/linux/phylink.h:349
msgid "interface mode to switch to"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:250
msgid ""
"phylink will call this method at the beginning of a full initialisation of "
"the link, which includes changing the interface mode or at initial startup "
"time. It may be called for the current mode. The MAC driver should perform "
"whatever actions are required, e.g. disabling the Serdes PHY."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:256
msgid ""
"This will be the first call in the sequence: - mac_prepare() - mac_config() "
"- pcs_config() - possible pcs_an_restart() - mac_finish()"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:263
#: include/linux/phylink.h:355
msgid ""
"Returns zero on success, or negative errno on failure which will be reported "
"to the kernel log."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:271
msgid "configure the MAC for the selected mode and state"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:275
#: include/linux/phylink.h:524 ../../../networking/kapi:150:
#: drivers/net/phy/phylink.c:1778
msgid "``const struct phylink_link_state *state``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:274
#: include/linux/phylink.h:566 ../../../networking/kapi:150:
#: drivers/net/phy/phylink.c:4044 drivers/net/phy/phylink.c:4110
msgid ""
"a pointer to a :c:type:`struct phylink_link_state <phylink_link_state>`."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:275
msgid ""
"Note - not all members of **state** are valid.  In particular, **state-"
">lp_advertising**, **state->link**, **state->an_complete** are never "
"guaranteed to be correct, and so any mac_config() implementation must never "
"reference these fields."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:280
msgid ""
"This will only be called to reconfigure the MAC for a \"major\" change in e."
"g. interface mode. It will not be called for changes in speed, duplex or "
"pause modes or to change the in-band advertisement."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:284
msgid ""
"In all negotiation modes, as defined by **mode**, **state->pause** indicates "
"the pause settings which should be applied as follows. If ``MLO_PAUSE_AN`` "
"is not set, ``MLO_PAUSE_TX`` and ``MLO_PAUSE_RX`` indicate whether the MAC "
"should send pause frames and/or act on received pause frames respectively. "
"Otherwise, the results of in-band negotiation/status from the MAC PCS should "
"be used to control the MAC pause mode settings."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:291
msgid "The action performed depends on the currently selected mode:"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:293
msgid "``MLO_AN_FIXED``, ``MLO_AN_PHY``:"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:294
msgid ""
"Configure for non-inband negotiation mode, where the link settings are "
"completely communicated via mac_link_up().  The physical link protocol from "
"the MAC is specified by **state->interface**."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:298
msgid "**state->advertising** may be used, but is not required."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:300
msgid ""
"Older drivers (prior to the mac_link_up() change) may use **state->speed**, "
"**state->duplex** and **state->pause** to configure the MAC, but this is "
"deprecated; such drivers should be converted to use mac_link_up()."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:304
msgid "Other members of **state** must be ignored."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:306
msgid ""
"Valid state members: interface, advertising. Deprecated state members: "
"speed, duplex, pause."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:309
msgid "``MLO_AN_INBAND``:"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:310
msgid ""
"place the link in an inband negotiation mode (such as 802.3z 1000base-X or "
"Cisco SGMII mode depending on the **state->interface** mode). In both cases, "
"link state management (whether the link is up or not) is performed by the "
"MAC, and reported via the pcs_get_state() callback. Changes in link state "
"must be made by calling phylink_mac_change()."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:317
msgid "Interface mode specific details are mentioned below."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:319
msgid ""
"If in 802.3z mode, the link speed is fixed, dependent on the **state-"
">interface**. Duplex and pause modes are negotiated via the in-band "
"configuration word. Advertised pause modes are set according to **state-"
">advertising**. Beware of MACs which only support full duplex at gigabit and "
"higher speeds."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:325
msgid ""
"If in Cisco SGMII mode, the link speed and duplex mode are passed in the "
"serial bitstream 16-bit configuration word, and the MAC should be configured "
"to read these bits and acknowledge the configuration word. Nothing is "
"advertised by the MAC. The MAC is responsible for reading the configuration "
"word and configuring itself accordingly."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:332
msgid "Valid state members: interface, pause, advertising."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:334
msgid ""
"Implementations are expected to update the MAC to reflect the requested "
"settings - i.o.w., if nothing has changed between two calls, no action is "
"expected.  If only flow control settings have changed, flow control should "
"be updated *without* taking the link down.  This \"update\" behaviour is "
"critical to avoid bouncing the link up status."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:346
msgid "finish a to change the PHY interface mode"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:350
msgid ""
"phylink will call this if it called mac_prepare() to allow the MAC to "
"complete any necessary steps after the MAC and PCS have been configured for "
"the **mode** and **iface**. E.g. a MAC driver may wish to re-enable the "
"Serdes PHY here if it was previously disabled by mac_prepare()."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:363
msgid "notification that the link has gone down"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:365
#: include/linux/phylink.h:386
msgid "link autonegotiation mode"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:367
msgid ""
"Notifies the MAC that the link has gone down. This will not be called unless "
"mac_link_up() has been previously called."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:370
msgid ""
"The MAC should stop processing packets for transmission and reception. "
"phylink will have called netif_carrier_off() to notify the networking stack "
"that the link has gone down, so MAC drivers should not make this call."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:375
msgid ""
"If **mode** is ``MLO_AN_INBAND``, then this function must not prevent the "
"link coming up."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:383
msgid "notification that the link has come up"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:385
msgid "any attached phy (deprecated - please use LPI interfaces)"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:388
#: include/linux/phylink.h:633
msgid "link speed"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:389
#: include/linux/phylink.h:634
msgid "link duplex"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:391
msgid "``bool tx_pause``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:390
msgid "link transmit pause enablement status"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:392
msgid "``bool rx_pause``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:391
msgid "link receive pause enablement status"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:392
msgid ""
"Notifies the MAC that the link has come up, and the parameters of the link "
"as seen from the MACs point of view. If mac_link_up() has been called "
"previously, there will be an intervening call to mac_link_down() before this "
"method will be subsequently called."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:397
msgid ""
"**speed**, **duplex**, **tx_pause** and **rx_pause** indicate the finalised "
"link settings, and should be used to configure the MAC block appropriately "
"where these settings are not automatically conveyed from the PCS block, or "
"if in-band negotiation (as defined by phylink_autoneg_inband(**mode**)) is "
"disabled."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:403
msgid ""
"Note that when 802.3z in-band negotiation is in use, it is possible that the "
"user wishes to override the pause settings, and this should be allowed when "
"considering the implementation of this method."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:407
msgid ""
"Once configured, the MAC may begin to process packets for transmission and "
"reception."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:410
msgid "Interface type selection must be done in mac_config()."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:418
msgid "disable LPI generation at the MAC"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:420
msgid ""
"Disable generation of LPI at the MAC, effectively preventing the MAC from "
"indicating that it is idle."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:427
msgid "configure and enable LPI generation at the MAC"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:430
msgid "``u32 timer``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:429
msgid "LPI timeout in microseconds."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:431
msgid "``bool tx_clk_stop``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:430
msgid "allow xMII transmit clock to be stopped during LPI"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:431
msgid ""
"Configure the LPI timeout accordingly. This will only be called when the "
"link is already up, to cater for situations where the hardware needs to be "
"programmed according to the link speed."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:435
msgid ""
"Enable LPI generation at the MAC, and configure whether the xMII transmit "
"clock may be stopped."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:439
msgid "0 on success. Please consult with rmk before returning an error."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:448
msgid "PHYLINK PCS instance"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:450
msgid "describing which PHY_INTERFACE_MODE_xxx are supported by this PCS."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:452
msgid ""
"a pointer to the :c:type:`struct phylink_pcs_ops <phylink_pcs_ops>` structure"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:453
msgid "pointer to :c:type:`struct phylink_config <phylink_config>`"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:453
msgid "``poll``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:454
msgid "poll the PCS for link changes"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:454
msgid "``rxc_always_on``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:455
msgid ""
"The MAC driver requires the reference clock to always be on. Standalone PCS "
"drivers which do not have access to a PHY device can check this instead of "
"PHY_F_RXC_ALWAYS_ON."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:458
msgid ""
"This structure is designed to be embedded within the PCS private data, and "
"will be passed between phylink and the PCS."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:461
msgid ""
"The **phylink** member is private to phylink and must not be touched by the "
"PCS driver."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:474
msgid "MAC PCS operations structure."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:475
msgid "``pcs_validate``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:476
#: include/linux/phylink.h:520
msgid "validate the link configuration."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:476
msgid "``pcs_inband_caps``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:477
msgid "query inband support for interface mode."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:477
msgid "``pcs_enable``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:478
#: include/linux/phylink.h:551
msgid "enable the PCS."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:478
msgid "``pcs_disable``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:479
#: include/linux/phylink.h:557
msgid "disable the PCS."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:479
msgid "``pcs_pre_config``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:480
msgid "pre-mac_config method (for errata)"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:480
msgid "``pcs_post_config``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:481
msgid "post-mac_config method (for arrata)"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:481
msgid "``pcs_get_state``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:482
msgid "read the current MAC PCS link state from the hardware."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:482
msgid "``pcs_config``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:483
msgid "configure the MAC PCS for the selected mode and state."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:483
msgid "``pcs_an_restart``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:484
msgid "restart 802.3z BaseX autonegotiation."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:484
msgid "``pcs_link_up``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:485
msgid "program the PCS for the resolved link configuration (where necessary)."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:486
msgid "``pcs_disable_eee``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:487
msgid "optional notification to PCS that EEE has been disabled at the MAC."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:488
msgid "``pcs_enable_eee``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:489
msgid "optional notification to PCS that EEE will be enabled at the MAC."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:490
msgid "``pcs_pre_init``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:491
msgid ""
"configure PCS components necessary for MAC hardware initialization e.g. RX "
"clock for stmmac."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:526
#: include/linux/phylink.h:543 include/linux/phylink.h:557
#: include/linux/phylink.h:563 include/linux/phylink.h:569
#: include/linux/phylink.h:588 include/linux/phylink.h:626
#: include/linux/phylink.h:635 include/linux/phylink.h:655
#: include/linux/phylink.h:663 include/linux/phylink.h:671
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1064
#: drivers/net/phy/phylink.c:2385
msgid "``struct phylink_pcs *pcs``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:521
#: include/linux/phylink.h:538 include/linux/phylink.h:552
#: include/linux/phylink.h:558 include/linux/phylink.h:564
#: include/linux/phylink.h:583 include/linux/phylink.h:621
#: include/linux/phylink.h:630 include/linux/phylink.h:666
msgid "a pointer to a :c:type:`struct phylink_pcs <phylink_pcs>`."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:523
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:490
msgid "``unsigned long *supported``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:522
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:485
msgid "ethtool bitmask for supported link modes."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:523
msgid ""
"a const pointer to a :c:type:`struct phylink_link_state "
"<phylink_link_state>`."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:524
msgid ""
"Validate the interface mode, and advertising's autoneg bit, removing any "
"media ethtool link modes that would not be supportable from the supported "
"mask. Phylink will propagate the changes to the advertising mask. See the :c:"
"type:`struct phylink_mac_ops <phylink_mac_ops>` validate() method."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:529
msgid ""
"Returns -EINVAL if the interface mode/autoneg mode is not supported. Returns "
"non-zero positive if the link state can be supported."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:537
msgid "query PCS in-band capabilities for interface mode."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:539
msgid "interface mode to be queried"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:540
msgid ""
"Returns zero if it is unknown what in-band signalling is supported by the "
"PHY (e.g. because the PHY driver doesn't implement the method.) Otherwise, "
"returns a bit mask of the LINK_INBAND_* values from :c:type:`enum "
"link_inband_signalling <link_inband_signalling>` to describe which inband "
"modes are supported for this interface mode."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:563
msgid "Read the current inband link state from the hardware"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:566
#: include/linux/phylink.h:585 include/linux/phylink.h:632
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4046
#: drivers/net/phy/phylink.c:4110 drivers/net/phy/phylink.c:4184
msgid "``unsigned int neg_mode``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:565
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4045
#: drivers/net/phy/phylink.c:4109
msgid "link negotiation mode (PHYLINK_PCS_NEG_xxx)"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:567
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:487
#: drivers/net/phy/phylink.c:3971 drivers/net/phy/phylink.c:4014
#: drivers/net/phy/phylink.c:4049 drivers/net/phy/phylink.c:4111
msgid "``struct phylink_link_state *state``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:567
msgid ""
"Read the current inband link state from the MAC PCS, reporting the current "
"speed in **state->speed**, duplex mode in **state->duplex**, pause mode in "
"**state->pause** using the ``MLO_PAUSE_RX`` and ``MLO_PAUSE_TX`` bits, "
"negotiation completion state in **state->an_complete**, and link up state in "
"**state->link**. If possible, **state->lp_advertising** should also be "
"populated."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:574
msgid ""
"Note that the **neg_mode** parameter is always the PHYLINK_PCS_NEG_xxx "
"state, not MLO_AN_xxx."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:582
msgid "Configure the PCS mode and advertisement"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:584
#: include/linux/phylink.h:631
msgid "link negotiation mode (see below)"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:585
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1064
msgid "interface mode to be used"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:587
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1066
#: drivers/net/phy/phylink.c:4143 drivers/net/phy/phylink.c:4183
msgid "``const unsigned long *advertising``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:586
#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1065
msgid "adertisement ethtool link mode mask"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:588
msgid "``bool permit_pause_to_mac``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:587
msgid "permit forwarding pause resolution to MAC"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:588
msgid ""
"Configure the PCS for the operating mode, the interface mode, and set the "
"advertisement mask. **permit_pause_to_mac** indicates whether the hardware "
"may forward the pause mode resolution to the MAC."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:592
msgid ""
"When operating in ``MLO_AN_INBAND``, inband should always be enabled, "
"otherwise inband should be disabled."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:595
msgid ""
"For SGMII, there is no advertisement from the MAC side, the PCS should be "
"programmed to acknowledge the inband word from the PHY."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:598
msgid "For 1000BASE-X, the advertisement should be programmed into the PCS."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:600
msgid "For most 10GBASE-R, there is no advertisement."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:602
msgid ""
"The ``neg_mode`` argument should be tested via the phylink_mode_*() family "
"of functions, or for PCS that set pcs->neg_mode true, should be tested "
"against the PHYLINK_PCS_NEG_* definitions."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:606
msgid ""
"pcs_config() will be called when configuration of the PCS is required or "
"when the advertisement is possibly updated. It must not unnecessarily "
"disrupt an established link."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:610
msgid ""
"When an autonegotiation restart is required for 802.3z modes, .pcs_config() "
"should return a positive non-zero integer (e.g. 1) to indicate to phylink to "
"call the pcs_an_restart() method."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:620
msgid "restart 802.3z BaseX autonegotiation"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:622
msgid ""
"When PCS ops are present, this overrides mac_an_restart() in :c:type:`struct "
"phylink_mac_ops <phylink_mac_ops>`."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:629
msgid "program the PCS for the resolved link configuration"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:635
msgid ""
"This call will be made just before mac_link_up() to inform the PCS of the "
"resolved link parameters. For example, a PCS operating in SGMII mode without "
"in-band AN needs to be manually configured for the link and duplex setting. "
"Otherwise, this should be a no-op."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:640
msgid ""
"The ``mode`` argument should be tested via the phylink_mode_*() family of "
"functions, or for PCS that set pcs->neg_mode true, should be tested against "
"the PHYLINK_PCS_NEG_* definitions."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:649
msgid "Disable EEE at the PCS"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:650
#: include/linux/phylink.h:658
msgid "a pointer to a :c:type:`struct phylink_pcs <phylink_pcs>`"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:651
msgid ""
"Optional method informing the PCS that EEE has been disabled at the MAC."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:657
msgid "Enable EEE at the PCS"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:659
msgid ""
"Optional method informing the PCS that EEE is about to be enabled at the MAC."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:665
msgid "Configure PCS components necessary for MAC initialization"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:667
msgid ""
"This function can be called by MAC drivers through the "
"phylink_pcs_pre_init() wrapper, before their hardware is initialized. It "
"should not be called after the link is brought up, as reconfiguring the PCS "
"at this point could break the link."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:672
msgid ""
"Some MAC devices require specific hardware initialization to be performed by "
"their associated PCS device before they can properly initialize their own "
"hardware. An example of this is the initialization of stmmac controllers, "
"which requires an active REF_CLK signal to be provided by the PHY/PCS."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:677
msgid ""
"By calling phylink_pcs_pre_init(), MAC drivers can ensure that the PCS is "
"setup in a way that allows for successful hardware initialization."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:680
msgid ""
"The specific configuration performed by pcs_pre_init() is dependent on the "
"model of PCS and the requirements of the MAC device attached to it. PCS "
"driver authors should consider whether their target device is to be used in "
"conjunction with a MAC device whose driver calls phylink_pcs_pre_init(). MAC "
"driver authors should document their requirements for the PCS pre-"
"initialization."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:755
msgid "return the PCS link timer value"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:757
msgid ""
"Return the PCS link timer setting in nanoseconds for the PHY **interface** "
"mode, or -EINVAL if not appropriate."
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:780
msgid "determine if MAC implements LPI ops"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:786
msgid "``const struct phylink_mac_ops *ops``"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:781
msgid "phylink_mac_ops structure"
msgstr ""

#: ../../../networking/kapi:147: include/linux/phylink.h:782
msgid ""
"Returns true if the phylink MAC operations structure indicates that the LPI "
"operations have been implemented, false otherwise."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:38
msgid "internal data type for phylink"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:148
msgid "set the port type modes in the ethtool mask"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:154
msgid "``unsigned long *mask``"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:149
msgid "ethtool link mode mask"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:150
msgid ""
"Sets all the port type modes in the ethtool mask.  MAC drivers should use "
"this in their 'validate' callback."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:224
msgid "get the maximum speed of a phy interface"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:225
#: drivers/net/phy/phylink.c:423
msgid ""
"phy interface mode defined by :c:type:`typedef phy_interface_t "
"<phy_interface_t>`"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:226
msgid ""
"Determine the maximum speed of a phy interface. This is intended to help "
"determine the correct speed to pass to the MAC when the phy is performing "
"rate matching."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:231
msgid "The maximum speed of **interface**"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:328
msgid "Convert a set of MAC capabilities LINK caps"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:334
#: drivers/net/phy/phylink.c:361
msgid "``unsigned long caps``"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:329
msgid "A set of MAC capabilities"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:331
msgid "The corresponding set of LINK_CAPA as defined in phy-caps.h"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:358
msgid "Convert capabilities to ethtool link modes"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:364
msgid "``unsigned long *linkmodes``"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:359
msgid "ethtool linkmode mask (must be already initialised)"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:360
#: drivers/net/phy/phylink.c:424 drivers/net/phy/phylink.c:487
msgid "bitmask of MAC capabilities"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:361
msgid ""
"Set all possible pause, speed and duplex linkmodes in **linkmodes** that are "
"supported by the **caps**. **linkmodes** must have been initialised "
"previously."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:380
msgid "limit the phylink_config to a maximum speed"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:381
msgid "pointer to a :c:type:`struct phylink_config <phylink_config>`"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:382
msgid "maximum speed"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:383
msgid ""
"Mask off MAC capabilities for speeds higher than the **max_speed** "
"parameter. Any further motifications of config.mac_capabilities will "
"override this."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:398
msgid "Get mac capability from speed/duplex"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:399
msgid "the speed to search for"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:400
msgid "the duplex to search for"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:401
msgid "Find the mac capability for a given speed and duplex."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:404
msgid ""
"A mask with the mac capability patching **speed** and **duplex**, or 0 if "
"there were no matches."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:422
msgid "get capabilities for a given MAC"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:425
#: drivers/net/phy/phylink.c:488
msgid "``unsigned long mac_capabilities``"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:425
msgid "type of rate matching being performed"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:426
msgid ""
"Get the MAC capabilities that are supported by the **interface** mode and "
"**mac_capabilities**."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:484
msgid "Restrict link modes based on caps"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:486
msgid "pointer to a :c:type:`struct phylink_link_state <phylink_link_state>`."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:488
msgid ""
"Calculate the supported link modes based on **mac_capabilities**, and "
"restrict **supported** and **state** based on that. Use this function if "
"your capabiliies aren't constant, such as if they vary depending on the "
"interface."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1061
msgid "helper to determine PCS inband mode"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1067
#: drivers/net/phy/phylink.c:1781 drivers/net/phy/phylink.c:1927
#: drivers/net/phy/phylink.c:1947 drivers/net/phy/phylink.c:2213
#: drivers/net/phy/phylink.c:2250 drivers/net/phy/phylink.c:2269
#: drivers/net/phy/phylink.c:2330 drivers/net/phy/phylink.c:2371
#: drivers/net/phy/phylink.c:2414 drivers/net/phy/phylink.c:2480
#: drivers/net/phy/phylink.c:2514 drivers/net/phy/phylink.c:2543
#: drivers/net/phy/phylink.c:2572 drivers/net/phy/phylink.c:2618
#: drivers/net/phy/phylink.c:2643 drivers/net/phy/phylink.c:2683
#: drivers/net/phy/phylink.c:2704 drivers/net/phy/phylink.c:2812
#: drivers/net/phy/phylink.c:2886 drivers/net/phy/phylink.c:3056
#: drivers/net/phy/phylink.c:3081 drivers/net/phy/phylink.c:3097
#: drivers/net/phy/phylink.c:3183 drivers/net/phy/phylink.c:3206
#: drivers/net/phy/phylink.c:3232 drivers/net/phy/phylink.c:3421
#: drivers/net/phy/phylink.c:3499 drivers/net/phy/phylink.c:3524
msgid "``struct phylink *pl``"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1062
#: drivers/net/phy/phylink.c:1776 drivers/net/phy/phylink.c:1922
#: drivers/net/phy/phylink.c:1942 drivers/net/phy/phylink.c:2208
#: drivers/net/phy/phylink.c:2245 drivers/net/phy/phylink.c:2264
#: drivers/net/phy/phylink.c:2326 drivers/net/phy/phylink.c:2366
#: drivers/net/phy/phylink.c:2409 drivers/net/phy/phylink.c:2475
#: drivers/net/phy/phylink.c:2509 drivers/net/phy/phylink.c:2538
#: drivers/net/phy/phylink.c:2567 drivers/net/phy/phylink.c:2613
#: drivers/net/phy/phylink.c:2638 drivers/net/phy/phylink.c:2678
#: drivers/net/phy/phylink.c:2699 drivers/net/phy/phylink.c:2807
#: drivers/net/phy/phylink.c:2881 drivers/net/phy/phylink.c:3051
#: drivers/net/phy/phylink.c:3076 drivers/net/phy/phylink.c:3092
#: drivers/net/phy/phylink.c:3201 drivers/net/phy/phylink.c:3227
#: drivers/net/phy/phylink.c:3416 drivers/net/phy/phylink.c:3495
#: drivers/net/phy/phylink.c:3520
msgid ""
"a pointer to a :c:type:`struct phylink <phylink>` returned from "
"phylink_create()"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1063
msgid "a pointer to :c:type:`struct phylink_pcs <phylink_pcs>`"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1066
msgid ""
"Determines the negotiation mode to be used by the PCS, and returns one of:"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1069
msgid "``PHYLINK_PCS_NEG_NONE``: interface mode does not support inband"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1070
msgid ""
"``PHYLINK_PCS_NEG_OUTBAND``: an out of band mode (e.g. reading the PHY) will "
"be used."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1072
msgid ""
"``PHYLINK_PCS_NEG_INBAND_DISABLED``: inband mode selected but autoneg "
"disabled"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1074
msgid ""
"``PHYLINK_PCS_NEG_INBAND_ENABLED``: inband mode selected and autoneg enabled"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1077
msgid ""
"this is for cases where the PCS itself is involved in negotiation (e.g. "
"Clause 37, SGMII and similar) not Clause 73."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1775
msgid "set the fixed link"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1777
#: drivers/net/phy/phylink.c:3966 drivers/net/phy/phylink.c:4009
msgid "a pointer to a struct phylink_link_state."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1778
msgid ""
"This function is used when the link parameters are known and do not change, "
"making it suitable for certain types of network connections."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1782
#: drivers/net/phy/phylink.c:3423
msgid "zero on success or negative error code."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1816
msgid "create a phylink instance"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1817
msgid ""
"a pointer to the target :c:type:`struct phylink_config <phylink_config>`"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1818
msgid ""
"a pointer to a :c:type:`struct fwnode_handle <fwnode_handle>` describing the "
"network interface"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1820
msgid ""
"the desired link mode defined by :c:type:`typedef phy_interface_t "
"<phy_interface_t>`"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1822
msgid "``const struct phylink_mac_ops *mac_ops``"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1821
msgid ""
"a pointer to a :c:type:`struct phylink_mac_ops <phylink_mac_ops>` for the "
"MAC."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1822
msgid ""
"Create a new phylink instance, and parse the link parameters found in "
"**np**. This will parse in-band modes, fixed-link or SFP configuration."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1826
#: drivers/net/phy/phylink.c:1927
msgid "the rtnl lock must not be held when calling this function."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1828
msgid ""
"Returns a pointer to a :c:type:`struct phylink <phylink>`, or an error-"
"pointer value. Users must use IS_ERR() to check for errors from this "
"function."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1921
msgid "cleanup and destroy the phylink instance"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1923
msgid ""
"Destroy a phylink instance. Any PHY that has been attached must have been "
"cleaned up via phylink_disconnect_phy() prior to calling this function."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1941
msgid "Determine if phylink expects a phy to be attached"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1943
msgid ""
"When using fixed-link mode, or in-band mode with 1000base-X or 2500base-X, "
"no PHY is needed."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:1946
msgid "Returns true if phylink will be expecting a PHY."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2207
msgid "connect a PHY to the phylink instance"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2209
msgid "a pointer to a :c:type:`struct phy_device <phy_device>`."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2210
msgid ""
"Connect **phy** to the phylink instance specified by **pl** by calling "
"phy_attach_direct(). Configure the **phy** according to the MAC driver's "
"capabilities, start the PHYLIB state machine and enable any interrupts that "
"the PHY supports."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2215
msgid ""
"This updates the phylink's ethtool supported and advertising link mode masks."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2218
#: drivers/net/phy/phylink.c:2252 drivers/net/phy/phylink.c:2270
msgid "Returns 0 on success or a negative errno."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2244
msgid "connect the PHY specified in the DT mode."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2247
msgid "``struct device_node *dn``"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2246
msgid "a pointer to a :c:type:`struct device_node <device_node>`."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2247
#: drivers/net/phy/phylink.c:2266
msgid "PHY-specific flags to communicate to the PHY device driver"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2248
msgid ""
"Connect the phy specified in the device node **dn** to the phylink instance "
"specified by **pl**. Actions specified in phylink_connect_phy() will be "
"performed."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2263
msgid "connect the PHY specified in the fwnode."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2265
msgid "a pointer to a :c:type:`struct fwnode_handle <fwnode_handle>`."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2267
msgid ""
"Connect the phy specified **fwnode** to the phylink instance specified by "
"**pl**."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2324
msgid "disconnect any PHY attached to the phylink instance."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2327
msgid ""
"Disconnect any current PHY from the phylink instance described by **pl**."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2365
msgid "notify phylink of a change in MAC state"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2368
#: drivers/net/phy/phylink.c:2382
msgid "``bool up``"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2367
#: drivers/net/phy/phylink.c:2381
msgid "indicates whether the link is currently up."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2368
msgid ""
"The MAC driver should call this driver when the state of its link changes "
"(eg, link failure, new negotiation results, etc.)"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2379
msgid "notify phylink of a change to PCS link state"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2380
msgid "pointer to :c:type:`struct phylink_pcs <phylink_pcs>`"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2382
msgid ""
"The PCS driver should call this when the state of its link changes (e.g. "
"link failure, new negotiation results, etc.) Note: it should not determine "
"\"up\" by reading the BMSR. If in doubt about the link state at interrupt "
"time, then pass true if pcs_get_state() returns the latched link-down state, "
"otherwise pass false."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2408
msgid "start a phylink instance"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2410
msgid ""
"Start the phylink instance specified by **pl**, configuring the MAC for the "
"desired link mode(s) and negotiation style. This should be called from the "
"network device driver's :c:type:`struct net_device_ops <net_device_ops>` "
"ndo_open() method."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2474
msgid "stop a phylink instance"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2476
msgid ""
"Stop the phylink instance specified by **pl**. This should be called from "
"the network device driver's :c:type:`struct net_device_ops <net_device_ops>` "
"ndo_stop() method.  The network device's carrier state should not be changed "
"prior to calling this function."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2481
msgid ""
"This will synchronously bring down the link if the link is not already down "
"(in other words, it will trigger a mac_link_down() method call.)"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2508
msgid "block PHY ability to stop receive clock in LPI"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2510
msgid ""
"Disable the PHY's ability to stop the receive clock while the receive path "
"is in EEE LPI state, until the number of calls to "
"phylink_rx_clk_stop_block() are balanced by calls to "
"phylink_rx_clk_stop_unblock()."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2537
msgid "unblock PHY ability to stop receive clock"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2539
msgid ""
"All calls to phylink_rx_clk_stop_block() must be balanced with a "
"corresponding call to phylink_rx_clk_stop_unblock() to restore the PHYs "
"ability to stop the receive clock when the receive path is in EEE LPI mode."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2566
msgid "handle a network device suspend event"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2569
msgid "``bool mac_wol``"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2568
msgid "true if the MAC needs to receive packets for Wake-on-Lan"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2569
msgid "Handle a network device suspend event. There are several cases:"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2571
msgid ""
"If Wake-on-Lan is not active, we can bring down the link between the MAC and "
"PHY by calling phylink_stop()."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2573
msgid ""
"If Wake-on-Lan is active, and being handled only by the PHY, we can also "
"bring down the link between the MAC and PHY."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2575
msgid ""
"If Wake-on-Lan is active, but being handled by the MAC, the MAC still needs "
"to receive packets, so we can not bring the link down."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2612
msgid "prepare to resume a network device"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2614
msgid "Optional, but if called must be called prior to phylink_resume()."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2616
msgid "Prepare to resume a network device, preparing the PHY as necessary."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2637
msgid "handle a network device resume event"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2639
msgid ""
"Undo the effects of phylink_suspend(), returning the link to an operational "
"state."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2677
msgid "get the wake on lan parameters for the PHY"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2679
msgid ""
"a pointer to :c:type:`struct ethtool_wolinfo <ethtool_wolinfo>` to hold the "
"read parameters"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2680
msgid ""
"Read the wake on lan parameters from the PHY attached to the phylink "
"instance specified by **pl**. If no PHY is currently attached, report no "
"support for wake on lan."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2698
msgid "set wake on lan parameters"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2700
msgid ""
"a pointer to :c:type:`struct ethtool_wolinfo <ethtool_wolinfo>` for the "
"desired parameters"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2701
msgid ""
"Set the wake on lan parameters for the PHY attached to the phylink instance "
"specified by **pl**. If no PHY is attached, returns ``EOPNOTSUPP`` error."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2705
msgid "Returns zero on success or negative errno code."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2806
msgid "get the current link settings"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2809
msgid "``struct ethtool_link_ksettings *kset``"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2808
msgid ""
"a pointer to a :c:type:`struct ethtool_link_ksettings "
"<ethtool_link_ksettings>` to hold link settings"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2809
msgid ""
"Read the current link settings for the phylink instance specified by **pl**. "
"This will be the link settings read from the MAC, PHY or fixed link settings "
"depending on the current negotiation mode."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2880
msgid "set the link settings"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2883
msgid "``const struct ethtool_link_ksettings *kset``"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:2882
msgid ""
"a pointer to a :c:type:`struct ethtool_link_ksettings "
"<ethtool_link_ksettings>` for the desired modes"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3050
msgid "restart negotiation"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3052
msgid ""
"Restart negotiation for the phylink instance specified by **pl**. This will "
"cause any attached phy to restart negotiation with the link partner, and if "
"the MAC is in a BaseX mode, the MAC will also be requested to restart "
"negotiation."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3057
msgid "Returns zero on success, or negative error code."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3075
msgid "get the current pause parameters"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3078
#: drivers/net/phy/phylink.c:3094
msgid "``struct ethtool_pauseparam *pause``"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3077
#: drivers/net/phy/phylink.c:3093
msgid "a pointer to a :c:type:`struct ethtool_pauseparam <ethtool_pauseparam>`"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3091
msgid "set the current pause parameters"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3177
msgid "read the energy efficient ethernet error counter"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3179
msgid ""
"a pointer to a :c:type:`struct phylink <phylink>` returned from "
"phylink_create()."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3180
msgid ""
"Read the Energy Efficient Ethernet error counter from the PHY associated "
"with the phylink instance specified by **pl**."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3183
msgid "Returns positive error counter value, or negative error code."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3200
msgid "read the energy efficient ethernet parameters"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3203
#: drivers/net/phy/phylink.c:3229
msgid "``struct ethtool_keee *eee``"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3202
msgid ""
"a pointer to a :c:type:`struct ethtool_keee <ethtool_keee>` for the read "
"parameters"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3226
msgid "set the energy efficient ethernet parameters"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3228
msgid ""
"a pointer to a :c:type:`struct ethtool_keee <ethtool_keee>` for the desired "
"parameters"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3415
msgid "generic mii ioctl interface"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3417
msgid "a pointer to a :c:type:`struct ifreq <ifreq>` for socket ioctls"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3419
msgid ""
"Perform the specified MII ioctl on the PHY attached to the phylink instance "
"specified by **pl**. If no PHY is attached, emulate the presence of the PHY."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3423
msgid "``SIOCGMIIPHY``:"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3424
msgid "read register from the current PHY."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3425
msgid "``SIOCGMIIREG``:"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3426
msgid "read register from the specified PHY."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3427
msgid "``SIOCSMIIREG``:"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3428
msgid "set a register on the specified PHY."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3493
msgid "set the non-SFP PHY to lowest speed supported by both link partners"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3497
msgid ""
"If we have a PHY that is not part of a SFP module, then set the speed as "
"described in the phy_speed_down() function. Please see this function for a "
"description of the **sync** parameter."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3501
msgid "Returns zero if there is no PHY, otherwise as per phy_speed_down()."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3518
msgid "restore the advertised speeds prior to the call to phylink_speed_down()"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3521
msgid ""
"If we have a PHY that is not part of a SFP module, then restore the PHY "
"speeds as per phy_speed_up()."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3524
msgid "Returns zero if there is no PHY, otherwise as per phy_speed_up()."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3965
msgid "decode the USXGMII word from a MAC PCS"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3968
#: drivers/net/phy/phylink.c:4011
msgid "``uint16_t lpa``"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3967
msgid "a 16 bit value which stores the USXGMII auto-negotiation word"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:3968
msgid ""
"Helper for MAC PCS supporting the USXGMII protocol and the auto-negotiation "
"code word.  Decode the USXGMII code word and populate the corresponding "
"fields (speed, duplex) into the phylink_link_state structure."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4008
msgid "decode the USGMII word from a MAC PCS"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4010
msgid "a 16 bit value which stores the USGMII auto-negotiation word"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4011
msgid ""
"Helper for MAC PCS supporting the USGMII protocol and the auto-negotiation "
"code word.  Decode the USGMII code word and populate the corresponding "
"fields (speed, duplex) into the phylink_link_state structure. The structure "
"for this word is the same as the USXGMII word, except it only supports "
"speeds up to 1Gbps."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4043
msgid "Decode MAC PCS state from MII registers"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4047
msgid "``u16 bmsr``"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4046
msgid "The value of the ``MII_BMSR`` register"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4048
msgid "``u16 lpa``"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4047
msgid "The value of the ``MII_LPA`` register"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4048
#: drivers/net/phy/phylink.c:4111 drivers/net/phy/phylink.c:4143
msgid ""
"Helper for MAC PCS supporting the 802.3 clause 22 register set for clause 37 "
"negotiation and/or SGMII control."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4051
msgid ""
"Parse the Clause 37 or Cisco SGMII link partner negotiation word into the "
"phylink **state** structure. This is suitable to be used for implementing "
"the pcs_get_state() member of the struct phylink_pcs_ops structure if "
"accessing **bmsr** and **lpa** cannot be done with MDIO directly."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4107
msgid "read the MAC PCS state"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4113
#: drivers/net/phy/phylink.c:4185 drivers/net/phy/phylink.c:4229
msgid "``struct mdio_device *pcs``"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4108
#: drivers/net/phy/phylink.c:4180 drivers/net/phy/phylink.c:4224
msgid "a pointer to a :c:type:`struct mdio_device <mdio_device>`."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4114
msgid ""
"Read the MAC PCS state from the MII device configured in **config** and "
"parse the Clause 37 or Cisco SGMII link partner negotiation word into the "
"phylink **state** structure. This is suitable to be directly plugged into "
"the pcs_get_state() member of the struct phylink_pcs_ops structure."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4139
msgid "configure the clause 37 PCS advertisement"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4141
#: drivers/net/phy/phylink.c:4181
msgid "the PHY interface mode being configured"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4142
#: drivers/net/phy/phylink.c:4182
msgid "the ethtool advertisement mask"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4146
msgid ""
"Encode the clause 37 PCS advertisement as specified by **interface** and "
"**advertising**."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4150
msgid "The new value for **adv**, or ``-EINVAL`` if it should not be changed."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4179
msgid "configure clause 22 PCS"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4183
msgid "PCS negotiation mode"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4184
msgid ""
"Configure a Clause 22 PCS PHY with the appropriate negotiation parameters "
"for the **mode**, **interface** and **advertising** parameters. Returns "
"negative error number on failure, zero if the advertisement has not changed, "
"or positive if there is a change."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4223
msgid "restart 802.3z autonegotiation"
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4225
msgid ""
"Helper for MAC PCS supporting the 802.3 clause 22 register set for clause 37 "
"negotiation."
msgstr ""

#: ../../../networking/kapi:150: drivers/net/phy/phylink.c:4228
msgid ""
"Restart the clause 37 negotiation with the link partner. This is suitable to "
"be directly plugged into the pcs_get_state() member of the struct "
"phylink_pcs_ops structure."
msgstr ""

#: ../../../networking/kapi.rst:153
msgid "SFP support"
msgstr ""

#: ../../../networking/kapi:155: drivers/net/phy/sfp-bus.c:14
msgid "internal representation of a sfp bus"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:221
msgid "raw SFP module identification information"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:222
msgid "``base``"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:223
msgid "base SFP module identification structure"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:223
msgid "``ext``"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:224
msgid "extended SFP module identification structure"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:224
msgid ""
"See the SFF-8472 specification and related documents for the definition of "
"these structure members. This can be obtained from https://www.snia.org/"
"technology-communities/sff/specifications"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:525
msgid "sfp module capabilities"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:526
msgid "``interfaces``"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:527
msgid "bitmap of interfaces that the module may support"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:527
msgid "``link_modes``"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:528
msgid "bitmap of ethtool link modes that the module may support"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:533
msgid "``may_have_phy``"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:534
msgid ""
"indicate whether the module may have an ethernet PHY There is no way to be "
"sure that a module has a PHY as the EEPROM doesn't contain this information. "
"When set, this does not mean that the module definitely has a PHY."
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:541
msgid ""
"one of ethtool ``PORT_*`` definitions, parsed from the module EEPROM, or "
"``PORT_OTHER`` if the port type is not known."
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:547
msgid "upstream operations structure"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:548
msgid "``attach``"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:549
msgid "called when the sfp socket driver is bound to the upstream (mandatory)."
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:550
msgid "``detach``"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:551
msgid ""
"called when the sfp socket driver is unbound from the upstream (mandatory)."
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:552
msgid "``module_insert``"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:553
msgid ""
"called after a module has been detected to determine whether the module is "
"supported for the upstream device."
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:554
msgid "``module_remove``"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:555
msgid "called after the module has been removed."
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:555
msgid "``module_start``"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:556
msgid "called after the PHY probe step"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:556
msgid "``module_stop``"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:557
msgid "called before the PHY is removed"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:557
msgid "``link_down``"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:558
msgid "called when the link is non-operational for whatever reason."
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:559
msgid "``link_up``"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:560
msgid "called when the link is operational."
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:560
msgid "``connect_phy``"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:561
msgid "called when an I2C accessible PHY has been detected on the module."
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:562
msgid "``disconnect_phy``"
msgstr ""

#: ../../../networking/kapi:158: include/linux/sfp.h:563
msgid "called when a module with an I2C accessible PHY has been removed."
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:333
msgid "Select appropriate phy_interface_t mode"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:334
#: drivers/net/phy/sfp-bus.c:480 drivers/net/phy/sfp-bus.c:496
#: drivers/net/phy/sfp-bus.c:514 drivers/net/phy/sfp-bus.c:534
#: drivers/net/phy/sfp-bus.c:551 drivers/net/phy/sfp-bus.c:574
#: drivers/net/phy/sfp-bus.c:689 drivers/net/phy/sfp-bus.c:710
msgid ""
"a pointer to the :c:type:`struct sfp_bus <sfp_bus>` structure for the sfp "
"module"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:336
msgid "``const unsigned long *link_modes``"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:335
msgid "ethtool link modes mask"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:336
msgid ""
"Derive the phy_interface_t mode for the SFP module from the link modes mask."
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:428
msgid "put a reference on the :c:type:`struct sfp_bus <sfp_bus>`"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:429
#: drivers/net/phy/sfp-bus.c:639
msgid "the :c:type:`struct sfp_bus <sfp_bus>` found via sfp_bus_find_fwnode()"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:430
msgid ""
"Put a reference on the :c:type:`struct sfp_bus <sfp_bus>` and free the "
"underlying structure if this was the last reference."
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:479
msgid "Get the ethtool_modinfo for a SFP module"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:482
msgid "``struct ethtool_modinfo *modinfo``"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:481
msgid "a :c:type:`struct ethtool_modinfo <ethtool_modinfo>`"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:482
msgid ""
"Fill in the type and eeprom_len parameters in **modinfo** for a module on "
"the sfp bus specified by **bus**."
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:485
#: drivers/net/phy/sfp-bus.c:502
msgid "Returns 0 on success or a negative errno number."
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:495
msgid "Read the SFP module EEPROM"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:498
msgid "``struct ethtool_eeprom *ee``"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:497
msgid "a :c:type:`struct ethtool_eeprom <ethtool_eeprom>`"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:498
msgid "buffer to contain the EEPROM data (must be at least **ee->len** bytes)"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:499
msgid ""
"Read the EEPROM as specified by the supplied **ee**. See the documentation "
"for :c:type:`struct ethtool_eeprom <ethtool_eeprom>` for the region to be "
"read."
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:513
msgid "Read a page from the SFP module EEPROM"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:516
msgid "``const struct ethtool_module_eeprom *page``"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:515
msgid "a :c:type:`struct ethtool_module_eeprom <ethtool_module_eeprom>`"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:516
msgid "extack for reporting problems"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:517
msgid ""
"Read an EEPROM page as specified by the supplied **page**. See the "
"documentation for :c:type:`struct ethtool_module_eeprom "
"<ethtool_module_eeprom>` for the page to be read."
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:520
msgid ""
"Returns 0 on success or a negative errno number. More error information "
"might be provided via extack"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:533
msgid "Inform the SFP that the network device is up"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:535
msgid ""
"Inform the SFP socket that the network device is now up, so that the module "
"can be enabled by allowing TX_DISABLE to be deasserted. This should be "
"called from the network device driver's :c:type:`struct net_device_ops "
"<net_device_ops>` ndo_open() method."
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:550
msgid "Inform the SFP that the network device is down"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:552
msgid ""
"Inform the SFP socket that the network device is now up, so that the module "
"can be disabled by asserting TX_DISABLE, disabling the laser in optical "
"modules. This should be called from the network device driver's :c:type:"
"`struct net_device_ops <net_device_ops>` ndo_stop() method."
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:573
msgid "set data signalling rate"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:576
msgid "``unsigned int rate_kbd``"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:575
msgid "signalling rate in units of 1000 baud"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:576
msgid ""
"Configure the rate select settings on the SFP module for the signalling rate "
"(not the same as the data rate)."
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:579
msgid "Locks that may be held:"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:580
msgid "Phylink's state_mutex rtnl lock SFP's sm_mutex"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:593
msgid "parse and locate the SFP bus from fwnode"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:594
msgid "firmware node for the parent device (MAC or PHY)"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:595
msgid ""
"Parse the parent device's firmware node for a SFP bus, and locate the "
"sfp_bus structure, incrementing its reference count.  This must be put via "
"sfp_bus_put() when done."
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:600
#: drivers/net/phy/sfp-bus.c:647
msgid ""
"corresponding to the errors detailed for "
"fwnode_property_get_reference_args()."
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:602
#: drivers/net/phy/sfp-bus.c:649
msgid "``-ENOMEM`` if we failed to allocate the bus."
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:603
#: drivers/net/phy/sfp-bus.c:650
msgid "an error from the upstream's connect_phy() method."
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:600
#: drivers/net/phy/sfp-bus.c:647
msgid "on success, a pointer to the sfp_bus structure,"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:601
#: drivers/net/phy/sfp-bus.c:648
msgid "``NULL`` if no SFP is specified,"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:602
#: drivers/net/phy/sfp-bus.c:649
msgid "on failure, an error pointer value:"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:638
msgid "parse and register the neighbouring device"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:640
msgid "the upstream private data"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:641
msgid "the upstream's :c:type:`struct sfp_upstream_ops <sfp_upstream_ops>`"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:642
msgid ""
"Add upstream driver for the SFP bus, and if the bus is complete, register "
"the SFP bus using sfp_register_upstream().  This takes a reference on the "
"bus, so it is safe to put the bus after this call."
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:688
msgid "Delete a sfp bus"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:690
msgid ""
"Delete a previously registered upstream connection for the SFP module. "
"**bus** should have been added by sfp_bus_add_upstream()."
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:709
msgid "Get the SFP device name"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:711
msgid ""
"Gets the SFP device's name, if **bus** has a registered socket. Callers must "
"hold RTNL, and the returned name is only valid until RTNL is released."
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:715
msgid "The name of the SFP device registered with sfp_register_socket()"
msgstr ""

#: ../../../networking/kapi:161: drivers/net/phy/sfp-bus.c:716
msgid "``NULL`` if no device was registered on **bus**"
msgstr ""
