# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/fib_trie.rst:5
msgid "LC-trie implementation notes"
msgstr ""

#: ../../../networking/fib_trie.rst:8
msgid "Node types"
msgstr ""

#: ../../../networking/fib_trie.rst:9
msgid "leaf"
msgstr ""

#: ../../../networking/fib_trie.rst:10
msgid ""
"An end node with data. This has a copy of the relevant key, along with "
"'hlist' with routing table entries sorted by prefix length. See struct leaf "
"and struct leaf_info."
msgstr ""

#: ../../../networking/fib_trie.rst:14
msgid "trie node or tnode"
msgstr ""

#: ../../../networking/fib_trie.rst:15
msgid ""
"An internal node, holding an array of child (leaf or tnode) pointers, "
"indexed through a subset of the key. See Level Compression."
msgstr ""

#: ../../../networking/fib_trie.rst:19
msgid "A few concepts explained"
msgstr ""

#: ../../../networking/fib_trie.rst:20
msgid "Bits (tnode)"
msgstr ""

#: ../../../networking/fib_trie.rst:21
msgid ""
"The number of bits in the key segment used for indexing into the child array "
"- the \"child index\". See Level Compression."
msgstr ""

#: ../../../networking/fib_trie.rst:24
msgid "Pos (tnode)"
msgstr ""

#: ../../../networking/fib_trie.rst:25
msgid ""
"The position (in the key) of the key segment used for indexing into the "
"child array. See Path Compression."
msgstr ""

#: ../../../networking/fib_trie.rst:28
msgid "Path Compression / skipped bits"
msgstr ""

#: ../../../networking/fib_trie.rst:29
msgid ""
"Any given tnode is linked to from the child array of its parent, using a "
"segment of the key specified by the parent's \"pos\" and \"bits\" In certain "
"cases, this tnode's own \"pos\" will not be immediately adjacent to the "
"parent (pos+bits), but there will be some bits in the key skipped over "
"because they represent a single path with no deviations. These \"skipped "
"bits\" constitute Path Compression. Note that the search algorithm will "
"simply skip over these bits when searching, making it necessary to save the "
"keys in the leaves to verify that they actually do match the key we are "
"searching for."
msgstr ""

#: ../../../networking/fib_trie.rst:39
msgid "Level Compression / child arrays"
msgstr ""

#: ../../../networking/fib_trie.rst:40
msgid ""
"the trie is kept level balanced moving, under certain conditions, the "
"children of a full child (see \"full_children\") up one level, so that "
"instead of a pure binary tree, each internal node (\"tnode\") may contain an "
"arbitrarily large array of links to several children. Conversely, a tnode "
"with a mostly empty child array (see empty_children) may be \"halved\", "
"having some of its children moved downwards one level, in order to avoid "
"ever-increasing child arrays."
msgstr ""

#: ../../../networking/fib_trie.rst:48
msgid "empty_children"
msgstr ""

#: ../../../networking/fib_trie.rst:49
msgid ""
"the number of positions in the child array of a given tnode that are NULL."
msgstr ""

#: ../../../networking/fib_trie.rst:52
msgid "full_children"
msgstr ""

#: ../../../networking/fib_trie.rst:53
msgid ""
"the number of children of a given tnode that aren't path compressed. (in "
"other words, they aren't NULL or leaves and their \"pos\" is equal to this "
"tnode's \"pos\"+\"bits\")."
msgstr ""

#: ../../../networking/fib_trie.rst:57
msgid ""
"(The word \"full\" here is used more in the sense of \"complete\" than as "
"the opposite of \"empty\", which might be a tad confusing.)"
msgstr ""

#: ../../../networking/fib_trie.rst:61
msgid "Comments"
msgstr ""

#: ../../../networking/fib_trie.rst:63
msgid ""
"We have tried to keep the structure of the code as close to fib_hash as "
"possible to allow verification and help up reviewing."
msgstr ""

#: ../../../networking/fib_trie.rst:66
msgid "fib_find_node()"
msgstr ""

#: ../../../networking/fib_trie.rst:67
msgid ""
"A good start for understanding this code. This function implements a "
"straightforward trie lookup."
msgstr ""

#: ../../../networking/fib_trie.rst:70
msgid "fib_insert_node()"
msgstr ""

#: ../../../networking/fib_trie.rst:71
msgid ""
"Inserts a new leaf node in the trie. This is bit more complicated than "
"fib_find_node(). Inserting a new node means we might have to run the level "
"compression algorithm on part of the trie."
msgstr ""

#: ../../../networking/fib_trie.rst:75
msgid "trie_leaf_remove()"
msgstr ""

#: ../../../networking/fib_trie.rst:76
msgid "Looks up a key, deletes it and runs the level compression algorithm."
msgstr ""

#: ../../../networking/fib_trie.rst:78
msgid "trie_rebalance()"
msgstr ""

#: ../../../networking/fib_trie.rst:79
msgid ""
"The key function for the dynamic trie after any change in the trie it is run "
"to optimize and reorganize. It will walk the trie upwards towards the root "
"from a given tnode, doing a resize() at each step to implement level "
"compression."
msgstr ""

#: ../../../networking/fib_trie.rst:84
msgid "resize()"
msgstr ""

#: ../../../networking/fib_trie.rst:85
msgid ""
"Analyzes a tnode and optimizes the child array size by either inflating or "
"shrinking it repeatedly until it fulfills the criteria for optimal level "
"compression. This part follows the original paper pretty closely and there "
"may be some room for experimentation here."
msgstr ""

#: ../../../networking/fib_trie.rst:90
msgid "inflate()"
msgstr ""

#: ../../../networking/fib_trie.rst:91
msgid "Doubles the size of the child array within a tnode. Used by resize()."
msgstr ""

#: ../../../networking/fib_trie.rst:93
msgid "halve()"
msgstr ""

#: ../../../networking/fib_trie.rst:94
msgid ""
"Halves the size of the child array within a tnode - the inverse of "
"inflate(). Used by resize();"
msgstr ""

#: ../../../networking/fib_trie.rst:97
msgid "fn_trie_insert(), fn_trie_delete(), fn_trie_select_default()"
msgstr ""

#: ../../../networking/fib_trie.rst:98
msgid ""
"The route manipulation functions. Should conform pretty closely to the "
"corresponding functions in fib_hash."
msgstr ""

#: ../../../networking/fib_trie.rst:101
msgid "fn_trie_flush()"
msgstr ""

#: ../../../networking/fib_trie.rst:102
msgid ""
"This walks the full trie (using nextleaf()) and searches for empty leaves "
"which have to be removed."
msgstr ""

#: ../../../networking/fib_trie.rst:105
msgid "fn_trie_dump()"
msgstr ""

#: ../../../networking/fib_trie.rst:106
msgid ""
"Dumps the routing table ordered by prefix length. This is somewhat slower "
"than the corresponding fib_hash function, as we have to walk the entire trie "
"for each prefix length. In comparison, fib_hash is organized as one \"zone\"/"
"hash per prefix length."
msgstr ""

#: ../../../networking/fib_trie.rst:112
msgid "Locking"
msgstr ""

#: ../../../networking/fib_trie.rst:114
msgid ""
"fib_lock is used for an RW-lock in the same way that this is done in "
"fib_hash. However, the functions are somewhat separated for other possible "
"locking scenarios. It might conceivably be possible to run trie_rebalance "
"via RCU to avoid read_lock in the fn_trie_lookup() function."
msgstr ""

#: ../../../networking/fib_trie.rst:120
msgid "Main lookup mechanism"
msgstr ""

#: ../../../networking/fib_trie.rst:121
msgid "fn_trie_lookup() is the main lookup function."
msgstr ""

#: ../../../networking/fib_trie.rst:123
msgid ""
"The lookup is in its simplest form just like fib_find_node(). We descend the "
"trie, key segment by key segment, until we find a leaf. check_leaf() does "
"the fib_semantic_match in the leaf's sorted prefix hlist."
msgstr ""

#: ../../../networking/fib_trie.rst:127
msgid "If we find a match, we are done."
msgstr ""

#: ../../../networking/fib_trie.rst:129
msgid ""
"If we don't find a match, we enter prefix matching mode. The prefix length, "
"starting out at the same as the key length, is reduced one step at a time, "
"and we backtrack upwards through the trie trying to find a longest matching "
"prefix. The goal is always to reach a leaf and get a positive result from "
"the fib_semantic_match mechanism."
msgstr ""

#: ../../../networking/fib_trie.rst:135
msgid ""
"Inside each tnode, the search for longest matching prefix consists of "
"searching through the child array, chopping off (zeroing) the least "
"significant \"1\" of the child index until we find a match or the child "
"index consists of nothing but zeros."
msgstr ""

#: ../../../networking/fib_trie.rst:140
msgid ""
"At this point we backtrack (t->stats.backtrack++) up the trie, continuing to "
"chop off part of the key in order to find the longest matching prefix."
msgstr ""

#: ../../../networking/fib_trie.rst:143
msgid ""
"At this point we will repeatedly descend subtries to look for a match, and "
"there are some optimizations available that can provide us with "
"\"shortcuts\" to avoid descending into dead ends. Look for \"HL_OPTIMIZE\" "
"sections in the code."
msgstr ""

#: ../../../networking/fib_trie.rst:147
msgid ""
"To alleviate any doubts about the correctness of the route selection "
"process, a new netlink operation has been added. Look for "
"NETLINK_FIB_LOOKUP, which gives userland access to fib_lookup()."
msgstr ""
