# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/filter.rst:7
msgid "Linux Socket Filtering aka Berkeley Packet Filter (BPF)"
msgstr ""

#: ../../../networking/filter.rst:10
msgid "Notice"
msgstr ""

#: ../../../networking/filter.rst:12
msgid ""
"This file used to document the eBPF format and mechanisms even when not "
"related to socket filtering.  The ../bpf/index.rst has more details on eBPF."
msgstr ""

#: ../../../networking/filter.rst:17
msgid "Introduction"
msgstr ""

#: ../../../networking/filter.rst:19
msgid ""
"Linux Socket Filtering (LSF) is derived from the Berkeley Packet Filter. "
"Though there are some distinct differences between the BSD and Linux Kernel "
"filtering, but when we speak of BPF or LSF in Linux context, we mean the "
"very same mechanism of filtering in the Linux kernel."
msgstr ""

#: ../../../networking/filter.rst:24
msgid ""
"BPF allows a user-space program to attach a filter onto any socket and allow "
"or disallow certain types of data to come through the socket. LSF follows "
"exactly the same filter code structure as BSD's BPF, so referring to the BSD "
"bpf.4 manpage is very helpful in creating filters."
msgstr ""

#: ../../../networking/filter.rst:29
msgid ""
"On Linux, BPF is much simpler than on BSD. One does not have to worry about "
"devices or anything like that. You simply create your filter code, send it "
"to the kernel via the SO_ATTACH_FILTER option and if your filter code passes "
"the kernel check on it, you then immediately begin filtering data on that "
"socket."
msgstr ""

#: ../../../networking/filter.rst:35
msgid ""
"You can also detach filters from your socket via the SO_DETACH_FILTER "
"option. This will probably not be used much since when you close a socket "
"that has a filter on it the filter is automagically removed. The other less "
"common case may be adding a different filter on the same socket where you "
"had another filter that is still running: the kernel takes care of removing "
"the old one and placing your new one in its place, assuming your filter has "
"passed the checks, otherwise if it fails the old filter will remain on that "
"socket."
msgstr ""

#: ../../../networking/filter.rst:44
msgid ""
"SO_LOCK_FILTER option allows to lock the filter attached to a socket. Once "
"set, a filter cannot be removed or changed. This allows one process to setup "
"a socket, attach a filter, lock it then drop privileges and be assured that "
"the filter will be kept until the socket is closed."
msgstr ""

#: ../../../networking/filter.rst:49
msgid ""
"The biggest user of this construct might be libpcap. Issuing a high-level "
"filter command like `tcpdump -i em1 port 22` passes through the libpcap "
"internal compiler that generates a structure that can eventually be loaded "
"via SO_ATTACH_FILTER to the kernel. `tcpdump -i em1 port 22 -ddd` displays "
"what is being placed into this structure."
msgstr ""

#: ../../../networking/filter.rst:55
msgid ""
"Although we were only speaking about sockets here, BPF in Linux is used in "
"many more places. There's xt_bpf for netfilter, cls_bpf in the kernel qdisc "
"layer, SECCOMP-BPF (SECure COMPuting [1]_), and lots of other places such as "
"team driver, PTP code, etc where BPF is being used."
msgstr ""

#: ../../../networking/filter.rst:60
msgid "Documentation/userspace-api/seccomp_filter.rst"
msgstr ""

#: ../../../networking/filter.rst:62
msgid "Original BPF paper:"
msgstr ""

#: ../../../networking/filter.rst:64
msgid ""
"Steven McCanne and Van Jacobson. 1993. The BSD packet filter: a new "
"architecture for user-level packet capture. In Proceedings of the USENIX "
"Winter 1993 Conference Proceedings on USENIX Winter 1993 Conference "
"Proceedings (USENIX'93). USENIX Association, Berkeley, CA, USA, 2-2. [http://"
"www.tcpdump.org/papers/bpf-usenix93.pdf]"
msgstr ""

#: ../../../networking/filter.rst:71
msgid "Structure"
msgstr ""

#: ../../../networking/filter.rst:73
msgid ""
"User space applications include <linux/filter.h> which contains the "
"following relevant structures::"
msgstr ""

#: ../../../networking/filter.rst:83
msgid ""
"Such a structure is assembled as an array of 4-tuples, that contains a code, "
"jt, jf and k value. jt and jf are jump offsets and k a generic value to be "
"used for a provided code::"
msgstr ""

#: ../../../networking/filter.rst:92
msgid ""
"For socket filtering, a pointer to this structure (as shown in follow-up "
"example) is being passed to the kernel through setsockopt(2)."
msgstr ""

#: ../../../networking/filter.rst:96
msgid "Example"
msgstr ""

#: ../../../networking/filter.rst:150
msgid ""
"The above example code attaches a socket filter for a PF_PACKET socket in "
"order to let all IPv4/IPv6 packets with port 22 pass. The rest will be "
"dropped for this socket."
msgstr ""

#: ../../../networking/filter.rst:154
msgid ""
"The setsockopt(2) call to SO_DETACH_FILTER doesn't need any arguments and "
"SO_LOCK_FILTER for preventing the filter to be detached, takes an integer "
"value with 0 or 1."
msgstr ""

#: ../../../networking/filter.rst:158
msgid ""
"Note that socket filters are not restricted to PF_PACKET sockets only, but "
"can also be used on other socket families."
msgstr ""

#: ../../../networking/filter.rst:161
msgid "Summary of system calls:"
msgstr ""

#: ../../../networking/filter.rst:163
msgid "setsockopt(sockfd, SOL_SOCKET, SO_ATTACH_FILTER, &val, sizeof(val));"
msgstr ""

#: ../../../networking/filter.rst:164
msgid "setsockopt(sockfd, SOL_SOCKET, SO_DETACH_FILTER, &val, sizeof(val));"
msgstr ""

#: ../../../networking/filter.rst:165
msgid "setsockopt(sockfd, SOL_SOCKET, SO_LOCK_FILTER,   &val, sizeof(val));"
msgstr ""

#: ../../../networking/filter.rst:167
msgid ""
"Normally, most use cases for socket filtering on packet sockets will be "
"covered by libpcap in high-level syntax, so as an application developer you "
"should stick to that. libpcap wraps its own layer around all that."
msgstr ""

#: ../../../networking/filter.rst:171
msgid ""
"Unless i) using/linking to libpcap is not an option, ii) the required BPF "
"filters use Linux extensions that are not supported by libpcap's compiler, "
"iii) a filter might be more complex and not cleanly implementable with "
"libpcap's compiler, or iv) particular filter codes should be optimized "
"differently than libpcap's internal compiler does; then in such cases "
"writing such a filter \"by hand\" can be of an alternative. For example, "
"xt_bpf and cls_bpf users might have requirements that could result in more "
"complex filter code, or one that cannot be expressed with libpcap (e.g. "
"different return codes for various code paths). Moreover, BPF JIT "
"implementors may wish to manually write test cases and thus need low-level "
"access to BPF code as well."
msgstr ""

#: ../../../networking/filter.rst:184
msgid "BPF engine and instruction set"
msgstr ""

#: ../../../networking/filter.rst:186
msgid ""
"Under tools/bpf/ there's a small helper tool called bpf_asm which can be "
"used to write low-level filters for example scenarios mentioned in the "
"previous section. Asm-like syntax mentioned here has been implemented in "
"bpf_asm and will be used for further explanations (instead of dealing with "
"less readable opcodes directly, principles are the same). The syntax is "
"closely modelled after Steven McCanne's and Van Jacobson's BPF paper."
msgstr ""

#: ../../../networking/filter.rst:193
msgid "The BPF architecture consists of the following basic elements:"
msgstr ""

#: ../../../networking/filter.rst:196
msgid "Element"
msgstr ""

#: ../../../networking/filter.rst:196 ../../../networking/filter.rst:221
#: ../../../networking/filter.rst:266 ../../../networking/filter.rst:291
msgid "Description"
msgstr ""

#: ../../../networking/filter.rst:198
msgid "A"
msgstr ""

#: ../../../networking/filter.rst:198
msgid "32 bit wide accumulator"
msgstr ""

#: ../../../networking/filter.rst:199
msgid "X"
msgstr ""

#: ../../../networking/filter.rst:199
msgid "32 bit wide X register"
msgstr ""

#: ../../../networking/filter.rst:200
msgid "M[]"
msgstr ""

#: ../../../networking/filter.rst:200
msgid ""
"16 x 32 bit wide misc registers aka \"scratch memory store\", addressable "
"from 0 to 15"
msgstr ""

#: ../../../networking/filter.rst:204
msgid ""
"A program, that is translated by bpf_asm into \"opcodes\" is an array that "
"consists of the following elements (as already mentioned)::"
msgstr ""

#: ../../../networking/filter.rst:209
msgid ""
"The element op is a 16 bit wide opcode that has a particular instruction "
"encoded. jt and jf are two 8 bit wide jump targets, one for condition \"jump "
"if true\", the other one \"jump if false\". Eventually, element k contains a "
"miscellaneous argument that can be interpreted in different ways depending "
"on the given instruction in op."
msgstr ""

#: ../../../networking/filter.rst:215
msgid ""
"The instruction set consists of load, store, branch, alu, miscellaneous and "
"return instructions that are also represented in bpf_asm syntax. This table "
"lists all bpf_asm instructions available resp. what their underlying opcodes "
"as defined in linux/filter.h stand for:"
msgstr ""

#: ../../../networking/filter.rst:221
msgid "Instruction"
msgstr ""

#: ../../../networking/filter.rst:221 ../../../networking/filter.rst:266
msgid "Addressing mode"
msgstr ""

#: ../../../networking/filter.rst:223
msgid "ld"
msgstr ""

#: ../../../networking/filter.rst:223
msgid "1, 2, 3, 4, 12"
msgstr ""

#: ../../../networking/filter.rst:223 ../../../networking/filter.rst:224
msgid "Load word into A"
msgstr ""

#: ../../../networking/filter.rst:224
msgid "ldi"
msgstr ""

#: ../../../networking/filter.rst:224 ../../../networking/filter.rst:228
#: ../../../networking/filter.rst:272
msgid "4"
msgstr ""

#: ../../../networking/filter.rst:225
msgid "ldh"
msgstr ""

#: ../../../networking/filter.rst:225 ../../../networking/filter.rst:226
msgid "1, 2"
msgstr ""

#: ../../../networking/filter.rst:225
msgid "Load half-word into A"
msgstr ""

#: ../../../networking/filter.rst:226
msgid "ldb"
msgstr ""

#: ../../../networking/filter.rst:226
msgid "Load byte into A"
msgstr ""

#: ../../../networking/filter.rst:227
msgid "ldx"
msgstr ""

#: ../../../networking/filter.rst:227
msgid "3, 4, 5, 12"
msgstr ""

#: ../../../networking/filter.rst:227 ../../../networking/filter.rst:228
msgid "Load word into X"
msgstr ""

#: ../../../networking/filter.rst:228
msgid "ldxi"
msgstr ""

#: ../../../networking/filter.rst:229
msgid "ldxb"
msgstr ""

#: ../../../networking/filter.rst:229 ../../../networking/filter.rst:273
msgid "5"
msgstr ""

#: ../../../networking/filter.rst:229
msgid "Load byte into X"
msgstr ""

#: ../../../networking/filter.rst:231
msgid "st"
msgstr ""

#: ../../../networking/filter.rst:231 ../../../networking/filter.rst:232
#: ../../../networking/filter.rst:271
msgid "3"
msgstr ""

#: ../../../networking/filter.rst:231
msgid "Store A into M[]"
msgstr ""

#: ../../../networking/filter.rst:232
msgid "stx"
msgstr ""

#: ../../../networking/filter.rst:232
msgid "Store X into M[]"
msgstr ""

#: ../../../networking/filter.rst:234
msgid "jmp"
msgstr ""

#: ../../../networking/filter.rst:234 ../../../networking/filter.rst:235
#: ../../../networking/filter.rst:274
msgid "6"
msgstr ""

#: ../../../networking/filter.rst:234 ../../../networking/filter.rst:235
msgid "Jump to label"
msgstr ""

#: ../../../networking/filter.rst:235
msgid "ja"
msgstr ""

#: ../../../networking/filter.rst:236
msgid "jeq"
msgstr ""

#: ../../../networking/filter.rst:236 ../../../networking/filter.rst:241
#: ../../../networking/filter.rst:242 ../../../networking/filter.rst:243
msgid "7, 8, 9, 10"
msgstr ""

#: ../../../networking/filter.rst:236
msgid "Jump on A == <x>"
msgstr ""

#: ../../../networking/filter.rst:237
msgid "jneq"
msgstr ""

#: ../../../networking/filter.rst:237 ../../../networking/filter.rst:238
#: ../../../networking/filter.rst:239 ../../../networking/filter.rst:240
msgid "9, 10"
msgstr ""

#: ../../../networking/filter.rst:237 ../../../networking/filter.rst:238
msgid "Jump on A != <x>"
msgstr ""

#: ../../../networking/filter.rst:238
msgid "jne"
msgstr ""

#: ../../../networking/filter.rst:239
msgid "jlt"
msgstr ""

#: ../../../networking/filter.rst:239
msgid "Jump on A <  <x>"
msgstr ""

#: ../../../networking/filter.rst:240
msgid "jle"
msgstr ""

#: ../../../networking/filter.rst:240
msgid "Jump on A <= <x>"
msgstr ""

#: ../../../networking/filter.rst:241
msgid "jgt"
msgstr ""

#: ../../../networking/filter.rst:241
msgid "Jump on A >  <x>"
msgstr ""

#: ../../../networking/filter.rst:242
msgid "jge"
msgstr ""

#: ../../../networking/filter.rst:242
msgid "Jump on A >= <x>"
msgstr ""

#: ../../../networking/filter.rst:243
msgid "jset"
msgstr ""

#: ../../../networking/filter.rst:243
msgid "Jump on A &  <x>"
msgstr ""

#: ../../../networking/filter.rst:245
msgid "add"
msgstr ""

#: ../../../networking/filter.rst:245 ../../../networking/filter.rst:246
#: ../../../networking/filter.rst:247 ../../../networking/filter.rst:248
#: ../../../networking/filter.rst:249 ../../../networking/filter.rst:251
#: ../../../networking/filter.rst:252 ../../../networking/filter.rst:253
#: ../../../networking/filter.rst:254 ../../../networking/filter.rst:255
msgid "0, 4"
msgstr ""

#: ../../../networking/filter.rst:245
msgid "A + <x>"
msgstr ""

#: ../../../networking/filter.rst:246
msgid "sub"
msgstr ""

#: ../../../networking/filter.rst:246
msgid "A - <x>"
msgstr ""

#: ../../../networking/filter.rst:247
msgid "mul"
msgstr ""

#: ../../../networking/filter.rst:247
msgid "A * <x>"
msgstr ""

#: ../../../networking/filter.rst:248
msgid "div"
msgstr ""

#: ../../../networking/filter.rst:248
msgid "A / <x>"
msgstr ""

#: ../../../networking/filter.rst:249
msgid "mod"
msgstr ""

#: ../../../networking/filter.rst:249
msgid "A % <x>"
msgstr ""

#: ../../../networking/filter.rst:250
msgid "neg"
msgstr ""

#: ../../../networking/filter.rst:250
msgid "!A"
msgstr ""

#: ../../../networking/filter.rst:251
msgid "and"
msgstr ""

#: ../../../networking/filter.rst:251
msgid "A & <x>"
msgstr ""

#: ../../../networking/filter.rst:252
msgid "or"
msgstr ""

#: ../../../networking/filter.rst:252
msgid "A | <x>"
msgstr ""

#: ../../../networking/filter.rst:253
msgid "xor"
msgstr ""

#: ../../../networking/filter.rst:253
msgid "A ^ <x>"
msgstr ""

#: ../../../networking/filter.rst:254
msgid "lsh"
msgstr ""

#: ../../../networking/filter.rst:254
msgid "A << <x>"
msgstr ""

#: ../../../networking/filter.rst:255
msgid "rsh"
msgstr ""

#: ../../../networking/filter.rst:255
msgid "A >> <x>"
msgstr ""

#: ../../../networking/filter.rst:257
msgid "tax"
msgstr ""

#: ../../../networking/filter.rst:257
msgid "Copy A into X"
msgstr ""

#: ../../../networking/filter.rst:258
msgid "txa"
msgstr ""

#: ../../../networking/filter.rst:258
msgid "Copy X into A"
msgstr ""

#: ../../../networking/filter.rst:260
msgid "ret"
msgstr ""

#: ../../../networking/filter.rst:260
msgid "4, 11"
msgstr ""

#: ../../../networking/filter.rst:260
msgid "Return"
msgstr ""

#: ../../../networking/filter.rst:263
msgid "The next table shows addressing formats from the 2nd column:"
msgstr ""

#: ../../../networking/filter.rst:266
msgid "Syntax"
msgstr ""

#: ../../../networking/filter.rst:268
msgid "0"
msgstr ""

#: ../../../networking/filter.rst:268
msgid "x/%x"
msgstr ""

#: ../../../networking/filter.rst:268
msgid "Register X"
msgstr ""

#: ../../../networking/filter.rst:269
msgid "1"
msgstr ""

#: ../../../networking/filter.rst:269
msgid "[k]"
msgstr ""

#: ../../../networking/filter.rst:269
msgid "BHW at byte offset k in the packet"
msgstr ""

#: ../../../networking/filter.rst:270
msgid "2"
msgstr ""

#: ../../../networking/filter.rst:270
msgid "[x + k]"
msgstr ""

#: ../../../networking/filter.rst:270
msgid "BHW at the offset X + k in the packet"
msgstr ""

#: ../../../networking/filter.rst:271
msgid "M[k]"
msgstr ""

#: ../../../networking/filter.rst:271
msgid "Word at offset k in M[]"
msgstr ""

#: ../../../networking/filter.rst:272
msgid "#k"
msgstr ""

#: ../../../networking/filter.rst:272
msgid "Literal value stored in k"
msgstr ""

#: ../../../networking/filter.rst:273
msgid "4*([k]&0xf)"
msgstr ""

#: ../../../networking/filter.rst:273
msgid "Lower nibble * 4 at byte offset k in the packet"
msgstr ""

#: ../../../networking/filter.rst:274
msgid "L"
msgstr ""

#: ../../../networking/filter.rst:274
msgid "Jump label L"
msgstr ""

#: ../../../networking/filter.rst:275
msgid "7"
msgstr ""

#: ../../../networking/filter.rst:275
msgid "#k,Lt,Lf"
msgstr ""

#: ../../../networking/filter.rst:275 ../../../networking/filter.rst:276
msgid "Jump to Lt if true, otherwise jump to Lf"
msgstr ""

#: ../../../networking/filter.rst:276
msgid "8"
msgstr ""

#: ../../../networking/filter.rst:276
msgid "x/%x,Lt,Lf"
msgstr ""

#: ../../../networking/filter.rst:277
msgid "9"
msgstr ""

#: ../../../networking/filter.rst:277
msgid "#k,Lt"
msgstr ""

#: ../../../networking/filter.rst:277 ../../../networking/filter.rst:278
msgid "Jump to Lt if predicate is true"
msgstr ""

#: ../../../networking/filter.rst:278
msgid "10"
msgstr ""

#: ../../../networking/filter.rst:278
msgid "x/%x,Lt"
msgstr ""

#: ../../../networking/filter.rst:279
msgid "11"
msgstr ""

#: ../../../networking/filter.rst:279
msgid "a/%a"
msgstr ""

#: ../../../networking/filter.rst:279
msgid "Accumulator A"
msgstr ""

#: ../../../networking/filter.rst:280
msgid "12"
msgstr ""

#: ../../../networking/filter.rst:280
msgid "extension"
msgstr ""

#: ../../../networking/filter.rst:280
msgid "BPF extension"
msgstr ""

#: ../../../networking/filter.rst:283
msgid ""
"The Linux kernel also has a couple of BPF extensions that are used along "
"with the class of load instructions by \"overloading\" the k argument with a "
"negative offset + a particular extension offset. The result of such BPF "
"extensions are loaded into A."
msgstr ""

#: ../../../networking/filter.rst:288
msgid "Possible BPF extensions are shown in the following table:"
msgstr ""

#: ../../../networking/filter.rst:291
msgid "Extension"
msgstr ""

#: ../../../networking/filter.rst:293
msgid "len"
msgstr ""

#: ../../../networking/filter.rst:293
msgid "skb->len"
msgstr ""

#: ../../../networking/filter.rst:294
msgid "proto"
msgstr ""

#: ../../../networking/filter.rst:294
msgid "skb->protocol"
msgstr ""

#: ../../../networking/filter.rst:295
msgid "type"
msgstr ""

#: ../../../networking/filter.rst:295
msgid "skb->pkt_type"
msgstr ""

#: ../../../networking/filter.rst:296
msgid "poff"
msgstr ""

#: ../../../networking/filter.rst:296
msgid "Payload start offset"
msgstr ""

#: ../../../networking/filter.rst:297
msgid "ifidx"
msgstr ""

#: ../../../networking/filter.rst:297
msgid "skb->dev->ifindex"
msgstr ""

#: ../../../networking/filter.rst:298
msgid "nla"
msgstr ""

#: ../../../networking/filter.rst:298
msgid "Netlink attribute of type X with offset A"
msgstr ""

#: ../../../networking/filter.rst:299
msgid "nlan"
msgstr ""

#: ../../../networking/filter.rst:299
msgid "Nested Netlink attribute of type X with offset A"
msgstr ""

#: ../../../networking/filter.rst:300
msgid "mark"
msgstr ""

#: ../../../networking/filter.rst:300
msgid "skb->mark"
msgstr ""

#: ../../../networking/filter.rst:301
msgid "queue"
msgstr ""

#: ../../../networking/filter.rst:301
msgid "skb->queue_mapping"
msgstr ""

#: ../../../networking/filter.rst:302
msgid "hatype"
msgstr ""

#: ../../../networking/filter.rst:302
msgid "skb->dev->type"
msgstr ""

#: ../../../networking/filter.rst:303
msgid "rxhash"
msgstr ""

#: ../../../networking/filter.rst:303
msgid "skb->hash"
msgstr ""

#: ../../../networking/filter.rst:304
msgid "cpu"
msgstr ""

#: ../../../networking/filter.rst:304
msgid "raw_smp_processor_id()"
msgstr ""

#: ../../../networking/filter.rst:305
msgid "vlan_tci"
msgstr ""

#: ../../../networking/filter.rst:305
msgid "skb_vlan_tag_get(skb)"
msgstr ""

#: ../../../networking/filter.rst:306
msgid "vlan_avail"
msgstr ""

#: ../../../networking/filter.rst:306
msgid "skb_vlan_tag_present(skb)"
msgstr ""

#: ../../../networking/filter.rst:307
msgid "vlan_tpid"
msgstr ""

#: ../../../networking/filter.rst:307
msgid "skb->vlan_proto"
msgstr ""

#: ../../../networking/filter.rst:308
msgid "rand"
msgstr ""

#: ../../../networking/filter.rst:308
msgid "get_random_u32()"
msgstr ""

#: ../../../networking/filter.rst:311
msgid ""
"These extensions can also be prefixed with '#'. Examples for low-level BPF:"
msgstr ""

#: ../../../networking/filter.rst:314
msgid "**ARP packets**::"
msgstr ""

#: ../../../networking/filter.rst:321
msgid "**IPv4 TCP packets**::"
msgstr ""

#: ../../../networking/filter.rst:330
msgid "**icmp random packet sampling, 1 in 4**::"
msgstr ""

#: ../../../networking/filter.rst:343
msgid "**SECCOMP filter example**::"
msgstr ""

#: ../../../networking/filter.rst:361
msgid "Examples for low-level BPF extension:"
msgstr ""

#: ../../../networking/filter.rst:363
msgid "**Packet for interface index 13**::"
msgstr ""

#: ../../../networking/filter.rst:370
msgid "**(Accelerated) VLAN w/ id 10**::"
msgstr ""

#: ../../../networking/filter.rst:377
msgid ""
"The above example code can be placed into a file (here called \"foo\"), and "
"then be passed to the bpf_asm tool for generating opcodes, output that "
"xt_bpf and cls_bpf understands and can directly be loaded with. Example with "
"above ARP code::"
msgstr ""

#: ../../../networking/filter.rst:385
msgid "In copy and paste C-like output::"
msgstr ""

#: ../../../networking/filter.rst:393
msgid ""
"In particular, as usage with xt_bpf or cls_bpf can result in more complex "
"BPF filters that might not be obvious at first, it's good to test filters "
"before attaching to a live system. For that purpose, there's a small tool "
"called bpf_dbg under tools/bpf/ in the kernel source directory. This "
"debugger allows for testing BPF filters against given pcap files, single "
"stepping through the BPF code on the pcap's packets and to do BPF machine "
"register dumps."
msgstr ""

#: ../../../networking/filter.rst:400
msgid "Starting bpf_dbg is trivial and just requires issuing::"
msgstr ""

#: ../../../networking/filter.rst:404
msgid ""
"In case input and output do not equal stdin/stdout, bpf_dbg takes an "
"alternative stdin source as a first argument, and an alternative stdout sink "
"as a second one, e.g. `./bpf_dbg test_in.txt test_out.txt`."
msgstr ""

#: ../../../networking/filter.rst:408
msgid ""
"Other than that, a particular libreadline configuration can be set via file "
"\"~/.bpf_dbg_init\" and the command history is stored in the file \"~/."
"bpf_dbg_history\"."
msgstr ""

#: ../../../networking/filter.rst:412
msgid ""
"Interaction in bpf_dbg happens through a shell that also has auto-completion "
"support (follow-up example commands starting with '>' denote bpf_dbg shell). "
"The usual workflow would be to ..."
msgstr ""

#: ../../../networking/filter.rst:416
msgid ""
"load bpf 6,40 0 0 12,21 0 3 2048,48 0 0 23,21 0 1 1,6 0 0 65535,6 0 0 0 "
"Loads a BPF filter from standard output of bpf_asm, or transformed via e.g. "
"``tcpdump -iem1 -ddd port 22 | tr '\\n' ','``. Note that for JIT debugging "
"(next section), this command creates a temporary socket and loads the BPF "
"code into the kernel. Thus, this will also be useful for JIT developers."
msgstr ""

#: ../../../networking/filter.rst:423
msgid "load pcap foo.pcap"
msgstr ""

#: ../../../networking/filter.rst:425
msgid "Loads standard tcpdump pcap file."
msgstr ""

#: ../../../networking/filter.rst:427
msgid "run [<n>]"
msgstr ""

#: ../../../networking/filter.rst:429
msgid "bpf passes:1 fails:9"
msgstr ""

#: ../../../networking/filter.rst:430
msgid ""
"Runs through all packets from a pcap to account how many passes and fails "
"the filter will generate. A limit of packets to traverse can be given."
msgstr ""

#: ../../../networking/filter.rst:433
msgid "disassemble::"
msgstr ""

#: ../../../networking/filter.rst:442
msgid "Prints out BPF code disassembly."
msgstr ""

#: ../../../networking/filter.rst:444
msgid "dump::"
msgstr ""

#: ../../../networking/filter.rst:454
msgid "Prints out C-style BPF code dump."
msgstr ""

#: ../../../networking/filter.rst:456
msgid "breakpoint 0::"
msgstr ""

#: ../../../networking/filter.rst:460
msgid "breakpoint 1::"
msgstr ""

#: ../../../networking/filter.rst:464
msgid "..."
msgstr ""

#: ../../../networking/filter.rst:466
msgid ""
"Sets breakpoints at particular BPF instructions. Issuing a `run` command "
"will walk through the pcap file continuing from the current packet and break "
"when a breakpoint is being hit (another `run` will continue from the "
"currently active breakpoint executing next instructions):"
msgstr ""

#: ../../../networking/filter.rst:471
msgid "run::"
msgstr ""

#: ../../../networking/filter.rst:488
msgid "breakpoint::"
msgstr ""

#: ../../../networking/filter.rst:492
msgid "Prints currently set breakpoints."
msgstr ""

#: ../../../networking/filter.rst:494
msgid "step [-<n>, +<n>]"
msgstr ""

#: ../../../networking/filter.rst:496
msgid ""
"Performs single stepping through the BPF program from the current pc offset. "
"Thus, on each step invocation, above register dump is issued. This can go "
"forwards and backwards in time, a plain `step` will break on the next BPF "
"instruction, thus +1. (No `run` needs to be issued here.)"
msgstr ""

#: ../../../networking/filter.rst:501
msgid "select <n>"
msgstr ""

#: ../../../networking/filter.rst:503
msgid ""
"Selects a given packet from the pcap file to continue from. Thus, on the "
"next `run` or `step`, the BPF program is being evaluated against the user "
"pre-selected packet. Numbering starts just as in Wireshark with index 1."
msgstr ""

#: ../../../networking/filter.rst:508
msgid "quit"
msgstr ""

#: ../../../networking/filter.rst:510
msgid "Exits bpf_dbg."
msgstr ""

#: ../../../networking/filter.rst:513
msgid "JIT compiler"
msgstr ""

#: ../../../networking/filter.rst:515
msgid ""
"The Linux kernel has a built-in BPF JIT compiler for x86_64, SPARC, PowerPC, "
"ARM, ARM64, MIPS, RISC-V, s390, and ARC and can be enabled through "
"CONFIG_BPF_JIT. The JIT compiler is transparently invoked for each attached "
"filter from user space or for internal kernel users if it has been "
"previously enabled by root::"
msgstr ""

#: ../../../networking/filter.rst:523
msgid ""
"For JIT developers, doing audits etc, each compile run can output the "
"generated opcode image into the kernel log via::"
msgstr ""

#: ../../../networking/filter.rst:528
msgid "Example output from dmesg::"
msgstr ""

#: ../../../networking/filter.rst:537
msgid ""
"When CONFIG_BPF_JIT_ALWAYS_ON is enabled, bpf_jit_enable is permanently set "
"to 1 and setting any other value than that will return in failure. This is "
"even the case for setting bpf_jit_enable to 2, since dumping the final JIT "
"image into the kernel log is discouraged and introspection through bpftool "
"(under tools/bpf/bpftool/) is the generally recommended approach instead."
msgstr ""

#: ../../../networking/filter.rst:543
msgid ""
"In the kernel source tree under tools/bpf/, there's bpf_jit_disasm for "
"generating disassembly out of the kernel log's hexdump::"
msgstr ""

#: ../../../networking/filter.rst:617
msgid ""
"For BPF JIT developers, bpf_jit_disasm, bpf_asm and bpf_dbg provides a "
"useful toolchain for developing and testing the kernel's JIT compiler."
msgstr ""

#: ../../../networking/filter.rst:621
msgid "BPF kernel internals"
msgstr ""

#: ../../../networking/filter.rst:622
msgid ""
"Internally, for the kernel interpreter, a different instruction set format "
"with similar underlying principles from BPF described in previous paragraphs "
"is being used. However, the instruction set format is modelled closer to the "
"underlying architecture to mimic native instruction sets, so that a better "
"performance can be achieved (more details later). This new ISA is called "
"eBPF.  See the ../bpf/index.rst for details.  (Note: eBPF which originates "
"from [e]xtended BPF is not the same as BPF extensions! While eBPF is an ISA, "
"BPF extensions date back to classic BPF's 'overloading' of BPF_LD | BPF_{B,H,"
"W} | BPF_ABS instruction.)"
msgstr ""

#: ../../../networking/filter.rst:632
msgid ""
"The new instruction set was originally designed with the possible goal in "
"mind to write programs in \"restricted C\" and compile into eBPF with a "
"optional GCC/LLVM backend, so that it can just-in-time map to modern 64-bit "
"CPUs with minimal performance overhead over two steps, that is, C -> eBPF -> "
"native code."
msgstr ""

#: ../../../networking/filter.rst:637
msgid ""
"Currently, the new format is being used for running user BPF programs, which "
"includes seccomp BPF, classic socket filters, cls_bpf traffic classifier, "
"team driver's classifier for its load-balancing mode, netfilter's xt_bpf "
"extension, PTP dissector/classifier, and much more. They are all internally "
"converted by the kernel into the new instruction set representation and run "
"in the eBPF interpreter. For in-kernel handlers, this all works "
"transparently by using bpf_prog_create() for setting up the filter, resp. "
"bpf_prog_destroy() for destroying it. The function bpf_prog_run(filter, ctx) "
"transparently invokes eBPF interpreter or JITed code to run the filter. "
"'filter' is a pointer to struct bpf_prog that we got from bpf_prog_create(), "
"and 'ctx' the given context (e.g. skb pointer). All constraints and "
"restrictions from bpf_check_classic() apply before a conversion to the new "
"layout is being done behind the scenes!"
msgstr ""

#: ../../../networking/filter.rst:651
msgid ""
"Currently, the classic BPF format is being used for JITing on most 32-bit "
"architectures, whereas x86-64, aarch64, s390x, powerpc64, sparc64, arm32, "
"riscv64, riscv32, loongarch64, arc perform JIT compilation from eBPF "
"instruction set."
msgstr ""

#: ../../../networking/filter.rst:657
msgid "Testing"
msgstr ""

#: ../../../networking/filter.rst:659
msgid ""
"Next to the BPF toolchain, the kernel also ships a test module that contains "
"various test cases for classic and eBPF that can be executed against the BPF "
"interpreter and JIT compiler. It can be found in lib/test_bpf.c and enabled "
"via Kconfig::"
msgstr ""

#: ../../../networking/filter.rst:666
msgid ""
"After the module has been built and installed, the test suite can be "
"executed via insmod or modprobe against 'test_bpf' module. Results of the "
"test cases including timings in nsec can be found in the kernel log (dmesg)."
msgstr ""

#: ../../../networking/filter.rst:671
msgid "Misc"
msgstr ""

#: ../../../networking/filter.rst:673
msgid ""
"Also trinity, the Linux syscall fuzzer, has built-in support for BPF and "
"SECCOMP-BPF kernel fuzzing."
msgstr ""

#: ../../../networking/filter.rst:677
msgid "Written by"
msgstr ""

#: ../../../networking/filter.rst:679
msgid ""
"The document was written in the hope that it is found useful and in order to "
"give potential BPF hackers or security auditors a better overview of the "
"underlying architecture."
msgstr ""

#: ../../../networking/filter.rst:683
msgid "Jay Schulist <jschlst@samba.org>"
msgstr ""

#: ../../../networking/filter.rst:684
msgid "Daniel Borkmann <daniel@iogearbox.net>"
msgstr ""

#: ../../../networking/filter.rst:685
msgid "Alexei Starovoitov <ast@kernel.org>"
msgstr ""
