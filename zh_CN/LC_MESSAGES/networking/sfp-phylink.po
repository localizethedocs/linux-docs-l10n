# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../networking/sfp-phylink.rst:5
msgid "phylink"
msgstr ""

#: ../../../networking/sfp-phylink.rst:8
msgid "Overview"
msgstr ""

#: ../../../networking/sfp-phylink.rst:10
msgid ""
"phylink is a mechanism to support hot-pluggable networking modules directly "
"connected to a MAC without needing to re-initialise the adapter on hot-plug "
"events."
msgstr ""

#: ../../../networking/sfp-phylink.rst:14
msgid ""
"phylink supports conventional phylib-based setups, fixed link setups and SFP "
"(Small Formfactor Pluggable) modules at present."
msgstr ""

#: ../../../networking/sfp-phylink.rst:18
msgid "Modes of operation"
msgstr ""

#: ../../../networking/sfp-phylink.rst:20
msgid ""
"phylink has several modes of operation, which depend on the firmware "
"settings."
msgstr ""

#: ../../../networking/sfp-phylink.rst:23
msgid "PHY mode"
msgstr ""

#: ../../../networking/sfp-phylink.rst:25
msgid ""
"In PHY mode, we use phylib to read the current link settings from the PHY, "
"and pass them to the MAC driver.  We expect the MAC driver to configure "
"exactly the modes that are specified without any negotiation being enabled "
"on the link."
msgstr ""

#: ../../../networking/sfp-phylink.rst:30
msgid "Fixed mode"
msgstr ""

#: ../../../networking/sfp-phylink.rst:32
msgid ""
"Fixed mode is the same as PHY mode as far as the MAC driver is concerned."
msgstr ""

#: ../../../networking/sfp-phylink.rst:35
msgid "In-band mode"
msgstr ""

#: ../../../networking/sfp-phylink.rst:37
msgid ""
"In-band mode is used with 802.3z, SGMII and similar interface modes, and we "
"are expecting to use and honor the in-band negotiation or control word sent "
"across the serdes channel."
msgstr ""

#: ../../../networking/sfp-phylink.rst:41
msgid "By example, what this means is that:"
msgstr ""

#: ../../../networking/sfp-phylink.rst:50
msgid ""
"does not use in-band SGMII signalling.  The PHY is expected to follow "
"exactly the settings given to it in its :c:func:`mac_config` function. The "
"link should be forced up or down appropriately in the :c:func:`mac_link_up` "
"and :c:func:`mac_link_down` functions."
msgstr ""

#: ../../../networking/sfp-phylink.rst:63
msgid ""
"uses in-band mode, where results from the PHY's negotiation are passed to "
"the MAC through the SGMII control word, and the MAC is expected to "
"acknowledge the control word.  The :c:func:`mac_link_up` and :c:func:"
"`mac_link_down` functions must not force the MAC side link up and down."
msgstr ""

#: ../../../networking/sfp-phylink.rst:70
msgid "Rough guide to converting a network driver to sfp/phylink"
msgstr ""

#: ../../../networking/sfp-phylink.rst:72
msgid ""
"This guide briefly describes how to convert a network driver from phylib to "
"the sfp/phylink support.  Please send patches to improve this documentation."
msgstr ""

#: ../../../networking/sfp-phylink.rst:76
msgid ""
"Optionally split the network driver's phylib update function into two parts "
"dealing with link-down and link-up. This can be done as a separate "
"preparation commit."
msgstr ""

#: ../../../networking/sfp-phylink.rst:80
msgid ""
"An older example of this preparation can be found in git commit "
"fc548b991fb0, although this was splitting into three parts; the link-up part "
"now includes configuring the MAC for the link settings. Please see :c:func:"
"`mac_link_up` for more information on this."
msgstr ""

#: ../../../networking/sfp-phylink.rst:85
msgid "Replace::"
msgstr ""

#: ../../../networking/sfp-phylink.rst:90
msgid "with::"
msgstr ""

#: ../../../networking/sfp-phylink.rst:94
msgid "in the driver's Kconfig stanza."
msgstr ""

#: ../../../networking/sfp-phylink.rst:96
#: ../../../networking/sfp-phylink.rst:102
msgid "Add::"
msgstr ""

#: ../../../networking/sfp-phylink.rst:100
msgid "to the driver's list of header files."
msgstr ""

#: ../../../networking/sfp-phylink.rst:107
msgid ""
"to the driver's private data structure.  We shall refer to the driver's "
"private data pointer as ``priv`` below, and the driver's private data "
"structure as ``struct foo_priv``."
msgstr ""

#: ../../../networking/sfp-phylink.rst:111
msgid "Replace the following functions:"
msgstr ""

#: ../../../networking/sfp-phylink.rst:118
msgid "Original function"
msgstr ""

#: ../../../networking/sfp-phylink.rst:119
msgid "Replacement function"
msgstr ""

#: ../../../networking/sfp-phylink.rst:120
msgid "phy_start(phydev)"
msgstr ""

#: ../../../networking/sfp-phylink.rst:121
msgid "phylink_start(priv->phylink)"
msgstr ""

#: ../../../networking/sfp-phylink.rst:122
msgid "phy_stop(phydev)"
msgstr ""

#: ../../../networking/sfp-phylink.rst:123
msgid "phylink_stop(priv->phylink)"
msgstr ""

#: ../../../networking/sfp-phylink.rst:124
msgid "phy_mii_ioctl(phydev, ifr, cmd)"
msgstr ""

#: ../../../networking/sfp-phylink.rst:125
msgid "phylink_mii_ioctl(priv->phylink, ifr, cmd)"
msgstr ""

#: ../../../networking/sfp-phylink.rst:126
msgid "phy_ethtool_get_wol(phydev, wol)"
msgstr ""

#: ../../../networking/sfp-phylink.rst:127
msgid "phylink_ethtool_get_wol(priv->phylink, wol)"
msgstr ""

#: ../../../networking/sfp-phylink.rst:128
msgid "phy_ethtool_set_wol(phydev, wol)"
msgstr ""

#: ../../../networking/sfp-phylink.rst:129
msgid "phylink_ethtool_set_wol(priv->phylink, wol)"
msgstr ""

#: ../../../networking/sfp-phylink.rst:130
msgid "phy_disconnect(phydev)"
msgstr ""

#: ../../../networking/sfp-phylink.rst:131
msgid "phylink_disconnect_phy(priv->phylink)"
msgstr ""

#: ../../../networking/sfp-phylink.rst:133
msgid ""
"Please note that some of these functions must be called under the rtnl lock, "
"and will warn if not. This will normally be the case, except if these are "
"called from the driver suspend/resume paths."
msgstr ""

#: ../../../networking/sfp-phylink.rst:137
msgid "Add/replace ksettings get/set methods with:"
msgstr ""

#: ../../../networking/sfp-phylink.rst:157
msgid "Replace the call to::"
msgstr ""

#: ../../../networking/sfp-phylink.rst:161
msgid "and associated code with a call to::"
msgstr ""

#: ../../../networking/sfp-phylink.rst:165
msgid ""
"For the most part, ``flags`` can be zero; these flags are passed to the "
"phy_attach_direct() inside this function call if a PHY is specified in the "
"DT node ``node``."
msgstr ""

#: ../../../networking/sfp-phylink.rst:169
msgid ""
"``node`` should be the DT node which contains the network phy property, "
"fixed link properties, and will also contain the sfp property."
msgstr ""

#: ../../../networking/sfp-phylink.rst:172
msgid ""
"The setup of fixed links should also be removed; these are handled "
"internally by phylink."
msgstr ""

#: ../../../networking/sfp-phylink.rst:175
msgid ""
"of_phy_connect() was also passed a function pointer for link updates. This "
"function is replaced by a different form of MAC updates described below in "
"(8)."
msgstr ""

#: ../../../networking/sfp-phylink.rst:179
msgid ""
"Manipulation of the PHY's supported/advertised happens within phylink based "
"on the validate callback, see below in (8)."
msgstr ""

#: ../../../networking/sfp-phylink.rst:182
msgid ""
"Note that the driver no longer needs to store the ``phy_interface``, and "
"also note that ``phy_interface`` becomes a dynamic property, just like the "
"speed, duplex etc. settings."
msgstr ""

#: ../../../networking/sfp-phylink.rst:186
msgid ""
"Finally, note that the MAC driver has no direct access to the PHY anymore; "
"that is because in the phylink model, the PHY can be dynamic."
msgstr ""

#: ../../../networking/sfp-phylink.rst:190
msgid ""
"Add a :c:type:`struct phylink_mac_ops <phylink_mac_ops>` instance to the "
"driver, which is a table of function pointers, and implement these "
"functions. The old link update function for :c:func:`of_phy_connect` becomes "
"three methods: :c:func:`mac_link_up`, :c:func:`mac_link_down`, and :c:func:"
"`mac_config`. If step 1 was performed, then the functionality will have been "
"split there."
msgstr ""

#: ../../../networking/sfp-phylink.rst:197
msgid ""
"It is important that if in-band negotiation is used, :c:func:`mac_link_up` "
"and :c:func:`mac_link_down` do not prevent the in-band negotiation from "
"completing, since these functions are called when the in-band link state "
"changes - otherwise the link will never come up."
msgstr ""

#: ../../../networking/sfp-phylink.rst:203
msgid ""
"The :c:func:`mac_get_caps` method is optional, and if provided should return "
"the phylink MAC capabilities that are supported for the passed ``interface`` "
"mode. In general, there is no need to implement this method. Phylink will "
"use these capabilities in combination with permissible capabilities for "
"``interface`` to determine the allowable ethtool link modes."
msgstr ""

#: ../../../networking/sfp-phylink.rst:210
msgid ""
"The :c:func:`mac_link_state` method is used to read the link state from the "
"MAC, and report back the settings that the MAC is currently using. This is "
"particularly important for in-band negotiation methods such as 1000base-X "
"and SGMII."
msgstr ""

#: ../../../networking/sfp-phylink.rst:215
msgid ""
"The :c:func:`mac_link_up` method is used to inform the MAC that the link has "
"come up. The call includes the negotiation mode and interface for reference "
"only. The finalised link parameters are also supplied (speed, duplex and "
"flow control/pause enablement settings) which should be used to configure "
"the MAC when the MAC and PCS are not tightly integrated, or when the "
"settings are not coming from in-band negotiation."
msgstr ""

#: ../../../networking/sfp-phylink.rst:223
msgid ""
"The :c:func:`mac_config` method is used to update the MAC with the requested "
"state, and must avoid unnecessarily taking the link down when making changes "
"to the MAC configuration.  This means the function should modify the state "
"and only take the link down when absolutely necessary to change the MAC "
"configuration.  An example of how to do this can be found in :c:func:"
"`mvneta_mac_config` in ``drivers/net/ethernet/marvell/mvneta.c``."
msgstr ""

#: ../../../networking/sfp-phylink.rst:231
msgid ""
"For further information on these methods, please see the inline "
"documentation in :c:type:`struct phylink_mac_ops <phylink_mac_ops>`."
msgstr ""

#: ../../../networking/sfp-phylink.rst:234
msgid ""
"Fill-in the :c:type:`struct phylink_config <phylink_config>` fields with a "
"reference to the :c:type:`struct device <device>` associated to your :c:type:"
"`struct net_device <net_device>`:"
msgstr ""

#: ../../../networking/sfp-phylink.rst:243
msgid "Fill-in the various speeds, pause and duplex modes your MAC can handle:"
msgstr ""

#: ../../../networking/sfp-phylink.rst:249
msgid ""
"Some Ethernet controllers work in pair with a PCS (Physical Coding Sublayer) "
"block, that can handle among other things the encoding/decoding, link "
"establishment detection and autonegotiation. While some MACs have internal "
"PCS whose operation is transparent, some other require dedicated PCS "
"configuration for the link to become functional. In that case, phylink "
"provides a PCS abstraction through :c:type:`struct phylink_pcs "
"<phylink_pcs>`."
msgstr ""

#: ../../../networking/sfp-phylink.rst:256
msgid ""
"Identify if your driver has one or more internal PCS blocks, and/or if your "
"controller can use an external PCS block that might be internally connected "
"to your controller."
msgstr ""

#: ../../../networking/sfp-phylink.rst:260
msgid ""
"If your controller doesn't have any internal PCS, you can go to step 11."
msgstr ""

#: ../../../networking/sfp-phylink.rst:262
msgid ""
"If your Ethernet controller contains one or several PCS blocks, create one :"
"c:type:`struct phylink_pcs <phylink_pcs>` instance per PCS block within your "
"driver's private data structure:"
msgstr ""

#: ../../../networking/sfp-phylink.rst:270
msgid ""
"Populate the relevant :c:type:`struct phylink_pcs_ops <phylink_pcs_ops>` to "
"configure your PCS. Create a :c:func:`pcs_get_state` function that reports "
"the inband link state, a :c:func:`pcs_config` function to configure your PCS "
"according to phylink-provided parameters, and a :c:func:`pcs_validate` "
"function that report to phylink all accepted configuration parameters for "
"your PCS:"
msgstr ""

#: ../../../networking/sfp-phylink.rst:285
msgid ""
"Arrange for PCS link state interrupts to be forwarded into phylink, via:"
msgstr ""

#: ../../../networking/sfp-phylink.rst:292
msgid ""
"where ``link_is_up`` is true if the link is currently up or false otherwise. "
"If a PCS is unable to provide these interrupts, then it should set ``pcs-"
">pcs_poll = true;`` when creating the PCS."
msgstr ""

#: ../../../networking/sfp-phylink.rst:296
msgid ""
"If your controller relies on, or accepts the presence of an external PCS "
"controlled through its own driver, add a pointer to a phylink_pcs instance "
"in your driver private data structure:"
msgstr ""

#: ../../../networking/sfp-phylink.rst:304
msgid ""
"The way of getting an instance of the actual PCS depends on the platform, "
"some PCS sit on an MDIO bus and are grabbed by passing a pointer to the "
"corresponding :c:type:`struct mii_bus <mii_bus>` and the PCS's address on "
"that bus. In this example, we assume the controller attaches to a Lynx PCS "
"instance:"
msgstr ""

#: ../../../networking/sfp-phylink.rst:314
msgid "Some PCS can be recovered based on firmware information:"
msgstr ""

#: ../../../networking/sfp-phylink.rst:320
msgid ""
"Populate the :c:func:`mac_select_pcs` callback and add it to your :c:type:"
"`struct phylink_mac_ops <phylink_mac_ops>` set of ops. This function must "
"return a pointer to the relevant :c:type:`struct phylink_pcs <phylink_pcs>` "
"that will be used for the requested link configuration:"
msgstr ""

#: ../../../networking/sfp-phylink.rst:339
msgid ""
"See :c:func:`mvpp2_select_pcs` for an example of a driver that has multiple "
"internal PCS."
msgstr ""

#: ../../../networking/sfp-phylink.rst:342
msgid ""
"Fill-in all the :c:type:`phy_interface_t <phy_interface_t>` (i.e. all MAC to "
"PHY link modes) that your MAC can output. The following example shows a "
"configuration for a MAC that can handle all RGMII modes, SGMII and "
"1000BaseX. You must adjust these according to what your MAC and all PCS "
"associated with this MAC are capable of, and not just the interface you wish "
"to use:"
msgstr ""

#: ../../../networking/sfp-phylink.rst:356
msgid ""
"Remove calls to of_parse_phandle() for the PHY, of_phy_register_fixed_link() "
"for fixed links etc. from the probe function, and replace with:"
msgstr ""

#: ../../../networking/sfp-phylink.rst:372
msgid ""
"and arrange to destroy the phylink in the probe failure path as appropriate "
"and the removal path too by calling:"
msgstr ""

#: ../../../networking/sfp-phylink.rst:379
msgid ""
"Arrange for MAC link state interrupts to be forwarded into phylink, via:"
msgstr ""

#: ../../../networking/sfp-phylink.rst:386
msgid ""
"where ``link_is_up`` is true if the link is currently up or false otherwise."
msgstr ""

#: ../../../networking/sfp-phylink.rst:389
msgid "Verify that the driver does not call::"
msgstr ""

#: ../../../networking/sfp-phylink.rst:394
msgid ""
"as these will interfere with phylink's tracking of the link state, and cause "
"phylink to omit calls via the :c:func:`mac_link_up` and :c:func:"
"`mac_link_down` methods."
msgstr ""

#: ../../../networking/sfp-phylink.rst:398
msgid ""
"Network drivers should call phylink_stop() and phylink_start() via their "
"suspend/resume paths, which ensures that the appropriate :c:type:`struct "
"phylink_mac_ops <phylink_mac_ops>` methods are called as necessary."
msgstr ""

#: ../../../networking/sfp-phylink.rst:403
msgid ""
"For information describing the SFP cage in DT, please see the binding "
"documentation in the kernel source tree ``Documentation/devicetree/bindings/"
"net/sff,sfp.yaml``."
msgstr ""
