# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-24 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../userspace-api/netlink/intro-specs.rst:5
msgid "Using Netlink protocol specifications"
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:7
msgid ""
"This document is a quick starting guide for using Netlink protocol "
"specifications. For more detailed description of the specs see :doc:`specs`."
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:11
msgid "Simple CLI"
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:13
msgid ""
"Kernel comes with a simple CLI tool which should be useful when developing "
"Netlink related code. The tool is implemented in Python and can use a YAML "
"specification to issue Netlink requests to the kernel."
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:18
msgid ""
"The tool is located at ``tools/net/ynl/pyynl/cli.py``. It accepts a handful "
"of arguments, the most important ones are:"
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:21
msgid "``--spec`` - point to the spec file"
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:22
msgid "``--do $name`` / ``--dump $name`` - issue request ``$name``"
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:23
msgid "``--json $attrs`` - provide attributes for the request"
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:24
msgid "``--subscribe $group`` - receive notifications from ``$group``"
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:26
msgid "YAML specs can be found under ``Documentation/netlink/specs/``."
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:28
msgid "Example use::"
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:44
msgid ""
"The input arguments are parsed as JSON, while the output is only Python-"
"pretty-printed. This is because some Netlink types can't be expressed as "
"JSON directly. If such attributes are needed in the input some hacking of "
"the script will be necessary."
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:49
msgid ""
"The spec and Netlink internals are factored out as a standalone library - it "
"should be easy to write Python tools / tests reusing code from ``cli.py``."
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:54
msgid "Generating kernel code"
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:56
msgid ""
"``tools/net/ynl/ynl-regen.sh`` scans the kernel tree in search of auto-"
"generated files which need to be updated. Using this tool is the easiest way "
"to generate / update auto-generated code."
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:60
msgid ""
"By default code is re-generated only if spec is newer than the source, to "
"force regeneration use ``-f``."
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:63
msgid ""
"``ynl-regen.sh`` searches for ``YNL-GEN`` in the contents of files (note "
"that it only scans files in the git index, that is only files tracked by "
"git!) For instance the ``fou_nl.c`` kernel source contains::"
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:70
msgid ""
"``ynl-regen.sh`` will find this marker and replace the file with kernel "
"source based on fou.yaml."
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:73
msgid ""
"The simplest way to generate a new file based on a spec is to add the two "
"marker lines like above to a file, add that file to git, and run the "
"regeneration tool. Grep the tree for ``YNL-GEN`` to see other examples."
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:78
msgid ""
"The code generation itself is performed by ``tools/net/ynl/pyynl/ynl_gen_c."
"py`` but it takes a few arguments so calling it directly for each file "
"quickly becomes tedious."
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:83
msgid "YNL lib"
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:85
msgid ""
"``tools/net/ynl/lib/`` contains an implementation of a C library (based on "
"libmnl) which integrates with code generated by ``tools/net/ynl/pyynl/"
"ynl_gen_c.py`` to create easy to use netlink wrappers."
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:90
msgid "YNL basics"
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:92
msgid ""
"The YNL library consists of two parts - the generic code (functions prefix "
"by ``ynl_``) and per-family auto-generated code (prefixed with the name of "
"the family)."
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:96
msgid ""
"To create a YNL socket call ynl_sock_create() passing the family struct "
"(family structs are exported by the auto-generated code). ynl_sock_destroy() "
"closes the socket."
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:101
msgid "YNL requests"
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:103
msgid ""
"Steps for issuing YNL requests are best explained on an example. All the "
"functions and types in this example come from the auto-generated code (for "
"the netdev family in this case):"
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:135
msgid "YNL dumps"
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:137
msgid ""
"Performing dumps follows similar pattern as requests. Dumps return a list of "
"objects terminated by a special marker, or NULL on error. Use "
"``ynl_dump_foreach()`` to iterate over the result."
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:143
msgid "YNL notifications"
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:145
msgid ""
"YNL lib supports using the same socket for notifications and requests. In "
"case notifications arrive during processing of a request they are queued "
"internally and can be retrieved at a later time."
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:149
msgid ""
"To subscribed to notifications use ``ynl_subscribe()``. The notifications "
"have to be read out from the socket, ``ynl_socket_get_fd()`` returns the "
"underlying socket fd which can be plugged into appropriate asynchronous IO "
"API like ``poll``, or ``select``."
msgstr ""

#: ../../../userspace-api/netlink/intro-specs.rst:155
msgid ""
"Notifications can be retrieved using ``ynl_ntf_dequeue()`` and have to be "
"freed using ``ynl_ntf_free()``. Since we don't know the notification type "
"upfront the notifications are returned as ``struct ynl_ntf_base_type *`` and "
"user is expected to cast them to the appropriate full type based on the "
"``cmd`` member."
msgstr ""
