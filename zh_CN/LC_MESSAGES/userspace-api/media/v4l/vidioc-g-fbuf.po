# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:8
msgid "ioctl VIDIOC_G_FBUF, VIDIOC_S_FBUF"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:11
msgid "Name"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:13
msgid ""
"VIDIOC_G_FBUF - VIDIOC_S_FBUF - Get or set frame buffer overlay parameters"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:16
msgid "Synopsis"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:20
msgid "``int ioctl(int fd, VIDIOC_G_FBUF, struct v4l2_framebuffer *argp)``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:24
msgid ""
"``int ioctl(int fd, VIDIOC_S_FBUF, const struct v4l2_framebuffer *argp)``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:27
msgid "Arguments"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:29
msgid "``fd``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:30
msgid "File descriptor returned by :c:func:`open()`."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:32
msgid "``argp``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:33
msgid "Pointer to struct :c:type:`v4l2_framebuffer`."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:36
msgid "Description"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:38
msgid ""
"Applications can use the :ref:`VIDIOC_G_FBUF <VIDIOC_G_FBUF>` and :ref:"
"`VIDIOC_S_FBUF <VIDIOC_G_FBUF>` ioctl to get and set the framebuffer "
"parameters for a :ref:`Video Overlay <overlay>` or :ref:`Video Output "
"Overlay <osd>` (OSD). The type of overlay is implied by the device type "
"(capture or output device) and can be determined with the :ref:"
"`VIDIOC_QUERYCAP` ioctl. One ``/dev/videoN`` device must not support both "
"kinds of overlay."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:46
msgid ""
"The V4L2 API distinguishes destructive and non-destructive overlays. A "
"destructive overlay copies captured video images into the video memory of a "
"graphics card. A non-destructive overlay blends video images into a VGA "
"signal or graphics into a video signal. *Video Output Overlays* are always "
"non-destructive."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:52
msgid ""
"Destructive overlay support has been removed: with modern GPUs and CPUs this "
"is no longer needed, and it was always a very dangerous feature."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:55
msgid ""
"To get the current parameters applications call the :ref:`VIDIOC_G_FBUF "
"<VIDIOC_G_FBUF>` ioctl with a pointer to a struct :c:type:`v4l2_framebuffer` "
"structure. The driver fills all fields of the structure or returns an EINVAL "
"error code when overlays are not supported."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:60
msgid ""
"To set the parameters for a *Video Output Overlay*, applications must "
"initialize the ``flags`` field of a struct :c:type:`v4l2_framebuffer`. Since "
"the framebuffer is implemented on the TV card all other parameters are "
"determined by the driver. When an application calls :ref:`VIDIOC_S_FBUF "
"<VIDIOC_G_FBUF>` with a pointer to this structure, the driver prepares for "
"the overlay and returns the framebuffer parameters as :ref:`VIDIOC_G_FBUF "
"<VIDIOC_G_FBUF>` does, or it returns an error code."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:69
msgid ""
"To set the parameters for a *Video Capture Overlay* applications must "
"initialize the ``flags`` field, the ``fmt`` substructure, and call :ref:"
"`VIDIOC_S_FBUF <VIDIOC_G_FBUF>`. Again the driver prepares for the overlay "
"and returns the framebuffer parameters as :ref:`VIDIOC_G_FBUF "
"<VIDIOC_G_FBUF>` does, or it returns an error code."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:81
msgid "struct v4l2_framebuffer"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:86
#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:91
#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:113
#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:117
#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:121
#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:153
#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:177
#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:191
msgid "__u32"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:87
msgid "``capability``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:89
msgid "Overlay capability flags set by the driver, see :ref:`framebuffer-cap`."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:92
msgid "``flags``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:94
msgid ""
"Overlay control flags set by application and driver, see :ref:`framebuffer-"
"flags`"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:96
msgid "void *"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:97
msgid "``base``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:99
msgid ""
"Physical base address of the framebuffer, that is the address of the pixel "
"in the top left corner of the framebuffer. For :ref:`VIDIOC_S_FBUF "
"<VIDIOC_G_FBUF>` this field is no longer supported and the kernel will "
"always set this to NULL. For *Video Output Overlays* the driver will return "
"a valid base address, so applications can find the corresponding Linux "
"framebuffer device (see :ref:`osd`). For *Video Capture Overlays* this field "
"will always be NULL."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:108
msgid "struct"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:109
msgid "``fmt``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:111
msgid "Layout of the frame buffer."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:114
msgid "``width``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:115
msgid "Width of the frame buffer in pixels."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:118
msgid "``height``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:119
msgid "Height of the frame buffer in pixels."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:122
msgid "``pixelformat``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:123
msgid "The pixel format of the framebuffer."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:127
msgid ""
"For *non-destructive Video Overlays* this field only defines a format for "
"the struct :c:type:`v4l2_window` ``chromakey`` field."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:133
msgid "For *Video Output Overlays* the driver must return a valid format."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:138
msgid ""
"Usually this is an RGB format (for example :ref:`V4L2_PIX_FMT_RGB565 <V4L2-"
"PIX-FMT-RGB565>`) but YUV formats (only packed YUV formats when chroma "
"keying is used, not including ``V4L2_PIX_FMT_YUYV`` and "
"``V4L2_PIX_FMT_UYVY``) and the ``V4L2_PIX_FMT_PAL8`` format are also "
"permitted. The behavior of the driver when an application requests a "
"compressed format is undefined. See :ref:`pixfmt` for information on pixel "
"formats."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:146
msgid "enum :c:type:`v4l2_field`"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:147
msgid "``field``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:148
msgid ""
"Drivers and applications shall ignore this field. If applicable, the field "
"order is selected with the :ref:`VIDIOC_S_FMT <VIDIOC_G_FMT>` ioctl, using "
"the ``field`` field of struct :c:type:`v4l2_window`."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:154
msgid "``bytesperline``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:155
msgid "Distance in bytes between the leftmost pixels in two adjacent lines."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:157
msgid ":cspan:`3`"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:159
msgid "This field is irrelevant to *non-destructive Video Overlays*."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:161
msgid "For *Video Output Overlays* the driver must return a valid value."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:163
msgid ""
"Video hardware may access padding bytes, therefore they must reside in "
"accessible memory. Consider for example the case where padding bytes after "
"the last line of an image cross a system page boundary. Capture devices may "
"write padding bytes, the value is undefined. Output devices ignore the "
"contents of padding bytes."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:169
msgid ""
"When the image format is planar the ``bytesperline`` value applies to the "
"first plane and is divided by the same factor as the ``width`` field for the "
"other planes. For example the Cb and Cr planes of a YUV 4:2:0 image have "
"half as many padding bytes following each line as the Y plane. To avoid "
"ambiguities drivers must return a ``bytesperline`` value rounded up to a "
"multiple of the scale factor."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:178
msgid "``sizeimage``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:179
msgid ""
"This field is irrelevant to *non-destructive Video Overlays*. For *Video "
"Output Overlays* the driver must return a valid format."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:183
msgid ""
"Together with ``base`` it defines the framebuffer memory accessible by the "
"driver."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:186
msgid "enum :c:type:`v4l2_colorspace`"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:187
msgid "``colorspace``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:188
msgid ""
"This information supplements the ``pixelformat`` and must be set by the "
"driver, see :ref:`colorspaces`."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:192
msgid "``priv``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:193
msgid "Reserved. Drivers and applications must set this field to zero."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:199
msgid "Frame Buffer Capability Flags"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:204
msgid "``V4L2_FBUF_CAP_EXTERNOVERLAY``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:205
#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:257
msgid "0x0001"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:206
msgid ""
"The device is capable of non-destructive overlays. When the driver clears "
"this flag, only destructive overlays are supported. There are no drivers yet "
"which support both destructive and non-destructive overlays. Video Output "
"Overlays are in practice always non-destructive."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:211
msgid "``V4L2_FBUF_CAP_CHROMAKEY``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:212
#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:263
msgid "0x0002"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:213
msgid ""
"The device supports clipping by chroma-keying the images. That is, image "
"pixels replace pixels in the VGA or video signal only where the latter "
"assume a certain color. Chroma-keying makes no sense for destructive "
"overlays."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:217
msgid "``V4L2_FBUF_CAP_LIST_CLIPPING``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:218
#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:278
msgid "0x0004"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:219
msgid ""
"The device supports clipping using a list of clip rectangles. Note that this "
"is no longer supported."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:221
msgid "``V4L2_FBUF_CAP_BITMAP_CLIPPING``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:222
#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:288
msgid "0x0008"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:223
msgid ""
"The device supports clipping using a bit mask. Note that this is no longer "
"supported."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:225
msgid "``V4L2_FBUF_CAP_LOCAL_ALPHA``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:226
#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:294
msgid "0x0010"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:227
msgid ""
"The device supports clipping/blending using the alpha channel of the "
"framebuffer or VGA signal. Alpha blending makes no sense for destructive "
"overlays."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:230
msgid "``V4L2_FBUF_CAP_GLOBAL_ALPHA``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:231
#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:303
msgid "0x0020"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:232
msgid ""
"The device supports alpha blending using a global alpha value. Alpha "
"blending makes no sense for destructive overlays."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:234
msgid "``V4L2_FBUF_CAP_LOCAL_INV_ALPHA``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:235
#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:310
msgid "0x0040"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:236
msgid ""
"The device supports clipping/blending using the inverted alpha channel of "
"the framebuffer or VGA signal. Alpha blending makes no sense for destructive "
"overlays."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:239
msgid "``V4L2_FBUF_CAP_SRC_CHROMAKEY``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:240
msgid "0x0080"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:241
msgid ""
"The device supports Source Chroma-keying. Video pixels with the chroma-key "
"colors are replaced by framebuffer pixels, which is exactly opposite of "
"``V4L2_FBUF_CAP_CHROMAKEY``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:251
msgid "Frame Buffer Flags"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:256
msgid "``V4L2_FBUF_FLAG_PRIMARY``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:258
msgid ""
"The framebuffer is the primary graphics surface. In other words, the overlay "
"is destructive. This flag is typically set by any driver that doesn't have "
"the ``V4L2_FBUF_CAP_EXTERNOVERLAY`` capability and it is cleared otherwise."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:262
msgid "``V4L2_FBUF_FLAG_OVERLAY``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:264
msgid ""
"If this flag is set for a video capture device, then the driver will set the "
"initial overlay size to cover the full framebuffer size, otherwise the "
"existing overlay size (as set by :ref:`VIDIOC_S_FMT <VIDIOC_G_FMT>`) will be "
"used. Only one video capture driver (bttv) supports this flag. The use of "
"this flag for capture devices is deprecated. There is no way to detect which "
"drivers support this flag, so the only reliable method of setting the "
"overlay size is through :ref:`VIDIOC_S_FMT <VIDIOC_G_FMT>`. If this flag is "
"set for a video output device, then the video output overlay window is "
"relative to the top-left corner of the framebuffer and restricted to the "
"size of the framebuffer. If it is cleared, then the video output overlay "
"window is relative to the video output display."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:277
msgid "``V4L2_FBUF_FLAG_CHROMAKEY``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:279
msgid ""
"Use chroma-keying. The chroma-key color is determined by the ``chromakey`` "
"field of struct :c:type:`v4l2_window` and negotiated with the :ref:"
"`VIDIOC_S_FMT <VIDIOC_G_FMT>` ioctl, see :ref:`overlay` and :ref:`osd`."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:283
msgid ""
":cspan:`2` There are no flags to enable clipping using a list of clip "
"rectangles or a bitmap. These methods are negotiated with the :ref:"
"`VIDIOC_S_FMT <VIDIOC_G_FMT>` ioctl, see :ref:`overlay` and :ref:`osd`."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:287
msgid "``V4L2_FBUF_FLAG_LOCAL_ALPHA``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:289
msgid ""
"Use the alpha channel of the framebuffer to clip or blend framebuffer pixels "
"with video images. The blend function is: output = framebuffer pixel * alpha "
"+ video pixel * (1 - alpha). The actual alpha depth depends on the "
"framebuffer pixel format."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:293
msgid "``V4L2_FBUF_FLAG_GLOBAL_ALPHA``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:295
msgid ""
"Use a global alpha value to blend the framebuffer with video images. The "
"blend function is: output = (framebuffer pixel * alpha + video pixel * (255 "
"- alpha)) / 255. The alpha value is determined by the ``global_alpha`` field "
"of struct :c:type:`v4l2_window` and negotiated with the :ref:`VIDIOC_S_FMT "
"<VIDIOC_G_FMT>` ioctl, see :ref:`overlay` and :ref:`osd`."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:302
msgid "``V4L2_FBUF_FLAG_LOCAL_INV_ALPHA``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:304
msgid ""
"Like ``V4L2_FBUF_FLAG_LOCAL_ALPHA``, use the alpha channel of the "
"framebuffer to clip or blend framebuffer pixels with video images, but with "
"an inverted alpha value. The blend function is: output = framebuffer pixel * "
"(1 - alpha) + video pixel * alpha. The actual alpha depth depends on the "
"framebuffer pixel format."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:309
msgid "``V4L2_FBUF_FLAG_SRC_CHROMAKEY``"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:311
msgid ""
"Use source chroma-keying. The source chroma-key color is determined by the "
"``chromakey`` field of struct :c:type:`v4l2_window` and negotiated with the :"
"ref:`VIDIOC_S_FMT <VIDIOC_G_FMT>` ioctl, see :ref:`overlay` and :ref:`osd`. "
"Both chroma-keying are mutual exclusive to each other, so same ``chromakey`` "
"field of struct :c:type:`v4l2_window` is being used."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:320
msgid "Return Value"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:322
msgid ""
"On success 0 is returned, on error -1 and the ``errno`` variable is set "
"appropriately. The generic error codes are described at the :ref:`Generic "
"Error Codes <gen-errors>` chapter."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:326
msgid "EPERM"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:327
msgid ""
":ref:`VIDIOC_S_FBUF <VIDIOC_G_FBUF>` can only be called by a privileged user "
"to negotiate the parameters for a destructive overlay."
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:330
msgid "EINVAL"
msgstr ""

#: ../../../userspace-api/media/v4l/vidioc-g-fbuf.rst:331
msgid "The :ref:`VIDIOC_S_FBUF <VIDIOC_G_FBUF>` parameters are unsuitable."
msgstr ""
