# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/bcachefs/future/idle_work.rst:1
msgid "Idle/background work classes design doc:"
msgstr ""

#: ../../../filesystems/bcachefs/future/idle_work.rst:3
msgid ""
"Right now, our behaviour at idle isn't ideal, it was designed for servers "
"that would be under sustained load, to keep pending work at a \"medium\" "
"level, to let work build up so we can process it in more efficient batches, "
"while also giving headroom for bursts in load."
msgstr ""

#: ../../../filesystems/bcachefs/future/idle_work.rst:8
msgid ""
"But for desktops or mobile - scenarios where work is less sustained and "
"power usage is more important - we want to operate differently, with a "
"\"rush to idle\" so the system can go to sleep. We don't want to be "
"dribbling out background work while the system should be idle."
msgstr ""

#: ../../../filesystems/bcachefs/future/idle_work.rst:13
msgid ""
"The complicating factor is that there are a number of background tasks, "
"which form a heirarchy (or a digraph, depending on how you divide it up) - "
"one background task may generate work for another."
msgstr ""

#: ../../../filesystems/bcachefs/future/idle_work.rst:17
msgid "Thus proper idle detection needs to model this heirarchy."
msgstr ""

#: ../../../filesystems/bcachefs/future/idle_work.rst:19
msgid "Foreground writes"
msgstr ""

#: ../../../filesystems/bcachefs/future/idle_work.rst:20
msgid "Page cache writeback"
msgstr ""

#: ../../../filesystems/bcachefs/future/idle_work.rst:21
msgid "Copygc, rebalance"
msgstr ""

#: ../../../filesystems/bcachefs/future/idle_work.rst:22
msgid "Journal reclaim"
msgstr ""

#: ../../../filesystems/bcachefs/future/idle_work.rst:24
msgid ""
"When we implement idle detection and rush to idle, we need to be careful not "
"to disturb too much the existing behaviour that works reasonably well when "
"the system is under sustained load (or perhaps improve it in the case of "
"rebalance, which currently does not actively attempt to let work batch up)."
msgstr ""

#: ../../../filesystems/bcachefs/future/idle_work.rst:30
msgid "SUSTAINED LOAD REGIME"
msgstr ""

#: ../../../filesystems/bcachefs/future/idle_work.rst:32
msgid ""
"When the system is under continuous load, we want these jobs to run "
"continuously - this is perhaps best modelled with a P/D controller, where "
"they'll be trying to keep a target value (i.e. fragmented disk space, "
"available journal space) roughly in the middle of some range."
msgstr ""

#: ../../../filesystems/bcachefs/future/idle_work.rst:37
msgid ""
"The goal under sustained load is to balance our ability to handle load "
"spikes without running out of x resource (free disk space, free space in the "
"journal), while also letting some work accumululate to be batched (or become "
"unnecessary)."
msgstr ""

#: ../../../filesystems/bcachefs/future/idle_work.rst:42
msgid ""
"For example, we don't want to run copygc too aggressively, because then it "
"will be evacuating buckets that would have become empty (been overwritten or "
"deleted) anyways, and we don't want to wait until we're almost out of free "
"space because then the system will behave unpredicably - suddenly we're "
"doing a lot more work to service each write and the system becomes much "
"slower."
msgstr ""

#: ../../../filesystems/bcachefs/future/idle_work.rst:49
msgid "IDLE REGIME"
msgstr ""

#: ../../../filesystems/bcachefs/future/idle_work.rst:51
msgid ""
"When the system becomes idle, we should start flushing our pending work "
"quicker so the system can go to sleep."
msgstr ""

#: ../../../filesystems/bcachefs/future/idle_work.rst:54
msgid ""
"Note that the definition of \"idle\" depends on where in the heirarchy a "
"task is - a task should start flushing work more quickly when the task above "
"it has stopped generating new work."
msgstr ""

#: ../../../filesystems/bcachefs/future/idle_work.rst:58
msgid ""
"e.g. rebalance should start flushing more quickly when page cache writeback "
"is idle, and journal reclaim should only start flushing more quickly when "
"both copygc and rebalance are idle."
msgstr ""

#: ../../../filesystems/bcachefs/future/idle_work.rst:62
msgid ""
"It's important to let work accumulate when more work is still incoming and "
"we still have room, because flushing is always more efficient if we let it "
"batch up. New writes may overwrite data before rebalance moves it, and tasks "
"may be generating more updates for the btree nodes that journal reclaim "
"needs to flush."
msgstr ""

#: ../../../filesystems/bcachefs/future/idle_work.rst:67
msgid ""
"On idle, how much work we do at each interval should be proportional to the "
"length of time we have been idle for. If we're idle only for a short "
"duration, we shouldn't flush everything right away; the system might wake up "
"and start generating new work soon, and flushing immediately might end up "
"doing a lot of work that would have been unnecessary if we'd allowed things "
"to batch more."
msgstr ""

#: ../../../filesystems/bcachefs/future/idle_work.rst:73
msgid "To summarize, we will need:"
msgstr ""

#: ../../../filesystems/bcachefs/future/idle_work.rst:75
msgid ""
"A list of classes for background tasks that generate work, which will "
"include one \"foreground\" class."
msgstr ""

#: ../../../filesystems/bcachefs/future/idle_work.rst:77
msgid "Tracking for each class - \"Am I doing work, or have I gone to sleep?\""
msgstr ""

#: ../../../filesystems/bcachefs/future/idle_work.rst:78
msgid ""
"And each class should check the class above it when deciding how much work "
"to issue."
msgstr ""
