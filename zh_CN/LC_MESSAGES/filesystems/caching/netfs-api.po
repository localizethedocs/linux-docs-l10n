# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-06 06:05+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../filesystems/caching/netfs-api.rst:5
msgid "Network Filesystem Caching API"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:7
msgid ""
"Fscache provides an API by which a network filesystem can make use of local "
"caching facilities.  The API is arranged around a number of principles:"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:10
msgid ""
"A cache is logically organised into volumes and data storage objects within "
"those volumes."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:13
msgid ""
"Volumes and data storage objects are represented by various types of cookie."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:16
msgid "Cookies have keys that distinguish them from their peers."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:18
msgid ""
"Cookies have coherency data that allows a cache to determine if the cached "
"data is still valid."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:21
msgid "I/O is done asynchronously where possible."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:23
msgid "This API is used by::"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:43
msgid "Overview"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:45
msgid ""
"The fscache hierarchy is organised on two levels from a network filesystem's "
"point of view.  The upper level represents \"volumes\" and the lower level "
"represents \"data storage objects\".  These are represented by two types of "
"cookie, hereafter referred to as \"volume cookies\" and \"cookies\"."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:50
msgid ""
"A network filesystem acquires a volume cookie for a volume using a volume "
"key, which represents all the information that defines that volume (e.g. "
"cell name or server address, volume ID or share name).  This must be "
"rendered as a printable string that can be used as a directory name (ie. no "
"'/' characters and shouldn't begin with a '.').  The maximum name length is "
"one less than the maximum size of a filename component (allowing the cache "
"backend one char for its own purposes)."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:58
msgid "A filesystem would typically have a volume cookie for each superblock."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:60
msgid ""
"The filesystem then acquires a cookie for each file within that volume using "
"an object key.  Object keys are binary blobs and only need to be unique "
"within their parent volume.  The cache backend is responsible for rendering "
"the binary blob into something it can use and may employ hash tables, trees "
"or whatever to improve its ability to find an object.  This is transparent "
"to the network filesystem."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:67
msgid ""
"A filesystem would typically have a cookie for each inode, and would acquire "
"it in iget and relinquish it when evicting the cookie."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:70
msgid ""
"Once it has a cookie, the filesystem needs to mark the cookie as being in "
"use. This causes fscache to send the cache backend off to look up/create "
"resources for the cookie in the background, to check its coherency and, if "
"necessary, to mark the object as being under modification."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:75
msgid ""
"A filesystem would typically \"use\" the cookie in its file open routine and "
"unuse it in file release and it needs to use the cookie around calls to "
"truncate the cookie locally.  It *also* needs to use the cookie when the "
"pagecache becomes dirty and unuse it when writeback is complete.  This is "
"slightly tricky, and provision is made for it."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:81
msgid ""
"When performing a read, write or resize on a cookie, the filesystem must "
"first begin an operation.  This copies the resources into a holding struct "
"and puts extra pins into the cache to stop cache withdrawal from tearing "
"down the structures being used.  The actual operation can then be issued and "
"conflicting invalidations can be detected upon completion."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:87
msgid ""
"The filesystem is expected to use netfslib to access the cache, but that's "
"not actually required and it can use the fscache I/O API directly."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:92
msgid "Volume Registration"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:94
msgid ""
"The first step for a network filesystem is to acquire a volume cookie for "
"the volume it wants to access::"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:103
msgid ""
"This function creates a volume cookie with the specified volume key as its "
"name and notes the coherency data."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:106
msgid ""
"The volume key must be a printable string with no '/' characters in it.  It "
"should begin with the name of the filesystem and should be no longer than "
"254 characters.  It should uniquely represent the volume and will be matched "
"with what's stored in the cache."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:111
msgid ""
"The caller may also specify the name of the cache to use.  If specified, "
"fscache will look up or create a cache cookie of that name and will use a "
"cache of that name if it is online or comes online.  If no cache name is "
"specified, it will use the first cache that comes to hand and set the name "
"to that."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:116
msgid ""
"The specified coherency data is stored in the cookie and will be matched "
"against coherency data stored on disk.  The data pointer may be NULL if no "
"data is provided.  If the coherency data doesn't match, the entire cache "
"volume will be invalidated."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:121
msgid ""
"This function can return errors such as EBUSY if the volume key is already "
"in use by an acquired volume or ENOMEM if an allocation failure occurred.  "
"It may also return a NULL volume cookie if fscache is not enabled.  It is "
"safe to pass a NULL cookie to any function that takes a volume cookie.  This "
"will cause that function to do nothing."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:128
msgid ""
"When the network filesystem has finished with a volume, it should relinquish "
"it by calling::"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:135
msgid ""
"This will cause the volume to be committed or removed, and if sealed the "
"coherency data will be set to the value supplied.  The amount of coherency "
"data must match the length specified when the volume was acquired.  Note "
"that all data cookies obtained in this volume must be relinquished before "
"the volume is relinquished."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:143
msgid "Data File Registration"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:145
msgid ""
"Once it has a volume cookie, a network filesystem can use it to acquire a "
"cookie for data storage::"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:157
msgid ""
"This creates the cookie in the volume using the specified index key.  The "
"index key is a binary blob of the given length and must be unique for the "
"volume. This is saved into the cookie.  There are no restrictions on the "
"content, but its length shouldn't exceed about three quarters of the maximum "
"filename length to allow for encoding."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:163
msgid ""
"The caller should also pass in a piece of coherency data in aux_data.  A "
"buffer of size aux_data_len will be allocated and the coherency data copied "
"in.  It is assumed that the size is invariant over time.  The coherency data "
"is used to check the validity of data in the cache.  Functions are provided "
"by which the coherency data can be updated."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:169
msgid ""
"The file size of the object being cached should also be provided.  This may "
"be used to trim the data and will be stored with the coherency data."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:172
msgid ""
"This function never returns an error, though it may return a NULL cookie on "
"allocation failure or if fscache is not enabled.  It is safe to pass in a "
"NULL volume cookie and pass the NULL cookie returned to any function that "
"takes it. This will cause that function to do nothing."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:178
msgid ""
"When the network filesystem has finished with a cookie, it should relinquish "
"it by calling::"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:184
msgid ""
"This will cause fscache to either commit the storage backing the cookie or "
"delete it."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:189
msgid "Marking A Cookie In-Use"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:191
msgid ""
"Once a cookie has been acquired by a network filesystem, the filesystem "
"should tell fscache when it intends to use the cookie (typically done on "
"file open) and should say when it has finished with it (typically on file "
"close)::"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:201
msgid ""
"The *use* function tells fscache that it will use the cookie and, "
"additionally, indicate if the user is intending to modify the contents "
"locally.  If not yet done, this will trigger the cache backend to go and "
"gather the resources it needs to access/store data in the cache.  This is "
"done in the background, and so may not be complete by the time the function "
"returns."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:207
msgid ""
"The *unuse* function indicates that a filesystem has finished using a "
"cookie. It optionally updates the stored coherency data and object size and "
"then decreases the in-use counter.  When the last user unuses the cookie, it "
"is scheduled for garbage collection.  If not reused within a short time, the "
"resources will be released to reduce system resource consumption."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:213
msgid ""
"A cookie must be marked in-use before it can be accessed for read, write or "
"resize - and an in-use mark must be kept whilst there is dirty data in the "
"pagecache in order to avoid an oops due to trying to open a file during "
"process exit."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:218
msgid ""
"Note that in-use marks are cumulative.  For each time a cookie is marked in-"
"use, it must be unused."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:223
msgid "Resizing A Data File (Truncation)"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:225
msgid ""
"If a network filesystem file is resized locally by truncation, the following "
"should be called to notify the cache::"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:231
msgid ""
"The caller must have first marked the cookie in-use.  The cookie and the new "
"size are passed in and the cache is synchronously resized.  This is expected "
"to be called from ``->setattr()`` inode operation under the inode lock."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:237
msgid "Data I/O API"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:239
msgid ""
"To do data I/O operations directly through a cookie, the following functions "
"are available::"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:256
msgid ""
"The *begin* function sets up an operation, attaching the resources required "
"to the cache resources block from the cookie.  Assuming it doesn't return an "
"error (for instance, it will return -ENOBUFS if given a NULL cookie, but "
"otherwise do nothing), then one of the other two functions can be issued."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:261
msgid ""
"The *read* and *write* functions initiate a direct-IO operation.  Both take "
"the previously set up cache resources block, an indication of the start file "
"position, and an I/O iterator that describes buffer and indicates the amount "
"of data."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:266
msgid ""
"The read function also takes a parameter to indicate how it should handle a "
"partially populated region (a hole) in the disk content.  This may be to "
"ignore it, skip over an initial hole and place zeros in the buffer or give "
"an error."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:270
msgid ""
"The read and write functions can be given an optional termination function "
"that will be run on completion::"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:277
msgid ""
"If a termination function is given, the operation will be run asynchronously "
"and the termination function will be called upon completion.  If not given, "
"the operation will be run synchronously.  Note that in the asynchronous "
"case, it is possible for the operation to complete before the function "
"returns."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:282
msgid ""
"Both the read and write functions end the operation when they complete, "
"detaching any pinned resources."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:285
msgid ""
"The read operation will fail with ESTALE if invalidation occurred whilst the "
"operation was ongoing."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:290
msgid "Data File Coherency"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:292
msgid ""
"To request an update of the coherency data and file size on a cookie, the "
"following should be called::"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:299
msgid "This will update the cookie's coherency data and/or file size."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:303
msgid "Data File Invalidation"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:305
msgid ""
"Sometimes it will be necessary to invalidate an object that contains data. "
"Typically this will be necessary when the server informs the network "
"filesystem of a remote third-party change - at which point the filesystem "
"has to throw away the state and cached data that it had for an file and "
"reload from the server."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:311
msgid ""
"To indicate that a cache object should be invalidated, the following should "
"be called::"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:319
msgid ""
"This increases the invalidation counter in the cookie to cause outstanding "
"reads to fail with -ESTALE, sets the coherency data and file size from the "
"information supplied, blocks new I/O on the cookie and dispatches the cache "
"to go and get rid of the old data."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:324
msgid ""
"Invalidation runs asynchronously in a worker thread so that it doesn't block "
"too much."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:329
msgid "Write-Back Resource Management"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:331
msgid ""
"To write data to the cache from network filesystem writeback, the cache "
"resources required need to be pinned at the point the modification is made "
"(for instance when the page is marked dirty) as it's not possible to open a "
"file in a thread that's exiting."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:336
msgid "The following facilities are provided to manage this:"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:338
msgid ""
"An inode flag, ``I_PINNING_FSCACHE_WB``, is provided to indicate that an in-"
"use is held on the cookie for this inode.  It can only be changed if the the "
"inode lock is held."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:342
msgid ""
"A flag, ``unpinned_fscache_wb`` is placed in the ``writeback_control`` "
"struct that gets set if ``__writeback_single_inode()`` clears "
"``I_PINNING_FSCACHE_WB`` because all the dirty pages were cleared."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:346
msgid "To support this, the following functions are provided::"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:357
msgid ""
"The *set* function is intended to be called from the filesystem's "
"``dirty_folio`` address space operation.  If ``I_PINNING_FSCACHE_WB`` is not "
"set, it sets that flag and increments the use count on the cookie (the "
"caller must already have called ``fscache_use_cookie()``)."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:362
msgid ""
"The *unpin* function is intended to be called from the filesystem's "
"``write_inode`` superblock operation.  It cleans up after writing by unusing "
"the cookie if unpinned_fscache_wb is set in the writeback_control struct."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:366
msgid ""
"The *clear* function is intended to be called from the netfs's "
"``evict_inode`` superblock operation.  It must be called *after* "
"``truncate_inode_pages_final()``, but *before* ``clear_inode()``.  This "
"cleans up any hanging ``I_PINNING_FSCACHE_WB``.  It also allows the "
"coherency data to be updated."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:374
msgid "Caching of Local Modifications"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:376
msgid ""
"If a network filesystem has locally modified data that it wants to write to "
"the cache, it needs to mark the pages to indicate that a write is in "
"progress, and if the mark is already present, it needs to wait for it to be "
"removed first (presumably due to an already in-progress operation).  This "
"prevents multiple competing DIO writes to the same storage in the cache."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:382
msgid ""
"Firstly, the netfs should determine if caching is available by doing "
"something like::"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:387
msgid ""
"If caching is to be attempted, pages should be waited for and then marked "
"using the following functions provided by the netfs helper library::"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:394
msgid ""
"Once all the pages in the span are marked, the netfs can ask fscache to "
"schedule a write of that region::"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:404
msgid ""
"And if an error occurs before that point is reached, the marks can be "
"removed by calling::"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:411
msgid ""
"In these functions, a pointer to the mapping to which the source pages are "
"attached is passed in and start and len indicate the size of the region "
"that's going to be written (it doesn't have to align to page boundaries "
"necessarily, but it does have to align to DIO boundaries on the backing "
"filesystem).  The caching parameter indicates if caching should be skipped, "
"and if false, the functions do nothing."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:418
msgid ""
"The write function takes some additional parameters: the cookie representing "
"the cache object to be written to, i_size indicates the size of the netfs "
"file and term_func indicates an optional completion function, to which "
"term_func_priv will be passed, along with the error or amount written."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:423
msgid ""
"Note that the write function will always run asynchronously and will unmark "
"all the pages upon completion before calling term_func."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:428
msgid "Page Release and Invalidation"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:430
msgid ""
"Fscache keeps track of whether we have any data in the cache yet for a cache "
"object we've just created.  It knows it doesn't have to do any reading until "
"it has done a write and then the page it wrote from has been released by the "
"VM, after which it *has* to look in the cache."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:435
msgid ""
"To inform fscache that a page might now be in the cache, the following "
"function should be called from the ``release_folio`` address space op::"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:440
msgid "if the page has been released (ie. release_folio returned true)."
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:442
msgid ""
"Page release and page invalidation should also wait for any mark left on the "
"page to say that a DIO write is underway from that page::"
msgstr ""

#: ../../../filesystems/caching/netfs-api.rst:450
msgid "API Function Reference"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:184
msgid "Register a volume as desiring caching services"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:188
#: ../include/linux/fscache.h:216 ../include/linux/fscache.h:235
#: ../include/linux/fscache.h:267 ../include/linux/fscache.h:283
#: ../include/linux/fscache.h:300 ../include/linux/fscache.h:361
#: ../include/linux/fscache.h:383 ../include/linux/fscache.h:400
#: ../include/linux/fscache.h:427 ../include/linux/fscache.h:439
#: ../include/linux/fscache.h:466 ../include/linux/fscache.h:480
#: ../include/linux/fscache.h:521 ../include/linux/fscache.h:548
#: ../include/linux/fscache.h:578 ../include/linux/fscache.h:596
#: ../include/linux/fscache.h:637
msgid "**Parameters**"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:190
msgid "``const char *volume_key``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:185
msgid "An identification string for the volume"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:187
msgid "``const char *cache_name``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:186
msgid "The name of the cache to use (or NULL for the default)"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:188
#: ../include/linux/fscache.h:215
msgid "``const void *coherency_data``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:187
msgid "Piece of arbitrary coherency data to check (or NULL)"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:189
msgid "``size_t coherency_len``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:188
msgid "The size of the coherency data"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:190
#: ../include/linux/fscache.h:217 ../include/linux/fscache.h:240
#: ../include/linux/fscache.h:267 ../include/linux/fscache.h:284
#: ../include/linux/fscache.h:301 ../include/linux/fscache.h:362
#: ../include/linux/fscache.h:383 ../include/linux/fscache.h:402
#: ../include/linux/fscache.h:426 ../include/linux/fscache.h:439
#: ../include/linux/fscache.h:465 ../include/linux/fscache.h:484
#: ../include/linux/fscache.h:521 ../include/linux/fscache.h:551
#: ../include/linux/fscache.h:580 ../include/linux/fscache.h:603
#: ../include/linux/fscache.h:636
msgid "**Description**"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:189
msgid ""
"Register a volume as desiring caching services if they're available.  The "
"caller must provide an identifier for the volume and may also indicate which "
"cache it should be in.  If a preexisting volume entry is found in the cache, "
"the coherency data must match otherwise the entry will be invalidated."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:194
msgid ""
"Returns a cookie pointer on success, -ENOMEM if out of memory or -EBUSY if a "
"cache volume of that name is already acquired.  Note that \"NULL\" is a "
"valid cookie pointer and can be returned if caching is refused."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:212
msgid "Cease caching a volume"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:218
#: ../include/linux/fscache.h:237
msgid "``struct fscache_volume *volume``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:213
msgid "The volume cookie"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:214
msgid "Piece of arbitrary coherency data to set (or NULL)"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:216
msgid "``bool invalidate``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:215
msgid "True if the volume should be invalidated"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:216
msgid ""
"Indicate that a filesystem no longer desires caching services for a volume. "
"The caller must have relinquished all file cookies prior to calling this. "
"The stored coherency data is updated."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:231
msgid "Acquire a cookie to represent a cache object"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:232
msgid "The volume in which to locate/create this cookie"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:234
msgid "``u8 advice``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:233
msgid "Advice flags (FSCACHE_COOKIE_ADV_*)"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:235
msgid "``const void *index_key``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:234
msgid "The index key for this cookie"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:236
msgid "``size_t index_key_len``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:235
msgid "Size of the index key"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:237
#: ../include/linux/fscache.h:282 ../include/linux/fscache.h:360
#: ../include/linux/fscache.h:399
msgid "``const void *aux_data``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:236
msgid "The auxiliary data for the cookie (may be NULL)"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:238
msgid "``size_t aux_data_len``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:237
msgid "Size of the auxiliary data buffer"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:239
msgid "``loff_t object_size``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:238
msgid "The initial size of object"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:239
msgid ""
"Acquire a cookie to represent a data file within the given cache volume."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:241
#: ../include/linux/fscache.h:303 ../include/linux/fscache.h:366
#: ../include/linux/fscache.h:384 ../include/linux/fscache.h:410
msgid ""
"See Documentation/filesystems/caching/netfs-api.rst for a complete "
"description."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:263
msgid "Request usage of cookie attached to an object"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:269
#: ../include/linux/fscache.h:285 ../include/linux/fscache.h:302
#: ../include/linux/fscache.h:363 ../include/linux/fscache.h:385
#: ../include/linux/fscache.h:402 ../include/linux/fscache.h:438
#: ../include/linux/fscache.h:520 ../include/linux/fscache.h:598
#: ../include/linux/fscache.h:639
msgid "``struct fscache_cookie *cookie``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:264
#: ../include/linux/fscache.h:280 ../include/linux/fscache.h:358
#: ../include/linux/fscache.h:380 ../include/linux/fscache.h:397
#: ../include/linux/fscache.h:437 ../include/linux/fscache.h:519
#: ../include/linux/fscache.h:593
msgid "The cookie representing the cache object"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:266
msgid "``bool will_modify``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:265
msgid "If cache is expected to be modified locally"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:266
msgid ""
"Request usage of the cookie attached to an object.  The caller should tell "
"the cache if the object's contents are about to be modified locally and then "
"the cache can apply the policy that has been set to handle this case."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:279
msgid "Cease usage of cookie attached to an object"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:281
msgid "Updated auxiliary data (or NULL)"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:283
#: ../include/linux/fscache.h:361
msgid "``const loff_t *object_size``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:282
msgid "Revised size of the object (or NULL)"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:283
msgid ""
"Cease usage of the cookie attached to an object.  When the users count "
"reaches zero then the cookie relinquishment will be permitted to proceed."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:296
msgid "Return the cookie to the cache, maybe discarding it"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:298
msgid "The cookie being returned"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:300
msgid "``bool retire``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:299
msgid "True if the cache object the cookie represents is to be discarded"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:300
msgid ""
"This function returns a cookie to the cache, forcibly discarding the "
"associated cache object if retire is set to true."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:357
msgid "Request that a cache object be updated"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:359
#: ../include/linux/fscache.h:398
msgid "The updated auxiliary data for the cookie (may be NULL)"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:360
msgid "The current size of the object (may be NULL)"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:361
msgid ""
"Request an update of the index data for the cache object associated with the "
"cookie.  The auxiliary data on the cookie will be updated first if "
"**aux_data** is set and the object size will be updated and the object "
"possibly trimmed if **object_size** is set."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:379
msgid "Request that a cache object be resized"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:382
msgid "``loff_t new_size``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:381
msgid "The new size of the object (may be NULL)"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:382
msgid "Request that the size of an object be changed."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:396
msgid "Notify cache that an object needs invalidation"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:400
msgid "``loff_t size``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:399
msgid "The revised size of the object."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:401
msgid "``unsigned int flags``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:400
msgid "Invalidation flags (FSCACHE_INVAL_*)"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:401
msgid ""
"Notify the cache that an object is needs to be invalidated and that it "
"should abort any retrievals or stores it is doing on the cache.  This "
"increments inval_counter on the cookie which can be used by the caller to "
"reconsider I/O requests as they complete."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:406
msgid ""
"If **flags** has FSCACHE_INVAL_DIO_WRITE set, this indicates that this is "
"due to a direct I/O write and will cause caching to be disabled on this "
"cookie until it is completely unused."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:423
msgid "Return true if operations resources are usable"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:429
msgid "``const struct netfs_cache_resources *cres``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:424
msgid "The resources to check."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:425
msgid "Returns a pointer to the operations table if usable or NULL if not."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:435
msgid "Begin a read operation for the netfs lib"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:441
#: ../include/linux/fscache.h:468 ../include/linux/fscache.h:482
#: ../include/linux/fscache.h:523 ../include/linux/fscache.h:550
msgid "``struct netfs_cache_resources *cres``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:436
msgid "The cache resources for the read being performed"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:438
msgid ""
"Begin a read operation on behalf of the netfs helper library.  **cres** "
"indicates the cache resources to which the operation state should be "
"attached; **cookie** indicates the cache object that will be accessed."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:442
#: ../include/linux/fscache.h:524
msgid ""
"**cres->inval_counter** is set from **cookie->inval_counter** for comparison "
"at the end of the operation.  This allows invalidation during the operation "
"to be detected by the caller."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:446
#: ../include/linux/fscache.h:528
msgid "**Return**"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:447
#: ../include/linux/fscache.h:529
msgid "0          - Success"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:448
#: ../include/linux/fscache.h:530
msgid "No caching available"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:449
#: ../include/linux/fscache.h:531
msgid "Other error code from the cache, such as -ENOMEM."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:462
msgid "End the read operation for the netfs lib"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:463
msgid "The cache resources for the read operation"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:464
msgid "Clean up the resources at the end of the read request."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:476
msgid "Start a read from the cache."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:477
#: ../include/linux/fscache.h:545
msgid "The cache resources to use"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:479
#: ../include/linux/fscache.h:547
msgid "``loff_t start_pos``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:478
#: ../include/linux/fscache.h:546
msgid "The beginning file offset in the cache file"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:480
#: ../include/linux/fscache.h:548
msgid "``struct iov_iter *iter``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:479
msgid "The buffer to fill - and also the length"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:481
msgid "``enum netfs_read_from_hole read_hole``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:480
msgid "How to handle a hole in the data."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:482
#: ../include/linux/fscache.h:549 ../include/linux/fscache.h:599
msgid "``netfs_io_terminated_t term_func``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:481
#: ../include/linux/fscache.h:548 ../include/linux/fscache.h:598
msgid "The function to call upon completion"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:483
#: ../include/linux/fscache.h:550 ../include/linux/fscache.h:600
msgid "``void *term_func_priv``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:482
#: ../include/linux/fscache.h:549 ../include/linux/fscache.h:599
msgid "The private data for **term_func**"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:483
msgid ""
"Start a read from the cache.  **cres** indicates the cache object to read "
"from and must be obtained by a call to fscache_begin_operation() beforehand."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:486
msgid ""
"The data is read into the iterator, **iter**, and that also indicates the "
"size of the operation.  **start_pos** is the start position in the file, "
"though if **seek_data** is set appropriately, the cache can use SEEK_DATA to "
"find the next piece of data, writing zeros for the hole into the iterator."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:491
#: ../include/linux/fscache.h:557
msgid ""
"Upon termination of the operation, **term_func** will be called and supplied "
"with **term_func_priv** plus the amount of data written, if successful, or "
"the error code otherwise."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:495
msgid ""
"**read_hole** indicates how a partially populated region in the cache should "
"be handled.  It can be one of a number of settings:"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:498
msgid "NETFS_READ_HOLE_IGNORE - Just try to read (may return a short read)."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:500
msgid "NETFS_READ_HOLE_FAIL - Give ENODATA if we encounter a hole."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:517
msgid "Begin a write operation for the netfs lib"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:518
msgid "The cache resources for the write being performed"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:520
msgid ""
"Begin a write operation on behalf of the netfs helper library.  **cres** "
"indicates the cache resources to which the operation state should be "
"attached; **cookie** indicates the cache object that will be accessed."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:544
msgid "Start a write to the cache."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:547
msgid "The data to write - and also the length"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:550
msgid ""
"Start a write to the cache.  **cres** indicates the cache object to write to "
"and must be obtained by a call to fscache_begin_operation() beforehand."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:553
msgid ""
"The data to be written is obtained from the iterator, **iter**, and that "
"also indicates the size of the operation.  **start_pos** is the start "
"position in the file."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:574
msgid "Clear the PG_fscache bits from a set of pages"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:580
#: ../include/linux/fscache.h:595
msgid "``struct address_space *mapping``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:575
#: ../include/linux/fscache.h:594
msgid "The netfs inode to use as the source"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:577
#: ../include/linux/fscache.h:596
msgid "``loff_t start``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:576
#: ../include/linux/fscache.h:595
msgid "The start position in **mapping**"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:578
#: ../include/linux/fscache.h:597
msgid "``size_t len``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:577
msgid "The amount of data to unlock"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:579
#: ../include/linux/fscache.h:602
msgid "``bool caching``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:578
msgid "If PG_fscache has been set"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:579
msgid ""
"Clear the PG_fscache flag from a sequence of pages and wake up anyone who's "
"waiting."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:592
msgid "Save a write to the cache and clear PG_fscache"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:596
msgid "The amount of data to write back"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:598
msgid "``loff_t i_size``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:597
msgid "The new size of the inode"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:601
msgid "``bool using_pgpriv2``"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:600
msgid "If we're using PG_private_2 to mark in-progress write"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:601
msgid "If we actually want to do the caching"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:602
msgid ""
"Helper function for a netfs to write dirty data from an inode into the cache "
"object that's backing it."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:605
msgid ""
"**start** and **len** describe the range of the data.  This does not need to "
"be page-aligned, but to satisfy DIO requirements, the cache may expand it up "
"to the page boundaries on either end.  All the pages covering the range must "
"be marked with PG_fscache."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:610
msgid ""
"If given, **term_func** will be called upon completion and supplied with "
"**term_func_priv**.  Note that if **using_pgpriv2** is set, the PG_private_2 "
"flags will have been cleared by this point, so the netfs must retain its own "
"pin on the mapping."
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:633
msgid "Note that a netfs page got released"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:634
msgid "The cookie corresponding to the file"
msgstr ""

#: ../../../filesystems/caching/netfs-api:452: ../include/linux/fscache.h:635
msgid ""
"Note that a page that has been copied to the cache has been released.  This "
"means that future reads will need to look in the cache to see if it's there."
msgstr ""
