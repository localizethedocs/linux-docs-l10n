# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../mm/split_page_table_lock.rst:3
msgid "Split page table lock"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:5
msgid ""
"Originally, mm->page_table_lock spinlock protected all page tables of the "
"mm_struct. But this approach leads to poor page fault scalability of multi-"
"threaded applications due to high contention on the lock. To improve "
"scalability, split page table lock was introduced."
msgstr ""

#: ../../../mm/split_page_table_lock.rst:10
msgid ""
"With split page table lock we have separate per-table lock to serialize "
"access to the table. At the moment we use split lock for PTE and PMD tables. "
"Access to higher level tables protected by mm->page_table_lock."
msgstr ""

#: ../../../mm/split_page_table_lock.rst:14
msgid "There are helpers to lock/unlock a table and other accessor functions:"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:16
msgid "pte_offset_map_lock()"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:17
msgid ""
"maps PTE and takes PTE table lock, returns pointer to PTE with pointer to "
"its PTE table lock, or returns NULL if no PTE table;"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:19
msgid "pte_offset_map_ro_nolock()"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:20
msgid ""
"maps PTE, returns pointer to PTE with pointer to its PTE table lock (not "
"taken), or returns NULL if no PTE table;"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:22
msgid "pte_offset_map_rw_nolock()"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:23
msgid ""
"maps PTE, returns pointer to PTE with pointer to its PTE table lock (not "
"taken) and the value of its pmd entry, or returns NULL if no PTE table;"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:26
msgid "pte_offset_map()"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:27
msgid "maps PTE, returns pointer to PTE, or returns NULL if no PTE table;"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:28
msgid "pte_unmap()"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:29
msgid "unmaps PTE table;"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:30
msgid "pte_unmap_unlock()"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:31
msgid "unlocks and unmaps PTE table;"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:32
msgid "pte_alloc_map_lock()"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:33
msgid ""
"allocates PTE table if needed and takes its lock, returns pointer to PTE "
"with pointer to its lock, or returns NULL if allocation failed;"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:35
msgid "pmd_lock()"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:36
msgid "takes PMD table lock, returns pointer to taken lock;"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:37
msgid "pmd_lockptr()"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:38
msgid "returns pointer to PMD table lock;"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:40
msgid ""
"Split page table lock for PTE tables is enabled compile-time if "
"CONFIG_SPLIT_PTLOCK_CPUS (usually 4) is less or equal to NR_CPUS. If split "
"lock is disabled, all tables are guarded by mm->page_table_lock."
msgstr ""

#: ../../../mm/split_page_table_lock.rst:44
msgid ""
"Split page table lock for PMD tables is enabled, if it's enabled for PTE "
"tables and the architecture supports it (see below)."
msgstr ""

#: ../../../mm/split_page_table_lock.rst:48
msgid "Hugetlb and split page table lock"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:50
msgid ""
"Hugetlb can support several page sizes. We use split lock only for PMD "
"level, but not for PUD."
msgstr ""

#: ../../../mm/split_page_table_lock.rst:53
msgid "Hugetlb-specific helpers:"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:55
msgid "huge_pte_lock()"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:56
msgid "takes pmd split lock for PMD_SIZE page, mm->page_table_lock otherwise;"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:58
msgid "huge_pte_lockptr()"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:59
msgid "returns pointer to table lock;"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:62
msgid "Support of split page table lock by an architecture"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:64
msgid ""
"There's no need in special enabling of PTE split page table lock: everything "
"required is done by pagetable_pte_ctor() and pagetable_dtor(), which must be "
"called on PTE table allocation / freeing."
msgstr ""

#: ../../../mm/split_page_table_lock.rst:68
msgid ""
"Make sure the architecture doesn't use slab allocator for page table "
"allocation: slab uses page->slab_cache for its pages. This field shares "
"storage with page->ptl."
msgstr ""

#: ../../../mm/split_page_table_lock.rst:72
msgid ""
"PMD split lock only makes sense if you have more than two page table levels."
msgstr ""

#: ../../../mm/split_page_table_lock.rst:75
msgid ""
"PMD split lock enabling requires pagetable_pmd_ctor() call on PMD table "
"allocation and pagetable_dtor() on freeing."
msgstr ""

#: ../../../mm/split_page_table_lock.rst:78
msgid ""
"Allocation usually happens in pmd_alloc_one(), freeing in pmd_free() and "
"pmd_free_tlb(), but make sure you cover all PMD table allocation / freeing "
"paths: i.e X86_PAE preallocate few PMDs on pgd_alloc()."
msgstr ""

#: ../../../mm/split_page_table_lock.rst:82
msgid ""
"With everything in place you can set CONFIG_ARCH_ENABLE_SPLIT_PMD_PTLOCK."
msgstr ""

#: ../../../mm/split_page_table_lock.rst:84
msgid ""
"NOTE: pagetable_pte_ctor() and pagetable_pmd_ctor() can fail -- it must be "
"handled properly."
msgstr ""

#: ../../../mm/split_page_table_lock.rst:88
msgid "page->ptl"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:90
msgid ""
"page->ptl is used to access split page table lock, where 'page' is struct "
"page of page containing the table. It shares storage with page->private (and "
"few other fields in union)."
msgstr ""

#: ../../../mm/split_page_table_lock.rst:94
msgid ""
"To avoid increasing size of struct page and have best performance, we use a "
"trick:"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:97
msgid ""
"if spinlock_t fits into long, we use page->ptr as spinlock, so we can avoid "
"indirect access and save a cache line."
msgstr ""

#: ../../../mm/split_page_table_lock.rst:99
msgid ""
"if size of spinlock_t is bigger then size of long, we use page->ptl as "
"pointer to spinlock_t and allocate it dynamically. This allows to use split "
"lock with enabled DEBUG_SPINLOCK or DEBUG_LOCK_ALLOC, but costs one more "
"cache line for indirect access;"
msgstr ""

#: ../../../mm/split_page_table_lock.rst:104
msgid ""
"The spinlock_t allocated in pagetable_pte_ctor() for PTE table and in "
"pagetable_pmd_ctor() for PMD table."
msgstr ""

#: ../../../mm/split_page_table_lock.rst:107
msgid "Please, never access page->ptl directly -- use appropriate helper."
msgstr ""
