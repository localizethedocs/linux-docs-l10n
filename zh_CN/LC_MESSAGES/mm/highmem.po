# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-21 08:55+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../mm/highmem.rst:3
msgid "High Memory Handling"
msgstr ""

#: ../../../mm/highmem.rst:5
msgid "By: Peter Zijlstra <a.p.zijlstra@chello.nl>"
msgstr ""

#: ../../../mm/highmem.rst:10
msgid "What Is High Memory?"
msgstr ""

#: ../../../mm/highmem.rst:12
msgid ""
"High memory (highmem) is used when the size of physical memory approaches or "
"exceeds the maximum size of virtual memory.  At that point it becomes "
"impossible for the kernel to keep all of the available physical memory "
"mapped at all times.  This means the kernel needs to start using temporary "
"mappings of the pieces of physical memory that it wants to access."
msgstr ""

#: ../../../mm/highmem.rst:18
msgid ""
"The part of (physical) memory not covered by a permanent mapping is what we "
"refer to as 'highmem'.  There are various architecture dependent constraints "
"on where exactly that border lies."
msgstr ""

#: ../../../mm/highmem.rst:22
msgid ""
"In the i386 arch, for example, we choose to map the kernel into every "
"process's VM space so that we don't have to pay the full TLB invalidation "
"costs for kernel entry/exit.  This means the available virtual memory space "
"(4GiB on i386) has to be divided between user and kernel space."
msgstr ""

#: ../../../mm/highmem.rst:27
msgid ""
"The traditional split for architectures using this approach is 3:1, 3GiB for "
"userspace and the top 1GiB for kernel space::"
msgstr ""

#: ../../../mm/highmem.rst:38
msgid ""
"This means that the kernel can at most map 1GiB of physical memory at any "
"one time, but because we need virtual address space for other things - "
"including temporary maps to access the rest of the physical memory - the "
"actual direct map will typically be less (usually around ~896MiB)."
msgstr ""

#: ../../../mm/highmem.rst:43
msgid ""
"Other architectures that have mm context tagged TLBs can have separate "
"kernel and user maps.  Some hardware (like some ARMs), however, have limited "
"virtual space when they use mm context tags."
msgstr ""

#: ../../../mm/highmem.rst:49
msgid "Temporary Virtual Mappings"
msgstr ""

#: ../../../mm/highmem.rst:51
msgid ""
"The kernel contains several ways of creating temporary mappings. The "
"following list shows them in order of preference of use."
msgstr ""

#: ../../../mm/highmem.rst:54
msgid ""
"kmap_local_page(), kmap_local_folio() - These functions are used to create "
"short term mappings. They can be invoked from any context (including "
"interrupts) but the mappings can only be used in the context which acquired "
"them. The only differences between them consist in the first taking a "
"pointer to a struct page and the second taking a pointer to struct folio and "
"the byte offset within the folio which identifies the page."
msgstr ""

#: ../../../mm/highmem.rst:61
msgid ""
"These functions should always be used, whereas kmap_atomic() and kmap() have "
"been deprecated."
msgstr ""

#: ../../../mm/highmem.rst:64
msgid ""
"These mappings are thread-local and CPU-local, meaning that the mapping can "
"only be accessed from within this thread and the thread is bound to the CPU "
"while the mapping is active. Although preemption is never disabled by this "
"function, the CPU can not be unplugged from the system via CPU-hotplug until "
"the mapping is disposed."
msgstr ""

#: ../../../mm/highmem.rst:70
msgid ""
"It's valid to take pagefaults in a local kmap region, unless the context in "
"which the local mapping is acquired does not allow it for other reasons."
msgstr ""

#: ../../../mm/highmem.rst:73
msgid ""
"As said, pagefaults and preemption are never disabled. There is no need to "
"disable preemption because, when context switches to a different task, the "
"maps of the outgoing task are saved and those of the incoming one are "
"restored."
msgstr ""

#: ../../../mm/highmem.rst:78
msgid ""
"kmap_local_page(), as well as kmap_local_folio() always returns valid "
"virtual kernel addresses and it is assumed that kunmap_local() will never "
"fail."
msgstr ""

#: ../../../mm/highmem.rst:81
msgid ""
"On CONFIG_HIGHMEM=n kernels and for low memory pages they return the virtual "
"address of the direct mapping. Only real highmem pages are temporarily "
"mapped. Therefore, users may call a plain page_address() for pages which are "
"known to not come from ZONE_HIGHMEM. However, it is always safe to use "
"kmap_local_{page,folio}() / kunmap_local()."
msgstr ""

#: ../../../mm/highmem.rst:87
msgid ""
"While they are significantly faster than kmap(), for the highmem case they "
"come with restrictions about the pointers validity. Contrary to kmap() "
"mappings, the local mappings are only valid in the context of the caller and "
"cannot be handed to other contexts. This implies that users must be "
"absolutely sure to keep the use of the return address local to the thread "
"which mapped it."
msgstr ""

#: ../../../mm/highmem.rst:94
msgid ""
"Most code can be designed to use thread local mappings. User should "
"therefore try to design their code to avoid the use of kmap() by mapping "
"pages in the same thread the address will be used and prefer "
"kmap_local_page() or kmap_local_folio()."
msgstr ""

#: ../../../mm/highmem.rst:99
msgid ""
"Nesting kmap_local_page() and kmap_atomic() mappings is allowed to a certain "
"extent (up to KMAP_TYPE_NR) but their invocations have to be strictly "
"ordered because the map implementation is stack based. See kmap_local_page() "
"kdocs (included in the \"Functions\" section) for details on how to manage "
"nested mappings."
msgstr ""

#: ../../../mm/highmem.rst:105
msgid ""
"kmap_atomic(). This function has been deprecated; use kmap_local_page()."
msgstr ""

#: ../../../mm/highmem.rst:107
msgid ""
"NOTE: Conversions to kmap_local_page() must take care to follow the mapping "
"restrictions imposed on kmap_local_page(). Furthermore, the code between "
"calls to kmap_atomic() and kunmap_atomic() may implicitly depend on the side "
"effects of atomic mappings, i.e. disabling page faults or preemption, or "
"both. In that case, explicit calls to pagefault_disable() or "
"preempt_disable() or both must be made in conjunction with the use of "
"kmap_local_page()."
msgstr ""

#: ../../../mm/highmem.rst:114 ../../../mm/highmem.rst:138
msgid "[Legacy documentation]"
msgstr ""

#: ../../../mm/highmem.rst:116
msgid ""
"This permits a very short duration mapping of a single page.  Since the "
"mapping is restricted to the CPU that issued it, it performs well, but the "
"issuing task is therefore required to stay on that CPU until it has "
"finished, lest some other task displace its mappings."
msgstr ""

#: ../../../mm/highmem.rst:121
msgid ""
"kmap_atomic() may also be used by interrupt contexts, since it does not "
"sleep and the callers too may not sleep until after kunmap_atomic() is "
"called."
msgstr ""

#: ../../../mm/highmem.rst:125
msgid ""
"Each call of kmap_atomic() in the kernel creates a non-preemptible section "
"and disable pagefaults. This could be a source of unwanted latency. "
"Therefore users should prefer kmap_local_page() instead of kmap_atomic()."
msgstr ""

#: ../../../mm/highmem.rst:129
msgid "It is assumed that k[un]map_atomic() won't fail."
msgstr ""

#: ../../../mm/highmem.rst:131
msgid "kmap(). This function has been deprecated; use kmap_local_page()."
msgstr ""

#: ../../../mm/highmem.rst:133
msgid ""
"NOTE: Conversions to kmap_local_page() must take care to follow the mapping "
"restrictions imposed on kmap_local_page(). In particular, it is necessary to "
"make sure that the kernel virtual memory pointer is only valid in the thread "
"that obtained it."
msgstr ""

#: ../../../mm/highmem.rst:140
msgid ""
"This should be used to make short duration mapping of a single page with no "
"restrictions on preemption or migration. It comes with an overhead as "
"mapping space is restricted and protected by a global lock for "
"synchronization. When mapping is no longer needed, the address that the page "
"was mapped to must be released with kunmap()."
msgstr ""

#: ../../../mm/highmem.rst:146
msgid ""
"Mapping changes must be propagated across all the CPUs. kmap() also requires "
"global TLB invalidation when the kmap's pool wraps and it might block when "
"the mapping space is fully utilized until a slot becomes available. "
"Therefore, kmap() is only callable from preemptible context."
msgstr ""

#: ../../../mm/highmem.rst:151
msgid ""
"All the above work is necessary if a mapping must last for a relatively long "
"time but the bulk of high-memory mappings in the kernel are short-lived and "
"only used in one place. This means that the cost of kmap() is mostly wasted "
"in such cases. kmap() was not intended for long term mappings but it has "
"morphed in that direction and its use is strongly discouraged in newer code "
"and the set of the preceding functions should be preferred."
msgstr ""

#: ../../../mm/highmem.rst:159
msgid ""
"On 64-bit systems, calls to kmap_local_page(), kmap_atomic() and kmap() have "
"no real work to do because a 64-bit address space is more than sufficient to "
"address all the physical memory whose pages are permanently mapped."
msgstr ""

#: ../../../mm/highmem.rst:163
msgid ""
"vmap().  This can be used to make a long duration mapping of multiple "
"physical pages into a contiguous virtual space.  It needs global "
"synchronization to unmap."
msgstr ""

#: ../../../mm/highmem.rst:169
msgid "Cost of Temporary Mappings"
msgstr ""

#: ../../../mm/highmem.rst:171
msgid ""
"The cost of creating temporary mappings can be quite high.  The arch has to "
"manipulate the kernel's page tables, the data TLB and/or the MMU's registers."
msgstr ""

#: ../../../mm/highmem.rst:174
msgid ""
"If CONFIG_HIGHMEM is not set, then the kernel will try and create a mapping "
"simply with a bit of arithmetic that will convert the page struct address "
"into a pointer to the page contents rather than juggling mappings about.  In "
"such a case, the unmap operation may be a null operation."
msgstr ""

#: ../../../mm/highmem.rst:179
msgid ""
"If CONFIG_MMU is not set, then there can be no temporary mappings and no "
"highmem.  In such a case, the arithmetic approach will also be used."
msgstr ""

#: ../../../mm/highmem.rst:184
msgid "i386 PAE"
msgstr ""

#: ../../../mm/highmem.rst:186
msgid ""
"The i386 arch, under some circumstances, will permit you to stick up to "
"64GiB of RAM into your 32-bit machine.  This has a number of consequences:"
msgstr ""

#: ../../../mm/highmem.rst:189
msgid ""
"Linux needs a page-frame structure for each page in the system and the "
"pageframes need to live in the permanent mapping, which means:"
msgstr ""

#: ../../../mm/highmem.rst:192
msgid ""
"you can have 896M/sizeof(struct page) page-frames at most; with struct page "
"being 32-bytes that would end up being something in the order of 112G worth "
"of pages; the kernel, however, needs to store more than just page-frames in "
"that memory..."
msgstr ""

#: ../../../mm/highmem.rst:197
msgid ""
"PAE makes your page tables larger - which slows the system down as more data "
"has to be accessed to traverse in TLB fills and the like.  One advantage is "
"that PAE has more PTE bits and can provide advanced features like NX and PAT."
msgstr ""

#: ../../../mm/highmem.rst:202
msgid ""
"The general recommendation is that you don't use more than 8GiB on a 32-bit "
"machine - although more might work for you and your workload, you're pretty "
"much on your own - don't expect kernel developers to really care much if "
"things come apart."
msgstr ""

#: ../../../mm/highmem.rst:209
msgid "Functions"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:17
msgid "Map a page for long term usage"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:21
#: include/linux/highmem.h:44 include/linux/highmem.h:53
#: include/linux/highmem.h:61 include/linux/highmem.h:67
#: include/linux/highmem.h:103 include/linux/highmem.h:139
#: include/linux/highmem.h:216 include/linux/highmem.h:474
#: include/linux/highmem.h:502 include/linux/highmem.h:532
#: include/linux/highmem.h:570 include/linux/highmem.h:608
#: include/linux/highmem.h:638 include/linux/highmem.h:652
#: include/linux/highmem.h:664 include/linux/highmem.h:676
#: ../../../mm/highmem:212: mm/highmem.c:304 mm/highmem.c:332 mm/highmem.c:357
#: mm/highmem.c:752 mm/highmem.c:786 ../../../mm/highmem:213:
#: include/linux/highmem-internal.h:265 include/linux/highmem-internal.h:287
msgid "**Parameters**"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:23 ../../../mm/highmem:212:
#: mm/highmem.c:306 mm/highmem.c:788
msgid "``struct page *page``"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:18
#: include/linux/highmem.h:64 include/linux/highmem.h:136
msgid "Pointer to the page to be mapped"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:20
#: include/linux/highmem.h:52 include/linux/highmem.h:66
#: include/linux/highmem.h:131 include/linux/highmem.h:138
#: include/linux/highmem.h:219 include/linux/highmem.h:538
#: include/linux/highmem.h:612
msgid "**Return**"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:20
#: include/linux/highmem.h:66 include/linux/highmem.h:138
msgid "The virtual address of the mapping"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:22
#: include/linux/highmem.h:43 include/linux/highmem.h:68
#: include/linux/highmem.h:103 include/linux/highmem.h:140
#: include/linux/highmem.h:216 include/linux/highmem.h:533
#: include/linux/highmem.h:572 include/linux/highmem.h:610
#: include/linux/highmem.h:676 ../../../mm/highmem:212: mm/highmem.c:303
#: mm/highmem.c:331 mm/highmem.c:356 mm/highmem.c:751 ../../../mm/highmem:213:
#: include/linux/highmem-internal.h:264 include/linux/highmem-internal.h:286
msgid "**Description**"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:21
msgid ""
"Can only be invoked from preemptible task context because on 32bit systems "
"with CONFIG_HIGHMEM enabled this function might sleep."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:24
msgid ""
"For systems with CONFIG_HIGHMEM=n and for pages in the low memory area this "
"returns the virtual address of the direct kernel mapping."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:27
msgid ""
"The returned virtual address is globally visible and valid up to the point "
"where it is unmapped via kunmap(). The pointer can be handed to other "
"contexts."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:31
msgid ""
"For highmem pages on 32bit systems this can be slow as the mapping space is "
"limited and protected by a global lock. In case that there is no mapping "
"slot available the function blocks until a slot is released via kunmap()."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:40
msgid "Unmap the virtual address mapped by kmap()"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:46
#: include/linux/highmem.h:69 include/linux/highmem.h:141
#: ../../../mm/highmem:212: mm/highmem.c:334 mm/highmem.c:359 mm/highmem.c:754
msgid "``const struct page *page``"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:41
msgid "Pointer to the page which was mapped by kmap()"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:42
msgid ""
"Counterpart to kmap(). A NOOP for CONFIG_HIGHMEM=n and for mappings of pages "
"in the low memory area."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:49
msgid "Get the page for a kmap'ed address"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:55
#: include/linux/highmem.h:675
msgid "``void *addr``"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:50
msgid "The address to look up"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:52
msgid "The page which is mapped to **addr**."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:57
msgid "Flush all unused kmap mappings in order to remove stray mappings"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:63
msgid "``void``"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:1
msgid "no arguments"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:63
msgid "Map a page for temporary usage"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:67
msgid "Can be invoked from any context, including interrupts."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:69
msgid ""
"Requires careful handling when nesting multiple mappings because the map "
"management is stack based. The unmap has to be in the reverse order of the "
"map operation:"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:73
msgid ""
"addr1 = kmap_local_page(page1); addr2 = kmap_local_page(page2); ... "
"kunmap_local(addr2); kunmap_local(addr1);"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:79
#: include/linux/highmem.h:112
msgid "Unmapping addr1 before addr2 is invalid and causes malfunction."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:81
#: include/linux/highmem.h:114
msgid ""
"Contrary to kmap() mappings the mapping is only valid in the context of the "
"caller and cannot be handed to other contexts."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:84
#: include/linux/highmem.h:117
msgid ""
"On CONFIG_HIGHMEM=n kernels and for low memory pages this returns the "
"virtual address of the direct mapping. Only real highmem pages are "
"temporarily mapped."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:88
msgid ""
"While kmap_local_page() is significantly faster than kmap() for the highmem "
"case it comes with restrictions about the pointer validity."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:91
msgid ""
"On HIGHMEM enabled systems mapping a highmem page has the side effect of "
"disabling migration in order to keep the virtual address stable across "
"preemption. No caller of kmap_local_page() can rely on this side effect."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:99
msgid "Map a page in this folio for temporary usage"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:105
msgid "``const struct folio *folio``"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:100
msgid "The folio containing the page."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:102
#: include/linux/highmem.h:474 include/linux/highmem.h:501
#: include/linux/highmem.h:531 include/linux/highmem.h:569
msgid "``size_t offset``"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:101
msgid "The byte offset within the folio which identifies the page."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:102
msgid ""
"Requires careful handling when nesting multiple mappings because the map "
"management is stack based. The unmap has to be in the reverse order of the "
"map operation::"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:121
msgid ""
"While it is significantly faster than kmap() for the highmem case it comes "
"with restrictions about the pointer validity."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:124
msgid ""
"On HIGHMEM enabled systems mapping a highmem page has the side effect of "
"disabling migration in order to keep the virtual address stable across "
"preemption. No caller of kmap_local_folio() can rely on this side effect."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:128
msgid "**Context**"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:129
msgid "Can be invoked from any context."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:130
msgid "The virtual address of **offset**."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:135
msgid "Atomically map a page for temporary usage - Deprecated!"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:139
msgid ""
"In fact a wrapper around kmap_local_page() which also disables pagefaults "
"and, depending on PREEMPT_RT configuration, also CPU migration and "
"preemption. Therefore users should not count on the latter two side effects."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:143
msgid "Mappings should always be released by kunmap_atomic()."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:145
msgid "Do not use in new code. Use kmap_local_page() instead."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:147
msgid ""
"It is used in atomic context when code wants to access the contents of a "
"page that might be allocated from high memory (see __GFP_HIGHMEM), for "
"example a page in the pagecache.  The API has two functions, and they can be "
"used in a manner similar to the following::"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:164
msgid ""
"Note that the kunmap_atomic() call takes the result of the kmap_atomic() "
"call, not the argument."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:167
msgid ""
"If you need to map two pages because you want to copy from one page to "
"another you need to keep the kmap_atomic calls strictly nested, like:"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:170
msgid "vaddr1 = kmap_atomic(page1); vaddr2 = kmap_atomic(page2);"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:173
msgid "memcpy(vaddr1, vaddr2, PAGE_SIZE);"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:175
msgid "kunmap_atomic(vaddr2); kunmap_atomic(vaddr1);"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:212
msgid "Allocate a zeroed page for a VMA."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:218
msgid "``struct vm_area_struct *vma``"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:213
msgid "The VMA the page is to be allocated for."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:215
msgid "``unsigned long vaddr``"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:214
msgid "The virtual address the page will be inserted into."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:215
msgid ""
"This function will allocate a page suitable for inserting into this VMA at "
"this virtual address.  It may be allocated from highmem or the movable "
"zone.  An architecture may provide its own implementation."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:220
msgid ""
"A folio containing one allocated and zeroed page or NULL if we are out of "
"memory."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:470
msgid "Copy a range of bytes from a folio."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:476
#: include/linux/highmem.h:610
msgid "``char *to``"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:471
msgid "The memory to copy to."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:473
#: include/linux/highmem.h:504 include/linux/highmem.h:534
#: include/linux/highmem.h:572 include/linux/highmem.h:607
#: include/linux/highmem.h:640 include/linux/highmem.h:654
#: include/linux/highmem.h:666 include/linux/highmem.h:678
msgid "``struct folio *folio``"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:472
msgid "The folio to read from."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:473
msgid "The first byte in the folio to read."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:475
#: include/linux/highmem.h:503 include/linux/highmem.h:571
#: include/linux/highmem.h:609
msgid "``size_t len``"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:474
#: include/linux/highmem.h:502
msgid "The number of bytes to copy."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:498
msgid "Copy a range of bytes to a folio."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:499
#: include/linux/highmem.h:635 include/linux/highmem.h:649
#: include/linux/highmem.h:661
msgid "The folio to write to."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:500
msgid "The first byte in the folio to store to."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:502
#: include/linux/highmem.h:570
msgid "``const char *from``"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:501
msgid "The memory to copy from."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:528
msgid "Zero the tail of a folio."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:529
msgid "The folio to zero."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:530
msgid "The byte offset in the folio to start zeroing at."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:532
msgid "``void *kaddr``"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:531
msgid "The address the folio is currently mapped to."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:532
msgid ""
"If you have already used kmap_local_folio() to map a folio, written some "
"data to it and now need to zero the end of the folio (and flush the dcache), "
"you can use this function.  If you do not have the folio kmapped (eg the "
"folio has been partially populated by DMA), use folio_zero_range() or "
"folio_zero_segment() instead."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:539
msgid "An address which can be passed to kunmap_local()."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:566
msgid "Copy some data to a folio and pad with zeroes."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:567
msgid "The destination folio."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:568
msgid "The offset into **folio** at which to start copying."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:569
msgid "The data to copy."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:570
msgid "How many bytes of data to copy."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:571
msgid ""
"This function is most useful for filesystems which support inline data. When "
"they want to copy data from the inode into the page cache, this function "
"does everything for them.  It supports large folios even on HIGHMEM "
"configurations."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:604
msgid "Copy some bytes from a file folio."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:605
msgid "The destination buffer."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:606
msgid "The folio to copy from."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:608
msgid "``loff_t pos``"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:607
msgid "The position in the file."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:608
msgid "The maximum number of bytes to copy."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:609
msgid ""
"Copy up to **len** bytes from this folio.  This may be limited by PAGE_SIZE "
"if the folio comes from HIGHMEM, and by the size of the folio."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:613
msgid "The number of bytes copied from the folio."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:634
msgid "Zero two byte ranges in a folio."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:637
msgid "``size_t start1``"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:636
#: include/linux/highmem.h:650 include/linux/highmem.h:662
msgid "The first byte to zero."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:638
msgid "``size_t xend1``"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:637
msgid "One more than the last byte in the first range."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:639
msgid "``size_t start2``"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:638
msgid "The first byte to zero in the second range."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:640
msgid "``size_t xend2``"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:639
msgid "One more than the last byte in the second range."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:648
#: include/linux/highmem.h:660
msgid "Zero a byte range in a folio."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:651
#: include/linux/highmem.h:663
msgid "``size_t start``"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:652
msgid "``size_t xend``"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:651
msgid "One more than the last byte to zero."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:664
msgid "``size_t length``"
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:663
msgid "The number of bytes to zero."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:672
msgid "Unmap a folio and drop a refcount."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:673
msgid "The folio to release."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:674
msgid "The address previously returned by a call to kmap_local_folio()."
msgstr ""

#: ../../../mm/highmem:211: include/linux/highmem.h:675
msgid ""
"It is common, eg in directory handling to kmap a folio.  This function "
"unmaps the folio and drops the refcount that was being held to keep the "
"folio alive while we accessed it."
msgstr ""

#: ../../../mm/highmem:212: mm/highmem.c:300
msgid "map a highmem page into memory"
msgstr ""

#: ../../../mm/highmem:212: mm/highmem.c:301
msgid ":c:type:`struct page <page>` to map"
msgstr ""

#: ../../../mm/highmem:212: mm/highmem.c:302
msgid "Returns the page's virtual memory address."
msgstr ""

#: ../../../mm/highmem:212: mm/highmem.c:304
msgid "We cannot call this from interrupts, as it may block."
msgstr ""

#: ../../../mm/highmem:212: mm/highmem.c:328
msgid "pin a highmem page into memory"
msgstr ""

#: ../../../mm/highmem:212: mm/highmem.c:329
msgid ":c:type:`struct page <page>` to pin"
msgstr ""

#: ../../../mm/highmem:212: mm/highmem.c:330
msgid ""
"Returns the page's current virtual memory address, or NULL if no mapping "
"exists.  If and only if a non null address is returned then a matching call "
"to kunmap_high() is necessary."
msgstr ""

#: ../../../mm/highmem:212: mm/highmem.c:334
msgid "This can be called from any context."
msgstr ""

#: ../../../mm/highmem:212: mm/highmem.c:353
msgid "unmap a highmem page into memory"
msgstr ""

#: ../../../mm/highmem:212: mm/highmem.c:354
msgid ":c:type:`struct page <page>` to unmap"
msgstr ""

#: ../../../mm/highmem:212: mm/highmem.c:355
msgid ""
"If ARCH_NEEDS_KMAP_HIGH_GET is not defined then this may be called only from "
"user context."
msgstr ""

#: ../../../mm/highmem:212: mm/highmem.c:748
msgid "get the mapped virtual address of a page"
msgstr ""

#: ../../../mm/highmem:212: mm/highmem.c:749
msgid ":c:type:`struct page <page>` to get the virtual address of"
msgstr ""

#: ../../../mm/highmem:212: mm/highmem.c:750
msgid "Returns the page's virtual address."
msgstr ""

#: ../../../mm/highmem:212: mm/highmem.c:782
msgid "set a page's virtual address"
msgstr ""

#: ../../../mm/highmem:212: mm/highmem.c:783
msgid ":c:type:`struct page <page>` to set"
msgstr ""

#: ../../../mm/highmem:212: mm/highmem.c:785
msgid "``void *virtual``"
msgstr ""

#: ../../../mm/highmem:212: mm/highmem.c:784
msgid "virtual address to use"
msgstr ""

#: ../../../mm/highmem:213: include/linux/highmem-internal.h:263
msgid "``kunmap_atomic (__addr)``"
msgstr ""

#: ../../../mm/highmem:213: include/linux/highmem-internal.h:261
msgid "Unmap the virtual address mapped by kmap_atomic() - deprecated!"
msgstr ""

#: ../../../mm/highmem:213: include/linux/highmem-internal.h:267
#: include/linux/highmem-internal.h:289
msgid "``__addr``"
msgstr ""

#: ../../../mm/highmem:213: include/linux/highmem-internal.h:262
msgid "Virtual address to be unmapped"
msgstr ""

#: ../../../mm/highmem:213: include/linux/highmem-internal.h:263
msgid ""
"Unmaps an address previously mapped by kmap_atomic() and re-enables "
"pagefaults. Depending on PREEMP_RT configuration, re-enables also migration "
"and preemption. Users should not count on these side effects."
msgstr ""

#: ../../../mm/highmem:213: include/linux/highmem-internal.h:267
msgid ""
"Mappings should be unmapped in the reverse order that they were mapped. See "
"kmap_local_page() for details on nesting."
msgstr ""

#: ../../../mm/highmem:213: include/linux/highmem-internal.h:270
msgid ""
"**__addr** can be any address within the mapped page, so there is no need to "
"subtract any offset that has been added. In contrast to kunmap(), this "
"function takes the address returned from kmap_atomic(), not the page passed "
"to it. The compiler will warn you if you pass the page."
msgstr ""

#: ../../../mm/highmem:213: include/linux/highmem-internal.h:285
msgid "``kunmap_local (__addr)``"
msgstr ""

#: ../../../mm/highmem:213: include/linux/highmem-internal.h:283
msgid "Unmap a page mapped via kmap_local_page()."
msgstr ""

#: ../../../mm/highmem:213: include/linux/highmem-internal.h:284
msgid "An address within the page mapped"
msgstr ""

#: ../../../mm/highmem:213: include/linux/highmem-internal.h:285
msgid ""
"**__addr** can be any address within the mapped page.  Commonly it is the "
"address return from kmap_local_page(), but it can also include offsets."
msgstr ""

#: ../../../mm/highmem:213: include/linux/highmem-internal.h:288
msgid ""
"Unmapping should be done in the reverse order of the mapping.  See "
"kmap_local_page() for details."
msgstr ""
