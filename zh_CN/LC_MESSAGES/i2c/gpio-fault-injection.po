# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../i2c/gpio-fault-injection.rst:3
msgid "Linux I2C fault injection"
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:5
msgid ""
"The GPIO based I2C bus master driver can be configured to provide fault "
"injection capabilities. It is then meant to be connected to another I2C bus "
"which is driven by the I2C bus master driver under test. The GPIO fault "
"injection driver can create special states on the bus which the other I2C "
"bus master driver should handle gracefully."
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:11
msgid ""
"Once the Kconfig option I2C_GPIO_FAULT_INJECTOR is enabled, there will be an "
"'i2c-fault-injector' subdirectory in the Kernel debugfs filesystem, usually "
"mounted at /sys/kernel/debug. There will be a separate subdirectory per GPIO "
"driven I2C bus. Each subdirectory will contain files to trigger the fault "
"injection. They will be described now along with their intended use-cases."
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:18
msgid "Wire states"
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:21
msgid "\"scl\""
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:23
msgid ""
"By reading this file, you get the current state of SCL. By writing, you can "
"change its state to either force it low or to release it again. So, by using "
"\"echo 0 > scl\" you force SCL low and thus, no communication will be "
"possible because the bus master under test will not be able to clock. It "
"should detect the condition of SCL being unresponsive and report an error to "
"the upper layers."
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:31
msgid "\"sda\""
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:33
msgid ""
"By reading this file, you get the current state of SDA. By writing, you can "
"change its state to either force it low or to release it again. So, by using "
"\"echo 0 > sda\" you force SDA low and thus, data cannot be transmitted. The "
"bus master under test should detect this condition and trigger a bus "
"recovery (see I2C specification version 4, section 3.1.16) using the helpers "
"of the Linux I2C core (see 'struct bus_recovery_info'). However, the bus "
"recovery will not succeed because SDA is still pinned low until you manually "
"release it again with \"echo 1 > sda\". A test with an automatic release can "
"be done with the \"incomplete transfers\" class of fault injectors."
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:44
msgid "Incomplete transfers"
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:46
msgid ""
"The following fault injectors create situations where SDA will be held low "
"by a device. Bus recovery should be able to fix these situations. But please "
"note: there are I2C client devices which detect a stuck SDA on their side "
"and release it on their own after a few milliseconds. Also, there might be "
"an external device deglitching and monitoring the I2C bus. It could also "
"detect a stuck SDA and will init a bus recovery on its own. If you want to "
"implement bus recovery in a bus master driver, make sure you checked your "
"hardware setup for such devices before. And always verify with a scope or "
"logic analyzer!"
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:56
msgid "\"incomplete_address_phase\""
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:58
msgid ""
"This file is write only and you need to write the address of an existing I2C "
"client device to it. Then, a read transfer to this device will be started, "
"but it will stop at the ACK phase after the address of the client has been "
"transmitted. Because the device will ACK its presence, this results in SDA "
"being pulled low by the device while SCL is high. So, similar to the \"sda\" "
"file above, the bus master under test should detect this condition and try a "
"bus recovery. This time, however, it should succeed and the device should "
"release SDA after toggling SCL."
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:68
msgid "\"incomplete_write_byte\""
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:70
msgid ""
"Similar to above, this file is write only and you need to write the address "
"of an existing I2C client device to it."
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:73
msgid ""
"The injector will again stop at one ACK phase, so the device will keep SDA "
"low because it acknowledges data. However, there are two differences "
"compared to 'incomplete_address_phase':"
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:77
msgid "the message sent out will be a write message"
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:78
msgid ""
"after the address byte, a 0x00 byte will be transferred. Then, stop at ACK."
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:80
msgid ""
"This is a highly delicate state, the device is set up to write any data to "
"register 0x00 (if it has registers) when further clock pulses happen on SCL. "
"This is why bus recovery (up to 9 clock pulses) must either check SDA or "
"send additional STOP conditions to ensure the bus has been released. "
"Otherwise random data will be written to a device!"
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:87
msgid "Lost arbitration"
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:89
msgid ""
"Here, we want to simulate the condition where the master under test loses "
"the bus arbitration against another master in a multi-master setup."
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:93
msgid "\"lose_arbitration\""
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:95
msgid ""
"This file is write only and you need to write the duration of the "
"arbitration interference (in µs, maximum is 100ms). The calling process will "
"then sleep and wait for the next bus clock. The process is interruptible, "
"though."
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:99
msgid ""
"Arbitration lost is achieved by waiting for SCL going down by the master "
"under test and then pulling SDA low for some time. So, the I2C address sent "
"out should be corrupted and that should be detected properly. That means "
"that the address sent out should have a lot of '1' bits to be able to detect "
"corruption. There doesn't need to be a device at this address because "
"arbitration lost should be detected beforehand. Also note, that SCL going "
"down is monitored using interrupts, so the interrupt latency might cause the "
"first bits to be not corrupted. A good starting point for using this fault "
"injector on an otherwise idle bus is::"
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:113
msgid "Panic during transfer"
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:115
msgid ""
"This fault injector will create a Kernel panic once the master under test "
"started a transfer. This usually means that the state machine of the bus "
"master driver will be ungracefully interrupted and the bus may end up in an "
"unusual state. Use this to check if your shutdown/reboot/boot code can "
"handle this scenario."
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:122
msgid "\"inject_panic\""
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:124
msgid ""
"This file is write only and you need to write the delay between the detected "
"start of a transmission and the induced Kernel panic (in µs, maximum is "
"100ms). The calling process will then sleep and wait for the next bus clock. "
"The process is interruptible, though."
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:129
msgid ""
"Start of a transfer is detected by waiting for SCL going down by the master "
"under test.  A good starting point for using this fault injector is::"
msgstr ""

#: ../../../i2c/gpio-fault-injection.rst:135
msgid ""
"Note that there doesn't need to be a device listening to the address you are "
"using. Results may vary depending on that, though."
msgstr ""
