# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../i2c/slave-testunit-backend.rst:5
msgid "Linux I2C slave testunit backend"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:7
msgid "by Wolfram Sang <wsa@sang-engineering.com> in 2020"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:9
msgid ""
"This backend can be used to trigger test cases for I2C bus masters which "
"require a remote device with certain capabilities (and which are usually not "
"so easy to obtain). Examples include multi-master testing, and SMBus Host "
"Notify testing. For some tests, the I2C slave controller must be able to "
"switch between master and slave mode because it needs to send data, too."
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:15
msgid ""
"Note that this is a device for testing and debugging. It should not be "
"enabled in a production build. And while there is some versioning and we try "
"hard to keep backward compatibility, there is no stable ABI guaranteed!"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:19
msgid "Instantiating the device is regular. Example for bus 0, address 0x30::"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:23
msgid ""
"Or using firmware nodes. Here is a devicetree example (note this is only a "
"debug device, so there are no official DT bindings)::"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:35
msgid ""
"After that, you will have the device listening. Reading will return a single "
"byte. Its value is 0 if the testunit is idle, otherwise the command number "
"of the currently running command."
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:39
msgid ""
"When writing, the device consists of 4 8-bit registers and, except for some "
"\"partial\" commands, all registers must be written to start a testcase, i."
"e. you usually write 4 bytes to the device. The registers are:"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:1
msgid "Offset"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:1
msgid "Name"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:1
msgid "Description"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:1
msgid "0x00"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:1
#: ../../../i2c/slave-testunit-backend.rst:76
#: ../../../i2c/slave-testunit-backend.rst:100
#: ../../../i2c/slave-testunit-backend.rst:127
#: ../../../i2c/slave-testunit-backend.rst:157
#: ../../../i2c/slave-testunit-backend.rst:195
msgid "CMD"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:1
msgid "which test to trigger"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:1
#: ../../../i2c/slave-testunit-backend.rst:81
msgid "0x01"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:1
#: ../../../i2c/slave-testunit-backend.rst:77
#: ../../../i2c/slave-testunit-backend.rst:101
#: ../../../i2c/slave-testunit-backend.rst:128
#: ../../../i2c/slave-testunit-backend.rst:158
#: ../../../i2c/slave-testunit-backend.rst:196
msgid "DATAL"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:1
msgid "configuration byte 1 for the test"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:1
#: ../../../i2c/slave-testunit-backend.rst:105
msgid "0x02"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:1
#: ../../../i2c/slave-testunit-backend.rst:78
#: ../../../i2c/slave-testunit-backend.rst:102
#: ../../../i2c/slave-testunit-backend.rst:129
#: ../../../i2c/slave-testunit-backend.rst:159
#: ../../../i2c/slave-testunit-backend.rst:197
msgid "DATAH"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:1
msgid "configuration byte 2 for the test"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:1
#: ../../../i2c/slave-testunit-backend.rst:132
msgid "0x03"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:1
#: ../../../i2c/slave-testunit-backend.rst:79
#: ../../../i2c/slave-testunit-backend.rst:103
#: ../../../i2c/slave-testunit-backend.rst:130
#: ../../../i2c/slave-testunit-backend.rst:160
#: ../../../i2c/slave-testunit-backend.rst:198
msgid "DELAY"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:1
msgid "delay in n * 10ms until test is started"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:51
msgid ""
"Using 'i2cset' from the i2c-tools package, the generic command looks like::"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:55
msgid ""
"DELAY is a generic parameter which will delay the execution of the test in "
"CMD. While a command is running (including the delay), new commands will not "
"be acknowledged. You need to wait until the old one is completed."
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:59
msgid ""
"The commands are described in the following section. An invalid command will "
"result in the transfer not being acknowledged."
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:63
msgid "Commands"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:66
msgid "0x00 NOOP"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:68
msgid "Reserved for future use."
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:71
msgid "0x01 READ_BYTES"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:82
msgid "address to read data from (lower 7 bits, highest bit currently unused)"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:83
msgid "number of bytes to read"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:84
#: ../../../i2c/slave-testunit-backend.rst:108
#: ../../../i2c/slave-testunit-backend.rst:203
msgid "n * 10ms"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:86
msgid ""
"Also needs master mode. This is useful to test if your bus master driver is "
"handling multi-master correctly. You can trigger the testunit to read bytes "
"from another device on the bus. If the bus master under test also wants to "
"access the bus at the same time, the bus will be busy. Example to read 128 "
"bytes from device 0x50 after 50ms of delay::"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:95
msgid "0x02 SMBUS_HOST_NOTIFY"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:106
msgid "low byte of the status word to send"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:107
msgid "high byte of the status word to send"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:110
msgid ""
"Also needs master mode. This test will send an SMBUS_HOST_NOTIFY message to "
"the host. Note that the status word is currently ignored in the Linux "
"Kernel. Example to send a notification with status word 0x6442 after 10ms::"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:116
msgid ""
"If the host controller supports HostNotify, this message with debug level "
"should appear (Linux 6.11 and later)::"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:122
msgid "0x03 SMBUS_BLOCK_PROC_CALL"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:133
msgid "0x01 (i.e. one further byte will be written)"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:134
msgid "number of bytes to be sent back"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:135
#: ../../../i2c/slave-testunit-backend.rst:165
msgid "leave out, partial command!"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:137
msgid ""
"Partial command. This test will respond to a block process call as defined "
"by the SMBus specification. The one data byte written specifies how many "
"bytes will be sent back in the following read transfer. Note that in this "
"read transfer, the testunit will prefix the length of the bytes to follow. "
"So, if your host bus driver emulates SMBus calls like the majority does, it "
"needs to support the I2C_M_RECV_LEN flag of an i2c_msg. This is a good "
"testcase for it. The returned data consists of the length first, and then of "
"an array of bytes from length-1 to 0. Here is an example which emulates "
"i2c_smbus_block_process_call() using i2ctransfer (you need i2c-tools v4.2 or "
"later)::"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:152
msgid "0x04 GET_VERSION_WITH_REP_START"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:162
msgid "0x04"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:163
#: ../../../i2c/slave-testunit-backend.rst:164
#: ../../../i2c/slave-testunit-backend.rst:202
msgid "currently unused"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:167
msgid ""
"Partial command. After sending this command, the testunit will reply to a "
"read message with a NUL terminated version string based on UTS_RELEASE. The "
"first character is always a 'v' and the length of the version string is at "
"maximum 128 bytes. However, it will only respond if the read message is "
"connected to the write message via repeated start. If your controller driver "
"handles repeated start correctly, this will work::"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:177
msgid ""
"If you have i2c-tools 4.4 or later, you can print out the data right away::"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:182
msgid ""
"STOP/START combinations between the two messages will *not* work because "
"they are not equivalent to a REPEATED START. As an example, this returns "
"just the default response::"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:190
msgid "0x05 SMBUS_ALERT_REQUEST"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:200
msgid "0x05"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:201
msgid "response value (7 MSBs interpreted as I2C address)"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:205
msgid ""
"This test raises an interrupt via the SMBAlert pin which the host controller "
"must handle. The pin must be connected to the testunit as a GPIO. GPIO "
"access is not allowed to sleep. Currently, this can only be described using "
"firmware nodes. So, for devicetree, you would add something like this to the "
"testunit node::"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:213
msgid ""
"The following command will trigger the alert with a response of 0xc9 after 1 "
"second of delay::"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:218
msgid ""
"If the host controller supports SMBusAlert, this message with debug level "
"should appear::"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:223
msgid ""
"This message may appear more than once because the testunit is software not "
"hardware and, thus, may not be able to react to the response of the host "
"fast enough. The interrupt count should increase only by one, though::"
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:230
msgid ""
"If the host does not respond to the alert within 1 second, the test will be "
"aborted and the testunit will report an error."
msgstr ""

#: ../../../i2c/slave-testunit-backend.rst:233
msgid ""
"For this test, the testunit will shortly drop its assigned address and "
"listen on the SMBus Alert Response Address (0x0c). It will reassign its "
"original address afterwards."
msgstr ""
