# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../admin-guide/cgroup-v1/devices.rst:3
msgid "Device Whitelist Controller"
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:6
msgid "1. Description"
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:8
msgid ""
"Implement a cgroup to track and enforce open and mknod restrictions on "
"device files.  A device cgroup associates a device access whitelist with "
"each cgroup.  A whitelist entry has 4 fields. 'type' is a (all), c (char), "
"or b (block).  'all' means it applies to all types and all major and minor "
"numbers.  Major and minor are either an integer or * for all.  Access is a "
"composition of r (read), w (write), and m (mknod)."
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:16
msgid ""
"The root device cgroup starts with rwm to 'all'.  A child device cgroup gets "
"a copy of the parent.  Administrators can then remove devices from the "
"whitelist or add new entries.  A child cgroup can never receive a device "
"access which is denied by its parent."
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:22
msgid "2. User Interface"
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:24
msgid ""
"An entry is added using devices.allow, and removed using devices.deny.  For "
"instance::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:29
msgid ""
"allows cgroup 1 to read and mknod the device usually known as /dev/null.  "
"Doing::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:34
msgid "will remove the default 'a *:* rwm' entry. Doing::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:38
msgid "will add the 'a *:* rwm' entry to the whitelist."
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:41
msgid "3. Security"
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:43
msgid ""
"Any task can move itself between cgroups.  This clearly won't suffice, but "
"we can decide the best way to adequately restrict movement as people get "
"some experience with this.  We may just want to require CAP_SYS_ADMIN, which "
"at least is a separate bit from CAP_MKNOD.  We may want to just refuse "
"moving to a cgroup which isn't a descendant of the current one.  Or we may "
"want to use CAP_MAC_ADMIN, since we really are trying to lock down root."
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:51
msgid ""
"CAP_SYS_ADMIN is needed to modify the whitelist or move another task to a "
"new cgroup.  (Again we'll probably want to change that)."
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:54
msgid ""
"A cgroup may not be granted more permissions than the cgroup's parent has."
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:58
msgid "4. Hierarchy"
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:60
msgid ""
"device cgroups maintain hierarchy by making sure a cgroup never has more "
"access permissions than its parent.  Every time an entry is written to a "
"cgroup's devices.deny file, all its children will have that entry removed "
"from their whitelist and all the locally set whitelist entries will be re-"
"evaluated.  In case one of the locally set whitelist entries would provide "
"more access than the cgroup's parent, it'll be removed from the whitelist."
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:67
msgid "Example::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:77
msgid "If a device is denied in group A::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:81
msgid ""
"it'll propagate down and after revalidating B's entries, the whitelist entry "
"\"c 116:2 rwm\" will be removed::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:88
msgid ""
"In case parent's exceptions change and local exceptions are not allowed "
"anymore, they'll be deleted."
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:91
msgid "Notice that new whitelist entries will not be propagated::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:101
msgid "when adding ``c *:3 rwm``::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:105
msgid "the result::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:111
msgid "but now it'll be possible to add new entries to B::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:116
msgid "or even::"
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:120
msgid ""
"Allowing or denying all by writing 'a' to devices.allow or devices.deny will "
"not be possible once the device cgroups has children."
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:124
msgid "4.1 Hierarchy (internal implementation)"
msgstr ""

#: ../../../admin-guide/cgroup-v1/devices.rst:126
msgid ""
"device cgroups is implemented internally using a behavior (ALLOW, DENY) and "
"a list of exceptions.  The internal state is controlled using the same user "
"interface to preserve compatibility with the previous whitelist-only "
"implementation.  Removal or addition of exceptions that will reduce the "
"access to devices will be propagated down the hierarchy. For every "
"propagated exception, the effective rules will be re-evaluated based on "
"current parent's access rules."
msgstr ""
