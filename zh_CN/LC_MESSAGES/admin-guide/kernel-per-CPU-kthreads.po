# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:3
msgid "Reducing OS jitter due to per-cpu kthreads"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:5
msgid ""
"This document lists per-CPU kthreads in the Linux kernel and presents "
"options to control their OS jitter.  Note that non-per-CPU kthreads are not "
"listed here.  To reduce OS jitter from non-per-CPU kthreads, bind them to a "
"\"housekeeping\" CPU dedicated to such work."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:11
msgid "References"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:13
msgid ""
"Documentation/core-api/irq/irq-affinity.rst:  Binding interrupts to sets of "
"CPUs."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:15
msgid ""
"Documentation/admin-guide/cgroup-v1:  Using cgroups to bind tasks to sets of "
"CPUs."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:17
msgid "man taskset:  Using the taskset command to bind tasks to sets of CPUs."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:20
msgid ""
"man sched_setaffinity:  Using the sched_setaffinity() system call to bind "
"tasks to sets of CPUs."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:23
msgid ""
"/sys/devices/system/cpu/cpuN/online:  Control CPU N's hotplug state, writing "
"\"0\" to offline and \"1\" to online."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:26
msgid "In order to locate kernel-generated OS jitter on CPU N:"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:28
msgid ""
"cd /sys/kernel/tracing echo 1 > max_graph_depth # Increase the \"1\" for "
"more detail echo function_graph > current_tracer # run workload cat per_cpu/"
"cpuN/trace"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:35
msgid "kthreads"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:37
#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:56
#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:67
#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:81
#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:222
#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:285
#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:312
msgid "Name:"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:38
msgid "ehca_comp/%u"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:40
#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:59
#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:70
#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:84
#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:225
#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:288
#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:315
msgid "Purpose:"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:41
msgid "Periodically process Infiniband-related work."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:43
#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:228
msgid "To reduce its OS jitter, do any of the following:"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:45
msgid ""
"Don't use eHCA Infiniband hardware, instead choosing hardware that does not "
"require per-CPU kthreads.  This will prevent these kthreads from being "
"created in the first place.  (This will work for most people, as this "
"hardware, though important, is relatively old and is produced in relatively "
"low unit volumes.)"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:50
msgid ""
"Do all eHCA-Infiniband-related work on other CPUs, including interrupts."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:52
msgid ""
"Rework the eHCA driver so that its per-CPU kthreads are provisioned only on "
"selected CPUs."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:57
msgid "irq/%d-%s"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:60
msgid "Handle threaded interrupts."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:62
msgid "To reduce its OS jitter, do the following:"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:64
msgid "Use irq affinity to force the irq threads to execute on some other CPU."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:68
msgid "kcmtpd_ctr_%d"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:71
msgid "Handle Bluetooth work."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:73
msgid "To reduce its OS jitter, do one of the following:"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:75
msgid ""
"Don't use Bluetooth, in which case these kthreads won't be created in the "
"first place."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:77
msgid ""
"Use irq affinity to force Bluetooth-related interrupts to occur on some "
"other CPU and furthermore initiate all Bluetooth activity on some other CPU."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:82
msgid "ksoftirqd/%u"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:85
msgid "Execute softirq handlers when threaded or when under heavy load."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:87
msgid ""
"To reduce its OS jitter, each softirq vector must be handled separately as "
"follows:"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:91
msgid "TIMER_SOFTIRQ"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:93
#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:109
#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:121
#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:133
#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:156
#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:178
msgid "Do all of the following:"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:95
#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:203
#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:217
msgid ""
"To the extent possible, keep the CPU out of the kernel when it is non-idle, "
"for example, by avoiding system calls and by forcing both kernel threads and "
"interrupts to execute elsewhere."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:98
msgid ""
"Build with CONFIG_HOTPLUG_CPU=y.  After boot completes, force the CPU "
"offline, then bring it back online.  This forces recurring timers to migrate "
"elsewhere.  If you are concerned with multiple CPUs, force them all offline "
"before bringing the first one back online.  Once you have onlined the CPUs "
"in question, do not offline any other CPUs, because doing so could force the "
"timer back onto one of the CPUs in question."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:107
msgid "NET_TX_SOFTIRQ and NET_RX_SOFTIRQ"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:111
msgid "Force networking interrupts onto other CPUs."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:112
msgid "Initiate any network I/O on other CPUs."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:113
#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:125
#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:137
msgid ""
"Once your application has started, prevent CPU-hotplug operations from being "
"initiated from tasks that might run on the CPU to be de-jittered.  (It is OK "
"to force this CPU offline and then bring it back online before you start "
"your application.)"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:119
msgid "BLOCK_SOFTIRQ"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:123
#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:135
msgid "Force block-device interrupts onto some other CPU."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:124
msgid "Initiate any block I/O on other CPUs."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:131
msgid "IRQ_POLL_SOFTIRQ"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:136
msgid "Initiate any block I/O and block-I/O polling on other CPUs."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:143
msgid "TASKLET_SOFTIRQ"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:145
msgid "Do one or more of the following:"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:147
msgid ""
"Avoid use of drivers that use tasklets.  (Such drivers will contain calls to "
"things like tasklet_schedule().)"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:149
msgid "Convert all drivers that you must use from tasklets to workqueues."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:150
msgid ""
"Force interrupts for drivers using tasklets onto other CPUs, and also do I/O "
"involving these drivers on other CPUs."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:154
msgid "SCHED_SOFTIRQ"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:158
msgid ""
"Avoid sending scheduler IPIs to the CPU to be de-jittered, for example, "
"ensure that at most one runnable kthread is present on that CPU.  If a "
"thread that expects to run on the de-jittered CPU awakens, the scheduler "
"will send an IPI that can result in a subsequent SCHED_SOFTIRQ."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:163
msgid ""
"CONFIG_NO_HZ_FULL=y and ensure that the CPU to be de-jittered is marked as "
"an adaptive-ticks CPU using the \"nohz_full=\" boot parameter.  This reduces "
"the number of scheduler-clock interrupts that the de-jittered CPU receives, "
"minimizing its chances of being selected to do the load balancing work that "
"runs in SCHED_SOFTIRQ context."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:169
msgid ""
"To the extent possible, keep the CPU out of the kernel when it is non-idle, "
"for example, by avoiding system calls and by forcing both kernel threads and "
"interrupts to execute elsewhere. This further reduces the number of "
"scheduler-clock interrupts received by the de-jittered CPU."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:176
msgid "HRTIMER_SOFTIRQ"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:180
msgid ""
"To the extent possible, keep the CPU out of the kernel when it is non-idle.  "
"For example, avoid system calls and force both kernel threads and interrupts "
"to execute elsewhere."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:183
msgid ""
"Build with CONFIG_HOTPLUG_CPU=y.  Once boot completes, force the CPU "
"offline, then bring it back online.  This forces recurring timers to migrate "
"elsewhere.  If you are concerned with multiple CPUs, force them all offline "
"before bringing the first one back online.  Once you have onlined the CPUs "
"in question, do not offline any other CPUs, because doing so could force the "
"timer back onto one of the CPUs in question."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:192
msgid "RCU_SOFTIRQ"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:194
msgid "Do at least one of the following:"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:196
msgid ""
"Offload callbacks and keep the CPU in either dyntick-idle or adaptive-ticks "
"state by doing all of the following:"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:199
msgid ""
"CONFIG_NO_HZ_FULL=y and ensure that the CPU to be de-jittered is marked as "
"an adaptive-ticks CPU using the \"nohz_full=\" boot parameter.  Bind the "
"rcuo kthreads to housekeeping CPUs, which can tolerate OS jitter."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:208
msgid ""
"Enable RCU to do its processing remotely via dyntick-idle by doing all of "
"the following:"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:211
msgid "Build with CONFIG_NO_HZ=y."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:212
msgid ""
"Ensure that the CPU goes idle frequently, allowing other CPUs to detect that "
"it has passed through an RCU quiescent state.  If the kernel is built with "
"CONFIG_NO_HZ_FULL=y, userspace execution also allows other CPUs to detect "
"that the CPU in question has passed through a quiescent state."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:223
msgid "kworker/%u:%d%s (cpu, id, priority)"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:226
msgid "Execute workqueue requests"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:230
msgid ""
"Run your workload at a real-time priority, which will allow preempting the "
"kworker daemons."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:232
msgid ""
"A given workqueue can be made visible in the sysfs filesystem by passing the "
"WQ_SYSFS to that workqueue's alloc_workqueue(). Such a workqueue can be "
"confined to a given subset of the CPUs using the ``/sys/devices/virtual/"
"workqueue/*/cpumask`` sysfs files.  The set of WQ_SYSFS workqueues can be "
"displayed using \"ls /sys/devices/virtual/workqueue\".  That said, the "
"workqueues maintainer would like to caution people against indiscriminately "
"sprinkling WQ_SYSFS across all the workqueues.  The reason for caution is "
"that it is easy to add WQ_SYSFS, but because sysfs is part of the formal "
"user/kernel API, it can be nearly impossible to remove it, even if its "
"addition was a mistake."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:243
msgid ""
"Do any of the following needed to avoid jitter that your application cannot "
"tolerate:"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:246
msgid "Avoid using oprofile, thus avoiding OS jitter from wq_sync_buffer()."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:248
msgid ""
"Limit your CPU frequency so that a CPU-frequency governor is not required, "
"possibly enlisting the aid of special heatsinks or other cooling "
"technologies.  If done correctly, and if you CPU architecture permits, you "
"should be able to build your kernel with CONFIG_CPU_FREQ=n to avoid the CPU-"
"frequency governor periodically running on each CPU, including "
"cs_dbs_timer() and od_dbs_timer()."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:256
msgid ""
"WARNING:  Please check your CPU specifications to make sure that this is "
"safe on your particular system."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:258
msgid ""
"As of v3.18, Christoph Lameter's on-demand vmstat workers commit prevents OS "
"jitter due to vmstat_update() on CONFIG_SMP=y systems.  Before v3.18, is not "
"possible to entirely get rid of the OS jitter, but you can decrease its "
"frequency by writing a large value to /proc/sys/vm/stat_interval.  The "
"default value is HZ, for an interval of one second.  Of course, larger "
"values will make your virtual-memory statistics update more slowly.  Of "
"course, you can also run your workload at a real-time priority, thus "
"preempting vmstat_update(), but if your workload is CPU-bound, this is a bad "
"idea. However, there is an RFC patch from Christoph Lameter (based on an "
"earlier one from Gilad Ben-Yossef) that reduces or even eliminates vmstat "
"overhead for some workloads at https://lore.kernel.org/"
"r/00000140e9dfd6bd-40db3d4f-c1be-434f-8132-7820f81bb586-000000@email."
"amazonses.com."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:273
msgid ""
"If running on high-end powerpc servers, build with "
"CONFIG_PPC_RTAS_DAEMON=n.  This prevents the RTAS daemon from running on "
"each CPU every second or so. (This will require editing Kconfig files and "
"will defeat this platform's RAS functionality.)  This avoids jitter due to "
"the rtas_event_scan() function. WARNING:  Please check your CPU "
"specifications to make sure that this is safe on your particular system."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:281
msgid ""
"If running on PowerMAC, build your kernel with CONFIG_PMAC_RACKMETER=n to "
"disable the CPU-meter, avoiding OS jitter from rackmeter_do_timer()."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:286
msgid "rcuc/%u"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:289
msgid "Execute RCU callbacks in CONFIG_RCU_BOOST=y kernels."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:291
#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:318
msgid "To reduce its OS jitter, do at least one of the following:"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:293
msgid ""
"Build the kernel with CONFIG_PREEMPT=n.  This prevents these kthreads from "
"being created in the first place, and also obviates the need for RCU "
"priority boosting.  This approach is feasible for workloads that do not "
"require high degrees of responsiveness."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:297
msgid ""
"Build the kernel with CONFIG_RCU_BOOST=n.  This prevents these kthreads from "
"being created in the first place.  This approach is feasible only if your "
"workload never requires RCU priority boosting, for example, if you ensure "
"frequent idle time on all CPUs that might execute within the kernel."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:302
msgid ""
"Build with CONFIG_RCU_NOCB_CPU=y and boot with the rcu_nocbs= boot parameter "
"offloading RCU callbacks from all CPUs susceptible to OS jitter.  This "
"approach prevents the rcuc/%u kthreads from having any work to do, so that "
"they are never awakened."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:306
msgid ""
"Ensure that the CPU never enters the kernel, and, in particular, avoid "
"initiating any CPU hotplug operations on this CPU.  This is another way of "
"preventing any callbacks from being queued on the CPU, again preventing the "
"rcuc/%u kthreads from having any work to do."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:313
msgid "rcuop/%d, rcuos/%d, and rcuog/%d"
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:316
msgid "Offload RCU callbacks from the corresponding CPU."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:320
msgid ""
"Use affinity, cgroups, or other mechanism to force these kthreads to execute "
"on some other CPU."
msgstr ""

#: ../../../admin-guide/kernel-per-CPU-kthreads.rst:322
msgid ""
"Build with CONFIG_RCU_NOCB_CPU=n, which will prevent these kthreads from "
"being created in the first place.  However, please note that this will not "
"eliminate OS jitter, but will instead shift it to RCU_SOFTIRQ."
msgstr ""
