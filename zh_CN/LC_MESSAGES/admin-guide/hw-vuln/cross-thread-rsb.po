# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:5
#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:32
msgid "Cross-Thread Return Address Predictions"
msgstr ""

#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:7
msgid ""
"Certain AMD and Hygon processors are subject to a cross-thread return "
"address predictions vulnerability. When running in SMT mode and one sibling "
"thread transitions out of C0 state, the other sibling thread could use "
"return target predictions from the sibling thread that transitioned out of "
"C0."
msgstr ""

#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:12
msgid ""
"The Spectre v2 mitigations protect the Linux kernel, as it fills the return "
"address prediction entries with safe targets when context switching to the "
"idle thread. However, KVM does allow a VMM to prevent exiting guest mode "
"when transitioning out of C0. This could result in a guest-controlled return "
"target being consumed by the sibling thread."
msgstr ""

#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:19
msgid "Affected processors"
msgstr ""

#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:21
msgid "The following CPUs are vulnerable:"
msgstr ""

#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:23
msgid "AMD Family 17h processors"
msgstr ""

#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:24
msgid "Hygon Family 18h processors"
msgstr ""

#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:27
msgid "Related CVEs"
msgstr ""

#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:29
msgid "The following CVE entry is related to this issue:"
msgstr ""

#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:32
msgid "CVE-2022-27672"
msgstr ""

#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:36
msgid "Problem"
msgstr ""

#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:38
msgid ""
"Affected SMT-capable processors support 1T and 2T modes of execution when "
"SMT is enabled. In 2T mode, both threads in a core are executing code. For "
"the processor core to enter 1T mode, it is required that one of the threads "
"requests to transition out of the C0 state. This can be communicated with "
"the HLT instruction or with an MWAIT instruction that requests non-C0. When "
"the thread re-enters the C0 state, the processor transitions back to 2T "
"mode, assuming the other thread is also still in C0 state."
msgstr ""

#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:46
msgid ""
"In affected processors, the return address predictor (RAP) is partitioned "
"depending on the SMT mode. For instance, in 2T mode each thread uses a "
"private 16-entry RAP, but in 1T mode, the active thread uses a 32-entry RAP. "
"Upon transition between 1T/2T mode, the RAP contents are not modified but "
"the RAP pointers (which control the next return target to use for "
"predictions) may change. This behavior may result in return targets from one "
"SMT thread being used by RET predictions in the sibling thread following a "
"1T/2T switch. In particular, a RET instruction executed immediately after a "
"transition to 1T may use a return target from the thread that just became "
"idle. In theory, this could lead to information disclosure if the return "
"targets used do not come from trustworthy code."
msgstr ""

#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:59
msgid "Attack scenarios"
msgstr ""

#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:61
msgid ""
"An attack can be mounted on affected processors by performing a series of "
"CALL instructions with targeted return locations and then transitioning out "
"of C0 state."
msgstr ""

#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:66
msgid "Mitigation mechanism"
msgstr ""

#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:68
msgid ""
"Before entering idle state, the kernel context switches to the idle thread. "
"The context switch fills the RAP entries (referred to as the RSB in Linux) "
"with safe targets by performing a sequence of CALL instructions."
msgstr ""

#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:72
msgid ""
"Prevent a guest VM from directly putting the processor into an idle state by "
"intercepting HLT and MWAIT instructions."
msgstr ""

#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:75
msgid "Both mitigations are required to fully address this issue."
msgstr ""

#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:78
msgid "Mitigation control on the kernel command line"
msgstr ""

#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:80
msgid ""
"Use existing Spectre v2 mitigations that will fill the RSB on context switch."
msgstr ""

#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:83
msgid "Mitigation control for KVM - module parameter"
msgstr ""

#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:85
msgid ""
"By default, the KVM hypervisor mitigates this issue by intercepting guest "
"attempts to transition out of C0. A VMM can use the "
"KVM_CAP_X86_DISABLE_EXITS capability to override those interceptions, but "
"since this is not common, the mitigation that covers this path is not "
"enabled by default."
msgstr ""

#: ../../../admin-guide/hw-vuln/cross-thread-rsb.rst:90
msgid ""
"The mitigation for the KVM_CAP_X86_DISABLE_EXITS capability can be turned on "
"using the boolean module parameter mitigate_smt_rsb, e.g. ``kvm."
"mitigate_smt_rsb=1``."
msgstr ""
