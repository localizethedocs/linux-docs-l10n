# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../hid/intel-thc-hid.rst:5
msgid "Intel Touch Host Controller (THC)"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:7
msgid ""
"Touch Host Controller is the name of the IP block in PCH that interface with "
"Touch Devices (ex: touchscreen, touchpad etc.). It is comprised of 3 key "
"functional blocks:"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:10
msgid "A natively half-duplex Quad I/O capable SPI master"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:11
msgid "Low latency I2C interface to support HIDI2C compliant devices"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:12
msgid "A HW sequencer with RW DMA capability to system memory"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:14
msgid ""
"It has a single root space IOSF Primary interface that supports transactions "
"to/from touch devices. Host driver configures and controls the touch devices "
"over THC interface. THC provides high bandwidth DMA services to the touch "
"driver and transfers the HID report to host system main memory."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:18
msgid ""
"Hardware sequencer within the THC is responsible for transferring (via DMA) "
"data from touch devices into system memory. A ring buffer is used to avoid "
"data loss due to asynchronous nature of data consumption (by host) in "
"relation to data production (by touch device via DMA)."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:22
msgid ""
"Unlike other common SPI/I2C controllers, THC handles the HID device data "
"interrupt and reset signals directly."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:26
msgid "1. Overview"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:29
msgid "1.1 THC software/hardware stack"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:31
msgid ""
"Below diagram illustrates the high-level architecture of THC software/"
"hardware stack, which is fully capable of supporting HIDSPI/HIDI2C protocol "
"in Linux OS."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:68
msgid ""
"Touch IC (TIC), also as known as the Touch devices (touchscreen or "
"touchpad). The discrete analog components that sense and transfer either "
"discrete touch data or heatmap data in the form of HID reports over the SPI/"
"I2C bus to the THC Controller on the host."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:72
msgid ""
"THC Host Controller, which is a PCI device HBA (host bus adapter), "
"integrated into the PCH, that serves as a bridge between the Touch ICs and "
"the host."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:75
msgid ""
"THC Hardware Driver, provides THC hardware operation APIs for above QuickSPI/"
"QuickI2C driver, it accesses THC MMIO registers to configure and control THC "
"hardware."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:78
msgid ""
"THC QuickSPI/QuickI2C driver, also as known as HIDSPI/HIDI2C driver, is "
"registered as a HID low-level driver that manages the THC Controller and "
"implements HIDSPI/HIDI2C protocol."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:83
msgid "1.2 THC hardware diagram"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:84
msgid "Below diagram shows THC hardware components::"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:106
msgid ""
"As THC is exposed as a PCI devices, so it has standard PCI config space "
"registers for PCI enumeration and configuration."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:109
msgid ""
"MMIO Registers, which provide registers access for driver to configure and "
"control THC hardware, the registers include several categories: Interrupt "
"status and control, DMA configure, PIO (Programmed I/O, defined in section "
"3.2) status and control, SPI bus configure, I2C subIP status and control, "
"reset status and control..."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:114
msgid ""
"THC provides two ways for driver to communicate with external Touch ICs: PIO "
"and DMA. PIO can let driver manually write/read data to/from Touch ICs, "
"instead, THC DMA can automatically write/read data without driver involved."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:118
msgid ""
"HW Sequencer includes THC major logic, it gets instruction from MMIO "
"registers to control SPI bus and I2C bus to finish a bus data transaction, "
"it also can automatically handle Touch ICs interrupt and start DMA receive/"
"send data from/to Touch ICs according to interrupt type. That means THC HW "
"Sequencer understands HIDSPI/HIDI2C transfer protocol, and handle the "
"communication without driver involved, what driver needs to do is just "
"configure the THC properly, and prepare the formatted data packet or handle "
"received data packet."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:125
msgid ""
"As THC supports HIDSPI/HIDI2C protocols, it has SPI controller and I2C subIP "
"in it to expose SPI bus and I2C bus. THC also integrates a GPIO controller "
"to provide interrupt line support and reset line support."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:130
msgid "2. THC Hardware Interface"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:133
msgid "2.1 Host Interface"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:135
msgid ""
"THC is exposed as \"PCI Digitizer device\" to the host. The PCI product and "
"device IDs are changed from different generations of processors. So the "
"source code which enumerates drivers needs to update from generation to "
"generation."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:141
msgid "2.2 Device Interface"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:143
msgid ""
"THC supports two types of bus for Touch IC connection: Enhanced SPI bus and "
"I2C bus."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:146
msgid "2.2.1 SPI Port"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:148
msgid ""
"When PORT_TYPE = 00b in MMIO registers, THC uses SPI interfaces to "
"communicate with external Touch IC. THC enhanced SPI Bus supports different "
"SPI modes: standard Single IO mode, Dual IO mode and Quad IO mode."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:152
msgid ""
"In Single IO mode, THC drives MOSI line to send data to Touch ICs, and "
"receives data from Touch ICs data from MISO line. In Dual IO mode, THC "
"drivers MOSI and MISO both for data sending, and also receives the data on "
"both line. In Quad IO mode, there are other two lines (IO2 and IO3) are "
"added, THC drives MOSI (IO0), MISO (IO1), IO2 and IO3 at the same time for "
"data sending, and also receives the data on those 4 lines. Driver needs to "
"configure THC in different mode by setting different opcode."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:159
msgid ""
"Beside IO mode, driver also needs to configure SPI bus speed. THC supports "
"up to 42MHz SPI clock on Intel Lunar Lake platform."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:162
msgid "For THC sending data to Touch IC, the data flow on SPI bus::"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:167
msgid "For THC receiving data from Touch IC, the data flow on SPI bus::"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:173
msgid "2.2.2 I2C Port"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:175
msgid ""
"THC also integrates I2C controller in it, it's called I2C SubSystem. When "
"PORT_TYPE = 01, THC is configured to I2C mode. Comparing to SPI mode which "
"can be configured through MMIO registers directly, THC needs to use PIO read "
"(by setting SubIP read opcode) to I2C subIP APB registers' value and use PIO "
"write (by setting SubIP write opcode) to do a write operation."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:181
msgid "2.2.3 GPIO interface"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:183
msgid ""
"THC also includes two GPIO pins, one for interrupt and the other for device "
"reset control."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:185
msgid ""
"Interrupt line can be configured to either level triggered or edge triggered "
"by setting MMIO Control register."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:188
msgid ""
"Reset line is controlled by BIOS (or EFI) through ACPI _RST method, driver "
"needs to call this device ACPI _RST method to reset touch IC during "
"initialization."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:192
msgid "2.3 Max input size control"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:194
msgid ""
"This is a new feature introduced in Panther Lake platform, THC hardware "
"allows driver to set a max input size for RxDMA. After this max size gets "
"set and enabled, for every input report packet reading, THC hardware "
"sequencer will first read incoming input packet size, then compare input "
"packet size with the given max size:"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:199
msgid ""
"if input packet size <= max size, THC continues using input packet size to "
"finish the reading"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:200
msgid ""
"if input packet size > max size, there is potential input data crash risk "
"during transferring, THC will use max size instead of input packet size for "
"reading"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:203
msgid ""
"This feature is used to avoid data corruption which will cause RxDMA buffer "
"overrun issue for I2C bus, and enhance whole system stability."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:207
msgid "2.4 Interrupt delay"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:209
msgid ""
"Because of MCU performance limitation, some touch devices cannot de-assert "
"interrupt pin immediately after input data is transferred, which cause an "
"interrupt toggle delay. But THC always detects next interrupt immediately "
"after last input interrupt is handled. In this case, the delayed interrupt "
"de-assertion will be recognized as a new interrupt signal by THC, and causes "
"THC to start an input report reading spuriously."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:215
msgid ""
"In order to avoid this situation, THC introduced interrupt delay new feature "
"in Panther Lake platform, where THC allows driver to set an interrupt delay. "
"After this feature is enabled, THC will delay this given time for next "
"interrupt detection."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:220
msgid "3. High level concept"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:223
msgid "3.1 Opcode"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:225
msgid ""
"Opcode (operation code) is used to tell THC or Touch IC what the operation "
"will be, such as PIO read or PIO write."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:228
msgid ""
"When THC is configured to SPI mode, opcodes are used for determining the "
"read/write IO mode. There are some OPCode examples for SPI IO mode:"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:232 ../../../hid/intel-thc-hid.rst:254
msgid "opcode"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:232
msgid "Corresponding SPI command"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:234
msgid "0x0B"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:234
msgid "Read Single I/O"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:235
msgid "0x02"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:235
msgid "Write Single I/O"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:236
msgid "0xBB"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:236
msgid "Read Dual I/O"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:237
msgid "0xB2"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:237
msgid "Write Dual I/O"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:238
msgid "0xEB"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:238
msgid "Read Quad I/O"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:239
msgid "0xE2"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:239
msgid "Write Quad I/O"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:242
msgid ""
"In general, different touch IC has different OPCode definition. According to "
"HIDSPI protocol whitepaper, those OPCodes are defined in device ACPI table, "
"and driver needs to query those information through OS ACPI APIs during "
"driver initialization, then configures THC MMIO OPCode registers with "
"correct setting."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:247
msgid ""
"When THC is working in I2C mode, opcodes are used to tell THC what's the "
"next PIO type: I2C SubIP APB register read, I2C SubIP APB register write, "
"I2C touch IC device read, I2C touch IC device write, I2C touch IC device "
"write followed by read."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:251
msgid "Here are the THC pre-defined opcodes for I2C mode:"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:254
msgid "Corresponding I2C command"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:254
msgid "Address"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:256
msgid "0x12"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:256
msgid "Read I2C SubIP APB internal registers"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:256 ../../../hid/intel-thc-hid.rst:257
msgid "0h - FFh"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:257
msgid "0x13"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:257
msgid "Write I2C SubIP APB internal registers"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:258
msgid "0x14"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:258
msgid "Read external Touch IC through I2C bus"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:258 ../../../hid/intel-thc-hid.rst:259
#: ../../../hid/intel-thc-hid.rst:260
msgid "N/A"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:259
msgid "0x18"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:259
msgid "Write external Touch IC through I2C bus"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:260
msgid "0x1C"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:260
msgid "Write then read external Touch IC through I2C bus"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:264
msgid "3.2 PIO"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:266
msgid ""
"THC provides a programmed I/O (PIO) access interface for the driver to "
"access the touch IC's configuration registers, or access I2C subIP's "
"configuration registers. To use PIO to perform I/O operations, driver should "
"pre-program PIO control registers and PIO data registers and kick off the "
"sequencing cycle. THC uses different PIO opcodes to distinguish different "
"PIO operations (PIO read/write/write followed by read)."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:272
msgid ""
"If there is a Sequencing Cycle In Progress and an attempt is made to program "
"any of the control, address, or data register the cycle is blocked and a "
"sequence error will be encountered."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:275
msgid ""
"A status bit indicates when the cycle has completed allowing the driver to "
"know when read results can be checked and/or when to initiate a new command. "
"If enabled, the cycle done assertion can interrupt driver with an interrupt."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:279
msgid ""
"Because THC only has 16 FIFO registers for PIO, so all the data transfer "
"through PIO shouldn't exceed 64 bytes."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:282
msgid ""
"As DMA needs max packet size for transferring configuration, and the max "
"packet size information always in HID device descriptor which needs THC "
"driver to read it out from HID Device (Touch IC). So PIO typical use case "
"is, before DMA initialization, write RESET command (PIO write), read RESET "
"response (PIO read or PIO write followed by read), write Power ON command "
"(PIO write), read device descriptor (PIO read)."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:288
msgid ""
"For how to issue a PIO operation, here is the steps which driver needs "
"follow:"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:290
msgid "Program read/write data size in THC_SS_BC."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:291
msgid "Program I/O target address in THC_SW_SEQ_DATA0_ADDR."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:292
msgid "If write, program the write data in THC_SW_SEQ_DATA0..THC_SW_SEQ_DATAn."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:293
msgid "Program the PIO opcode in THC_SS_CMD."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:294
msgid "Set TSSGO = 1 to start the PIO write sequence."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:295
msgid "If THC_SS_CD_IE = 1, SW will receives a MSI when the PIO is completed."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:296
msgid "If read, read out the data in THC_SW_SEQ_DATA0..THC_SW_SEQ_DATAn."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:299
msgid "3.3 DMA"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:301
msgid ""
"THC has 4 DMA channels: Read DMA1, Read DMA2, Write DMA and Software DMA."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:304
msgid "3.3.1 Read DMA Channel"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:306
msgid ""
"THC has two Read DMA engines: 1st RxDMA (RxDMA1) and 2nd RxDMA (RxDMA2). "
"RxDMA1 is reserved for raw data mode. RxDMA2 is used for HID data mode and "
"it is the RxDMA engine currently driver uses for HID input report data "
"retrieval."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:310
msgid ""
"RxDMA's typical use case is auto receiving the data from Touch IC. Once "
"RxDMA is enabled by software, THC will start auto-handling receiving logic."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:313
msgid ""
"For SPI mode, THC RxDMA sequence is: when Touch IC triggers a interrupt to "
"THC, THC reads out report header to identify what's the report type, and "
"what's the report length, according to above information, THC reads out "
"report body to internal FIFO and start RxDMA coping the data to system "
"memory. After that, THC update interrupt cause register with report type, "
"and update RxDMA PRD table read pointer, then trigger a MSI interrupt to "
"notify driver RxDMA finishing data receiving."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:320
msgid ""
"For I2C mode, THC RxDMA's behavior is a little bit different, because of "
"HIDI2C protocol difference with HIDSPI protocol, RxDMA only be used to "
"receive input report. The sequence is, when Touch IC triggers a interrupt to "
"THC, THC first reads out 2 bytes from input report address to determine the "
"packet length, then use this packet length to start a DMA reading from input "
"report address for input report data. After that, THC update RxDMA PRD table "
"read pointer, then trigger a MSI interrupt to notify driver input report "
"data is ready in system memory."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:327
msgid ""
"All above sequence is hardware automatically handled, all driver needs to do "
"is configure RxDMA and waiting for interrupt ready then read out the data "
"from system memory."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:331
msgid "3.3.2 Software DMA channel"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:333
msgid ""
"THC supports a software triggered RxDMA mode to read the touch data from "
"touch IC. This SW RxDMA is the 3rd THC RxDMA engine with the similar "
"functionalities as the existing two RxDMAs, the only difference is this SW "
"RxDMA is triggered by software, and RxDMA2 is triggered by external Touch IC "
"interrupt. It gives a flexibility to software driver to use RxDMA read Touch "
"IC data in any time."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:338
msgid ""
"Before software starts a SW RxDMA, it shall stop the 1st and 2nd RxDMA, "
"clear PRD read/write pointer and quiesce the device interrupt "
"(THC_DEVINT_QUIESCE_HW_STS = 1), other operations are the same with RxDMA."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:343
msgid "3.3.3 Write DMA Channel"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:345
msgid ""
"THC has one write DMA engine, which can be used for sending data to Touch IC "
"automatically. According to HIDSPI and HIDI2C protocol, every time only one "
"command can be sent to touch IC, and before last command is completely "
"handled, next command cannot be sent, THC write DMA engine only supports "
"single PRD table."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:350
msgid ""
"What driver needs to do is, preparing PRD table and DMA buffer, then copy "
"data to DMA buffer and update PRD table with buffer address and buffer "
"length, then start write DMA. THC will automatically send the data to touch "
"IC, and trigger a DMA completion interrupt once transferring is done."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:356
msgid "3.4 PRD"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:358
msgid ""
"Physical Region Descriptor (PRD) provides the memory mapping description for "
"THC DMAs."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:361
msgid "3.4.1 PRD table and entry"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:363
msgid ""
"In order to improve physical DMA memory usage, modern drivers trend to "
"allocate a virtually contiguous, but physically fragmented buffer of memory "
"for each data buffer. Linux OS also provide SGL (scatter gather list) APIs "
"to support this usage."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:367
msgid ""
"THC uses PRD table (physical region descriptor) to support the corresponding "
"OS kernel SGL that describes the virtual to physical buffer mapping."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:382
msgid ""
"The read DMA engine supports multiple PRD tables held within a circular "
"buffer that allow the THC to support multiple data buffers from the Touch "
"IC. This allows host SW to arm the Read DMA engine with multiple buffers, "
"allowing the Touch IC to send multiple data frames to the THC without SW "
"interaction. This capability is required when the CPU processes touch frames "
"slower than the Touch IC can send them."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:388
msgid ""
"To simplify the design, SW assumes worst-case memory fragmentation. "
"Therefore,each PRD table shall contain the same number of PRD entries, "
"allowing for a global register (per Touch IC) to hold the number of PRD-"
"entries per PRD table."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:392
msgid ""
"SW allocates up to 128 PRD tables per Read DMA engine as specified in the "
"THC_M_PRT_RPRD_CNTRL.PCD register field. The number of PRD tables should "
"equal the number of data buffers."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:395
msgid ""
"Max OS memory fragmentation will be at a 4KB boundary, thus to address 1MB "
"of virtually contiguous memory 256 PRD entries are required for a single PRD "
"Table. SW writes the number of PRD entries for each PRD table in the "
"THC_M_PRT_RPRD_CNTRL.PTEC register field. The PRD entry's length must be "
"multiple of 4KB except for the last entry in a PRD table."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:400
msgid ""
"SW allocates all the data buffers and PRD tables only once at host "
"initialization."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:403
msgid "3.4.2 PRD Write pointer and read pointer"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:405
msgid ""
"As PRD tables are organized as a Circular Buffer (CB), a read pointer and a "
"write pointer for a CB are needed."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:408
msgid ""
"DMA HW consumes the PRD tables in the CB, one PRD entry at a time until the "
"EOP bit is found set in a PRD entry. At this point HW increments the PRD "
"read pointer. Thus, the read pointer points to the PRD which the DMA engine "
"is currently processing. This pointer rolls over once the circular buffer's "
"depth has been traversed with bit[7] the Rollover bit. E.g. if the DMA CB "
"depth is equal to 4 entries (0011b), then the read pointers will follow this "
"pattern (HW is required to honor this behavior): 00h 01h 02h 03h 80h 81h 82h "
"83h 00h 01h ..."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:415
msgid ""
"The write pointer is updated by SW. The write pointer points to location in "
"the DMA CB, where the next PRD table is going to be stored. SW needs to "
"ensure that this pointer rolls over once the circular buffer's depth has "
"been traversed with Bit[7] as the rollover bit. E.g. if the DMA CB depth is "
"equal to 5 entries (0100b), then the write pointers will follow this pattern "
"(SW is required to honor this behavior): 00h 01h 02h 03h 04h 80h 81h 82h 83h "
"84h 00h 01h .."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:422
msgid "3.4.3 PRD descriptor structure"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:424
msgid ""
"Intel THC uses PRD entry descriptor for every PRD entry. Every PRD entry "
"descriptor occupies 128 bits memories:"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:428
msgid "struct field"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:428
msgid "bit(s)"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:428
msgid "description"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:430
msgid "dest_addr"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:430
msgid "53..0"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:430
msgid ""
"destination memory address, as every entry is 4KB, ignore lowest 10 bits of "
"address."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:432
msgid "reserved1"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:432
msgid "54..62"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:432 ../../../hid/intel-thc-hid.rst:441
msgid "reserved"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:433
msgid "int_on_completion"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:433
msgid "63"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:433
msgid ""
"completion interrupt enable bit, if this bit set it means THC will trigger a "
"completion interrupt. This bit is set by SW driver."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:436
msgid "len"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:436
msgid "87..64"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:436
msgid "how many bytes of data in this entry."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:437
msgid "end_of_prd"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:437
msgid "88"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:437
msgid ""
"end of PRD table bit, if this bit is set, it means this entry is last entry "
"in this PRD table. This bit is set by SW driver."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:440
msgid "hw_status"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:440
msgid "90..89"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:440
msgid "HW status bits"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:441
msgid "reserved2"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:441
msgid "127..91"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:444
msgid ""
"And one PRD table can include up to 256 PRD entries, as every entries is 4K "
"bytes, so every PRD table can describe 1M bytes memory."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:453
msgid ""
"In general, every PRD table means one HID touch data packet. Every DMA "
"engine can support up to 128 PRD tables (except write DMA, write DMA only "
"has one PRD table). SW driver is responsible to get max packet length from "
"touch IC, and use this max packet length to create PRD entries for each PRD "
"table."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:459
msgid "4. HIDSPI support (QuickSPI)"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:461
msgid ""
"Intel THC is total compatible with HIDSPI protocol, THC HW sequenser can "
"accelerate HIDSPI protocol transferring."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:465
msgid "4.1 Reset Flow"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:467
msgid "Call ACPI _RST method to reset Touch IC device."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:468
msgid "Read the reset response from TIC through PIO read."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:469
msgid ""
"Issue a command to retrieve device descriptor from Touch IC through PIO "
"write."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:470
msgid "Read the device descriptor from Touch IC through PIO read."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:471 ../../../hid/intel-thc-hid.rst:527
msgid ""
"If the device descriptor is valid, allocate DMA buffers and configure all "
"DMA channels."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:472
msgid ""
"Issue a command to retrieve report descriptor from Touch IC through DMA."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:475
msgid "4.2 Input Report Data Flow"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:477 ../../../hid/intel-thc-hid.rst:537
msgid "Basic Flow:"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:479
msgid "Touch IC interrupts the THC Controller using an in-band THC interrupt."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:480
msgid ""
"THC Sequencer reads the input report header by transmitting read approval as "
"a signal to the Touch IC to prepare for host to read from the device."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:482
msgid ""
"THC Sequencer executes a Input Report Body Read operation corresponding to "
"the value reflected in “Input Report Length” field of the Input Report "
"Header."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:484
msgid ""
"THC DMA engine begins fetching data from the THC Sequencer and writes to "
"host memory at PRD entry 0 for the current CB PRD table entry. This process "
"continues until the THC Sequencer signals all data has been read or the THC "
"DMA Read Engine reaches the end of it's last PRD entry (or both)."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:488
msgid ""
"The THC Sequencer checks for the “Last Fragment Flag” bit in the Input "
"Report Header. If it is clear, the THC Sequencer enters an idle state."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:490
msgid ""
"If the “Last Fragment Flag” bit is enabled the THC Sequencer enters End-of-"
"Frame Processing."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:492
msgid "THC Sequencer End of Frame Processing:"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:494
msgid ""
"THC DMA engine increments the read pointer of the Read PRD CB, sets EOF "
"interrupt status in RxDMA2 register (THC_M_PRT_READ_DMA_INT_STS_2)."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:496 ../../../hid/intel-thc-hid.rst:558
msgid ""
"If THC EOF interrupt is enabled by the driver in the control register "
"(THC_M_PRT_READ_DMA_CNTRL_2), generates interrupt to software."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:499 ../../../hid/intel-thc-hid.rst:561
msgid "Sequence of steps to read data from RX DMA buffer:"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:501
msgid ""
"THC QuickSPI driver checks CB write Ptr and CB read Ptr to identify if any "
"data frame in DMA circular buffers."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:503
msgid "THC QuickSPI driver gets first unprocessed PRD table."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:504
msgid ""
"THC QuickSPI driver scans all PRD entries in this PRD table to calculate the "
"total frame size."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:505
msgid "THC QuickSPI driver copies all frame data out."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:506
msgid ""
"THC QuickSPI driver checks the data type according to input report body, and "
"calls related callbacks to process the data."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:508
msgid "THC QuickSPI driver updates write Ptr."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:511
msgid "4.3 Output Report Data Flow"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:513 ../../../hid/intel-thc-hid.rst:576
msgid "Generic Output Report Flow:"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:515
msgid ""
"HID core calls raw_request callback with a request to THC QuickSPI driver."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:516
msgid ""
"THC QuickSPI Driver converts request provided data into the output report "
"packet and copies it to THC's write DMA buffer."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:518
msgid "Start TxDMA to complete the write operation."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:521
msgid "5. HIDI2C support (QuickI2C)"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:524
msgid "5.1 Reset Flow"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:526
msgid ""
"Read device descriptor from Touch IC device through PIO write followed by "
"read."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:528
msgid ""
"Use PIO or TxDMA to write a SET_POWER request to TIC's command register, and "
"check if the write operation is successfully completed."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:530
msgid ""
"Use PIO or TxDMA to write a RESET request to TIC's command register. If the "
"write operation is successfully completed, wait for reset response from TIC."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:532
msgid ""
"Use SWDMA to read report descriptor through TIC's report descriptor register."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:535
msgid "5.2 Input Report Data Flow"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:539
msgid ""
"Touch IC asserts the interrupt indicating that it has an interrupt to send "
"to HOST. THC Sequencer issues a READ request over the I2C bus. The HIDI2C "
"device returns the first 2 bytes from the HIDI2C device which contains the "
"length of the received data."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:542
msgid ""
"THC Sequencer continues the Read operation as per the size of data indicated "
"in the length field."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:544
msgid ""
"THC DMA engine begins fetching data from the THC Sequencer and writes to "
"host memory at PRD entry 0 for the current CB PRD table entry. THC writes "
"2Bytes for length field plus the remaining data to RxDMA buffer. This "
"process continues until the THC Sequencer signals all data has been read or "
"the THC DMA Read Engine reaches the end of it's last PRD entry (or both)."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:549
msgid "THC Sequencer enters End-of-Input Report Processing."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:550
msgid ""
"If the device has no more input reports to send to the host, it de-asserts "
"the interrupt line. For any additional input reports, device keeps the "
"interrupt line asserted and steps 1 through 4 in the flow are repeated."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:554
msgid "THC Sequencer End of Input Report Processing:"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:556
msgid ""
"THC DMA engine increments the read pointer of the Read PRD CB, sets EOF "
"interrupt status in RxDMA 2 register (THC_M_PRT_READ_DMA_INT_STS_2)."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:563
msgid ""
"THC QuickI2C driver checks CB write Ptr and CB read Ptr to identify if any "
"data frame in DMA circular buffers."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:565
msgid "THC QuickI2C driver gets first unprocessed PRD table."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:566
msgid ""
"THC QuickI2C driver scans all PRD entries in this PRD table to calculate the "
"total frame size."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:567
msgid "THC QuickI2C driver copies all frame data out."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:568
msgid ""
"THC QuickI2C driver call hid_input_report to send the input report content "
"to HID core, which includes Report ID + Report Data Content (remove the "
"length field from the original report data)."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:571
msgid "THC QuickI2C driver updates write Ptr."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:574
msgid "5.3 Output Report Data Flow"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:578
msgid "HID core call THC QuickI2C raw_request callback."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:579
msgid ""
"THC QuickI2C uses PIO or TXDMA to write a SET_REPORT request to TIC's "
"command register. Report type in SET_REPORT should be set to Output."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:581
msgid ""
"THC QuickI2C programs TxDMA buffer with TX Data to be written to TIC's data "
"register. The first 2 bytes should indicate the length of the report "
"followed by the report contents including Report ID."
msgstr ""

#: ../../../hid/intel-thc-hid.rst:586
msgid "6. THC Debugging"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:588
msgid "To debug THC, event tracing mechanism is used. To enable debug logs::"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:594
msgid "7. Reference"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:595
msgid ""
"HIDSPI: https://download.microsoft.com/download/c/a/0/ca07aef3-3e10-4022-"
"b1e9-c98cea99465d/HidSpiProtocolSpec.pdf"
msgstr ""

#: ../../../hid/intel-thc-hid.rst:596
msgid ""
"HIDI2C: https://download.microsoft.com/download/7/d/d/7dd44bb7-2a7a-4505-"
"ac1c-7227d3d96d5b/hid-over-i2c-protocol-spec-v1-0.docx"
msgstr ""
