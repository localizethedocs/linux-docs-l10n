# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-06 06:05+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../power/pm_qos_interface.rst:3
msgid "PM Quality Of Service Interface"
msgstr ""

#: ../../../power/pm_qos_interface.rst:5
msgid ""
"This interface provides a kernel and user mode interface for registering "
"performance expectations by drivers, subsystems and user space applications "
"on one of the parameters."
msgstr ""

#: ../../../power/pm_qos_interface.rst:9
msgid "Two different PM QoS frameworks are available:"
msgstr ""

#: ../../../power/pm_qos_interface.rst:10
msgid "CPU latency QoS."
msgstr ""

#: ../../../power/pm_qos_interface.rst:11
msgid ""
"The per-device PM QoS framework provides the API to manage the per-device "
"latency constraints and PM QoS flags."
msgstr ""

#: ../../../power/pm_qos_interface.rst:14
msgid ""
"The latency unit used in the PM QoS framework is the microsecond (usec)."
msgstr ""

#: ../../../power/pm_qos_interface.rst:18
msgid "1. PM QoS framework"
msgstr ""

#: ../../../power/pm_qos_interface.rst:20
msgid ""
"A global list of CPU latency QoS requests is maintained along with an "
"aggregated (effective) target value.  The aggregated target value is updated "
"with changes to the request list or elements of the list.  For CPU latency "
"QoS, the aggregated target value is simply the min of the request values "
"held in the list elements."
msgstr ""

#: ../../../power/pm_qos_interface.rst:26
msgid ""
"Note: the aggregated target value is implemented as an atomic variable so "
"that reading the aggregated value does not require any locking mechanism."
msgstr ""

#: ../../../power/pm_qos_interface.rst:29
msgid "From kernel space the use of this interface is simple:"
msgstr ""

#: ../../../power/pm_qos_interface.rst:31
msgid "void cpu_latency_qos_add_request(handle, target_value):"
msgstr ""

#: ../../../power/pm_qos_interface.rst:32
msgid ""
"Will insert an element into the CPU latency QoS list with the target value. "
"Upon change to this list the new target is recomputed and any registered "
"notifiers are called only if the target value is now different. Clients of "
"PM QoS need to save the returned handle for future use in other PM QoS API "
"functions."
msgstr ""

#: ../../../power/pm_qos_interface.rst:38
msgid "void cpu_latency_qos_update_request(handle, new_target_value):"
msgstr ""

#: ../../../power/pm_qos_interface.rst:39
msgid ""
"Will update the list element pointed to by the handle with the new target "
"value and recompute the new aggregated target, calling the notification tree "
"if the target is changed."
msgstr ""

#: ../../../power/pm_qos_interface.rst:43
msgid "void cpu_latency_qos_remove_request(handle):"
msgstr ""

#: ../../../power/pm_qos_interface.rst:44
msgid ""
"Will remove the element.  After removal it will update the aggregate target "
"and call the notification tree if the target was changed as a result of "
"removing the request."
msgstr ""

#: ../../../power/pm_qos_interface.rst:48
msgid "int cpu_latency_qos_limit():"
msgstr ""

#: ../../../power/pm_qos_interface.rst:49
msgid "Returns the aggregated value for the CPU latency QoS."
msgstr ""

#: ../../../power/pm_qos_interface.rst:51
msgid "int cpu_latency_qos_request_active(handle):"
msgstr ""

#: ../../../power/pm_qos_interface.rst:52
msgid ""
"Returns if the request is still active, i.e. it has not been removed from "
"the CPU latency QoS list."
msgstr ""

#: ../../../power/pm_qos_interface.rst:56
msgid "From user space:"
msgstr ""

#: ../../../power/pm_qos_interface.rst:58
msgid ""
"The infrastructure exposes two separate device nodes, /dev/cpu_dma_latency "
"for the CPU latency QoS and /dev/cpu_wakeup_latency for the CPU system "
"wakeup latency QoS."
msgstr ""

#: ../../../power/pm_qos_interface.rst:62
msgid ""
"Only processes can register a PM QoS request.  To provide for automatic "
"cleanup of a process, the interface requires the process to register its "
"parameter requests as follows."
msgstr ""

#: ../../../power/pm_qos_interface.rst:66
msgid ""
"To register the default PM QoS target for the CPU latency QoS, the process "
"must open /dev/cpu_dma_latency.  To register a CPU system wakeup QoS limit, "
"the process must open /dev/cpu_wakeup_latency."
msgstr ""

#: ../../../power/pm_qos_interface.rst:70
msgid ""
"As long as the device node is held open that process has a registered "
"request on the parameter."
msgstr ""

#: ../../../power/pm_qos_interface.rst:73
msgid ""
"To change the requested target value, the process needs to write an s32 "
"value to the open device node.  Alternatively, it can write a hex string for "
"the value using the 10 char long format e.g. \"0x12345678\"."
msgstr ""

#: ../../../power/pm_qos_interface.rst:77
msgid ""
"To remove the user mode request for a target value simply close the device "
"node."
msgstr ""

#: ../../../power/pm_qos_interface.rst:82
msgid "2. PM QoS per-device latency and flags framework"
msgstr ""

#: ../../../power/pm_qos_interface.rst:84
msgid ""
"For each device, there are three lists of PM QoS requests. Two of them are "
"maintained along with the aggregated targets of resume latency and active "
"state latency tolerance (in microseconds) and the third one is for PM QoS "
"flags. Values are updated in response to changes of the request list."
msgstr ""

#: ../../../power/pm_qos_interface.rst:89
msgid ""
"The target values of resume latency and active state latency tolerance are "
"simply the minimum of the request values held in the parameter list "
"elements. The PM QoS flags aggregate value is a gather (bitwise OR) of all "
"list elements' values.  One device PM QoS flag is defined currently: "
"PM_QOS_FLAG_NO_POWER_OFF."
msgstr ""

#: ../../../power/pm_qos_interface.rst:94
msgid ""
"Note: The aggregated target values are implemented in such a way that "
"reading the aggregated value does not require any locking mechanism."
msgstr ""

#: ../../../power/pm_qos_interface.rst:98
msgid "From kernel mode the use of this interface is the following:"
msgstr ""

#: ../../../power/pm_qos_interface.rst:100
msgid "int dev_pm_qos_add_request(device, handle, type, value):"
msgstr ""

#: ../../../power/pm_qos_interface.rst:101
msgid ""
"Will insert an element into the list for that identified device with the "
"target value.  Upon change to this list the new target is recomputed and any "
"registered notifiers are called only if the target value is now different. "
"Clients of dev_pm_qos need to save the handle for future use in other "
"dev_pm_qos API functions."
msgstr ""

#: ../../../power/pm_qos_interface.rst:107
msgid "int dev_pm_qos_update_request(handle, new_value):"
msgstr ""

#: ../../../power/pm_qos_interface.rst:108
msgid ""
"Will update the list element pointed to by the handle with the new target "
"value and recompute the new aggregated target, calling the notification "
"trees if the target is changed."
msgstr ""

#: ../../../power/pm_qos_interface.rst:112
msgid "int dev_pm_qos_remove_request(handle):"
msgstr ""

#: ../../../power/pm_qos_interface.rst:113
msgid ""
"Will remove the element.  After removal it will update the aggregate target "
"and call the notification trees if the target was changed as a result of "
"removing the request."
msgstr ""

#: ../../../power/pm_qos_interface.rst:117
msgid "s32 dev_pm_qos_read_value(device, type):"
msgstr ""

#: ../../../power/pm_qos_interface.rst:118
msgid "Returns the aggregated value for a given device's constraints list."
msgstr ""

#: ../../../power/pm_qos_interface.rst:120
msgid "enum pm_qos_flags_status dev_pm_qos_flags(device, mask)"
msgstr ""

#: ../../../power/pm_qos_interface.rst:121
msgid ""
"Check PM QoS flags of the given device against the given mask of flags. The "
"meaning of the return values is as follows:"
msgstr ""

#: ../../../power/pm_qos_interface.rst:124
msgid "PM_QOS_FLAGS_ALL:"
msgstr ""

#: ../../../power/pm_qos_interface.rst:125
msgid "All flags from the mask are set"
msgstr ""

#: ../../../power/pm_qos_interface.rst:126
msgid "PM_QOS_FLAGS_SOME:"
msgstr ""

#: ../../../power/pm_qos_interface.rst:127
msgid "Some flags from the mask are set"
msgstr ""

#: ../../../power/pm_qos_interface.rst:128
msgid "PM_QOS_FLAGS_NONE:"
msgstr ""

#: ../../../power/pm_qos_interface.rst:129
msgid "No flags from the mask are set"
msgstr ""

#: ../../../power/pm_qos_interface.rst:130
msgid "PM_QOS_FLAGS_UNDEFINED:"
msgstr ""

#: ../../../power/pm_qos_interface.rst:131
msgid ""
"The device's PM QoS structure has not been initialized or the list of "
"requests is empty."
msgstr ""

#: ../../../power/pm_qos_interface.rst:134
msgid "int dev_pm_qos_add_ancestor_request(dev, handle, type, value)"
msgstr ""

#: ../../../power/pm_qos_interface.rst:135
msgid ""
"Add a PM QoS request for the first direct ancestor of the given device whose "
"power.ignore_children flag is unset (for DEV_PM_QOS_RESUME_LATENCY requests) "
"or whose power.set_latency_tolerance callback pointer is not NULL (for "
"DEV_PM_QOS_LATENCY_TOLERANCE requests)."
msgstr ""

#: ../../../power/pm_qos_interface.rst:140
msgid "int dev_pm_qos_expose_latency_limit(device, value)"
msgstr ""

#: ../../../power/pm_qos_interface.rst:141
msgid ""
"Add a request to the device's PM QoS list of resume latency constraints and "
"create a sysfs attribute pm_qos_resume_latency_us under the device's power "
"directory allowing user space to manipulate that request."
msgstr ""

#: ../../../power/pm_qos_interface.rst:145
msgid "void dev_pm_qos_hide_latency_limit(device)"
msgstr ""

#: ../../../power/pm_qos_interface.rst:146
msgid ""
"Drop the request added by dev_pm_qos_expose_latency_limit() from the "
"device's PM QoS list of resume latency constraints and remove sysfs "
"attribute pm_qos_resume_latency_us from the device's power directory."
msgstr ""

#: ../../../power/pm_qos_interface.rst:150
msgid "int dev_pm_qos_expose_flags(device, value)"
msgstr ""

#: ../../../power/pm_qos_interface.rst:151
msgid ""
"Add a request to the device's PM QoS list of flags and create sysfs "
"attribute pm_qos_no_power_off under the device's power directory allowing "
"user space to change the value of the PM_QOS_FLAG_NO_POWER_OFF flag."
msgstr ""

#: ../../../power/pm_qos_interface.rst:155
msgid "void dev_pm_qos_hide_flags(device)"
msgstr ""

#: ../../../power/pm_qos_interface.rst:156
msgid ""
"Drop the request added by dev_pm_qos_expose_flags() from the device's PM QoS "
"list of flags and remove sysfs attribute pm_qos_no_power_off from the "
"device's power directory."
msgstr ""

#: ../../../power/pm_qos_interface.rst:160
msgid "Notification mechanisms:"
msgstr ""

#: ../../../power/pm_qos_interface.rst:162
msgid "The per-device PM QoS framework has a per-device notification tree."
msgstr ""

#: ../../../power/pm_qos_interface.rst:164
msgid "int dev_pm_qos_add_notifier(device, notifier, type):"
msgstr ""

#: ../../../power/pm_qos_interface.rst:165
msgid ""
"Adds a notification callback function for the device for a particular "
"request type."
msgstr ""

#: ../../../power/pm_qos_interface.rst:168
msgid ""
"The callback is called when the aggregated value of the device constraints "
"list is changed."
msgstr ""

#: ../../../power/pm_qos_interface.rst:171
msgid "int dev_pm_qos_remove_notifier(device, notifier, type):"
msgstr ""

#: ../../../power/pm_qos_interface.rst:172
msgid "Removes the notification callback function for the device."
msgstr ""

#: ../../../power/pm_qos_interface.rst:176
msgid "Active state latency tolerance"
msgstr ""

#: ../../../power/pm_qos_interface.rst:178
msgid ""
"This device PM QoS type is used to support systems in which hardware may "
"switch to energy-saving operation modes on the fly.  In those systems, if "
"the operation mode chosen by the hardware attempts to save energy in an "
"overly aggressive way, it may cause excess latencies to be visible to "
"software, causing it to miss certain protocol requirements or target frame "
"or sample rates etc."
msgstr ""

#: ../../../power/pm_qos_interface.rst:184
msgid ""
"If there is a latency tolerance control mechanism for a given device "
"available to software, the .set_latency_tolerance callback in that device's "
"dev_pm_info structure should be populated.  The routine pointed to by it is "
"should implement whatever is necessary to transfer the effective requirement "
"value to the hardware."
msgstr ""

#: ../../../power/pm_qos_interface.rst:190
msgid ""
"Whenever the effective latency tolerance changes for the device, its ."
"set_latency_tolerance() callback will be executed and the effective value "
"will be passed to it.  If that value is negative, which means that the list "
"of latency tolerance requirements for the device is empty, the callback is "
"expected to switch the underlying hardware latency tolerance control "
"mechanism to an autonomous mode if available.  If that value is "
"PM_QOS_LATENCY_ANY, in turn, and the hardware supports a special \"no "
"requirement\" setting, the callback is expected to use it.  That allows "
"software to prevent the hardware from automatically updating the device's "
"latency tolerance in response to its power state changes (e.g. during "
"transitions from D3cold to D0), which generally may be done in the "
"autonomous latency tolerance control mode."
msgstr ""

#: ../../../power/pm_qos_interface.rst:202
msgid ""
"If .set_latency_tolerance() is present for the device, sysfs attribute "
"pm_qos_latency_tolerance_us will be present in the devivce's power "
"directory. Then, user space can use that attribute to specify its latency "
"tolerance requirement for the device, if any.  Writing \"any\" to it means "
"\"no requirement, but do not let the hardware control latency tolerance\" "
"and writing \"auto\" to it allows the hardware to be switched to the "
"autonomous mode if there are no other requirements from the kernel side in "
"the device's list."
msgstr ""

#: ../../../power/pm_qos_interface.rst:210
msgid ""
"Kernel code can use the functions described above along with the "
"DEV_PM_QOS_LATENCY_TOLERANCE device PM QoS type to add, remove and update "
"latency tolerance requirements for devices."
msgstr ""
