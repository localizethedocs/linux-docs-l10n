# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../scheduler/schedutil.rst:3
msgid "Schedutil"
msgstr ""

#: ../../../scheduler/schedutil.rst:7
msgid ""
"All this assumes a linear relation between frequency and work capacity, we "
"know this is flawed, but it is the best workable approximation."
msgstr ""

#: ../../../scheduler/schedutil.rst:12
msgid "PELT (Per Entity Load Tracking)"
msgstr ""

#: ../../../scheduler/schedutil.rst:14
msgid ""
"With PELT we track some metrics across the various scheduler entities, from "
"individual tasks to task-group slices to CPU runqueues. As the basis for "
"this we use an Exponentially Weighted Moving Average (EWMA), each period "
"(1024us) is decayed such that y^32 = 0.5. That is, the most recent 32ms "
"contribute half, while the rest of history contribute the other half."
msgstr ""

#: ../../../scheduler/schedutil.rst:20
msgid "Specifically:"
msgstr ""

#: ../../../scheduler/schedutil.rst:22
msgid "ewma_sum(u) := u_0 + u_1*y + u_2*y^2 + ..."
msgstr ""

#: ../../../scheduler/schedutil.rst:24
msgid "ewma(u) = ewma_sum(u) / ewma_sum(1)"
msgstr ""

#: ../../../scheduler/schedutil.rst:26
msgid ""
"Since this is essentially a progression of an infinite geometric series, the "
"results are composable, that is ewma(A) + ewma(B) = ewma(A+B). This property "
"is key, since it gives the ability to recompose the averages when tasks move "
"around."
msgstr ""

#: ../../../scheduler/schedutil.rst:31
msgid ""
"Note that blocked tasks still contribute to the aggregates (task-group "
"slices and CPU runqueues), which reflects their expected contribution when "
"they resume running."
msgstr ""

#: ../../../scheduler/schedutil.rst:35
msgid ""
"Using this we track 2 key metrics: 'running' and 'runnable'. 'Running' "
"reflects the time an entity spends on the CPU, while 'runnable' reflects the "
"time an entity spends on the runqueue. When there is only a single task "
"these two metrics are the same, but once there is contention for the CPU "
"'running' will decrease to reflect the fraction of time each task spends on "
"the CPU while 'runnable' will increase to reflect the amount of contention."
msgstr ""

#: ../../../scheduler/schedutil.rst:42
msgid "For more detail see: kernel/sched/pelt.c"
msgstr ""

#: ../../../scheduler/schedutil.rst:46
msgid "Frequency / CPU Invariance"
msgstr ""

#: ../../../scheduler/schedutil.rst:48
msgid ""
"Because consuming the CPU for 50% at 1GHz is not the same as consuming the "
"CPU for 50% at 2GHz, nor is running 50% on a LITTLE CPU the same as running "
"50% on a big CPU, we allow architectures to scale the time delta with two "
"ratios, one Dynamic Voltage and Frequency Scaling (DVFS) ratio and one "
"microarch ratio."
msgstr ""

#: ../../../scheduler/schedutil.rst:53
msgid ""
"For simple DVFS architectures (where software is in full control) we "
"trivially compute the ratio as::"
msgstr ""

#: ../../../scheduler/schedutil.rst:60
msgid ""
"For more dynamic systems where the hardware is in control of DVFS we use "
"hardware counters (Intel APERF/MPERF, ARMv8.4-AMU) to provide us this ratio. "
"For Intel specifically, we use::"
msgstr ""

#: ../../../scheduler/schedutil.rst:76
msgid "We pick 4C turbo over 1C turbo to make it slightly more sustainable."
msgstr ""

#: ../../../scheduler/schedutil.rst:78
msgid ""
"r_cpu is determined as the ratio of highest performance level of the current "
"CPU vs the highest performance level of any other CPU in the system."
msgstr ""

#: ../../../scheduler/schedutil.rst:81
msgid "r_tot = r_dvfs * r_cpu"
msgstr ""

#: ../../../scheduler/schedutil.rst:83
msgid ""
"The result is that the above 'running' and 'runnable' metrics become "
"invariant of DVFS and CPU type. IOW. we can transfer and compare them "
"between CPUs."
msgstr ""

#: ../../../scheduler/schedutil.rst:86
msgid "For more detail see:"
msgstr ""

#: ../../../scheduler/schedutil.rst:88
msgid "kernel/sched/pelt.h:update_rq_clock_pelt()"
msgstr ""

#: ../../../scheduler/schedutil.rst:89
msgid "arch/x86/kernel/smpboot.c:\"APERF/MPERF frequency ratio computation.\""
msgstr ""

#: ../../../scheduler/schedutil.rst:90
msgid ""
"Documentation/scheduler/sched-capacity.rst:\"1. CPU Capacity + 2. Task "
"utilization\""
msgstr ""

#: ../../../scheduler/schedutil.rst:94
msgid "UTIL_EST"
msgstr ""

#: ../../../scheduler/schedutil.rst:96
msgid ""
"Because periodic tasks have their averages decayed while they sleep, even "
"though when running their expected utilization will be the same, they suffer "
"a (DVFS) ramp-up after they are running again."
msgstr ""

#: ../../../scheduler/schedutil.rst:100
msgid ""
"To alleviate this (a default enabled option) UTIL_EST drives an Infinite "
"Impulse Response (IIR) EWMA with the 'running' value on dequeue -- when it "
"is highest. UTIL_EST filters to instantly increase and only decay on "
"decrease."
msgstr ""

#: ../../../scheduler/schedutil.rst:104
msgid "A further runqueue wide sum (of runnable tasks) is maintained of:"
msgstr ""

#: ../../../scheduler/schedutil.rst:106
msgid "util_est := \\Sum_t max( t_running, t_util_est_ewma )"
msgstr ""

#: ../../../scheduler/schedutil.rst:108
msgid "For more detail see: kernel/sched/fair.c:util_est_dequeue()"
msgstr ""

#: ../../../scheduler/schedutil.rst:112
msgid "UCLAMP"
msgstr ""

#: ../../../scheduler/schedutil.rst:114
msgid ""
"It is possible to set effective u_min and u_max clamps on each CFS or RT "
"task; the runqueue keeps an max aggregate of these clamps for all running "
"tasks."
msgstr ""

#: ../../../scheduler/schedutil.rst:117
msgid "For more detail see: include/uapi/linux/sched/types.h"
msgstr ""

#: ../../../scheduler/schedutil.rst:121
msgid "Schedutil / DVFS"
msgstr ""

#: ../../../scheduler/schedutil.rst:123
msgid ""
"Every time the scheduler load tracking is updated (task wakeup, task "
"migration, time progression) we call out to schedutil to update the hardware "
"DVFS state."
msgstr ""

#: ../../../scheduler/schedutil.rst:127
msgid ""
"The basis is the CPU runqueue's 'running' metric, which per the above it is "
"the frequency invariant utilization estimate of the CPU. From this we "
"compute a desired frequency like::"
msgstr ""

#: ../../../scheduler/schedutil.rst:141
msgid ""
"XXX IO-wait: when the update is due to a task wakeup from IO-completion we "
"boost 'u' above."
msgstr ""

#: ../../../scheduler/schedutil.rst:144
msgid ""
"This frequency is then used to select a P-state/OPP or directly munged into "
"a CPPC style request to the hardware."
msgstr ""

#: ../../../scheduler/schedutil.rst:147
msgid ""
"XXX: deadline tasks (Sporadic Task Model) allows us to calculate a hard "
"f_min required to satisfy the workload."
msgstr ""

#: ../../../scheduler/schedutil.rst:150
msgid ""
"Because these callbacks are directly from the scheduler, the DVFS hardware "
"interaction should be 'fast' and non-blocking. Schedutil supports rate-"
"limiting DVFS requests for when hardware interaction is slow and expensive, "
"this reduces effectiveness."
msgstr ""

#: ../../../scheduler/schedutil.rst:155
msgid "For more information see: kernel/sched/cpufreq_schedutil.c"
msgstr ""

#: ../../../scheduler/schedutil.rst:159
msgid "NOTES"
msgstr ""

#: ../../../scheduler/schedutil.rst:161
msgid ""
"On low-load scenarios, where DVFS is most relevant, the 'running' numbers "
"will closely reflect utilization."
msgstr ""

#: ../../../scheduler/schedutil.rst:164
msgid ""
"In saturated scenarios task movement will cause some transient dips, suppose "
"we have a CPU saturated with 4 tasks, then when we migrate a task to an idle "
"CPU, the old CPU will have a 'running' value of 0.75 while the new CPU will "
"gain 0.25. This is inevitable and time progression will correct this. XXX do "
"we still guarantee f_max due to no idle-time?"
msgstr ""

#: ../../../scheduler/schedutil.rst:170
msgid ""
"Much of the above is about avoiding DVFS dips, and independent DVFS domains "
"having to re-learn / ramp-up when load shifts."
msgstr ""
