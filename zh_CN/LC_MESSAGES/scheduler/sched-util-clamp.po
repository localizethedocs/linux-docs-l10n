# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../scheduler/sched-util-clamp.rst:5
msgid "Utilization Clamping"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:8
msgid "1. Introduction"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:10
msgid ""
"Utilization clamping, also known as util clamp or uclamp, is a scheduler "
"feature that allows user space to help in managing the performance "
"requirement of tasks. It was introduced in v5.3 release. The CGroup support "
"was merged in v5.4."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:15
msgid ""
"Uclamp is a hinting mechanism that allows the scheduler to understand the "
"performance requirements and restrictions of the tasks, thus it helps the "
"scheduler to make a better decision. And when schedutil cpufreq governor is "
"used, util clamp will influence the CPU frequency selection as well."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:20
msgid ""
"Since the scheduler and schedutil are both driven by PELT (util_avg) "
"signals, util clamp acts on that to achieve its goal by clamping the signal "
"to a certain point; hence the name. That is, by clamping utilization we are "
"making the system run at a certain performance point."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:25
msgid ""
"The right way to view util clamp is as a mechanism to make request or hint "
"on performance constraints. It consists of two tunables:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:28
msgid "UCLAMP_MIN, which sets the lower bound."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:29
msgid "UCLAMP_MAX, which sets the upper bound."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:31
msgid ""
"These two bounds will ensure a task will operate within this performance "
"range of the system. UCLAMP_MIN implies boosting a task, while UCLAMP_MAX "
"implies capping a task."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:35
msgid ""
"One can tell the system (scheduler) that some tasks require a minimum "
"performance point to operate at to deliver the desired user experience. Or "
"one can tell the system that some tasks should be restricted from consuming "
"too much resources and should not go above a specific performance point. "
"Viewing the uclamp values as performance points rather than utilization is a "
"better abstraction from user space point of view."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:42
msgid ""
"As an example, a game can use util clamp to form a feedback loop with its "
"perceived Frames Per Second (FPS). It can dynamically increase the minimum "
"performance point required by its display pipeline to ensure no frame is "
"dropped. It can also dynamically 'prime' up these tasks if it knows in the "
"coming few hundred milliseconds a computationally intensive scene is about "
"to happen."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:49
msgid ""
"On mobile hardware where the capability of the devices varies a lot, this "
"dynamic feedback loop offers a great flexibility to ensure best user "
"experience given the capabilities of any system."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:53
msgid ""
"Of course a static configuration is possible too. The exact usage will "
"depend on the system, application and the desired outcome."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:56
msgid ""
"Another example is in Android where tasks are classified as background, "
"foreground, top-app, etc. Util clamp can be used to constrain how much "
"resources background tasks are consuming by capping the performance point "
"they can run at. This constraint helps reserve resources for important "
"tasks, like the ones belonging to the currently active app (top-app group). "
"Beside this helps in limiting how much power they consume. This can be more "
"obvious in heterogeneous systems (e.g. Arm big.LITTLE); the constraint will "
"help bias the background tasks to stay on the little cores which will ensure "
"that:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:65
msgid ""
"The big cores are free to run top-app tasks immediately. top-app tasks are "
"the tasks the user is currently interacting with, hence the most important "
"tasks in the system."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:68
msgid ""
"They don't run on a power hungry core and drain battery even if they are CPU "
"intensive tasks."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:72
msgid "**little cores**:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:73
msgid "CPUs with capacity < 1024"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:75
msgid "**big cores**:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:76
msgid "CPUs with capacity = 1024"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:78
msgid ""
"By making these uclamp performance requests, or rather hints, user space can "
"ensure system resources are used optimally to deliver the best possible user "
"experience."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:82
msgid ""
"Another use case is to help with **overcoming the ramp up latency inherit in "
"how scheduler utilization signal is calculated**."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:85
msgid ""
"On the other hand, a busy task for instance that requires to run at maximum "
"performance point will suffer a delay of ~200ms (PELT HALFIFE = 32ms) for "
"the scheduler to realize that. This is known to affect workloads like gaming "
"on mobile devices where frames will drop due to slow response time to select "
"the higher frequency required for the tasks to finish their work in time. "
"Setting UCLAMP_MIN=1024 will ensure such tasks will always see the highest "
"performance level when they start running."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:93
msgid ""
"The overall visible effect goes beyond better perceived user experience/"
"performance and stretches to help achieve a better overall performance/watt "
"if used effectively."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:97
msgid ""
"User space can form a feedback loop with the thermal subsystem too to ensure "
"the device doesn't heat up to the point where it will throttle."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:100
msgid "Both SCHED_NORMAL/OTHER and SCHED_FIFO/RR honour uclamp requests/hints."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:102
msgid ""
"In the SCHED_FIFO/RR case, uclamp gives the option to run RT tasks at any "
"performance point rather than being tied to MAX frequency all the time. "
"Which can be useful on general purpose systems that run on battery powered "
"devices."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:106
msgid ""
"Note that by design RT tasks don't have per-task PELT signal and must always "
"run at a constant frequency to combat undeterministic DVFS rampup delays."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:109
msgid ""
"Note that using schedutil always implies a single delay to modify the "
"frequency when an RT task wakes up. This cost is unchanged by using uclamp. "
"Uclamp only helps picking what frequency to request instead of schedutil "
"always requesting MAX for all RT tasks."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:114
msgid ""
"See :ref:`section 3.4 <uclamp-default-values>` for default values and :ref:"
"`3.4.1 <sched-util-clamp-min-rt-default>` on how to change RT tasks default "
"value."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:119
msgid "2. Design"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:121
msgid ""
"Util clamp is a property of every task in the system. It sets the boundaries "
"of its utilization signal; acting as a bias mechanism that influences "
"certain decisions within the scheduler."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:125
msgid ""
"The actual utilization signal of a task is never clamped in reality. If you "
"inspect PELT signals at any point of time you should continue to see them as "
"they are intact. Clamping happens only when needed, e.g: when a task wakes "
"up and the scheduler needs to select a suitable CPU for it to run on."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:130
msgid ""
"Since the goal of util clamp is to allow requesting a minimum and maximum "
"performance point for a task to run on, it must be able to influence the "
"frequency selection as well as task placement to be most effective. Both of "
"which have implications on the utilization value at CPU runqueue (rq for "
"short) level, which brings us to the main design challenge."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:136
msgid ""
"When a task wakes up on an rq, the utilization signal of the rq will be "
"affected by the uclamp settings of all the tasks enqueued on it. For example "
"if a task requests to run at UTIL_MIN = 512, then the util signal of the rq "
"needs to respect to this request as well as all other requests from all of "
"the enqueued tasks."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:142
msgid ""
"To be able to aggregate the util clamp value of all the tasks attached to "
"the rq, uclamp must do some housekeeping at every enqueue/dequeue, which is "
"the scheduler hot path. Hence care must be taken since any slow down will "
"have significant impact on a lot of use cases and could hinder its usability "
"in practice."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:148
msgid ""
"The way this is handled is by dividing the utilization range into buckets "
"(struct uclamp_bucket) which allows us to reduce the search space from every "
"task on the rq to only a subset of tasks on the top-most bucket."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:152
msgid ""
"When a task is enqueued, the counter in the matching bucket is incremented, "
"and on dequeue it is decremented. This makes keeping track of the effective "
"uclamp value at rq level a lot easier."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:156
msgid ""
"As tasks are enqueued and dequeued, we keep track of the current effective "
"uclamp value of the rq. See :ref:`section 2.1 <uclamp-buckets>` for details "
"on how this works."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:160
msgid ""
"Later at any path that wants to identify the effective uclamp value of the "
"rq, it will simply need to read this effective uclamp value of the rq at "
"that exact moment of time it needs to take a decision."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:164
msgid ""
"For task placement case, only Energy Aware and Capacity Aware Scheduling "
"(EAS/CAS) make use of uclamp for now, which implies that it is applied on "
"heterogeneous systems only. When a task wakes up, the scheduler will look at "
"the current effective uclamp value of every rq and compare it with the "
"potential new value if the task were to be enqueued there. Favoring the rq "
"that will end up with the most energy efficient combination."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:172
msgid ""
"Similarly in schedutil, when it needs to make a frequency update it will "
"look at the current effective uclamp value of the rq which is influenced by "
"the set of tasks currently enqueued there and select the appropriate "
"frequency that will satisfy constraints from requests."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:177
msgid ""
"Other paths like setting overutilization state (which effectively disables "
"EAS) make use of uclamp as well. Such cases are considered necessary "
"housekeeping to allow the 2 main use cases above and will not be covered in "
"detail here as they could change with implementation details."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:185
msgid "2.1. Buckets"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:207
msgid ""
"The diagram above is an illustration rather than a true depiction of the "
"internal data structure."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:210
msgid ""
"To reduce the search space when trying to decide the effective uclamp value "
"of an rq as tasks are enqueued/dequeued, the whole utilization range is "
"divided into N buckets where N is configured at compile time by setting "
"CONFIG_UCLAMP_BUCKETS_COUNT. By default it is set to 5."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:215
msgid ""
"The rq has a bucket for each uclamp_id tunables: [UCLAMP_MIN, UCLAMP_MAX]."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:217
msgid ""
"The range of each bucket is 1024/N. For example, for the default value of 5 "
"there will be 5 buckets, each of which will cover the following range:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:230
msgid "When a task p with following tunable parameters"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:237
msgid ""
"is enqueued into the rq, bucket 1 will be incremented for UCLAMP_MIN and "
"bucket 4 will be incremented for UCLAMP_MAX to reflect the fact the rq has a "
"task in this range."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:241
msgid ""
"The rq then keeps track of its current effective uclamp value for each "
"uclamp_id."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:244
msgid "When a task p is enqueued, the rq value changes to:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:252
msgid "Similarly, when p is dequeued the rq value changes to:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:260
msgid ""
"When all buckets are empty, the rq uclamp values are reset to system "
"defaults. See :ref:`section 3.4 <uclamp-default-values>` for details on "
"default values."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:265
msgid "2.2. Max aggregation"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:267
msgid ""
"Util clamp is tuned to honour the request for the task that requires the "
"highest performance point."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:270
msgid ""
"When multiple tasks are attached to the same rq, then util clamp must make "
"sure the task that needs the highest performance point gets it even if "
"there's another task that doesn't need it or is disallowed from reaching "
"this point."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:274
msgid ""
"For example, if there are multiple tasks attached to an rq with the "
"following values:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:285
msgid ""
"then assuming both p0 and p1 are enqueued to the same rq, both UCLAMP_MIN "
"and UCLAMP_MAX become:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:293
msgid ""
"As we shall see in :ref:`section 5.1 <uclamp-capping-fail>`, this max "
"aggregation is the cause of one of limitations when using util clamp, in "
"particular for UCLAMP_MAX hint when user space would like to save power."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:298
msgid "2.3. Hierarchical aggregation"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:300
msgid ""
"As stated earlier, util clamp is a property of every task in the system. But "
"the actual applied (effective) value can be influenced by more than just the "
"request made by the task or another actor on its behalf (middleware library)."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:304
msgid "The effective util clamp value of any task is restricted as follows:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:306
msgid ""
"By the uclamp settings defined by the cgroup CPU controller it is attached "
"to, if any."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:308
msgid ""
"The restricted value in (1) is then further restricted by the system wide "
"uclamp settings."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:311
msgid ""
":ref:`Section 3 <uclamp-interfaces>` discusses the interfaces and will "
"expand further on that."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:314
msgid ""
"For now suffice to say that if a task makes a request, its actual effective "
"value will have to adhere to some restrictions imposed by cgroup and system "
"wide settings."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:318
msgid ""
"The system will still accept the request even if effectively will be beyond "
"the constraints, but as soon as the task moves to a different cgroup or a "
"sysadmin modifies the system settings, the request will be satisfied only if "
"it is within new constraints."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:323
msgid ""
"In other words, this aggregation will not cause an error when a task changes "
"its uclamp values, but rather the system may not be able to satisfy requests "
"based on those factors."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:328
msgid "2.4. Range"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:330
msgid "Uclamp performance request has the range of 0 to 1024 inclusive."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:332
msgid ""
"For cgroup interface percentage is used (that is 0 to 100 inclusive). Just "
"like other cgroup interfaces, you can use 'max' instead of 100."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:338
msgid "3. Interfaces"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:341
msgid "3.1. Per task interface"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:343
msgid "sched_setattr() syscall was extended to accept two new fields:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:345
msgid ""
"sched_util_min: requests the minimum performance point the system should run "
"at when this task is running. Or lower performance bound."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:347
msgid ""
"sched_util_max: requests the maximum performance point the system should run "
"at when this task is running. Or upper performance bound."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:350
msgid ""
"For example, the following scenario have 40% to 80% utilization constraints:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:357
msgid ""
"When task @p is running, **the scheduler should try its best to ensure it "
"starts at 40% performance level**. If the task runs for a long enough time "
"so that its actual utilization goes above 80%, the utilization, or "
"performance level, will be capped."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:362
msgid ""
"The special value -1 is used to reset the uclamp settings to the system "
"default."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:365
msgid ""
"Note that resetting the uclamp value to system default using -1 is not the "
"same as manually setting uclamp value to system default. This distinction is "
"important because as we shall see in system interfaces, the default value "
"for RT could be changed. SCHED_NORMAL/OTHER might gain similar knobs too in "
"the future."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:372
msgid "3.2. cgroup interface"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:374
msgid "There are two uclamp related values in the CPU cgroup controller:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:376
msgid "cpu.uclamp.min"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:377
msgid "cpu.uclamp.max"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:379
msgid ""
"When a task is attached to a CPU controller, its uclamp values will be "
"impacted as follows:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:382
msgid ""
"cpu.uclamp.min is a protection as described in :ref:`section 3-3 of cgroup "
"v2 documentation <cgroupv2-protections-distributor>`."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:385
msgid ""
"If a task uclamp_min value is lower than cpu.uclamp.min, then the task will "
"inherit the cgroup cpu.uclamp.min value."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:388
msgid ""
"In a cgroup hierarchy, effective cpu.uclamp.min is the max of (child, "
"parent)."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:391
msgid ""
"cpu.uclamp.max is a limit as described in :ref:`section 3-2 of cgroup v2 "
"documentation <cgroupv2-limits-distributor>`."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:394
msgid ""
"If a task uclamp_max value is higher than cpu.uclamp.max, then the task will "
"inherit the cgroup cpu.uclamp.max value."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:397
msgid ""
"In a cgroup hierarchy, effective cpu.uclamp.max is the min of (child, "
"parent)."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:400
msgid "For example, given following parameters:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:416
msgid "when p0 and p1 are attached to cgroup0, the values become:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:426
msgid "when p0 and p1 are attached to cgroup1, these instead become:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:436
msgid ""
"Note that cgroup interfaces allows cpu.uclamp.max value to be lower than cpu."
"uclamp.min. Other interfaces don't allow that."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:440
msgid "3.3. System interface"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:443
msgid "3.3.1 sched_util_clamp_min"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:445
msgid ""
"System wide limit of allowed UCLAMP_MIN range. By default it is set to 1024, "
"which means that permitted effective UCLAMP_MIN range for tasks is [0:1024]. "
"By changing it to 512 for example the range reduces to [0:512]. This is "
"useful to restrict how much boosting tasks are allowed to acquire."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:450
msgid ""
"Requests from tasks to go above this knob value will still succeed, but they "
"won't be satisfied until it is more than p->uclamp[UCLAMP_MIN]."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:453
msgid "The value must be smaller than or equal to sched_util_clamp_max."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:456
msgid "3.3.2 sched_util_clamp_max"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:458
msgid ""
"System wide limit of allowed UCLAMP_MAX range. By default it is set to 1024, "
"which means that permitted effective UCLAMP_MAX range for tasks is [0:1024]."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:461
msgid ""
"By changing it to 512 for example the effective allowed range reduces to "
"[0:512]. This means is that no task can run above 512, which implies that "
"all rqs are restricted too. IOW, the whole system is capped to half its "
"performance capacity."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:466
msgid ""
"This is useful to restrict the overall maximum performance point of the "
"system. For example, it can be handy to limit performance when running low "
"on battery or when the system wants to limit access to more energy hungry "
"performance levels when it's in idle state or screen is off."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:471
msgid ""
"Requests from tasks to go above this knob value will still succeed, but they "
"won't be satisfied until it is more than p->uclamp[UCLAMP_MAX]."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:474
msgid "The value must be greater than or equal to sched_util_clamp_min."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:479
msgid "3.4. Default values"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:481
msgid "By default all SCHED_NORMAL/SCHED_OTHER tasks are initialized to:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:488
msgid ""
"That is, by default they're boosted to run at the maximum performance point "
"of changed at boot or runtime. No argument was made yet as to why we should "
"provide this, but can be added in the future."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:492
msgid "For SCHED_FIFO/SCHED_RR tasks:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:499
msgid ""
"That is by default they're boosted to run at the maximum performance point "
"of the system which retains the historical behavior of the RT tasks."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:502
msgid ""
"RT tasks default uclamp_min value can be modified at boot or runtime via "
"sysctl. See below section."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:508
msgid "3.4.1 sched_util_clamp_min_rt_default"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:510
msgid ""
"Running RT tasks at maximum performance point is expensive on battery "
"powered devices and not necessary. To allow system developer to offer good "
"performance guarantees for these tasks without pushing it all the way to "
"maximum performance point, this sysctl knob allows tuning the best boost "
"value to address the system requirement without burning power running at "
"maximum performance point all the time."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:517
msgid ""
"Application developer are encouraged to use the per task util clamp "
"interface to ensure they are performance and power aware. Ideally this knob "
"should be set to 0 by system designers and leave the task of managing "
"performance requirements to the apps."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:523
msgid "4. How to use util clamp"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:525
msgid ""
"Util clamp promotes the concept of user space assisted power and performance "
"management. At the scheduler level there is no info required to make the "
"best decision. However, with util clamp user space can hint to the scheduler "
"to make better decision about task placement and frequency selection."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:530
msgid ""
"Best results are achieved by not making any assumptions about the system the "
"application is running on and to use it in conjunction with a feedback loop "
"to dynamically monitor and adjust. Ultimately this will allow for a better "
"user experience at a better perf/watt."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:535
msgid ""
"For some systems and use cases, static setup will help to achieve good "
"results. Portability will be a problem in this case. How much work one can "
"do at 100, 200 or 1024 is different for each system. Unless there's a "
"specific target system, static setup should be avoided."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:540
msgid ""
"There are enough possibilities to create a whole framework based on util "
"clamp or self contained app that makes use of it directly."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:544
msgid "4.1. Boost important and DVFS-latency-sensitive tasks"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:546
msgid ""
"A GUI task might not be busy to warrant driving the frequency high when it "
"wakes up. However, it requires to finish its work within a specific time "
"window to deliver the desired user experience. The right frequency it "
"requires at wakeup will be system dependent. On some underpowered systems it "
"will be high, on other overpowered ones it will be low or 0."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:552
msgid ""
"This task can increase its UCLAMP_MIN value every time it misses the "
"deadline to ensure on next wake up it runs at a higher performance point. It "
"should try to approach the lowest UCLAMP_MIN value that allows to meet its "
"deadline on any particular system to achieve the best possible perf/watt for "
"that system."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:557
msgid ""
"On heterogeneous systems, it might be important for this task to run on a "
"faster CPU."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:560
msgid ""
"**Generally it is advised to perceive the input as performance level or "
"point which will imply both task placement and frequency selection**."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:564
msgid "4.2. Cap background tasks"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:566
msgid ""
"Like explained for Android case in the introduction. Any app can lower "
"UCLAMP_MAX for some background tasks that don't care about performance but "
"could end up being busy and consume unnecessary system resources on the "
"system."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:571
msgid "4.3. Powersave mode"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:573
msgid ""
"sched_util_clamp_max system wide interface can be used to limit all tasks "
"from operating at the higher performance points which are usually energy "
"inefficient."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:577
msgid ""
"This is not unique to uclamp as one can achieve the same by reducing max "
"frequency of the cpufreq governor. It can be considered a more convenient "
"alternative interface."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:582
msgid "4.4. Per-app performance restriction"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:584
msgid ""
"Middleware/Utility can provide the user an option to set UCLAMP_MIN/MAX for "
"an app every time it is executed to guarantee a minimum performance point "
"and/or limit it from draining system power at the cost of reduced "
"performance for these apps."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:589
msgid ""
"If you want to prevent your laptop from heating up while on the go from "
"compiling the kernel and happy to sacrifice performance to save power, but "
"still would like to keep your browser performance intact, uclamp makes it "
"possible."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:595
msgid "5. Limitations"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:600
msgid "5.1. Capping frequency with uclamp_max fails under certain conditions"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:602
msgid "If task p0 is capped to run at 512:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:608
msgid ""
"and it shares the rq with p1 which is free to run at any performance point:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:614
msgid ""
"then due to max aggregation the rq will be allowed to reach max performance "
"point:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:621
msgid ""
"Assuming both p0 and p1 have UCLAMP_MIN = 0, then the frequency selection "
"for the rq will depend on the actual utilization value of the tasks."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:624
msgid ""
"If p1 is a small task but p0 is a CPU intensive task, then due to the fact "
"that both are running at the same rq, p1 will cause the frequency capping to "
"be left from the rq although p1, which is allowed to run at any performance "
"point, doesn't actually need to run at that frequency."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:630
msgid "5.2. UCLAMP_MAX can break PELT (util_avg) signal"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:632
msgid ""
"PELT assumes that frequency will always increase as the signals grow to "
"ensure there's always some idle time on the CPU. But with UCLAMP_MAX, this "
"frequency increase will be prevented which can lead to no idle time in some "
"circumstances. When there's no idle time, a task will stuck in a busy loop, "
"which would result in util_avg being 1024."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:638
msgid ""
"Combing with issue described below, this can lead to unwanted frequency "
"spikes when severely capped tasks share the rq with a small non capped task."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:641
msgid "As an example if task p, which have:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:648
msgid ""
"wakes up on an idle CPU, then it will run at min frequency (Fmin) this CPU "
"is capable of. The max CPU frequency (Fmax) matters here as well, since it "
"designates the shortest computational time to finish the task's work on this "
"CPU."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:657
msgid "If the ratio of Fmax/Fmin is 3, then maximum value will be:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:663
msgid ""
"which indicates the CPU will still see idle time since 900 is < 1024. The "
"_actual_ util_avg will not be 900 though, but somewhere between 300 and 900. "
"As long as there's idle time, p->util_avg updates will be off by a some "
"margin, but not proportional to Fmax/Fmin."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:672
msgid "Now if the ratio of Fmax/Fmin is 4, the maximum value becomes:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:678
msgid ""
"which is higher than 1024 and indicates that the CPU has no idle time. When "
"this happens, then the _actual_ util_avg will become:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:685
msgid "If task p1 wakes up on this CPU, which have:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:692
msgid ""
"then the effective UCLAMP_MAX for the CPU will be 1024 according to max "
"aggregation rule. But since the capped p0 task was running and throttled "
"severely, then the rq->util_avg will be:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:704
msgid ""
"Hence lead to a frequency spike since if p0 wasn't throttled we should get:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:713
msgid ""
"and run somewhere near mid performance point of that CPU, not the Fmax we "
"get."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:716
msgid "5.3. Schedutil response time issues"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:718
msgid "schedutil has three limitations:"
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:720
msgid ""
"Hardware takes non-zero time to respond to any frequency change request. On "
"some platforms can be in the order of few ms."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:722
msgid ""
"Non fast-switch systems require a worker deadline thread to wake up and "
"perform the frequency change, which adds measurable overhead."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:724
msgid ""
"schedutil rate_limit_us drops any requests during this rate_limit_us window."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:727
msgid ""
"If a relatively small task is doing critical job and requires a certain "
"performance point when it wakes up and starts running, then all these "
"limitations will prevent it from getting what it wants in the time scale it "
"expects."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:732
msgid ""
"This limitation is not only impactful when using uclamp, but will be more "
"prevalent as we no longer gradually ramp up or down. We could easily be "
"jumping between frequencies depending on the order tasks wake up, and their "
"respective uclamp values."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:737
msgid ""
"We regard that as a limitation of the capabilities of the underlying system "
"itself."
msgstr ""

#: ../../../scheduler/sched-util-clamp.rst:740
msgid ""
"There is room to improve the behavior of schedutil rate_limit_us, but not "
"much to be done for 1 or 2. They are considered hard limitations of the "
"system."
msgstr ""
