# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../input/input-programming.rst:3
msgid "Creating an input device driver"
msgstr ""

#: ../../../input/input-programming.rst:6
msgid "The simplest example"
msgstr ""

#: ../../../input/input-programming.rst:8
msgid ""
"Here comes a very simple example of an input device driver. The device has "
"just one button and the button is accessible at i/o port BUTTON_PORT. When "
"pressed or released a BUTTON_IRQ happens. The driver could look like::"
msgstr ""

#: ../../../input/input-programming.rst:72
msgid "What the example does"
msgstr ""

#: ../../../input/input-programming.rst:74
msgid ""
"First it has to include the <linux/input.h> file, which interfaces to the "
"input subsystem. This provides all the definitions needed."
msgstr ""

#: ../../../input/input-programming.rst:77
msgid ""
"In the _init function, which is called either upon module load or when "
"booting the kernel, it grabs the required resources (it should also check "
"for the presence of the device)."
msgstr ""

#: ../../../input/input-programming.rst:81
msgid ""
"Then it allocates a new input device structure with input_allocate_device() "
"and sets up input bitfields. This way the device driver tells the other "
"parts of the input systems what it is - what events can be generated or "
"accepted by this input device. Our example device can only generate EV_KEY "
"type events, and from those only BTN_0 event code. Thus we only set these "
"two bits. We could have used::"
msgstr ""

#: ../../../input/input-programming.rst:91
msgid ""
"as well, but with more than single bits the first approach tends to be "
"shorter."
msgstr ""

#: ../../../input/input-programming.rst:94
msgid ""
"Then the example driver registers the input device structure by calling::"
msgstr ""

#: ../../../input/input-programming.rst:98
msgid ""
"This adds the button_dev structure to linked lists of the input driver and "
"calls device handler modules _connect functions to tell them a new input "
"device has appeared. input_register_device() may sleep and therefore must "
"not be called from an interrupt or with a spinlock held."
msgstr ""

#: ../../../input/input-programming.rst:103
msgid "While in use, the only used function of the driver is::"
msgstr ""

#: ../../../input/input-programming.rst:107
msgid ""
"which upon every interrupt from the button checks its state and reports it "
"via the::"
msgstr ""

#: ../../../input/input-programming.rst:112
msgid ""
"call to the input system. There is no need to check whether the interrupt "
"routine isn't reporting two same value events (press, press for example) to "
"the input system, because the input_report_* functions check that themselves."
msgstr ""

#: ../../../input/input-programming.rst:117
msgid "Then there is the::"
msgstr ""

#: ../../../input/input-programming.rst:121
msgid ""
"call to tell those who receive the events that we've sent a complete report. "
"This doesn't seem important in the one button case, but is quite important "
"for example for mouse movement, where you don't want the X and Y values to "
"be interpreted separately, because that'd result in a different movement."
msgstr ""

#: ../../../input/input-programming.rst:127
msgid "dev->open() and dev->close()"
msgstr ""

#: ../../../input/input-programming.rst:129
msgid ""
"In case the driver has to repeatedly poll the device, because it doesn't "
"have an interrupt coming from it and the polling is too expensive to be done "
"all the time, or if the device uses a valuable resource (e.g. interrupt), it "
"can use the open and close callback to know when it can stop polling or "
"release the interrupt and when it must resume polling or grab the interrupt "
"again. To do that, we would add this to our example driver::"
msgstr ""

#: ../../../input/input-programming.rst:159
msgid ""
"Note that input core keeps track of number of users for the device and makes "
"sure that dev->open() is called only when the first user connects to the "
"device and that dev->close() is called when the very last user disconnects. "
"Calls to both callbacks are serialized."
msgstr ""

#: ../../../input/input-programming.rst:164
msgid ""
"The open() callback should return a 0 in case of success or any non-zero "
"value in case of failure. The close() callback (which is void) must always "
"succeed."
msgstr ""

#: ../../../input/input-programming.rst:168
msgid "Inhibiting input devices"
msgstr ""

#: ../../../input/input-programming.rst:170
msgid ""
"Inhibiting a device means ignoring input events from it. As such it is about "
"maintaining relationships with input handlers - either already existing "
"relationships, or relationships to be established while the device is in "
"inhibited state."
msgstr ""

#: ../../../input/input-programming.rst:175
msgid "If a device is inhibited, no input handler will receive events from it."
msgstr ""

#: ../../../input/input-programming.rst:177
msgid ""
"The fact that nobody wants events from the device is exploited further, by "
"calling device's close() (if there are users) and open() (if there are "
"users) on inhibit and uninhibit operations, respectively. Indeed, the "
"meaning of close() is to stop providing events to the input core and that of "
"open() is to start providing events to the input core."
msgstr ""

#: ../../../input/input-programming.rst:183
msgid ""
"Calling the device's close() method on inhibit (if there are users) allows "
"the driver to save power. Either by directly powering down the device or by "
"releasing the runtime-PM reference it got in open() when the driver is using "
"runtime-PM."
msgstr ""

#: ../../../input/input-programming.rst:188
msgid ""
"Inhibiting and uninhibiting are orthogonal to opening and closing the device "
"by input handlers. Userspace might want to inhibit a device in anticipation "
"before any handler is positively matched against it."
msgstr ""

#: ../../../input/input-programming.rst:192
msgid ""
"Inhibiting and uninhibiting are orthogonal to device's being a wakeup "
"source, too. Being a wakeup source plays a role when the system is sleeping, "
"not when the system is operating.  How drivers should program their "
"interaction between inhibiting, sleeping and being a wakeup source is driver-"
"specific."
msgstr ""

#: ../../../input/input-programming.rst:197
msgid ""
"Taking the analogy with the network devices - bringing a network interface "
"down doesn't mean that it should be impossible be wake the system up on LAN "
"through this interface. So, there may be input drivers which should be "
"considered wakeup sources even when inhibited. Actually, in many I2C input "
"devices their interrupt is declared a wakeup interrupt and its handling "
"happens in driver's core, which is not aware of input-specific inhibit (nor "
"should it be).  Composite devices containing several interfaces can be "
"inhibited on a per-interface basis and e.g. inhibiting one interface "
"shouldn't affect the device's capability of being a wakeup source."
msgstr ""

#: ../../../input/input-programming.rst:207
msgid ""
"If a device is to be considered a wakeup source while inhibited, special "
"care must be taken when programming its suspend(), as it might need to call "
"device's open(). Depending on what close() means for the device in question, "
"not opening() it before going to sleep might make it impossible to provide "
"any wakeup events. The device is going to sleep anyway."
msgstr ""

#: ../../../input/input-programming.rst:214
msgid "Basic event types"
msgstr ""

#: ../../../input/input-programming.rst:216
msgid ""
"The most simple event type is EV_KEY, which is used for keys and buttons. "
"It's reported to the input system via::"
msgstr ""

#: ../../../input/input-programming.rst:221
msgid ""
"See uapi/linux/input-event-codes.h for the allowable values of code (from 0 "
"to KEY_MAX). Value is interpreted as a truth value, i.e. any non-zero value "
"means key pressed, zero value means key released. The input code generates "
"events only in case the value is different from before."
msgstr ""

#: ../../../input/input-programming.rst:226
msgid ""
"In addition to EV_KEY, there are two more basic event types: EV_REL and "
"EV_ABS. They are used for relative and absolute values supplied by the "
"device. A relative value may be for example a mouse movement in the X axis. "
"The mouse reports it as a relative difference from the last position, "
"because it doesn't have any absolute coordinate system to work in. Absolute "
"events are namely for joysticks and digitizers - devices that do work in an "
"absolute coordinate systems."
msgstr ""

#: ../../../input/input-programming.rst:234
msgid ""
"Having the device report EV_REL buttons is as simple as with EV_KEY; simply "
"set the corresponding bits and call the::"
msgstr ""

#: ../../../input/input-programming.rst:239
msgid "function. Events are generated only for non-zero values."
msgstr ""

#: ../../../input/input-programming.rst:241
msgid ""
"However EV_ABS requires a little special care. Before calling "
"input_register_device, you have to fill additional fields in the input_dev "
"struct for each absolute axis your device has. If our button device had also "
"the ABS_X axis::"
msgstr ""

#: ../../../input/input-programming.rst:251
msgid "Or, you can just say::"
msgstr ""

#: ../../../input/input-programming.rst:255
msgid ""
"This setting would be appropriate for a joystick X axis, with the minimum of "
"0, maximum of 255 (which the joystick *must* be able to reach, no problem if "
"it sometimes reports more, but it must be able to always reach the min and "
"max values), with noise in the data up to +- 4, and with a center flat "
"position of size 8."
msgstr ""

#: ../../../input/input-programming.rst:261
msgid ""
"If you don't need absfuzz and absflat, you can set them to zero, which mean "
"that the thing is precise and always returns to exactly the center position "
"(if it has any)."
msgstr ""

#: ../../../input/input-programming.rst:266
msgid "BITS_TO_LONGS(), BIT_WORD(), BIT_MASK()"
msgstr ""

#: ../../../input/input-programming.rst:268
msgid "These three macros from bitops.h help some bitfield computations::"
msgstr ""

#: ../../../input/input-programming.rst:276
msgid "The id* and name fields"
msgstr ""

#: ../../../input/input-programming.rst:278
msgid ""
"The dev->name should be set before registering the input device by the input "
"device driver. It's a string like 'Generic button device' containing a user "
"friendly name of the device."
msgstr ""

#: ../../../input/input-programming.rst:282
msgid ""
"The id* fields contain the bus ID (PCI, USB, ...), vendor ID and device ID "
"of the device. The bus IDs are defined in input.h. The vendor and device IDs "
"are defined in pci_ids.h, usb_ids.h and similar include files. These fields "
"should be set by the input device driver before registering it."
msgstr ""

#: ../../../input/input-programming.rst:287
msgid ""
"The idtype field can be used for specific information for the input device "
"driver."
msgstr ""

#: ../../../input/input-programming.rst:290
msgid ""
"The id and name fields can be passed to userland via the evdev interface."
msgstr ""

#: ../../../input/input-programming.rst:293
msgid "The keycode, keycodemax, keycodesize fields"
msgstr ""

#: ../../../input/input-programming.rst:295
msgid ""
"These three fields should be used by input devices that have dense keymaps. "
"The keycode is an array used to map from scancodes to input system keycodes. "
"The keycode max should contain the size of the array and keycodesize the "
"size of each entry in it (in bytes)."
msgstr ""

#: ../../../input/input-programming.rst:300
msgid ""
"Userspace can query and alter current scancode to keycode mappings using "
"EVIOCGKEYCODE and EVIOCSKEYCODE ioctls on corresponding evdev interface. "
"When a device has all 3 aforementioned fields filled in, the driver may rely "
"on kernel's default implementation of setting and querying keycode mappings."
msgstr ""

#: ../../../input/input-programming.rst:307
msgid "dev->getkeycode() and dev->setkeycode()"
msgstr ""

#: ../../../input/input-programming.rst:309
msgid ""
"getkeycode() and setkeycode() callbacks allow drivers to override default "
"keycode/keycodesize/keycodemax mapping mechanism provided by input core and "
"implement sparse keycode maps."
msgstr ""

#: ../../../input/input-programming.rst:314
msgid "Key autorepeat"
msgstr ""

#: ../../../input/input-programming.rst:316
msgid ""
"... is simple. It is handled by the input.c module. Hardware autorepeat is "
"not used, because it's not present in many devices and even where it is "
"present, it is broken sometimes (at keyboards: Toshiba notebooks). To enable "
"autorepeat for your device, just set EV_REP in dev->evbit. All will be "
"handled by the input system."
msgstr ""

#: ../../../input/input-programming.rst:323
msgid "Other event types, handling output events"
msgstr ""

#: ../../../input/input-programming.rst:325
msgid "The other event types up to now are:"
msgstr ""

#: ../../../input/input-programming.rst:327
msgid "EV_LED - used for the keyboard LEDs."
msgstr ""

#: ../../../input/input-programming.rst:328
msgid "EV_SND - used for keyboard beeps."
msgstr ""

#: ../../../input/input-programming.rst:330
msgid ""
"They are very similar to for example key events, but they go in the other "
"direction - from the system to the input device driver. If your input device "
"driver can handle these events, it has to set the respective bits in evbit, "
"*and* also the callback routine::"
msgstr ""

#: ../../../input/input-programming.rst:347
msgid ""
"This callback routine can be called from an interrupt or a BH (although that "
"isn't a rule), and thus must not sleep, and must not take too long to finish."
msgstr ""

#: ../../../input/input-programming.rst:351
msgid "Polled input devices"
msgstr ""

#: ../../../input/input-programming.rst:353
msgid ""
"Input polling is set up by passing an input device struct and a callback to "
"the function::"
msgstr ""

#: ../../../input/input-programming.rst:359
msgid ""
"Within the callback, devices should use the regular input_report_* functions "
"and input_sync as is used by other devices."
msgstr ""

#: ../../../input/input-programming.rst:362
msgid "There is also the function::"
msgstr ""

#: ../../../input/input-programming.rst:366
msgid ""
"which is used to configure the interval, in milliseconds, that the device "
"will be polled at."
msgstr ""
