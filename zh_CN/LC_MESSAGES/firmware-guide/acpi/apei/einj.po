# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-30 08:40+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../firmware-guide/acpi/apei/einj.rst:5
msgid "APEI Error INJection"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:7
msgid ""
"EINJ provides a hardware error injection mechanism. It is very useful for "
"debugging and testing APEI and RAS features in general."
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:10
msgid ""
"You need to check whether your BIOS supports EINJ first. For that, look for "
"early boot messages similar to this one::"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:15
msgid ""
"which shows that the BIOS is exposing an EINJ table - it is the mechanism "
"through which the injection is done."
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:18
msgid ""
"Alternatively, look in /sys/firmware/acpi/tables for an \"EINJ\" file, which "
"is a different representation of the same thing."
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:21
msgid ""
"It doesn't necessarily mean that EINJ is not supported if those above don't "
"exist: before you give up, go into BIOS setup to see if the BIOS has an "
"option to enable error injection. Look for something called WHEA or similar. "
"Often, you need to enable an ACPI5 support option prior, in order to see the "
"APEI,EINJ,... functionality supported and exposed by the BIOS menu."
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:28
msgid ""
"To use EINJ, make sure the following are options enabled in your kernel "
"configuration::"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:35
msgid "...and to (optionally) enable CXL protocol error injection set::"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:39
msgid "The EINJ user interface is in <debugfs mount point>/apei/einj."
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:41
msgid "The following files belong to it:"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:43
msgid "available_error_type"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:45
msgid "This file shows which error types are supported:"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:48
msgid "Error Type Value"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:48
msgid "Error Description"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:50
msgid "0x00000001"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:50
msgid "Processor Correctable"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:51
msgid "0x00000002"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:51
msgid "Processor Uncorrectable non-fatal"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:52
msgid "0x00000004"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:52
msgid "Processor Uncorrectable fatal"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:53
msgid "0x00000008"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:53
msgid "Memory Correctable"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:54
msgid "0x00000010"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:54
msgid "Memory Uncorrectable non-fatal"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:55
msgid "0x00000020"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:55
msgid "Memory Uncorrectable fatal"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:56
msgid "0x00000040"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:56
msgid "PCI Express Correctable"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:57
msgid "0x00000080"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:57
msgid "PCI Express Uncorrectable non-fatal"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:58
msgid "0x00000100"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:58
msgid "PCI Express Uncorrectable fatal"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:59
msgid "0x00000200"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:59
msgid "Platform Correctable"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:60
msgid "0x00000400"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:60
msgid "Platform Uncorrectable non-fatal"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:61
msgid "0x00000800"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:61
msgid "Platform Uncorrectable fatal"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:62
msgid "V2_0x00000001"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:62
msgid "EINJV2 Processor Error"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:63
msgid "V2_0x00000002"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:63
msgid "EINJV2 Memory Error"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:64
msgid "V2_0x00000004"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:64
msgid "EINJV2 PCI Express Error"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:67
msgid ""
"The format of the file contents are as above, except present are only the "
"available error types."
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:70
msgid "error_type"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:72
msgid ""
"Set the value of the error type being injected. Possible error types are "
"defined in the file available_error_type above."
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:75
msgid "error_inject"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:77
msgid ""
"Write any integer to this file to trigger the error injection. Make sure you "
"have specified all necessary error parameters, i.e. this write should be the "
"last step when injecting errors."
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:81
msgid "flags"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:83
msgid ""
"Present for kernel versions 3.13 and above. Used to specify which of "
"param{1..4} are valid and should be used by the firmware during injection. "
"Value is a bitmask as specified in ACPI5.0 spec for the "
"SET_ERROR_TYPE_WITH_ADDRESS data structure:"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:88
msgid "Bit 0"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:89
msgid "Processor APIC field valid (see param3 below)."
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:90
msgid "Bit 1"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:91
msgid "Memory address and mask valid (param1 and param2)."
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:92
msgid "Bit 2"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:93
msgid "PCIe (seg,bus,dev,fn) valid (see param4 below)."
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:94
msgid "Bit 3"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:95
msgid "EINJv2 extension structure is valid"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:97
msgid ""
"If set to zero, legacy behavior is mimicked where the type of injection "
"specifies just one bit set, and param1 is multiplexed."
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:100
msgid "param1"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:102
msgid ""
"This file is used to set the first error parameter value. Its effect depends "
"on the error type specified in error_type. For example, if error type is "
"memory related type, the param1 should be a valid physical memory address. "
"[Unless \"flag\" is set - see above]"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:107
msgid "param2"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:109
msgid ""
"Same use as param1 above. For example, if error type is of memory related "
"type, then param2 should be a physical memory address mask. Linux requires "
"page or narrower granularity, say, 0xfffffffffffff000."
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:113
msgid "param3"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:115
msgid "Used when the 0x1 bit is set in \"flags\" to specify the APIC id"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:117
msgid ""
"param4 Used when the 0x4 bit is set in \"flags\" to specify target PCIe "
"device"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:120
msgid "notrigger"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:122
msgid ""
"The error injection mechanism is a two-step process. First inject the error, "
"then perform some actions to trigger it. Setting \"notrigger\" to 1 skips "
"the trigger phase, which *may* allow the user to cause the error in some "
"other context by a simple access to the CPU, memory location, or device that "
"is the target of the error injection. Whether this actually works depends on "
"what operations the BIOS actually includes in the trigger phase."
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:130
msgid ""
"component_id0 .. component_idN, component_syndrome0 .. component_syndromeN"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:132
msgid ""
"These files are used to set the \"Component Array\" field of the EINJv2 "
"Extension Structure. Each holds a 128-bit hex value. Writing just a newline "
"to any of these files sets an invalid (all-ones) value."
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:137
msgid ""
"CXL error types are supported from ACPI 6.5 onwards (given a CXL port is "
"present). The EINJ user interface for CXL error types is at <debugfs mount "
"point>/cxl. The following files belong to it:"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:141
msgid "einj_types:"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:143
msgid ""
"Provides the same functionality as available_error_types above, but for CXL "
"error types"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:146
msgid "$dport_dev/einj_inject:"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:148
msgid ""
"Injects a CXL error type into the CXL port represented by $dport_dev, where "
"$dport_dev is the name of the CXL port (usually a PCIe device name). Error "
"injections targeting a CXL 2.0+ port can use the legacy interface under "
"<debugfs mount point>/apei/einj, while CXL 1.1/1.0 port injections must use "
"this file."
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:155
msgid ""
"BIOS versions based on the ACPI 4.0 specification have limited options in "
"controlling where the errors are injected. Your BIOS may support an "
"extension (enabled with the param_extension=1 module parameter, or boot "
"command line einj.param_extension=1). This allows the address and mask for "
"memory injections to be specified by the param1 and param2 files in apei/"
"einj."
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:162
msgid ""
"BIOS versions based on the ACPI 5.0 specification have more control over the "
"target of the injection. For processor-related errors (type 0x1, 0x2 and "
"0x4), you can set flags to 0x3 (param3 for bit 0, and param1 and param2 for "
"bit 1) so that you have more information added to the error signature being "
"injected. The actual data passed is this::"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:173
msgid ""
"For memory errors (type 0x8, 0x10 and 0x20) the address is set using param1 "
"with a mask in param2 (0x0 is equivalent to all ones). For PCI express "
"errors (type 0x40, 0x80 and 0x100) the segment, bus, device and function are "
"specified using param1::"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:183
msgid ""
"Anyway, you get the idea, if there's doubt just take a look at the code in "
"drivers/acpi/apei/einj.c."
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:186
msgid ""
"An ACPI 5.0 BIOS may also allow vendor-specific errors to be injected. In "
"this case a file named vendor will contain identifying information from the "
"BIOS that hopefully will allow an application wishing to use the vendor-"
"specific extension to tell that they are running on a BIOS that supports it. "
"All vendor extensions have the 0x80000000 bit set in error_type. A file "
"vendor_flags controls the interpretation of param1 and param2 (1 = "
"PROCESSOR, 2 = MEMORY, 4 = PCI). See your BIOS vendor documentation for "
"details (and expect changes to this API if vendors creativity in using this "
"feature expands beyond our expectations)."
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:197
msgid "An error injection example::"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:209
msgid "An EINJv2 error injection example::"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:230
msgid "You should see something like this in dmesg::"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:239
msgid "A CXL error injection example with $dport_dev=0000:e0:01.1::"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:251
msgid "Special notes for injection into SGX enclaves:"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:253
msgid "There may be a separate BIOS setup option to enable SGX injection."
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:255
msgid ""
"The injection process consists of setting some special memory controller "
"trigger that will inject the error on the next write to the target address. "
"But the h/w prevents any software outside of an SGX enclave from accessing "
"enclave pages (even BIOS SMM mode)."
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:260
msgid "The following sequence can be used:"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:261
msgid "Determine physical address of enclave page"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:262
msgid ""
"Use \"notrigger=1\" mode to inject (this will setup the injection address, "
"but will not actually inject)"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:264
msgid "Enter the enclave"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:265
msgid "Store data to the virtual address matching physical address from step 1"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:266
msgid "Execute CLFLUSH for that virtual address"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:267
msgid "Spin delay for 250ms"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:268
msgid "Read from the virtual address. This will trigger the error"
msgstr ""

#: ../../../firmware-guide/acpi/apei/einj.rst:270
msgid ""
"For more information about EINJ, please refer to ACPI specification version "
"4.0, section 17.5 and ACPI 5.0, section 18.6."
msgstr ""
