# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-13 08:27+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../virt/kvm/x86/hypercalls.rst:5
msgid "Linux KVM Hypercall"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:7
msgid "X86:"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:8
msgid ""
"KVM Hypercalls have a three-byte sequence of either the vmcall or the "
"vmmcall instruction. The hypervisor can replace it with instructions that "
"are guaranteed to be supported."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:12
msgid ""
"Up to four arguments may be passed in rbx, rcx, rdx, and rsi respectively. "
"The hypercall number should be placed in rax and the return value will be "
"placed in rax.  No other registers will be clobbered unless explicitly "
"stated by the particular hypercall."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:17
msgid "S390:"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:18
msgid ""
"R2-R7 are used for parameters 1-6. In addition, R1 is used for hypercall "
"number. The return value is written to R2."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:21
msgid ""
"S390 uses diagnose instruction as hypercall (0x500) along with hypercall "
"number in R1."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:24
msgid ""
"For further information on the S390 diagnose call as supported by KVM, refer "
"to Documentation/virt/kvm/s390/s390-diag.rst."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:27
msgid "PowerPC:"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:28
msgid ""
"It uses R3-R10 and hypercall number in R11. R4-R11 are used as output "
"registers. Return value is placed in R3."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:31
msgid ""
"KVM hypercalls uses 4 byte opcode, that are patched with 'hypercall-"
"instructions' property inside the device tree's /hypervisor node. For more "
"information refer to Documentation/virt/kvm/ppc-pv.rst"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:35
msgid "MIPS:"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:36
msgid ""
"KVM hypercalls use the HYPCALL instruction with code 0 and the hypercall "
"number in $2 (v0). Up to four arguments may be placed in $4-$7 (a0-a3) and "
"the return value is placed in $2 (v0)."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:41
msgid "KVM Hypercalls Documentation"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:43
msgid ""
"The template for each hypercall is: 1. Hypercall name. 2. Architecture(s) 3. "
"Status (deprecated, obsolete, active) 4. Purpose"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:50
msgid "1. KVM_HC_VAPIC_POLL_IRQ"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:0
msgid "Architecture"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:52
#: ../../../virt/kvm/x86/hypercalls.rst:60
#: ../../../virt/kvm/x86/hypercalls.rst:89
#: ../../../virt/kvm/x86/hypercalls.rst:105
#: ../../../virt/kvm/x86/hypercalls.rst:143
#: ../../../virt/kvm/x86/hypercalls.rst:164
#: ../../../virt/kvm/x86/hypercalls.rst:175
msgid "x86"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:0
msgid "Status"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:53
#: ../../../virt/kvm/x86/hypercalls.rst:69
#: ../../../virt/kvm/x86/hypercalls.rst:80
#: ../../../virt/kvm/x86/hypercalls.rst:90
#: ../../../virt/kvm/x86/hypercalls.rst:106
#: ../../../virt/kvm/x86/hypercalls.rst:144
#: ../../../virt/kvm/x86/hypercalls.rst:165
#: ../../../virt/kvm/x86/hypercalls.rst:176
msgid "active"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:0
msgid "Purpose"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:54
msgid ""
"Trigger guest exit so that the host can check for pending interrupts on "
"reentry."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:58
msgid "2. KVM_HC_MMU_OP"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:61
msgid "deprecated."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:62
msgid ""
"Support MMU operations such as writing to PTE, flushing TLB, release PT."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:66
msgid "3. KVM_HC_FEATURES"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:68
#: ../../../virt/kvm/x86/hypercalls.rst:79
msgid "PPC"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:70
msgid ""
"Expose hypercall availability to the guest. On x86 platforms, cpuid used to "
"enumerate which hypercalls are available. On PPC, either device tree based "
"lookup ( which is also what EPAPR dictates) OR KVM specific enumeration "
"mechanism (which is this hypercall) can be used."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:77
msgid "4. KVM_HC_PPC_MAP_MAGIC_PAGE"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:81
msgid ""
"To enable communication between the hypervisor and guest there is a shared "
"page that contains parts of supervisor visible register state. The guest can "
"map this shared page to access its supervisor register through memory using "
"this hypercall."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:87
msgid "5. KVM_HC_KICK_CPU"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:91
msgid "Hypercall used to wakeup a vcpu from HLT state"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:0
msgid "Usage example"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:93
msgid ""
"A vcpu of a paravirtualized guest that is busywaiting in guest kernel mode "
"for an event to occur (ex: a spinlock to become available) can execute HLT "
"instruction once it has busy-waited for more than a threshold time-interval. "
"Execution of HLT instruction would cause the hypervisor to put the vcpu to "
"sleep until occurrence of an appropriate event. Another vcpu of the same "
"guest can wakeup the sleeping vcpu by issuing KVM_HC_KICK_CPU hypercall, "
"specifying APIC ID (a1) of the vcpu to be woken up. An additional argument "
"(a0) is used in the hypercall for future use."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:104
msgid "6. KVM_HC_CLOCK_PAIRING"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:107
msgid "Hypercall used to synchronize host and guest clocks."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:109
msgid "Usage:"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:111
msgid ""
"a0: guest physical address where host copies \"struct kvm_clock_offset\" "
"structure."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:114
msgid ""
"a1: clock_type, ATM only KVM_CLOCK_PAIRING_WALLCLOCK (0) is supported "
"(corresponding to the host's CLOCK_REALTIME clock)."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:127
msgid "Where:"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:128
msgid "sec: seconds from clock_type clock."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:129
msgid "nsec: nanoseconds from clock_type clock."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:130
msgid "tsc: guest TSC value used to calculate sec/nsec pair"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:131
msgid "flags: flags, unused (0) at the moment."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:133
msgid ""
"The hypercall lets a guest compute a precise timestamp across host and "
"guest.  The guest can use the returned TSC value to compute the "
"CLOCK_REALTIME for its clock, at the same instant."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:137
msgid ""
"Returns KVM_EOPNOTSUPP if the host does not use TSC clocksource, or if clock "
"type is different than KVM_CLOCK_PAIRING_WALLCLOCK."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:141
msgid "7. KVM_HC_SEND_IPI"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:145
msgid "Send IPIs to multiple vCPUs."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:147
msgid "a0: lower part of the bitmap of destination APIC IDs"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:148
msgid "a1: higher part of the bitmap of destination APIC IDs"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:149
msgid "a2: the lowest APIC ID in bitmap"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:150
msgid "a3: APIC ICR"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:152
msgid ""
"The hypercall lets a guest send multicast IPIs, with at most 128 128 "
"destinations per hypercall in 64-bit mode and 64 vCPUs per hypercall in 32-"
"bit mode.  The destinations are represented by a bitmap contained in the "
"first two arguments (a0 and a1). Bit 0 of a0 corresponds to the APIC ID in "
"the third argument (a2), bit 1 corresponds to the APIC ID a2+1, and so on."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:159
msgid ""
"Returns the number of CPUs to which the IPIs were delivered successfully."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:162
msgid "8. KVM_HC_SCHED_YIELD"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:166
msgid "Hypercall used to yield if the IPI target vCPU is preempted"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:168
msgid "a0: destination APIC ID"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:170
msgid ""
"When sending a call-function IPI-many to vCPUs, yield if any of the IPI "
"target vCPUs was preempted."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:174
msgid "9. KVM_HC_MAP_GPA_RANGE"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:177
msgid "Request KVM to map a GPA range with the specified attributes."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:179
msgid ""
"a0: the guest physical address of the start page a1: the number of (4kb) "
"pages (must be contiguous in GPA space) a2: attributes"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:183
msgid "Where 'attributes' :"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:184
msgid ""
"bits  3:0 - preferred page size encoding 0 = 4kb, 1 = 2mb, 2 = 1gb, etc..."
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:185
msgid "bit     4 - plaintext = 0, encrypted = 1"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:186
msgid "bits 63:5 - reserved (must be zero)"
msgstr ""

#: ../../../virt/kvm/x86/hypercalls.rst:188
msgid ""
"**Implementation note**: this hypercall is implemented in userspace via the "
"KVM_CAP_EXIT_HYPERCALL capability. Userspace must enable that capability "
"before advertising KVM_FEATURE_HC_MAP_GPA_RANGE in the guest CPUID.  In "
"addition, if the guest supports KVM_FEATURE_MIGRATION_CONTROL, userspace "
"must also set up an MSR filter to process writes to "
"MSR_KVM_MIGRATION_CONTROL."
msgstr ""
