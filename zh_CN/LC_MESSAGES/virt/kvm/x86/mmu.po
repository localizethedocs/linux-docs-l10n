# SOME DESCRIPTIVE TITLE.
# Copyright (C) The kernel development community
# This file is distributed under the same license as the The Linux Kernel package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: The Linux Kernel master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-29 08:26+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../virt/kvm/x86/mmu.rst:5
msgid "The x86 kvm shadow mmu"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:7
msgid ""
"The mmu (in arch/x86/kvm, files mmu.[ch] and paging_tmpl.h) is responsible "
"for presenting a standard x86 mmu to the guest, while translating guest "
"physical addresses to host physical addresses."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:11
msgid "The mmu code attempts to satisfy the following requirements:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:13
msgid "correctness:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:14
msgid ""
"the guest should not be able to determine that it is running on an emulated "
"mmu except for timing (we attempt to comply with the specification, not "
"emulate the characteristics of a particular implementation such as tlb size)"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:18
msgid "security:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:19
msgid "the guest must not be able to touch host memory not assigned to it"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:21
msgid "performance:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:22
msgid "minimize the performance penalty imposed by the mmu"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:23
msgid "scaling:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:24
msgid "need to scale to large memory and large vcpu guests"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:25
msgid "hardware:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:26
msgid "support the full range of x86 virtualization hardware"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:27
msgid "integration:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:28
msgid ""
"Linux memory management code must be in control of guest memory so that "
"swapping, page migration, page merging, transparent hugepages, and similar "
"features work without change"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:31
msgid "dirty tracking:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:32
msgid ""
"report writes to guest memory to enable live migration and framebuffer-based "
"displays"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:34
msgid "footprint:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:35
msgid ""
"keep the amount of pinned kernel memory low (most memory should be "
"shrinkable)"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:37
msgid "reliability:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:38
msgid "avoid multipage or GFP_ATOMIC allocations"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:41
msgid "Acronyms"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:44
msgid "pfn"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:44
msgid "host page frame number"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:45
msgid "hpa"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:45
msgid "host physical address"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:46
msgid "hva"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:46
msgid "host virtual address"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:47
msgid "gfn"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:47
msgid "guest frame number"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:48
msgid "gpa"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:48
msgid "guest physical address"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:49
msgid "gva"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:49
msgid "guest virtual address"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:50
msgid "ngpa"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:50
msgid "nested guest physical address"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:51
msgid "ngva"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:51
msgid "nested guest virtual address"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:52
msgid "pte"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:52
msgid ""
"page table entry (used also to refer generically to paging structure entries)"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:54
msgid "gpte"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:54
msgid "guest pte (referring to gfns)"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:55
msgid "spte"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:55
msgid "shadow pte (referring to pfns)"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:56
msgid "tdp"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:56
msgid "two dimensional paging (vendor neutral term for NPT and EPT)"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:60
msgid "Virtual and real hardware supported"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:62
msgid ""
"The mmu supports first-generation mmu hardware, which allows an atomic "
"switch of the current paging mode and cr3 during guest entry, as well as two-"
"dimensional paging (AMD's NPT and Intel's EPT).  The emulated hardware it "
"exposes is the traditional 2/3/4 level x86 mmu, with support for global "
"pages, pae, pse, pse36, cr0.wp, and 1GB pages. Emulated hardware also able "
"to expose NPT capable hardware on NPT capable hosts."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:70
msgid "Translation"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:72
msgid ""
"The primary job of the mmu is to program the processor's mmu to translate "
"addresses for the guest.  Different translations are required at different "
"times:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:76
msgid ""
"when guest paging is disabled, we translate guest physical addresses to host "
"physical addresses (gpa->hpa)"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:78
msgid ""
"when guest paging is enabled, we translate guest virtual addresses, to guest "
"physical addresses, to host physical addresses (gva->gpa->hpa)"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:80
msgid ""
"when the guest launches a guest of its own, we translate nested guest "
"virtual addresses, to nested guest physical addresses, to guest physical "
"addresses, to host physical addresses (ngva->ngpa->gpa->hpa)"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:84
msgid ""
"The primary challenge is to encode between 1 and 3 translations into "
"hardware that support only 1 (traditional) and 2 (tdp) translations.  When "
"the number of required translations matches the hardware, the mmu operates "
"in direct mode; otherwise it operates in shadow mode (see below)."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:90
msgid "Memory"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:92
msgid ""
"Guest memory (gpa) is part of the user address space of the process that is "
"using kvm.  Userspace defines the translation between guest addresses and "
"user addresses (gpa->hva); note that two gpas may alias to the same hva, but "
"not vice versa."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:97
msgid ""
"These hvas may be backed using any method available to the host: anonymous "
"memory, file backed memory, and device memory.  Memory might be paged by the "
"host at any time."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:102
msgid "Events"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:104
msgid "The mmu is driven by events, some from the guest, some from the host."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:106
msgid "Guest generated events:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:108
msgid "writes to control registers (especially cr3)"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:109
msgid "invlpg/invlpga instruction execution"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:110
msgid "access to missing or protected translations"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:112
msgid "Host generated events:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:114
msgid ""
"changes in the gpa->hpa translation (either through gpa->hva changes or "
"through hva->hpa changes)"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:116
msgid "memory pressure (the shrinker)"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:119
msgid "Shadow pages"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:121
msgid ""
"The principal data structure is the shadow page, 'struct kvm_mmu_page'.  A "
"shadow page contains 512 sptes, which can be either leaf or nonleaf sptes.  "
"A shadow page may contain a mix of leaf and nonleaf sptes."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:125
msgid ""
"A nonleaf spte allows the hardware mmu to reach the leaf pages and is not "
"related to a translation directly.  It points to other shadow pages."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:128
msgid ""
"A leaf spte corresponds to either one or two translations encoded into one "
"paging structure entry.  These are always the lowest level of the "
"translation stack, with optional higher level translations left to NPT/EPT. "
"Leaf ptes point at guest pages."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:133
msgid ""
"The following table shows translations encoded by leaf ptes, with higher-"
"level translations in parentheses:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:136
msgid "Non-nested guests::"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:142
msgid "Nested guests::"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:150
msgid "Shadow pages contain the following information:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:151
msgid "role.level:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:152
msgid ""
"The level in the shadow paging hierarchy that this shadow page belongs to. "
"1=4k sptes, 2=2M sptes, 3=1G sptes, etc."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:154
msgid "role.direct:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:155
msgid ""
"If set, leaf sptes reachable from this page are for a linear range. Examples "
"include real mode translation, large guest pages backed by small host pages, "
"and gpa->hpa translations when NPT or EPT is active. The linear range starts "
"at (gfn << PAGE_SHIFT) and its size is determined by role.level (2MB for "
"first level, 1GB for second level, 0.5TB for third level, 256TB for fourth "
"level) If clear, this page corresponds to a guest page table denoted by the "
"gfn field."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:163
msgid "role.quadrant:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:164
msgid ""
"When role.has_4_byte_gpte=1, the guest uses 32-bit gptes while the host uses "
"64-bit sptes.  That means a guest page table contains more ptes than the "
"host, so multiple shadow pages are needed to shadow one guest page. For "
"first-level shadow pages, role.quadrant can be 0 or 1 and denotes the first "
"or second 512-gpte block in the guest page table.  For second-level page "
"tables, each 32-bit gpte is converted to two 64-bit sptes (since each first-"
"level guest page is shadowed by two first-level shadow pages) so role."
"quadrant takes values in the range 0..3.  Each quadrant maps 1GB virtual "
"address space."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:173
msgid "role.access:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:174
msgid ""
"Inherited guest access permissions from the parent ptes in the form uwx. "
"Note execute permission is positive, not negative."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:176
msgid "role.invalid:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:177
msgid ""
"The page is invalid and should not be used.  It is a root page that is "
"currently pinned (by a cpu hardware register pointing to it); once it is "
"unpinned it will be destroyed."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:180
msgid "role.has_4_byte_gpte:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:181
msgid ""
"Reflects the size of the guest PTE for which the page is valid, i.e. '0' if "
"direct map or 64-bit gptes are in use, '1' if 32-bit gptes are in use."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:183
msgid "role.efer_nx:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:184
msgid "Contains the value of efer.nx for which the page is valid."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:185
msgid "role.cr0_wp:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:186
msgid "Contains the value of cr0.wp for which the page is valid."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:187
msgid "role.smep_andnot_wp:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:188
msgid ""
"Contains the value of cr4.smep && !cr0.wp for which the page is valid (pages "
"for which this is true are different from other pages; see the treatment of "
"cr0.wp=0 below)."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:191
msgid "role.smap_andnot_wp:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:192
msgid ""
"Contains the value of cr4.smap && !cr0.wp for which the page is valid (pages "
"for which this is true are different from other pages; see the treatment of "
"cr0.wp=0 below)."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:195
msgid "role.smm:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:196
msgid ""
"Is 1 if the page is valid in system management mode.  This field determines "
"which of the kvm_memslots array was used to build this shadow page; it is "
"also used to go back from a struct kvm_mmu_page to a memslot, through the "
"kvm_memslots_for_spte_role macro and __gfn_to_memslot."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:201
msgid "role.ad_disabled:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:202
msgid ""
"Is 1 if the MMU instance cannot use A/D bits.  EPT did not have A/D bits "
"before Haswell; shadow EPT page tables also cannot use A/D bits if the L1 "
"hypervisor does not enable them."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:205
msgid "role.guest_mode:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:206
msgid "Indicates the shadow page is created for a nested guest."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:207
msgid "role.passthrough:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:208
msgid ""
"The page is not backed by a guest page table, but its first entry points to "
"one.  This is set if NPT uses 5-level page tables (host CR4.LA57=1) and is "
"shadowing L1's 4-level NPT (L1 CR4.LA57=0)."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:211
msgid "mmu_valid_gen:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:212
msgid ""
"The MMU generation of this page, used to fast zap of all MMU pages within a "
"VM without blocking vCPUs too long. Specifically, KVM updates the per-VM "
"valid MMU generation which causes the mismatch of mmu_valid_gen for each mmu "
"page. This makes all existing MMU pages obsolete. Obsolete pages can't be "
"used. Therefore, vCPUs must load a new, valid root before re-entering the "
"guest. The MMU generation is only ever '0' or '1'. Note, the TDP MMU doesn't "
"use this field as non-root TDP MMU pages are reachable only from their "
"owning root. Thus it suffices for TDP MMU to use role.invalid in root pages "
"to invalidate all MMU pages."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:221
msgid "gfn:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:222
msgid ""
"Either the guest page table containing the translations shadowed by this "
"page, or the base page frame for linear translations.  See role.direct."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:224
msgid "spt:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:225
msgid ""
"A pageful of 64-bit sptes containing the translations for this page. "
"Accessed by both kvm and hardware. The page pointed to by spt will have its "
"page->private pointing back at the shadow page structure. sptes in spt point "
"either at guest pages, or at lower-level shadow pages. Specifically, if sp1 "
"and sp2 are shadow pages, then sp1->spt[n] may point at __pa(sp2->spt).  sp2 "
"will point back at sp1 through parent_pte. The spt array forms a DAG "
"structure with the shadow page as a node, and guest pages as leaves."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:234
msgid "shadowed_translation:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:235
msgid ""
"An array of 512 shadow translation entries, one for each present pte. Used "
"to perform a reverse map from a pte to a gfn as well as its access "
"permission. When role.direct is set, the shadow_translation array is not "
"allocated. This is because the gfn contained in any element of this array "
"can be calculated from the gfn field when used.  In addition, when role."
"direct is set, KVM does not track access permission for each of the gfn. See "
"role.direct and gfn."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:242
msgid "root_count / tdp_mmu_root_count:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:243
msgid ""
"root_count is a reference counter for root shadow pages in Shadow MMU. vCPUs "
"elevate the refcount when getting a shadow page that will be used as a root "
"page, i.e. page that will be loaded into hardware directly (CR3, PDPTRs, "
"nCR3 EPTP). Root pages cannot be destroyed while their refcount is non-zero. "
"See role.invalid. tdp_mmu_root_count is similar but exclusively used in TDP "
"MMU as an atomic refcount."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:249
msgid "parent_ptes:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:250
msgid ""
"The reverse mapping for the pte/ptes pointing at this page's spt. If "
"parent_ptes bit 0 is zero, only one spte points at this page and parent_ptes "
"points at this single spte, otherwise, there exists multiple sptes pointing "
"at this page and (parent_ptes & ~0x1) points at a data structure with a list "
"of parent sptes."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:255
msgid "ptep:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:256
msgid ""
"The kernel virtual address of the SPTE that points at this shadow page. Used "
"exclusively by the TDP MMU, this field is a union with parent_ptes."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:258
msgid "unsync:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:259
msgid ""
"If true, then the translations in this page may not match the guest's "
"translation.  This is equivalent to the state of the tlb when a pte is "
"changed but before the tlb entry is flushed.  Accordingly, unsync ptes are "
"synchronized when the guest executes invlpg or flushes its tlb by other "
"means.  Valid for leaf pages."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:264
msgid "unsync_children:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:265
msgid ""
"How many sptes in the page point at pages that are unsync (or have "
"unsynchronized children)."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:267
msgid "unsync_child_bitmap:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:268
msgid ""
"A bitmap indicating which sptes in spt point (directly or indirectly) at "
"pages that may be unsynchronized.  Used to quickly locate all unsynchronized "
"pages reachable from a given page."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:271
msgid "clear_spte_count:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:272
msgid ""
"Only present on 32-bit hosts, where a 64-bit spte cannot be written "
"atomically.  The reader uses this while running out of the MMU lock to "
"detect in-progress updates and retry them until the writer has finished the "
"write."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:276
msgid "write_flooding_count:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:277
msgid ""
"A guest may write to a page table many times, causing a lot of emulations if "
"the page needs to be write-protected (see \"Synchronized and unsynchronized "
"pages\" below).  Leaf pages can be unsynchronized so that they do not "
"trigger frequent emulation, but this is not possible for non-leafs.  This "
"field counts the number of emulations since the last time the page table was "
"actually used; if emulation is triggered too frequently on this page, KVM "
"will unmap the page to avoid emulation in the future."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:285
msgid "tdp_mmu_page:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:286
msgid ""
"Is 1 if the shadow page is a TDP MMU page. This variable is used to "
"bifurcate the control flows for KVM when walking any data structure that may "
"contain pages from both TDP MMU and shadow MMU."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:291
msgid "Reverse map"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:293
msgid ""
"The mmu maintains a reverse mapping whereby all ptes mapping a page can be "
"reached given its gfn.  This is used, for example, when swapping out a page."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:297
msgid "Synchronized and unsynchronized pages"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:299
msgid ""
"The guest uses two events to synchronize its tlb and page tables: tlb "
"flushes and page invalidations (invlpg)."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:302
msgid ""
"A tlb flush means that we need to synchronize all sptes reachable from the "
"guest's cr3.  This is expensive, so we keep all guest page tables write "
"protected, and synchronize sptes to gptes when a gpte is written."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:306
msgid ""
"A special case is when a guest page table is reachable from the current "
"guest cr3.  In this case, the guest is obliged to issue an invlpg "
"instruction before using the translation.  We take advantage of that by "
"removing write protection from the guest page, and allowing the guest to "
"modify it freely. We synchronize modified gptes when the guest invokes "
"invlpg.  This reduces the amount of emulation we have to do when the guest "
"modifies multiple gptes, or when the a guest page is no longer used as a "
"page table and is used for random guest data."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:315
msgid ""
"As a side effect we have to resynchronize all reachable unsynchronized "
"shadow pages on a tlb flush."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:320
msgid "Reaction to events"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:322
msgid "guest page fault (or npt page fault, or ept violation)"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:324
msgid "This is the most complicated event.  The cause of a page fault can be:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:326
msgid "a true guest fault (the guest translation won't allow the access) (*)"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:327
msgid "access to a missing translation"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:328
msgid ""
"access to a protected translation - when logging dirty pages, memory is "
"write protected - synchronized shadow pages are write protected (*)"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:331
msgid "access to untranslatable memory (mmio)"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:333
msgid "(*) not applicable in direct mode"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:335
msgid "Handling a page fault is performed as follows:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:337
msgid ""
"if the RSV bit of the error code is set, the page fault is caused by guest "
"accessing MMIO and cached MMIO information is available."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:340
msgid "walk shadow page table"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:341
msgid ""
"check for valid generation number in the spte (see \"Fast invalidation of "
"MMIO sptes\" below)"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:343
msgid ""
"cache the information to vcpu->arch.mmio_gva, vcpu->arch.mmio_access and "
"vcpu->arch.mmio_gfn, and call the emulator"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:346
msgid ""
"If both P bit and R/W bit of error code are set, this could possibly be "
"handled as a \"fast page fault\" (fixed without taking the MMU lock).  See "
"the description in Documentation/virt/kvm/locking.rst."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:350
msgid ""
"if needed, walk the guest page tables to determine the guest translation "
"(gva->gpa or ngpa->gpa)"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:353
msgid "if permissions are insufficient, reflect the fault back to the guest"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:355
msgid "determine the host page"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:357
msgid ""
"if this is an mmio request, there is no host page; cache the info to vcpu-"
">arch.mmio_gva, vcpu->arch.mmio_access and vcpu->arch.mmio_gfn"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:360
msgid ""
"walk the shadow page table to find the spte for the translation, "
"instantiating missing intermediate page tables as necessary"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:363
msgid ""
"If this is an mmio request, cache the mmio info to the spte and set some "
"reserved bit on the spte (see callers of kvm_mmu_set_mmio_spte_mask)"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:366
msgid "try to unsynchronize the page"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:368
msgid "if successful, we can let the guest continue and modify the gpte"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:370
msgid "emulate the instruction"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:372
msgid "if failed, unshadow the page and let the guest continue"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:374
msgid "update any translations that were modified by the instruction"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:376
msgid "invlpg handling:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:378
msgid "walk the shadow page hierarchy and drop affected translations"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:379
msgid ""
"try to reinstantiate the indicated translation in the hope that the guest "
"will use it in the near future"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:382
msgid "Guest control register updates:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:384
msgid "mov to cr3"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:386 ../../../virt/kvm/x86/mmu.rst:392
msgid "look up new shadow roots"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:387 ../../../virt/kvm/x86/mmu.rst:393
msgid "synchronize newly reachable shadow pages"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:389
msgid "mov to cr0/cr4/efer"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:391
msgid "set up mmu context for new paging mode"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:395
msgid "Host translation updates:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:397
msgid "mmu notifier called with updated hva"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:398
msgid "look up affected sptes through reverse map"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:399
msgid "drop (or update) translations"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:402
msgid "Emulating cr0.wp"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:404
msgid ""
"If tdp is not enabled, the host must keep cr0.wp=1 so page write protection "
"works for the guest kernel, not guest userspace.  When the guest cr0.wp=1, "
"this does not present a problem.  However when the guest cr0.wp=0, we cannot "
"map the permissions for gpte.u=1, gpte.w=0 to any spte (the semantics "
"require allowing any guest kernel access plus user read access)."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:410
msgid ""
"We handle this by mapping the permissions to two possible sptes, depending "
"on fault type:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:413
msgid ""
"kernel write fault: spte.u=0, spte.w=1 (allows full kernel access, disallows "
"user access)"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:415
msgid ""
"read fault: spte.u=1, spte.w=0 (allows full read access, disallows kernel "
"write access)"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:418
msgid "(user write faults generate a #PF)"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:420
msgid "In the first case there are two additional complications:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:422
msgid ""
"if CR4.SMEP is enabled: since we've turned the page into a kernel page, the "
"kernel may now execute it.  We handle this by also setting spte.nx. If we "
"get a user fetch or read fault, we'll change spte.u=1 and spte.nx=gpte.nx "
"back.  For this to work, KVM forces EFER.NX to 1 when shadow paging is in "
"use."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:427
msgid ""
"if CR4.SMAP is disabled: since the page has been changed to a kernel page, "
"it can not be reused when CR4.SMAP is enabled. We set CR4.SMAP && !CR0.WP "
"into shadow page's role to avoid this case. Note, here we do not care the "
"case that CR4.SMAP is enabled since KVM will directly inject #PF to guest "
"due to failed permission check."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:433
msgid ""
"To prevent an spte that was converted into a kernel page with cr0.wp=0 from "
"being written by the kernel after cr0.wp has changed to 1, we make the value "
"of cr0.wp part of the page role.  This means that an spte created with one "
"value of cr0.wp cannot be used when cr0.wp has a different value - it will "
"simply be missed by the shadow page lookup code.  A similar issue exists "
"when an spte created with cr0.wp=0 and cr4.smep=0 is used after changing cr4."
"smep to 1.  To avoid this, the value of !cr0.wp && cr4.smep is also made a "
"part of the page role."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:443
msgid "Large pages"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:445
msgid ""
"The mmu supports all combinations of large and small guest and host pages. "
"Supported page sizes include 4k, 2M, 4M, and 1G.  4M pages are treated as "
"two separate 2M pages, on both guest and host, since the mmu always uses PAE "
"paging."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:450
msgid "To instantiate a large spte, four constraints must be satisfied:"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:452
msgid "the spte must point to a large host page"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:453
msgid ""
"the guest pte must be a large pte of at least equivalent size (if tdp is "
"enabled, there is no guest pte and this condition is satisfied)"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:455
msgid ""
"if the spte will be writeable, the large page frame may not overlap any "
"write-protected pages"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:457
msgid "the guest page must be wholly contained by a single memory slot"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:459
msgid ""
"To check the last two conditions, the mmu maintains a ->disallow_lpage set "
"of arrays for each memory slot and large page size.  Every write protected "
"page causes its disallow_lpage to be incremented, thus preventing "
"instantiation of a large spte.  The frames at the end of an unaligned memory "
"slot have artificially inflated ->disallow_lpages so they can never be "
"instantiated."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:466
msgid "Fast invalidation of MMIO sptes"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:468
msgid ""
"As mentioned in \"Reaction to events\" above, kvm will cache MMIO "
"information in leaf sptes.  When a new memslot is added or an existing "
"memslot is changed, this information may become stale and needs to be "
"invalidated.  This also needs to hold the MMU lock while walking all shadow "
"pages, and is made more scalable with a similar technique."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:474
msgid ""
"MMIO sptes have a few spare bits, which are used to store a generation "
"number.  The global generation number is stored in kvm_memslots(kvm)-"
">generation, and increased whenever guest memory info changes."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:479
msgid ""
"When KVM finds an MMIO spte, it checks the generation number of the spte. If "
"the generation number of the spte does not equal the global generation "
"number, it will ignore the cached MMIO information and handle the page fault "
"through the slow path."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:484
msgid ""
"Since only 18 bits are used to store generation-number on mmio spte, all "
"pages are zapped when there is an overflow."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:487
msgid ""
"Unfortunately, a single memory access might access kvm_memslots(kvm) "
"multiple times, the last one happening when the generation number is "
"retrieved and stored into the MMIO spte.  Thus, the MMIO spte might be "
"created based on out-of-date information, but with an up-to-date generation "
"number."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:492
msgid ""
"To avoid this, the generation number is incremented again after "
"synchronize_srcu returns; thus, bit 63 of kvm_memslots(kvm)->generation set "
"to 1 only during a memslot update, while some SRCU readers might be using "
"the old copy.  We do not want to use an MMIO sptes created with an odd "
"generation number, and we can do this without losing a bit in the MMIO "
"spte.  The \"update in-progress\" bit of the generation is not stored in "
"MMIO spte, and is so is implicitly zero when the generation is extracted out "
"of the spte.  If KVM is unlucky and creates an MMIO spte while an update is "
"in-progress, the next access to the spte will always be a cache miss.  For "
"example, a subsequent access during the update window will miss due to the "
"in-progress flag diverging, while an access after the update window closes "
"will have a higher generation number (as compared to the spte)."
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:506
msgid "Further reading"
msgstr ""

#: ../../../virt/kvm/x86/mmu.rst:508
msgid ""
"NPT presentation from KVM Forum 2008 https://www.linux-kvm.org/images/c/c8/"
"KvmForum2008%24kdf2008_21.pdf"
msgstr ""
